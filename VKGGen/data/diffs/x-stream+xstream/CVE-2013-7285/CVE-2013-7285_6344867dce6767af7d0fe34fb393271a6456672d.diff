diff --git a/xstream-distribution/src/content/changes.html b/xstream-distribution/src/content/changes.html
index 4147f92f..bb64a293 100644
--- a/xstream-distribution/src/content/changes.html
+++ b/xstream-distribution/src/content/changes.html
@@ -35,6 +35,7 @@ <h1 id="upcoming">Upcoming</h1>
     <h2>Major changes</h2>
     
     <ul>
+   		<li>Add security framework to limit handled types while unmarshalling.</li>
    		<li>java.bean.EventHandler no longer handled automatically because of severe security vulnerability.</li>
     	<li>JIRA:XSTR-751: New SunLimitedUnsafeReflectionProvider that uses undocumented features only to allocate new
     	instances as required on Dalvik.</li>
@@ -54,6 +55,11 @@ <h2>Minor changes</h2>
     <h2>API changes</h2>
 
     <ul>
+    	<li>Added package c.t.x.security with interface TypePermission, all its implementations and
+    	ForbiddenClassException.</li>
+    	<li>Added c.t.x.mapper.SecurityMapper handling the new type permissions.</li>
+    	<li>Added methods addPermission, denyPermission, allowTypesXXX and denyTypesXXX to c.t.x.XStream to setup
+    	security at unmarshalling time.</li>
     	<li>Added c.t.x.converters.reflection.SunLimitedUnsafeReflectionProvider.</li>
     	<li>Deprecated c.t.x.converters.reflection.Sun14ReflectionProvider in favor of new
     	c.t.x.converters.reflection.SunUnsafeReflectionProvider.</li>
diff --git a/xstream-distribution/src/content/faq.html b/xstream-distribution/src/content/faq.html
index d3f462f5..7aade4ed 100644
--- a/xstream-distribution/src/content/faq.html
+++ b/xstream-distribution/src/content/faq.html
@@ -56,8 +56,9 @@ <h2 id="Compatibility_enhanced_mode_jvm">Which JVMs allow XStream to operate in
     undocumented internal Java runtime classes. This enhanced mode is known to be working on the Oracle/Sun, Apple, HP,
     IBM and Blackdown 1.4 JVMs and onwards, for IcedTea 6 and onwards, for Hitachi, SAP and Diablo from 1.5 and
     onwards, for BEA JRockit starting with R25.1.0. Generally it works for all modern Java runtimes based on OpenJDK.
-    Android basically supports the enhanced mode, but its security model limits the types that can be handled. Note,
-    that an active SecurityManager might prevent the usage of the enhanced mode also.</p>
+    Android basically supports the enhanced mode as well as the Google ApplicationEngine, but the latter's security
+    model limits the types that can be handled. Note, that an active SecurityManager might prevent the usage of the
+    enhanced mode also.</p>
 
     <!-- ...................................................... -->
     <h2 id="Compatibility_enhanced_mode_advantage">What are the advantages of using enhanced mode over pure Java mode?</h2>
diff --git a/xstream-distribution/src/content/security.html b/xstream-distribution/src/content/security.html
new file mode 100644
index 00000000..8fc6118f
--- /dev/null
+++ b/xstream-distribution/src/content/security.html
@@ -0,0 +1,207 @@
+<html>
+<!--
+ Copyright (C) 2014 XStream committers.
+ All rights reserved.
+ 
+ The software in this package is published under the terms of the BSD
+ style license a copy of which has been included with this distribution in
+ the LICENSE.txt file.
+ 
+ Created on 09. January 2014 by Joerg Schaible
+ -->
+  <head>
+    <title>Security</title>
+  </head>
+
+  <body>
+    <h1 id="intro">Introduction</h1>
+    
+    <p>XStream is designed as a library, that is easy to use. It takes its main task very serious to convert from Java
+     objects to XML and back.  As result it is possible that you create an instance of XStream with the default
+     constructor, call a method to turn an object into XML and call another one to turn the XML back into an equal Java
+     object.  There are not a lot limits for those objects, XStream can handle nearly all.</p>
+     
+     <p>This flexibility comes at a price.  XStream is using aggressive code internally like undocumented Java
+     features and reflection to be able to handle all kind of unknown types.  The XML output contains by default any
+     information required to rebuild all these types.  Regarding security we have now two different aspects:</p>
+     
+     <ol>
+     <li>a Java runtime can have security constraints (typically by an active SecurityManager) that prevents partly the
+     execution of such aggressive code</li>
+     <li>the input data (XML) can be manipulated to inject objects into the unmarshalled object graph that where not
+     present at marshalling time and that might be used to execute code or even shell commands (CVE-2013-7285).</li>
+     </ol>
+
+     <p>Always remember that manipulation of input data might happen on different levels, e.g. manipulation the value
+     of objects (e.g. exchanging a price value) or breaking the format causing the XML parser to fail.  The latter
+     raises at least an error condition while the former must be catched with validity checks in case of sensitive
+     data.  Even worse is an unrecognized injection resulting in a modified application execution with the worst case
+     of arbitrary command execution.</p>
+     
+    <h2 id="external">External Security</h2>
+
+	<p>An active SecurityManager can prevent actions required by XStream components or converters.  Same applies for
+	an environment like Google Application Engine.  XStream tries to some extend to check the functionality of a
+	converter before it claims to handle a type.</p>
+	
+	<p>Therefore it is possible that XStream behaves different in such an environment, because a converter suddenly no
+	longer handles a special type or any type at all.  It is essential that an application that will have to run in such an environment is
+	tested at an early stage to prevent nasty surprises.</p>
+      
+    <h2 id="implicit">Implicit Security</h2>
+	
+	<p>As already explained it is possible to inject other object instances if someone has the possibility to
+	manipulate the data stream used to deserialize the Java objects (typically XML, but XStream supports other formats
+	like JSON).  A known vulnerability can be created with the help of the Java runtime library using the Java Bean
+	<a href="http://docs.oracle.com/javase/7/docs/api/java/beans/EventHandler.html">EventHandler</a>.  As an instance
+	for the <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/InvocationHandler.html">InvocationHandler</a>
+	of a dynamic proxy it can be used to install a redirect for an arbitrary call to the original object to the method
+	of a completely different instance of an embedded object of the EventHandler itself.</p>
+	
+	<p>This scenario can be used perfectly to replace/inject a dynamic proxy with such an EventHandler at any location
+	in the XML	where its parent expects an object of such an interface's type or a simple object instance (any list
+	element will suffice).  The usage of a ProcessBuilder as embedded element and the redirection of any call to the
+	ProcessBuilder's <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html#start()">start()</a>
+	method allows even the call of shell commands.  All you have to know is the XML representation of such a
+	combination.</p>
+	
+	<p>Starting with XStream 1.4.7 an instance of the EventHandler is no longer handled by default.  You have to
+	register explicitly a ReflectionConverter for the EventHandler type, if your application has the requirement to
+	persist such an object.  However, you have to take special care about the location of the persisted data and how
+	you can ensure its integrity.</p>
+	
+	<p class=highlight>Note, that this vulnerability is not even a special problem of XStream.  The XML acts here like
+	a script and the scenario above can be created with any script that is executed within a Java runtime (e.g. using
+	its JavaScript interpreter) if someone is able to manipulate it externally.</p>     
+    
+    <h2 id="explicit">Explicit Security</h2>
+    
+    <p>While XStream implicitly avoids the vulnerability scenario with the EventHandler, there might be other
+    combinations with types from well-known and often used Java libraries like ASM, CGLIB, Groovy, or even in the Java
+    runtime that are currently simply unknown.</p>
+    
+    <p>Starting with XStream 1.4.7 it is possible to define <a href="#framework">permissions</a> for types to check the
+    type of an object that should be unmarshalled.  Those permissions can be used to allow or deny types explicitly.
+    With these permissions it is at least possible to inject types into an object graph that do not belong anywhere
+    into it.  Any application that deserializes data from an external source should at least use this possibility to
+    limit the danger of arbitrary command execution.</p>
+	
+	<p class=highlight>Apart from value manipulations, this implementation still allows the injection of allowed
+	objects at wrong locations. e.g. inserting an integer into a list of strings.</p>
+	
+	<p>Apart from the XStream security framework, it has always been possible to overwrite the setupConverter method of
+	XStream to register only the required converters.</p>
+    
+    <h2 id="validation">XML Validation</h2>
+
+    <p>XML itself supports input validation using a schema and a validating parser.  With XStream you can use e.g. a
+    StAX parser for validation, but it will take some effort to ensure that the XML read and written by XStream matches
+    the schema in first place.  Typically you will have to write some custom converters, but it can be worth the effort
+    depending on the use case.</p>
+
+    <h1 id="framework">Security Framework</h1>
+
+	<p>As explained, it might be possible, that other combinations are found with the Java runtime itself or other
+	often used Java libraries that allow a similar vulnerability like the known case using the Java Beans EventHandler.
+	To prevent such a possibility at all, XStream contains since version 1.4.7 a security framework, where you can
+	define, which types	are allowed to be unmarshalled with XStream.</p>
+	
+	<p>Core interface is <a href="javadoc/com/thoughtworks/xstream/security/TypePermission.html">TypePermission</a>.
+	The <a href="javadoc/com/thoughtworks/xstream/mapper/SecurityMapper.html">SecurityMapper</a> will evaluate a list
+	of registered instances for every type that will be required while unmarshalling input data. The interface has one
+	simple method:<p><div class="Source Java"><pre>boolean allow(Class&lt;?&gt;);</pre></div>
+	
+	<p>The <a href="javadoc/com/thoughtworks/xstream/XStream.html">XStream</a> facade provides following methods to
+	register such type permissions within the SecurityMapper:<p><div class="Source Java">
+<pre>XStream.addPermission(TypePermission);
+XStream.allowTypes(String...);
+XStream.allowTypesByRegExp(String...);
+XStream.allowTypesByRegExp(Pattern...);
+XStream.allowTypesByWildcard(String...);
+XStream.denyPermission(TypePermission);
+XStream.denyTypes(String...);
+XStream.denyTypesByRegExp(String...);
+XStream.denyTypesByRegExp(Pattern...);
+XStream.denyTypesByWildcard(String...);</pre></div>
+
+	<p>The sequence of registration is essential. The latest registered permission will be evaluated first.</p>
+	
+	<p>Every TypePermission has three options to implement the allow method and make decisions on the provided type:<p>
+	<ul>
+	<li>if the method returns <i>true</i>, the type is simply accepted and no other permission is evaluated anymore</li>
+	<li>if the method returns <i>false</i>, the implementation cannot judge over the type and the SecurityMapper will
+	continue with the next permission instance in its registration list</li>
+	<li>the method throws a <a href="javadoc/com/thoughtworks/xstream/security/ForbiddenClassException.html">ForbiddenClassException</a>
+	to stop the unmarshalling process</li>
+	</ul>
+	
+	<p>XStream provides some TypePermission implementations to allow any or no type at all, to allow primitive types
+	and their counterpart, null, array types, implementations match the name of the type by regular or wildcard
+	expression and one to invert a permission.</p>
+	
+	<table class="examplesTable" summary="Overview over all Converters delivered with XStream">
+	<!-- .................................................................................................. -->
+	<tr>
+	    <th>Permission</th>
+	    <th>Description</th>
+	    <th>Example</th>
+	</tr>
+	<tr>
+	    <td><a href="javadoc/com/thoughtworks/xstream/security/AnyTypePermission.html">AnyTypePermission</a></td>
+	    <td>Allow any type.  You may use the ANY instance directly. A registration of this permission will wipe any
+	    prior one.</td>
+	    <td>&nbsp;</td>
+	</tr>
+	<tr>
+	    <td><a href="javadoc/com/thoughtworks/xstream/security/ArrayTypePermission.html">ArrayTypePermission</a></td>
+	    <td>Allow any array type.</td>
+	    <td>&nbsp;</td>
+	</tr>
+	<tr>
+	    <td><a href="javadoc/com/thoughtworks/xstream/security/CGLIBProxyTypePermission.html">CGLIBProxyTypePermission</a></td>
+	    <td>Allow any CGLIB proxy type.</td>
+	    <td>&nbsp;</td>
+	</tr>
+	<tr>
+	    <td><a href="javadoc/com/thoughtworks/xstream/security/ExplicitTypePermission.html">ExplicitTypePermission</a></td>
+	    <td>Allow types explicitly by name.</td>
+	    <td>&nbsp;</td>
+	</tr>
+	<tr>
+	    <td><a href="javadoc/com/thoughtworks/xstream/hibernate/security/HibernateProxyTypePermission.html">HibernateProxyTypePermission</a></td>
+	    <td>Allow any Hibernate proxy type. Implementation is located in XStream's Hibernate extension.</td>
+	    <td>&nbsp;</td>
+	</tr>
+	<tr>
+	    <td><a href="javadoc/com/thoughtworks/xstream/security/NoPermission.html">NoPermission</a></td>
+	    <td>Invert any other permission.  Instances of this type are used by XStream in the deny methods.</td>
+	    <td class="example">&nbsp;</td>
+	</tr>
+	<tr>
+	    <td><a href="javadoc/com/thoughtworks/xstream/security/NullPermission.html">NullPermission</a></td>
+	    <td>Allow null as type.</td>
+	    <td>&nbsp;</td>
+	</tr>
+	<tr>
+	    <td><a href="javadoc/com/thoughtworks/xstream/security/PrimitiveTypePermission.html">PrimitiveTypePermission</a></td>
+	    <td>Allow any primitive type and its boxed counterpart.</td>
+	    <td>&nbsp;</td>
+	</tr>
+	<tr>
+	    <td><a href="javadoc/com/thoughtworks/xstream/security/ProxyTypePermission.html">ProxyTypePermission</a></td>
+	    <td>Allow any Java proxy type.</td>
+	    <td>&nbsp;</td>
+	</tr>
+	<tr>
+	    <td><a href="javadoc/com/thoughtworks/xstream/security/RegExpTypePermission.html">RegExpTypePermission</a></td>
+	    <td>Allow any type that matches with its name a regular expression.</td>
+	    <td class="example">.*\\.core\\..*<br/>[^$]+</td>
+	</tr>
+	<tr>
+	    <td><a href="javadoc/com/thoughtworks/xstream/security/WildcardTypePermission.html">WildcardTypePermission</a></td>
+	    <td>Allow any type that matches with its name a wildcard expression.</td>
+	    <td class="example">java.lang.*<br/>java.util.**</td>
+	</tr>
+    </table>
+  </body>
+ </html>
diff --git a/xstream-distribution/src/content/website.xml b/xstream-distribution/src/content/website.xml
index 1532af5e..34cd216a 100644
--- a/xstream-distribution/src/content/website.xml
+++ b/xstream-distribution/src/content/website.xml
@@ -32,6 +32,7 @@
         <name>Using XStream</name>
         <page>architecture.html</page>
         <page>converters.html</page>
+        <page>security.html</page>
         <page>faq.html</page>
         <page>list-user.html</page>
         <page>issues.html</page>
diff --git a/xstream-hibernate/src/java/com/thoughtworks/xstream/hibernate/security/HibernateProxyTypePermission.java b/xstream-hibernate/src/java/com/thoughtworks/xstream/hibernate/security/HibernateProxyTypePermission.java
new file mode 100644
index 00000000..f7771acb
--- /dev/null
+++ b/xstream-hibernate/src/java/com/thoughtworks/xstream/hibernate/security/HibernateProxyTypePermission.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 19. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.hibernate.security;
+
+import org.hibernate.proxy.HibernateProxy;
+
+import com.thoughtworks.xstream.security.TypePermission;
+
+
+/**
+ * Permission for any array type.
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class HibernateProxyTypePermission implements TypePermission {
+    /**
+     * @since upcoming
+     */
+    public static final TypePermission PROXIES = new HibernateProxyTypePermission();
+
+    public boolean allows(final Class type) {
+        return type != null && HibernateProxy.class.isAssignableFrom(type);
+    }
+
+    public int hashCode() {
+        return 31;
+    }
+
+    public boolean equals(final Object obj) {
+        return obj != null && obj.getClass() == HibernateProxyTypePermission.class;
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/XStream.java b/xstream/src/java/com/thoughtworks/xstream/XStream.java
index 459f7eeb..e4fea505 100644
--- a/xstream/src/java/com/thoughtworks/xstream/XStream.java
+++ b/xstream/src/java/com/thoughtworks/xstream/XStream.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2003, 2004, 2005, 2006 Joe Walnes.
- * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 XStream Committers.
+ * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 XStream Committers.
  * All rights reserved.
  *
  * The software in this package is published under the terms of the BSD
@@ -137,8 +137,16 @@
 import com.thoughtworks.xstream.mapper.MapperWrapper;
 import com.thoughtworks.xstream.mapper.OuterClassMapper;
 import com.thoughtworks.xstream.mapper.PackageAliasingMapper;
+import com.thoughtworks.xstream.mapper.SecurityMapper;
 import com.thoughtworks.xstream.mapper.SystemAttributeAliasingMapper;
 import com.thoughtworks.xstream.mapper.XStream11XmlFriendlyMapper;
+import com.thoughtworks.xstream.security.AnyTypePermission;
+import com.thoughtworks.xstream.security.ExplicitTypePermission;
+import com.thoughtworks.xstream.security.NoPermission;
+import com.thoughtworks.xstream.security.NoTypePermission;
+import com.thoughtworks.xstream.security.RegExpTypePermission;
+import com.thoughtworks.xstream.security.TypePermission;
+import com.thoughtworks.xstream.security.WildcardTypePermission;
 
 
 /**
@@ -274,7 +282,7 @@
  * The XStream instance is thread-safe. That is, once the XStream instance has been created and
  * configured, it may be shared across multiple threads allowing objects to be
  * serialized/deserialized concurrently. <em>Note, that this only applies if annotations are not 
- * auto-detected on -the-fly.</em>
+ * auto-detected on-the-fly.</em>
  * </p>
  * <h3>Implicit collections</h3>
  * 
@@ -310,6 +318,7 @@
     private ImmutableTypesMapper immutableTypesMapper;
     private ImplicitCollectionMapper implicitCollectionMapper;
     private LocalConversionMapper localConversionMapper;
+    private SecurityMapper securityMapper;
     private AnnotationConfiguration annotationConfiguration;
 
     public static final int NO_REFERENCES = 1001;
@@ -558,6 +567,7 @@ public XStream(
         this.mapper = mapper == null ? buildMapper() : mapper;
 
         setupMappers();
+        setupSecurity();
         setupAliases();
         setupDefaultImplementations();
         setupConverters();
@@ -588,6 +598,7 @@ private Mapper buildMapper() {
         }
         mapper = new LocalConversionMapper(mapper);
         mapper = new ImmutableTypesMapper(mapper);
+        mapper = new SecurityMapper(mapper);
         if (JVM.is15()) {
             mapper = buildMapperDynamically(ANNOTATION_MAPPER_TYPE, new Class[]{
                 Mapper.class, ConverterRegistry.class, ConverterLookup.class,
@@ -641,9 +652,19 @@ private void setupMappers() {
             .lookupMapperOfType(ImmutableTypesMapper.class);
         localConversionMapper = (LocalConversionMapper)this.mapper
             .lookupMapperOfType(LocalConversionMapper.class);
+        securityMapper = (SecurityMapper)this.mapper
+            .lookupMapperOfType(SecurityMapper.class);
         annotationConfiguration = (AnnotationConfiguration)this.mapper
             .lookupMapperOfType(AnnotationConfiguration.class);
     }
+    
+    protected void setupSecurity() {
+        if (securityMapper == null) {
+            return;
+        }
+        
+        addPermission(AnyTypePermission.ANY);
+    }
 
     protected void setupAliases() {
         if (classAliasingMapper == null) {
@@ -1974,6 +1995,129 @@ public void autodetectAnnotations(boolean mode) {
             annotationConfiguration.autodetectAnnotations(mode);
         }
     }
+    
+    /**
+     * Add a new security permission.
+     * 
+     * <p>
+     * Permissions are evaluated in the added sequence. An instance of {@link NoTypePermission} or
+     * {@link AnyTypePermission} will implicitly wipe any existing permission.
+     * </p>
+     * 
+     * @param permission the permission to add
+     * @since upcoming
+     */
+    public void addPermission(TypePermission permission) {
+        if (securityMapper != null) {
+            securityMapper.addPermission(permission);
+        }
+    }
+    
+    /**
+     * Add security permission for explicit types by name.
+     * 
+     * @param names the type names to allow
+     * @since upcoming
+     */
+    public void allowTypes(String... names) {
+        addPermission(new ExplicitTypePermission(names));
+    }
+    
+    /**
+     * Add security permission for types matching one of the specified regular expressions.
+     * 
+     * @param regexps the regular expressions to allow type names
+     * @since upcoming
+     */
+    public void allowTypesByRegExp(String... regexps) {
+        addPermission(new RegExpTypePermission(regexps));
+    }
+    
+    /**
+     * Add security permission for types matching one of the specified regular expressions.
+     * 
+     * @param regexps the regular expressions to allow type names
+     * @since upcoming
+     */
+    public void allowTypesByRegExp(Pattern... regexps) {
+        addPermission(new RegExpTypePermission(regexps));
+    }
+    
+    /**
+     * Add security permission for types matching one of the specified wildcard patterns.
+     * <p>
+     * Supported are patterns with path expressions using dot as separator:
+     * </p>
+     * <ul>
+     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>
+     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like 'java.lang.*'</li>
+     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and subpackages like 'java.lang.**'</li>
+     * </ul>
+     * 
+     * @param patterns the patterns to allow type names
+     * @since upcoming
+     */
+    public void allowTypesByWildcard(String... patterns) {
+        addPermission(new WildcardTypePermission(patterns));
+    }
+    
+    /**
+     * Add security permission denying another one.
+     * 
+     * @param permission the permission to deny
+     * @since upcoming
+     */
+    public void denyPermission(TypePermission permission) {
+        addPermission(new NoPermission(permission));
+    }
+    
+    /**
+     * Add security permission forbidding explicit types by name.
+     * 
+     * @param names the type names to forbid
+     * @since upcoming
+     */
+    public void denyTypes(String... names) {
+        denyPermission(new ExplicitTypePermission(names));
+    }
+    
+    /**
+     * Add security permission forbidding types matching one of the specified regular expressions.
+     * 
+     * @param regexps the regular expressions to forbid type names
+     * @since upcoming
+     */
+    public void denyTypesByRegExp(String... regexps) {
+        denyPermission(new RegExpTypePermission(regexps));
+    }
+    
+    /**
+     * Add security permission forbidding types matching one of the specified regular expressions.
+     * 
+     * @param regexps the regular expressions to forbid type names
+     * @since upcoming
+     */
+    public void denyTypesByRegExp(Pattern... regexps) {
+        denyPermission(new RegExpTypePermission(regexps));
+    }
+    
+    /**
+     * Add security permission forbidding types matching one of the specified wildcard patterns.
+     * <p>
+     * Supported are patterns with path expressions using dot as separator:
+     * </p>
+     * <ul>
+     * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>
+     * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like 'java.lang.*'</li>
+     * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and subpackages like 'java.lang.**'</li>
+     * </ul>
+     * 
+     * @param patterns the patterns to forbid names
+     * @since upcoming
+     */
+    public void denyTypesByWildcard(String... patterns) {
+        denyPermission(new WildcardTypePermission(patterns));
+    }
 
     /**
      * @deprecated As of 1.3, use {@link com.thoughtworks.xstream.InitializationException}
diff --git a/xstream/src/java/com/thoughtworks/xstream/mapper/CachingMapper.java b/xstream/src/java/com/thoughtworks/xstream/mapper/CachingMapper.java
index f4ea4cbb..c6dbee01 100644
--- a/xstream/src/java/com/thoughtworks/xstream/mapper/CachingMapper.java
+++ b/xstream/src/java/com/thoughtworks/xstream/mapper/CachingMapper.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2005 Joe Walnes.
- * Copyright (C) 2006, 2007, 2008, 2009, 2011, 2013 XStream Committers.
+ * Copyright (C) 2006, 2007, 2008, 2009, 2011, 2013, 2014 XStream Committers.
  * All rights reserved.
  *
  * The software in this package is published under the terms of the BSD
@@ -15,7 +15,9 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import com.thoughtworks.xstream.XStreamException;
 import com.thoughtworks.xstream.core.Caching;
+import com.thoughtworks.xstream.security.ForbiddenClassException;
 
 /**
  * Mapper that caches which names map to which classes. Prevents repetitive searching and class loading.
@@ -38,13 +40,16 @@ public Class realClass(String elementName) {
             if (cached instanceof Class) {
                 return (Class)cached;
             }
-            throw (CannotResolveClassException)cached;
+            throw (XStreamException)cached;
         }
 
         try {
             Class result = super.realClass(elementName);
             realClassCache.put(elementName, result);
             return result;
+        } catch (ForbiddenClassException e) {
+            realClassCache.put(elementName, e);
+            throw e;
         } catch (CannotResolveClassException e) {
             realClassCache.put(elementName, e);
             throw e;
diff --git a/xstream/src/java/com/thoughtworks/xstream/mapper/SecurityMapper.java b/xstream/src/java/com/thoughtworks/xstream/mapper/SecurityMapper.java
new file mode 100644
index 00000000..9171e396
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/mapper/SecurityMapper.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 08. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.mapper;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import com.thoughtworks.xstream.security.AnyTypePermission;
+import com.thoughtworks.xstream.security.ForbiddenClassException;
+import com.thoughtworks.xstream.security.NoTypePermission;
+import com.thoughtworks.xstream.security.TypePermission;
+
+
+/**
+ * A Mapper implementation injecting a security layer based on permission rules for any type required in the
+ * unmarshalling process.
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class SecurityMapper extends MapperWrapper {
+
+    private final List<TypePermission> permissions;
+
+    /**
+     * Construct a SecurityMapper.
+     * 
+     * @param wrapped the mapper chain
+     * @since upcoming
+     */
+    public SecurityMapper(final Mapper wrapped) {
+        this(wrapped, (TypePermission[])null);
+    }
+
+    /**
+     * Construct a SecurityMapper.
+     * 
+     * @param wrapped the mapper chain
+     * @param permissions the predefined permissions
+     * @since upcoming
+     */
+    public SecurityMapper(final Mapper wrapped, final TypePermission... permissions) {
+        super(wrapped);
+        this.permissions = permissions == null //
+            ? new ArrayList<TypePermission>()
+            : new ArrayList<TypePermission>(Arrays.asList(permissions));
+    }
+
+    /**
+     * Add a new permission.
+     * <p>
+     * Permissions are evaluated in the added sequence. An instance of {@link NoTypePermission} or
+     * {@link AnyTypePermission} will implicitly wipe any existing permission.
+     * </p>
+     * 
+     * @param permission the permission to add.
+     * @since upcoming
+     */
+    public void addPermission(final TypePermission permission) {
+        if (permission.equals(NoTypePermission.NONE) || permission.equals(AnyTypePermission.ANY))
+            permissions.clear();
+        permissions.add(permission);
+    }
+
+    public Class realClass(final String elementName) {
+        final Class type = super.realClass(elementName);
+        for (final TypePermission permission : permissions)
+            if (permission.allows(type))
+                return type;
+        throw new ForbiddenClassException(type);
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/AnyTypePermission.java b/xstream/src/java/com/thoughtworks/xstream/security/AnyTypePermission.java
new file mode 100644
index 00000000..21b36409
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/AnyTypePermission.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 08. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+/**
+ * Permission for any type and <code>null</code>.
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class AnyTypePermission implements TypePermission {
+    /**
+     * @since upcoming
+     */
+    public static final TypePermission ANY = new AnyTypePermission();
+
+    public boolean allows(Class type) {
+        return true;
+    }
+
+    public int hashCode() {
+        return 3;
+    }
+
+    public boolean equals(Object obj) {
+        return obj != null && obj.getClass() == AnyTypePermission.class;
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/ArrayTypePermission.java b/xstream/src/java/com/thoughtworks/xstream/security/ArrayTypePermission.java
new file mode 100644
index 00000000..34cc6288
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/ArrayTypePermission.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 09. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+/**
+ * Permission for any array type.
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class ArrayTypePermission implements TypePermission {
+    /**
+     * @since upcoming
+     */
+    public static final TypePermission ARRAYS = new ArrayTypePermission();
+
+    public boolean allows(Class type) {
+        return type != null && type.isArray();
+    }
+
+    public int hashCode() {
+        return 13;
+    }
+
+    public boolean equals(Object obj) {
+        return obj != null && obj.getClass() == ArrayTypePermission.class;
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/CGLIBProxyTypePermission.java b/xstream/src/java/com/thoughtworks/xstream/security/CGLIBProxyTypePermission.java
new file mode 100644
index 00000000..3e521b97
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/CGLIBProxyTypePermission.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 19. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+import net.sf.cglib.proxy.Proxy;
+
+
+/**
+ * Permission for any array type.
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class CGLIBProxyTypePermission implements TypePermission {
+    /**
+     * @since upcoming
+     */
+    public static final TypePermission PROXIES = new CGLIBProxyTypePermission();
+
+    public boolean allows(final Class type) {
+        return type != null && Proxy.isProxyClass(type);
+    }
+
+    public int hashCode() {
+        return 19;
+    }
+
+    public boolean equals(final Object obj) {
+        return obj != null && obj.getClass() == CGLIBProxyTypePermission.class;
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/ExplicitTypePermission.java b/xstream/src/java/com/thoughtworks/xstream/security/ExplicitTypePermission.java
new file mode 100644
index 00000000..1d8e4473
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/ExplicitTypePermission.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 09. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Explicit permission for a type with a name matching one in the provided list.
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class ExplicitTypePermission implements TypePermission {
+
+    final Set<String> names;
+    
+    /**
+     * @since upcoming
+     */
+    public ExplicitTypePermission(String...names) {
+        this.names = names == null ? Collections.<String>emptySet() : new HashSet<String>(Arrays.asList(names));
+    }
+
+    public boolean allows(Class type) {
+        if (type == null)
+            return false;
+        return names.contains(type.getName());
+    }
+
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/ForbiddenClassException.java b/xstream/src/java/com/thoughtworks/xstream/security/ForbiddenClassException.java
new file mode 100644
index 00000000..041e47a6
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/ForbiddenClassException.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 08. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+import com.thoughtworks.xstream.XStreamException;
+
+/**
+ * Exception thrown for a forbidden class.
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class ForbiddenClassException extends XStreamException {
+
+    /**
+     * Construct a ForbiddenClassException.
+     * @param type the forbidden class
+     * @since upcoming
+     */
+    public ForbiddenClassException(Class<?> type) {
+        super(type == null ? "null" : type.getName());
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/NoPermission.java b/xstream/src/java/com/thoughtworks/xstream/security/NoPermission.java
new file mode 100644
index 00000000..cf6ccb31
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/NoPermission.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 09. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+/**
+ * Wrapper to negate another type permission.
+ * <p>
+ * If the wrapped {@link TypePermission} allows the type, this instance will throw a {@link ForbiddenClassException}
+ * instead. An instance of this permission cannot be used to allow a type.
+ * </p>
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class NoPermission implements TypePermission {
+
+    private final TypePermission permission;
+
+    /**
+     * Construct a NoPermission.
+     * 
+     * @param permission the permission to negate or <code>null</code> to forbid any type
+     * @since upcoming
+     */
+    public NoPermission(final TypePermission permission) {
+        this.permission = permission;
+    }
+
+    public boolean allows(final Class type) {
+        if (permission == null || permission.allows(type)) {
+            throw new ForbiddenClassException(type);
+        }
+        return false;
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/NoTypePermission.java b/xstream/src/java/com/thoughtworks/xstream/security/NoTypePermission.java
new file mode 100644
index 00000000..89e08c28
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/NoTypePermission.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 08. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+/**
+ * No permission for any type.
+ * <p>
+ * Can be used to skip any existing default permission.
+ * </p>
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class NoTypePermission implements TypePermission {
+
+    /**
+     * @since upcoming
+     */
+    public static final TypePermission NONE = new NoTypePermission();
+
+    public boolean allows(Class type) {
+        throw new ForbiddenClassException(type);
+    }
+
+    public int hashCode() {
+        return 1;
+    }
+
+    public boolean equals(Object obj) {
+        return obj != null && obj.getClass() == NoTypePermission.class;
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/NullPermission.java b/xstream/src/java/com/thoughtworks/xstream/security/NullPermission.java
new file mode 100644
index 00000000..c9dc86de
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/NullPermission.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 09. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+import com.thoughtworks.xstream.mapper.Mapper;
+
+/**
+ * Permission for <code>null</code> or XStream's null replacement type.
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class NullPermission implements TypePermission {
+    /**
+     * @since upcoming
+     */
+    public static final TypePermission NULL = new NullPermission();
+
+    public boolean allows(Class type) {
+        return type == null || type == Mapper.Null.class;
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/PrimitiveTypePermission.java b/xstream/src/java/com/thoughtworks/xstream/security/PrimitiveTypePermission.java
new file mode 100644
index 00000000..4bdac260
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/PrimitiveTypePermission.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 09. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+import com.thoughtworks.xstream.core.util.Primitives;
+
+/**
+ * Permission for any primitive type and its boxed counterpart.
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class PrimitiveTypePermission implements TypePermission {
+    /**
+     * @since upcoming
+     */
+    public static final TypePermission PRIMITIVES = new PrimitiveTypePermission();
+
+    public boolean allows(Class type) {
+        return type != null && type.isPrimitive() || Primitives.isBoxed(type);
+    }
+
+    public int hashCode() {
+        return 7;
+    }
+
+    public boolean equals(Object obj) {
+        return obj != null && obj.getClass() == PrimitiveTypePermission.class;
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/ProxyTypePermission.java b/xstream/src/java/com/thoughtworks/xstream/security/ProxyTypePermission.java
new file mode 100644
index 00000000..82c6501f
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/ProxyTypePermission.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 19. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+import java.lang.reflect.Proxy;
+
+
+/**
+ * Permission for any array type.
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class ProxyTypePermission implements TypePermission {
+    /**
+     * @since upcoming
+     */
+    public static final TypePermission PROXIES = new ProxyTypePermission();
+
+    public boolean allows(final Class type) {
+        return type != null && Proxy.isProxyClass(type);
+    }
+
+    public int hashCode() {
+        return 17;
+    }
+
+    public boolean equals(final Object obj) {
+        return obj != null && obj.getClass() == ProxyTypePermission.class;
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/RegExpTypePermission.java b/xstream/src/java/com/thoughtworks/xstream/security/RegExpTypePermission.java
new file mode 100644
index 00000000..151ccdb2
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/RegExpTypePermission.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 09. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+import java.util.regex.Pattern;
+
+
+/**
+ * Permission for any type with a name matching one of the provided regular expressions.
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class RegExpTypePermission implements TypePermission {
+
+    private final Pattern[] patterns;
+
+    public RegExpTypePermission(final String... patterns) {
+        this(getPatterns(patterns));
+    }
+
+    public RegExpTypePermission(final Pattern... patterns) {
+        this.patterns = patterns == null ? new Pattern[0] : patterns;
+    }
+
+    public boolean allows(final Class type) {
+        if (type != null) {
+            final String name = type.getName();
+            for (final Pattern pattern : patterns)
+                if (pattern.matcher(name).matches())
+                    return true;
+        }
+        return false;
+    }
+
+    private static Pattern[] getPatterns(final String... patterns) {
+        if (patterns == null)
+            return null;
+        final Pattern[] array = new Pattern[patterns.length];
+        for (int i = 0; i < array.length; ++i)
+            array[i] = Pattern.compile(patterns[i]);
+        return array;
+    }
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/TypePermission.java b/xstream/src/java/com/thoughtworks/xstream/security/TypePermission.java
new file mode 100644
index 00000000..c38c8856
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/TypePermission.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 08. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+/**
+ * Definition of a type permission. 
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public interface TypePermission {
+    /**
+     * Check permission for a provided type.
+     * 
+     * @param type the type to check
+     * @return <code>true</code> if provided type is allowed, <code>false</code> if permission does not handle the type
+     * @throws ForbiddenClassException if provided type is explicitly forbidden
+     * @since upcoming
+     */
+    boolean allows(Class type);
+}
diff --git a/xstream/src/java/com/thoughtworks/xstream/security/WildcardTypePermission.java b/xstream/src/java/com/thoughtworks/xstream/security/WildcardTypePermission.java
new file mode 100644
index 00000000..ffa93de3
--- /dev/null
+++ b/xstream/src/java/com/thoughtworks/xstream/security/WildcardTypePermission.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 09. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.security;
+
+/**
+ * Permission for any type with a name matching one of the provided wildcard expressions.
+ * 
+ * <p>
+ * Supported are patterns with path expressions using dot as separator:
+ * </p>
+ * <ul>
+ * <li>?: one non-control character except separator, e.g. for 'java.net.Inet?Address'</li>
+ * <li>*: arbitrary number of non-control characters except separator, e.g. for types in a package like 'java.lang.*'</li>
+ * <li>**: arbitrary number of non-control characters including separator, e.g. for types in a package and subpackages like 'java.lang.**'</li>
+ * </ul>
+ * <p>
+ * The complete range of UTF-8 characters is supported except control characters.
+ * </p>
+ * 
+ * @author J&ouml;rg Schaible
+ * @since upcoming
+ */
+public class WildcardTypePermission extends RegExpTypePermission {
+
+    /**
+     * @since upcoming
+     */
+    public WildcardTypePermission(final String... patterns) {
+        super(getRegExpPatterns(patterns));
+    }
+
+    private static String[] getRegExpPatterns(final String... wildcards) {
+        if (wildcards == null)
+            return null;
+        final String[] regexps = new String[wildcards.length];
+        for (int i = 0; i < wildcards.length; ++i) {
+            final String wildcardExpression = wildcards[i];
+            final StringBuilder result = new StringBuilder(wildcardExpression.length() * 2);
+            result.append("(?u)");
+            final int length = wildcardExpression.length();
+            for (int j = 0; j < length; j++) {
+                final char ch = wildcardExpression.charAt(j);
+                switch (ch) {
+                case '\\':
+                case '.':
+                case '+':
+                case '|':
+                case '[':
+                case ']':
+                case '(':
+                case ')':
+                case '^':
+                case '$':
+                    result.append('\\').append(ch);
+                    break;
+
+                case '?':
+                    result.append('.');
+                    break;
+
+                case '*':
+                    // see "General Category Property" in http://www.unicode.org/reports/tr18/
+                    if (j + 1 < length && wildcardExpression.charAt(j + 1) == '*') {
+                        result.append("[\\P{C}]*");
+                        j++;
+                    } else {
+                        result.append("[\\P{C}&&[^").append('.').append("]]*");
+                    }
+                    break;
+
+                default:
+                    result.append(ch);
+                    break;
+                }
+            }
+            regexps[i] = result.toString();
+        }
+        return regexps;
+    }
+}
diff --git a/xstream/src/test/com/thoughtworks/xstream/mapper/SecurityMapperTest.java b/xstream/src/test/com/thoughtworks/xstream/mapper/SecurityMapperTest.java
new file mode 100644
index 00000000..ebde756e
--- /dev/null
+++ b/xstream/src/test/com/thoughtworks/xstream/mapper/SecurityMapperTest.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2014 XStream Committers.
+ * All rights reserved.
+ *
+ * Created on 09. January 2014 by Joerg Schaible
+ */
+package com.thoughtworks.xstream.mapper;
+
+import java.net.URL;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import com.thoughtworks.xstream.core.JVM;
+import com.thoughtworks.xstream.core.util.QuickWriter;
+import com.thoughtworks.xstream.security.AnyTypePermission;
+import com.thoughtworks.xstream.security.ArrayTypePermission;
+import com.thoughtworks.xstream.security.ExplicitTypePermission;
+import com.thoughtworks.xstream.security.ForbiddenClassException;
+import com.thoughtworks.xstream.security.NoTypePermission;
+import com.thoughtworks.xstream.security.NullPermission;
+import com.thoughtworks.xstream.security.PrimitiveTypePermission;
+import com.thoughtworks.xstream.security.RegExpTypePermission;
+import com.thoughtworks.xstream.security.TypePermission;
+import com.thoughtworks.xstream.security.WildcardTypePermission;
+
+import junit.framework.TestCase;
+
+
+/**
+ * Tests the {@link SecurityMapper} and the {@link TypePermission} implementations.
+ * 
+ * @author J&ouml;rg Schaible
+ */
+public class SecurityMapperTest extends TestCase {
+
+    private SecurityMapper mapper;
+    private Map<String, Class<?>> classMap;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        classMap = new HashMap<String, Class<?>>();
+        mapper = new SecurityMapper(new MapperWrapper(null) {
+            @Override
+            public Class realClass(final String elementName) {
+                return classMap.get(elementName);
+            }
+        });
+    }
+
+    private void register(final Class<?>... types) {
+        for (final Class<?> type : types) {
+            classMap.put(type.getName(), type);
+        }
+    }
+
+    public void testAnyType() {
+        register(String.class, URL.class, List.class);
+        mapper.addPermission(NoTypePermission.NONE);
+        mapper.addPermission(AnyTypePermission.ANY);
+        assertSame(String.class, mapper.realClass(String.class.getName()));
+        assertSame(List.class, mapper.realClass(List.class.getName()));
+        assertNull(mapper.realClass(null));
+    }
+
+    public void testNoType() {
+        register(String.class, URL.class, List.class);
+        mapper.addPermission(NoTypePermission.NONE);
+        try {
+            mapper.realClass(String.class.getName());
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals(String.class.getName(), e.getMessage());
+        }
+        try {
+            mapper.realClass(null);
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals("null", e.getMessage());
+        }
+    }
+
+    public void testNullType() {
+        register(String.class, Mapper.Null.class);
+        mapper.addPermission(NullPermission.NULL);
+        assertSame(Mapper.Null.class, mapper.realClass(Mapper.Null.class.getName()));
+        assertNull(mapper.realClass(null));
+        try {
+            mapper.realClass(String.class.getName());
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals(String.class.getName(), e.getMessage());
+        }
+    }
+
+    public void testPrimitiveTypes() {
+        register(String.class, int.class, Integer.class, char[].class, Character[].class);
+        mapper.addPermission(PrimitiveTypePermission.PRIMITIVES);
+        assertSame(int.class, mapper.realClass(int.class.getName()));
+        assertSame(Integer.class, mapper.realClass(Integer.class.getName()));
+        try {
+            mapper.realClass(String.class.getName());
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals(String.class.getName(), e.getMessage());
+        }
+        try {
+            mapper.realClass(null);
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals("null", e.getMessage());
+        }
+        try {
+            mapper.realClass(char[].class.getName());
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals(char[].class.getName(), e.getMessage());
+        }
+    }
+
+    public void testArrayTypes() {
+        register(String.class, int.class, Integer.class, char[].class, Character[].class);
+        mapper.addPermission(ArrayTypePermission.ARRAYS);
+        assertSame(char[].class, mapper.realClass(char[].class.getName()));
+        assertSame(Character[].class, mapper.realClass(Character[].class.getName()));
+        try {
+            mapper.realClass(String.class.getName());
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals(String.class.getName(), e.getMessage());
+        }
+        try {
+            mapper.realClass(null);
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals("null", e.getMessage());
+        }
+        try {
+            mapper.realClass(int.class.getName());
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals(int.class.getName(), e.getMessage());
+        }
+    }
+
+    public void testExplicitTypes() {
+        register(String.class, List.class);
+        mapper.addPermission(new ExplicitTypePermission(String.class.getName(), List.class.getName()));
+        assertSame(String.class, mapper.realClass(String.class.getName()));
+        assertSame(List.class, mapper.realClass(List.class.getName()));
+        try {
+            mapper.realClass(null);
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals("null", e.getMessage());
+        }
+    }
+
+    public void testNamesWithRegExps() {
+        class Foo$_0 {}
+        final Class<?> anonymous = new Object() {}.getClass();
+        register(String.class, JVM.class, QuickWriter.class, Foo$_0.class, anonymous, DefaultClassMapperTest.class);
+        mapper.addPermission(new RegExpTypePermission(".*Test", ".*\\.core\\..*", ".*SecurityMapperTest\\$.+"));
+        assertSame(DefaultClassMapperTest.class, mapper.realClass(DefaultClassMapperTest.class.getName()));
+        assertSame(JVM.class, mapper.realClass(JVM.class.getName()));
+        assertSame(QuickWriter.class, mapper.realClass(QuickWriter.class.getName()));
+        assertSame(Foo$_0.class, mapper.realClass(Foo$_0.class.getName()));
+        assertSame(anonymous, mapper.realClass(anonymous.getName()));
+        try {
+            mapper.realClass(String.class.getName());
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals(String.class.getName(), e.getMessage());
+        }
+    }
+
+    public void testNamesWithWildcardPatterns() {
+        class Foo$_0 {}
+        class Foo$_1 {}
+        final Class<?> anonymous = new Object() {}.getClass();
+        register(String.class, JVM.class, QuickWriter.class, Foo$_0.class, Foo$_1.class, anonymous);
+        mapper.addPermission(new WildcardTypePermission("**.*_0", "**.core.*", "**.SecurityMapperTest$?"));
+        assertSame(JVM.class, mapper.realClass(JVM.class.getName()));
+        assertSame(Foo$_0.class, mapper.realClass(Foo$_0.class.getName()));
+        assertSame(anonymous, mapper.realClass(anonymous.getName()));
+        try {
+            mapper.realClass(String.class.getName());
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals(String.class.getName(), e.getMessage());
+        }
+        try {
+            mapper.realClass(QuickWriter.class.getName());
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals(QuickWriter.class.getName(), e.getMessage());
+        }
+        try {
+            mapper.realClass(Foo$_1.class.getName());
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            assertEquals(Foo$_1.class.getName(), e.getMessage());
+        }
+    }
+}
