diff --git a/cdi/src/main/java/org/hibernate/validator/internal/cdi/InheritedMethodsHelper.java b/cdi/src/main/java/org/hibernate/validator/internal/cdi/InheritedMethodsHelper.java
new file mode 100644
index 000000000..97e0e4619
--- /dev/null
+++ b/cdi/src/main/java/org/hibernate/validator/internal/cdi/InheritedMethodsHelper.java
@@ -0,0 +1,71 @@
+/*
+ * JBoss, Home of Professional Open Source
+ * Copyright 2014, Red Hat, Inc. and/or its affiliates, and individual contributors
+ * by the @authors tag. See the copyright.txt in the distribution for a
+ * full listing of individual contributors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.hibernate.validator.internal.cdi;
+
+import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
+
+import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.Collections;
+import java.util.List;
+
+import org.hibernate.validator.internal.util.Contracts;
+import org.hibernate.validator.internal.util.classhierarchy.ClassHierarchyHelper;
+import org.hibernate.validator.internal.util.privilegedactions.GetMethods;
+
+/**
+ * Deals with methods of types in inheritance hierarchies.
+ *
+ * @author Hardy Ferentschik
+ * @author Gunnar Morling
+ *
+ */
+class InheritedMethodsHelper {
+
+	/**
+	 * Get a list of all methods wich the given class declares, implements,
+	 * overrides or inherits. Methods are added by adding first all methods of
+	 * the class itself and its implemented interfaces, then the super class and
+	 * its interfaces, etc.
+	 *
+	 * @param clazz the class for which to retrieve the methods
+	 *
+	 * @return set of all methods of the given class
+	 */
+	static List<Method> getAllMethods(Class<?> clazz) {
+		Contracts.assertNotNull( clazz );
+
+		List<Method> methods = newArrayList();
+
+		for ( Class<?> hierarchyClass : ClassHierarchyHelper.getHierarchy( clazz ) ) {
+			Collections.addAll( methods, run( GetMethods.action( hierarchyClass ) ) );
+		}
+
+		return methods;
+	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private static <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
+}
diff --git a/cdi/src/main/java/org/hibernate/validator/internal/cdi/ValidationExtension.java b/cdi/src/main/java/org/hibernate/validator/internal/cdi/ValidationExtension.java
index a52db0ebe..5d8c51ee9 100644
--- a/cdi/src/main/java/org/hibernate/validator/internal/cdi/ValidationExtension.java
+++ b/cdi/src/main/java/org/hibernate/validator/internal/cdi/ValidationExtension.java
@@ -26,6 +26,7 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
+
 import javax.enterprise.event.Observes;
 import javax.enterprise.inject.Default;
 import javax.enterprise.inject.spi.AfterBeanDiscovery;
@@ -60,7 +61,6 @@
 import org.hibernate.validator.internal.util.ExecutableHelper;
 import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.TypeResolutionHelper;
-import org.hibernate.validator.internal.util.classhierarchy.ClassHierarchyHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
 
@@ -268,7 +268,7 @@ else if ( bean.getTypes().contains( Validator.class ) || bean instanceof Validat
 	private <T> void determineConstrainedMethod(AnnotatedType<T> type,
 			BeanDescriptor beanDescriptor,
 			Set<AnnotatedCallable<? super T>> callables) {
-		List<Method> overriddenAndImplementedMethods = ClassHierarchyHelper.getAllMethods( type.getJavaClass() );
+		List<Method> overriddenAndImplementedMethods = InheritedMethodsHelper.getAllMethods( type.getJavaClass() );
 		for ( AnnotatedMethod<? super T> annotatedMethod : type.getMethods() ) {
 			Method method = annotatedMethod.getJavaMember();
 
diff --git a/cdi/src/main/java/org/hibernate/validator/internal/cdi/ValidatorFactoryBean.java b/cdi/src/main/java/org/hibernate/validator/internal/cdi/ValidatorFactoryBean.java
index e172a2a73..655c636e2 100644
--- a/cdi/src/main/java/org/hibernate/validator/internal/cdi/ValidatorFactoryBean.java
+++ b/cdi/src/main/java/org/hibernate/validator/internal/cdi/ValidatorFactoryBean.java
@@ -18,8 +18,11 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Collections;
 import java.util.Set;
+
 import javax.enterprise.context.ApplicationScoped;
 import javax.enterprise.context.spi.CreationalContext;
 import javax.enterprise.inject.spi.Bean;
@@ -36,8 +39,8 @@
 import javax.validation.ValidatorFactory;
 
 import org.hibernate.validator.internal.util.CollectionHelper;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.classhierarchy.ClassHierarchyHelper;
+import org.hibernate.validator.internal.util.privilegedactions.LoadClass;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
 
@@ -141,9 +144,11 @@ private MessageInterpolator createMessageInterpolator(Configuration<?> config) {
 		}
 
 		@SuppressWarnings("unchecked")
-		Class<MessageInterpolator> messageInterpolatorClass = (Class<MessageInterpolator>) ReflectionHelper.loadClass(
-				messageInterpolatorFqcn,
-				this.getClass()
+		Class<MessageInterpolator> messageInterpolatorClass = (Class<MessageInterpolator>) run(
+				LoadClass.action(
+						messageInterpolatorFqcn,
+						this.getClass()
+				)
 		);
 
 		return createInstance( messageInterpolatorClass );
@@ -158,9 +163,11 @@ private TraversableResolver createTraversableResolver(Configuration<?> config) {
 		}
 
 		@SuppressWarnings("unchecked")
-		Class<TraversableResolver> traversableResolverClass = (Class<TraversableResolver>) ReflectionHelper.loadClass(
-				traversableResolverFqcn,
-				this.getClass()
+		Class<TraversableResolver> traversableResolverClass = (Class<TraversableResolver>) run(
+				LoadClass.action(
+						traversableResolverFqcn,
+						this.getClass()
+				)
 		);
 
 		return createInstance( traversableResolverClass );
@@ -175,9 +182,11 @@ private ParameterNameProvider createParameterNameProvider(Configuration<?> confi
 		}
 
 		@SuppressWarnings("unchecked")
-		Class<ParameterNameProvider> parameterNameProviderClass = (Class<ParameterNameProvider>) ReflectionHelper.loadClass(
-				parameterNameProviderFqcn,
-				this.getClass()
+		Class<ParameterNameProvider> parameterNameProviderClass = (Class<ParameterNameProvider>) run(
+				LoadClass.action(
+						parameterNameProviderFqcn,
+						this.getClass()
+				)
 		);
 
 		return createInstance( parameterNameProviderClass );
@@ -193,11 +202,12 @@ private ConstraintValidatorFactory createConstraintValidatorFactory(Configuratio
 		}
 
 		@SuppressWarnings("unchecked")
-		Class<ConstraintValidatorFactory> constraintValidatorFactoryClass = (Class<ConstraintValidatorFactory>) ReflectionHelper
-				.loadClass(
+		Class<ConstraintValidatorFactory> constraintValidatorFactoryClass = (Class<ConstraintValidatorFactory>) run(
+				LoadClass.action(
 						constraintValidatorFactoryFqcn,
 						this.getClass()
-				);
+				)
+		);
 
 		return createInstance( constraintValidatorFactoryClass );
 	}
@@ -214,6 +224,16 @@ private ConstraintValidatorFactory createConstraintValidatorFactory(Configuratio
 				Validation.byProvider( org.hibernate.validator.HibernateValidator.class ).configure();
 	}
 
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
+
 	@Override
 	public String getId() {
 		return ValidatorFactoryBean.class.getName() + "_" + ( validationProviderHelper.isDefaultProvider() ? "default" : "hv" );
diff --git a/engine/src/main/java/org/hibernate/validator/internal/cfg/context/TypeConstraintMappingContextImpl.java b/engine/src/main/java/org/hibernate/validator/internal/cfg/context/TypeConstraintMappingContextImpl.java
index a7058dac8..a37e414aa 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/cfg/context/TypeConstraintMappingContextImpl.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/cfg/context/TypeConstraintMappingContextImpl.java
@@ -20,9 +20,12 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
+
 import javax.validation.ParameterNameProvider;
 
 import org.hibernate.validator.cfg.ConstraintDef;
@@ -44,6 +47,11 @@
 import org.hibernate.validator.internal.util.StringHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredConstructor;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredField;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredMethod;
+import org.hibernate.validator.internal.util.privilegedactions.GetMethod;
+import org.hibernate.validator.internal.util.privilegedactions.NewInstance;
 import org.hibernate.validator.spi.group.DefaultGroupSequenceProvider;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
@@ -114,7 +122,7 @@ public PropertyConstraintMappingContext property(String property, ElementType el
 		Contracts.assertNotNull( elementType, "The element type must not be null." );
 		Contracts.assertNotEmpty( property, MESSAGES.propertyNameMustNotBeEmpty() );
 
-		Member member = ReflectionHelper.getMember(
+		Member member = getMember(
 				beanClass, property, elementType
 		);
 
@@ -140,7 +148,7 @@ public PropertyConstraintMappingContext property(String property, ElementType el
 	public MethodConstraintMappingContext method(String name, Class<?>... parameterTypes) {
 		Contracts.assertNotNull( name, MESSAGES.methodNameMustNotBeNull() );
 
-		Method method = ReflectionHelper.getDeclaredMethod( beanClass, name, parameterTypes );
+		Method method = run( GetDeclaredMethod.action( beanClass, name, parameterTypes ) );
 
 		if ( method == null || method.getDeclaringClass() != beanClass ) {
 			throw log.getUnableToFindMethodException(
@@ -165,7 +173,7 @@ public MethodConstraintMappingContext method(String name, Class<?>... parameterT
 
 	@Override
 	public ConstructorConstraintMappingContext constructor(Class<?>... parameterTypes) {
-		Constructor<C> constructor = ReflectionHelper.getDeclaredConstructor( beanClass, parameterTypes );
+		Constructor<C> constructor = run( GetDeclaredConstructor.action( beanClass, parameterTypes ) );
 
 		if ( constructor == null || constructor.getDeclaringClass() != beanClass ) {
 			throw log.getBeanDoesNotContainConstructorException(
@@ -227,9 +235,11 @@ public ConstructorConstraintMappingContext constructor(Class<?>... parameterType
 	}
 
 	private DefaultGroupSequenceProvider<? super C> getDefaultGroupSequenceProvider() {
-		return defaultGroupSequenceProviderClass != null ? ReflectionHelper.newInstance(
-				defaultGroupSequenceProviderClass,
-				"default group sequence provider"
+		return defaultGroupSequenceProviderClass != null ? run(
+				NewInstance.action(
+						defaultGroupSequenceProviderClass,
+						"default group sequence provider"
+				)
 		) : null;
 	}
 
@@ -241,4 +251,50 @@ public ConstructorConstraintMappingContext constructor(Class<?>... parameterType
 	protected ConstraintType getConstraintType() {
 		return ConstraintType.GENERIC;
 	}
+
+	/**
+	 * Returns the member with the given name and type.
+	 *
+	 * @param clazz The class from which to retrieve the member. Cannot be {@code null}.
+	 * @param property The property name without "is", "get" or "has". Cannot be {@code null} or empty.
+	 * @param elementType The element type. Either {@code ElementType.FIELD} or {@code ElementType METHOD}.
+	 *
+	 * @return the member which matching the name and type or {@code null} if no such member exists.
+	 */
+	private Member getMember(Class<?> clazz, String property, ElementType elementType) {
+		Contracts.assertNotNull( clazz, MESSAGES.classCannotBeNull() );
+
+		if ( property == null || property.length() == 0 ) {
+			throw log.getPropertyNameCannotBeNullOrEmptyException();
+		}
+
+		if ( !( ElementType.FIELD.equals( elementType ) || ElementType.METHOD.equals( elementType ) ) ) {
+			throw log.getElementTypeHasToBeFieldOrMethodException();
+		}
+
+		Member member = null;
+		if ( ElementType.FIELD.equals( elementType ) ) {
+			member = run( GetDeclaredField.action( clazz, property ) );
+		}
+		else {
+			String methodName = property.substring( 0, 1 ).toUpperCase() + property.substring( 1 );
+			for ( String prefix : ReflectionHelper.PROPERTY_ACCESSOR_PREFIXES ) {
+				member = run( GetMethod.action( clazz, prefix + methodName ) );
+				if ( member != null ) {
+					break;
+				}
+			}
+		}
+		return member;
+	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/engine/ConfigurationImpl.java b/engine/src/main/java/org/hibernate/validator/internal/engine/ConfigurationImpl.java
index bf4f1fc37..74eb67cec 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/engine/ConfigurationImpl.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/engine/ConfigurationImpl.java
@@ -19,6 +19,8 @@
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -28,6 +30,7 @@
 import javax.validation.MessageInterpolator;
 import javax.validation.ParameterNameProvider;
 import javax.validation.TraversableResolver;
+import javax.validation.ValidationException;
 import javax.validation.ValidationProviderResolver;
 import javax.validation.ValidatorFactory;
 import javax.validation.spi.BootstrapState;
@@ -43,11 +46,11 @@
 import org.hibernate.validator.internal.engine.valuehandling.OptionalValueUnwrapper;
 import org.hibernate.validator.internal.util.CollectionHelper;
 import org.hibernate.validator.internal.util.Contracts;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.TypeResolutionHelper;
 import org.hibernate.validator.internal.util.Version;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.LoadClass;
 import org.hibernate.validator.internal.xml.ValidationBootstrapParameters;
 import org.hibernate.validator.internal.xml.ValidationXmlParser;
 import org.hibernate.validator.messageinterpolation.ResourceBundleMessageInterpolator;
@@ -433,6 +436,26 @@ private void applyXmlSettings(ValidationBootstrapParameters xmlParameters) {
 	}
 
 	private boolean isJavaFxInClasspath() {
-		return ReflectionHelper.isClassPresent( "javafx.application.Application", this.getClass() );
+		return isClassPresent( "javafx.application.Application" );
+	}
+
+	private boolean isClassPresent(String className) {
+		try {
+			run( LoadClass.action( className, getClass() ) );
+			return true;
+		}
+		catch ( ValidationException e ) {
+			return false;
+		}
+	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private static <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
 	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/engine/ValidatorFactoryImpl.java b/engine/src/main/java/org/hibernate/validator/internal/engine/ValidatorFactoryImpl.java
index 70a93957c..f7094c719 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/engine/ValidatorFactoryImpl.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/engine/ValidatorFactoryImpl.java
@@ -16,6 +16,8 @@
 */
 package org.hibernate.validator.internal.engine;
 
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Collections;
 import java.util.IdentityHashMap;
 import java.util.List;
@@ -40,10 +42,11 @@
 import org.hibernate.validator.internal.metadata.provider.ProgrammaticMetaDataProvider;
 import org.hibernate.validator.internal.metadata.provider.XmlMetaDataProvider;
 import org.hibernate.validator.internal.util.ExecutableHelper;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.TypeResolutionHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.LoadClass;
+import org.hibernate.validator.internal.util.privilegedactions.NewInstance;
 import org.hibernate.validator.messageinterpolation.ResourceBundleMessageInterpolator;
 import org.hibernate.validator.spi.valuehandling.ValidatedValueUnwrapper;
 
@@ -257,7 +260,7 @@ Validator createValidator(ConstraintValidatorFactory constraintValidatorFactory,
 				throw log.getMissingELDependenciesException();
 			}
 		}
-		
+
 		BeanMetaDataManager beanMetaDataManager;
 		if ( !beanMetaDataManagerMap.containsKey( parameterNameProvider ) ) {
 			beanMetaDataManager = new BeanMetaDataManager(
@@ -337,12 +340,21 @@ private boolean checkPropertiesForFailFast(Map<String, String> properties, boole
 
 		for ( String handlerName : handlerNames ) {
 			@SuppressWarnings("unchecked")
-			Class<? extends ValidatedValueUnwrapper<?>> handlerType = (Class<? extends ValidatedValueUnwrapper<?>>) ReflectionHelper
-					.loadClass( handlerName, ValidatorFactoryImpl.class );
-			handlers.add( ReflectionHelper.newInstance( handlerType, "validated value handler class" ) );
+			Class<? extends ValidatedValueUnwrapper<?>> handlerType = (Class<? extends ValidatedValueUnwrapper<?>>)
+					run( LoadClass.action( handlerName, ValidatorFactoryImpl.class ) );
+			handlers.add( run( NewInstance.action( handlerType, "validated value handler class" ) ) );
 		}
 
 		return handlers;
 	}
 
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/engine/constraintvalidation/ConstraintValidatorFactoryImpl.java b/engine/src/main/java/org/hibernate/validator/internal/engine/constraintvalidation/ConstraintValidatorFactoryImpl.java
index 90743225d..3252b4692 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/engine/constraintvalidation/ConstraintValidatorFactoryImpl.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/engine/constraintvalidation/ConstraintValidatorFactoryImpl.java
@@ -16,10 +16,13 @@
 */
 package org.hibernate.validator.internal.engine.constraintvalidation;
 
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+
 import javax.validation.ConstraintValidator;
 import javax.validation.ConstraintValidatorFactory;
 
-import org.hibernate.validator.internal.util.ReflectionHelper;
+import org.hibernate.validator.internal.util.privilegedactions.NewInstance;
 
 /**
  * Default {@code ConstraintValidatorFactory} using a no-arg constructor.
@@ -27,15 +30,26 @@
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  */
+//TODO Can we make the constructor non-public?
 public class ConstraintValidatorFactoryImpl implements ConstraintValidatorFactory {
 
 	@Override
 	public final <T extends ConstraintValidator<?, ?>> T getInstance(Class<T> key) {
-		return ReflectionHelper.newInstance( key, "ConstraintValidator" );
+		return run( NewInstance.action( key, "ConstraintValidator" ) );
 	}
 
 	@Override
 	public void releaseInstance(ConstraintValidator<?, ?> instance) {
 		// noop
 	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/engine/resolver/DefaultTraversableResolver.java b/engine/src/main/java/org/hibernate/validator/internal/engine/resolver/DefaultTraversableResolver.java
index 03faac84d..e8bd59293 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/engine/resolver/DefaultTraversableResolver.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/engine/resolver/DefaultTraversableResolver.java
@@ -18,6 +18,9 @@
 
 import java.lang.annotation.ElementType;
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+
 import javax.validation.Path;
 import javax.validation.TraversableResolver;
 import javax.validation.ValidationException;
@@ -25,6 +28,9 @@
 import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetMethod;
+import org.hibernate.validator.internal.util.privilegedactions.LoadClass;
+import org.hibernate.validator.internal.util.privilegedactions.NewInstance;
 
 /**
  * A JPA 2 aware {@code TraversableResolver}.
@@ -68,7 +74,7 @@ private void detectJPA() {
 		// check whether we have Persistence on the classpath
 		Class<?> persistenceClass;
 		try {
-			persistenceClass = ReflectionHelper.loadClass( PERSISTENCE_CLASS_NAME, this.getClass() );
+			persistenceClass = run( LoadClass.action( PERSISTENCE_CLASS_NAME, this.getClass() ) );
 		}
 		catch ( ValidationException e ) {
 			log.debugf(
@@ -79,7 +85,7 @@ private void detectJPA() {
 		}
 
 		// check whether Persistence contains getPersistenceUtil
-		Method persistenceUtilGetter = ReflectionHelper.getMethod( persistenceClass, PERSISTENCE_UTIL_METHOD );
+		Method persistenceUtilGetter = run( GetMethod.action( persistenceClass, PERSISTENCE_UTIL_METHOD ) );
 		if ( persistenceUtilGetter == null ) {
 			log.debugf(
 					"Found %s on classpath, but no method '%s'. Assuming JPA 1 environment. All properties will per default be traversable.",
@@ -92,7 +98,7 @@ private void detectJPA() {
 		// try to invoke the method to make sure that we are dealing with a complete JPA2 implementation
 		// unfortunately there are several incomplete implementations out there (see HV-374)
 		try {
-			Object persistence = ReflectionHelper.newInstance( persistenceClass, "persistence provider" );
+			Object persistence = run( NewInstance.action( persistenceClass, "persistence provider" ) );
 			ReflectionHelper.getValue(persistenceUtilGetter, persistence );
 		}
 		catch ( Exception e ) {
@@ -112,8 +118,8 @@ private void detectJPA() {
 		try {
 			@SuppressWarnings("unchecked")
 			Class<? extends TraversableResolver> jpaAwareResolverClass = (Class<? extends TraversableResolver>)
-					ReflectionHelper.loadClass( JPA_AWARE_TRAVERSABLE_RESOLVER_CLASS_NAME, this.getClass() );
-			jpaTraversableResolver = ReflectionHelper.newInstance( jpaAwareResolverClass, "" );
+					run( LoadClass.action( JPA_AWARE_TRAVERSABLE_RESOLVER_CLASS_NAME, this.getClass() ) );
+			jpaTraversableResolver = run( NewInstance.action( jpaAwareResolverClass, "" ) );
 			log.debugf(
 					"Instantiated JPA aware TraversableResolver of type %s.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASS_NAME
 			);
@@ -126,15 +132,27 @@ private void detectJPA() {
 		}
 	}
 
+	@Override
 	public boolean isReachable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType, Path pathToTraversableObject, ElementType elementType) {
 		return jpaTraversableResolver == null || jpaTraversableResolver.isReachable(
 				traversableObject, traversableProperty, rootBeanType, pathToTraversableObject, elementType
 		);
 	}
 
+	@Override
 	public boolean isCascadable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType, Path pathToTraversableObject, ElementType elementType) {
 		return jpaTraversableResolver == null || jpaTraversableResolver.isCascadable(
 				traversableObject, traversableProperty, rootBeanType, pathToTraversableObject, elementType
 		);
 	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/metadata/core/ConstraintHelper.java b/engine/src/main/java/org/hibernate/validator/internal/metadata/core/ConstraintHelper.java
index 19943c94a..5c8a97f54 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/metadata/core/ConstraintHelper.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/metadata/core/ConstraintHelper.java
@@ -18,13 +18,17 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ConcurrentMap;
+
 import javax.validation.Constraint;
 import javax.validation.ConstraintTarget;
 import javax.validation.ConstraintValidator;
+import javax.validation.ValidationException;
 import javax.validation.constraints.AssertFalse;
 import javax.validation.constraints.AssertTrue;
 import javax.validation.constraints.DecimalMax;
@@ -115,10 +119,13 @@
 import org.hibernate.validator.internal.constraintvalidators.bv.size.SizeValidatorForMap;
 import org.hibernate.validator.internal.constraintvalidators.hv.URLValidator;
 import org.hibernate.validator.internal.util.Contracts;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.Version;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetAnnotationParameter;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredMethods;
+import org.hibernate.validator.internal.util.privilegedactions.GetMethod;
+import org.hibernate.validator.internal.util.privilegedactions.LoadClass;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
 import static org.hibernate.validator.internal.util.CollectionHelper.newConcurrentHashMap;
@@ -415,7 +422,7 @@ private boolean supportsValidationTarget(Class<? extends ConstraintValidator<?,
 	 */
 	public boolean isMultiValueConstraint(Class<? extends Annotation> annotationType) {
 		boolean isMultiValueConstraint = false;
-		final Method method = ReflectionHelper.getMethod( annotationType, "value" );
+		final Method method = run( GetMethod.action( annotationType, "value" ) );
 		if ( method != null ) {
 			Class<?> returnType = method.getReturnType();
 			if ( returnType.isArray() && returnType.getComponentType().isAnnotation() ) {
@@ -444,10 +451,12 @@ public boolean isMultiValueConstraint(Class<? extends Annotation> annotationType
 	 * @return A list of constraint annotations, may be empty but never {@code null}.
 	 */
 	public <A extends Annotation> List<Annotation> getConstraintsFromMultiValueConstraint(A multiValueConstraint) {
-		Annotation[] annotations = ReflectionHelper.getAnnotationParameter(
-				multiValueConstraint,
-				"value",
-				Annotation[].class
+		Annotation[] annotations = run(
+				GetAnnotationParameter.action(
+						multiValueConstraint,
+						"value",
+						Annotation[].class
+				)
 		);
 		return Arrays.asList( annotations );
 	}
@@ -481,7 +490,7 @@ public boolean isConstraintAnnotation(Class<? extends Annotation> annotationType
 	}
 
 	private void assertNoParameterStartsWithValid(Class<? extends Annotation> annotationType) {
-		final Method[] methods = ReflectionHelper.getDeclaredMethods( annotationType );
+		final Method[] methods = run( GetDeclaredMethods.action( annotationType ) );
 		for ( Method m : methods ) {
 			if ( m.getName().startsWith( "valid" ) && !m.getName().equals( VALIDATION_APPLIES_TO ) ) {
 				throw log.getConstraintParametersCannotStartWithValidException();
@@ -491,7 +500,7 @@ private void assertNoParameterStartsWithValid(Class<? extends Annotation> annota
 
 	private void assertPayloadParameterExists(Class<? extends Annotation> annotationType) {
 		try {
-			final Method method = ReflectionHelper.getMethod( annotationType, PAYLOAD );
+			final Method method = run( GetMethod.action( annotationType, PAYLOAD ) );
 			if ( method == null ) {
 				throw log.getConstraintWithoutMandatoryParameterException( PAYLOAD, annotationType.getName() );
 			}
@@ -507,7 +516,7 @@ private void assertPayloadParameterExists(Class<? extends Annotation> annotation
 
 	private void assertGroupsParameterExists(Class<? extends Annotation> annotationType) {
 		try {
-			final Method method = ReflectionHelper.getMethod( annotationType, GROUPS );
+			final Method method = run( GetMethod.action( annotationType, GROUPS ) );
 			if ( method == null ) {
 				throw log.getConstraintWithoutMandatoryParameterException( GROUPS, annotationType.getName() );
 			}
@@ -522,7 +531,7 @@ private void assertGroupsParameterExists(Class<? extends Annotation> annotationT
 	}
 
 	private void assertMessageParameterExists(Class<? extends Annotation> annotationType) {
-		final Method method = ReflectionHelper.getMethod( annotationType, MESSAGE );
+		final Method method = run( GetMethod.action( annotationType, MESSAGE ) );
 		if ( method == null ) {
 			throw log.getConstraintWithoutMandatoryParameterException( MESSAGE, annotationType.getName() );
 		}
@@ -540,7 +549,7 @@ private void assertValidationAppliesToParameterSetUpCorrectly(Class<? extends An
 				annotationType,
 				ValidationTarget.PARAMETERS
 		).isEmpty();
-		final Method method = ReflectionHelper.getMethod( annotationType, VALIDATION_APPLIES_TO );
+		final Method method = run( GetMethod.action( annotationType, VALIDATION_APPLIES_TO ) );
 
 		if ( hasGenericValidators && hasCrossParameterValidator ) {
 			if ( method == null ) {
@@ -567,8 +576,8 @@ public boolean isConstraintComposition(Class<? extends Annotation> annotationTyp
 		return annotationType == ConstraintComposition.class;
 	}
 
-	private boolean isJodaTimeInClasspath() {
-		return ReflectionHelper.isClassPresent( JODA_TIME_CLASS_NAME, this.getClass() );
+	private static boolean isJodaTimeInClasspath() {
+		return isClassPresent( JODA_TIME_CLASS_NAME );
 	}
 
 	/**
@@ -593,6 +602,26 @@ private boolean isJodaTimeInClasspath() {
 		}
 	}
 
+	private static boolean isClassPresent(String className) {
+		try {
+			run( LoadClass.action( className, ConstraintHelper.class ) );
+			return true;
+		}
+		catch ( ValidationException e ) {
+			return false;
+		}
+	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private static <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
+
 	/**
 	 * A type-safe wrapper around a concurrent map from constraint types to
 	 * associated validator classes. The casts are safe as data is added trough
diff --git a/engine/src/main/java/org/hibernate/validator/internal/metadata/descriptor/ConstraintDescriptorImpl.java b/engine/src/main/java/org/hibernate/validator/internal/metadata/descriptor/ConstraintDescriptorImpl.java
index 3fa85e337..7f6840522 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/metadata/descriptor/ConstraintDescriptorImpl.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/metadata/descriptor/ConstraintDescriptorImpl.java
@@ -26,11 +26,14 @@
 import java.lang.reflect.Field;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
 import javax.validation.Constraint;
 import javax.validation.ConstraintTarget;
 import javax.validation.ConstraintValidator;
@@ -46,11 +49,13 @@
 import org.hibernate.validator.constraints.ConstraintComposition;
 import org.hibernate.validator.internal.metadata.core.ConstraintHelper;
 import org.hibernate.validator.internal.metadata.core.ConstraintOrigin;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.annotationfactory.AnnotationDescriptor;
 import org.hibernate.validator.internal.util.annotationfactory.AnnotationFactory;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetAnnotationParameter;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredMethods;
+import org.hibernate.validator.internal.util.privilegedactions.GetMethod;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashMap;
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
@@ -505,10 +510,8 @@ private boolean isExecutable(ElementType elementType) {
 		Class<Payload>[] payloadFromAnnotation;
 		try {
 			//TODO be extra safe and make sure this is an array of Payload
-			payloadFromAnnotation = ReflectionHelper.getAnnotationParameter(
-					annotation,
-					ConstraintHelper.PAYLOAD,
-					Class[].class
+			payloadFromAnnotation = run(
+					GetAnnotationParameter.action( annotation, ConstraintHelper.PAYLOAD, Class[].class )
 			);
 		}
 		catch ( ValidationException e ) {
@@ -523,8 +526,8 @@ private boolean isExecutable(ElementType elementType) {
 
 	private Set<Class<?>> buildGroupSet(Class<?> implicitGroup) {
 		Set<Class<?>> groupSet = newHashSet();
-		final Class<?>[] groupsFromAnnotation = ReflectionHelper.getAnnotationParameter(
-				annotation, ConstraintHelper.GROUPS, Class[].class
+		final Class<?>[] groupsFromAnnotation = run(
+				GetAnnotationParameter.action( annotation, ConstraintHelper.GROUPS, Class[].class )
 		);
 		if ( groupsFromAnnotation.length == 0 ) {
 			groupSet.add( Default.class );
@@ -541,10 +544,10 @@ private boolean isExecutable(ElementType elementType) {
 	}
 
 	private Map<String, Object> buildAnnotationParameterMap(Annotation annotation) {
-		final Method[] declaredMethods = ReflectionHelper.getDeclaredMethods( annotation.annotationType() );
+		final Method[] declaredMethods = run( GetDeclaredMethods.action( annotation.annotationType() ) );
 		Map<String, Object> parameters = newHashMap( declaredMethods.length );
 		for ( Method m : declaredMethods ) {
-			Object value = ReflectionHelper.getAnnotationParameter( annotation, m.getName(), Object.class );
+			Object value = run( GetAnnotationParameter.action( annotation, m.getName(), Object.class ) );
 			parameters.put( m.getName(), value );
 		}
 		return Collections.unmodifiableMap( parameters );
@@ -552,7 +555,7 @@ private boolean isExecutable(ElementType elementType) {
 
 	private Map<ClassIndexWrapper, Map<String, Object>> parseOverrideParameters() {
 		Map<ClassIndexWrapper, Map<String, Object>> overrideParameters = newHashMap();
-		final Method[] methods = ReflectionHelper.getDeclaredMethods( annotationType );
+		final Method[] methods = run( GetDeclaredMethods.action( annotationType ) );
 		for ( Method m : methods ) {
 			if ( m.getAnnotation( OverridesAttribute.class ) != null ) {
 				addOverrideAttributes(
@@ -571,7 +574,7 @@ else if ( m.getAnnotation( OverridesAttribute.List.class ) != null ) {
 	}
 
 	private void addOverrideAttributes(Map<ClassIndexWrapper, Map<String, Object>> overrideParameters, Method m, OverridesAttribute... attributes) {
-		Object value = ReflectionHelper.getAnnotationParameter( annotation, m.getName(), Object.class );
+		Object value = run( GetAnnotationParameter.action( annotation, m.getName(), Object.class ) );
 		for ( OverridesAttribute overridesAttribute : attributes ) {
 			ensureAttributeIsOverridable( m, overridesAttribute );
 
@@ -588,7 +591,7 @@ private void addOverrideAttributes(Map<ClassIndexWrapper, Map<String, Object>> o
 	}
 
 	private void ensureAttributeIsOverridable(Method m, OverridesAttribute overridesAttribute) {
-		final Method method = ReflectionHelper.getMethod( overridesAttribute.constraint(), overridesAttribute.name() );
+		final Method method = run( GetMethod.action( overridesAttribute.constraint(), overridesAttribute.name() ) );
 		if ( method == null ) {
 			throw log.getOverriddenConstraintAttributeNotFoundException( overridesAttribute.name() );
 		}
@@ -704,6 +707,16 @@ private CompositionType parseCompositionType(ConstraintHelper constraintHelper)
 		);
 	}
 
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private <P> P run(PrivilegedAction<P> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
+
 	/**
 	 * @return the compositionType
 	 */
diff --git a/engine/src/main/java/org/hibernate/validator/internal/metadata/provider/AnnotationMetaDataProvider.java b/engine/src/main/java/org/hibernate/validator/internal/metadata/provider/AnnotationMetaDataProvider.java
index a1ac7133e..8abe85ccc 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/metadata/provider/AnnotationMetaDataProvider.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/metadata/provider/AnnotationMetaDataProvider.java
@@ -23,6 +23,8 @@
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -57,6 +59,11 @@
 import org.hibernate.validator.internal.util.classhierarchy.ClassHierarchyHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredConstructors;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredFields;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredMethods;
+import org.hibernate.validator.internal.util.privilegedactions.GetMethods;
+import org.hibernate.validator.internal.util.privilegedactions.NewInstance;
 import org.hibernate.validator.spi.group.DefaultGroupSequenceProvider;
 import org.hibernate.validator.valuehandling.UnwrapValidatedValue;
 
@@ -65,8 +72,6 @@
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
 import static org.hibernate.validator.internal.util.CollectionHelper.partition;
 import static org.hibernate.validator.internal.util.ConcurrentReferenceHashMap.ReferenceType.SOFT;
-import static org.hibernate.validator.internal.util.ReflectionHelper.getMethods;
-import static org.hibernate.validator.internal.util.ReflectionHelper.newInstance;
 
 /**
  * {@code MetaDataProvider} which reads the metadata from annotations which is the default configuration source.
@@ -184,14 +189,14 @@ public AnnotationProcessingOptions getAnnotationProcessingOptions() {
 
 	private <T> DefaultGroupSequenceProvider<? super T> newGroupSequenceProviderClassInstance(Class<T> beanClass,
 			Class<? extends DefaultGroupSequenceProvider<? super T>> providerClass) {
-		Method[] providerMethods = getMethods( providerClass );
+		Method[] providerMethods = run( GetMethods.action( providerClass ) );
 		for ( Method method : providerMethods ) {
 			Class<?>[] paramTypes = method.getParameterTypes();
 			if ( "getValidationGroups".equals( method.getName() ) && !method.isBridge()
 					&& paramTypes.length == 1 && paramTypes[0].isAssignableFrom( beanClass ) ) {
 
-				return newInstance(
-						providerClass, "the default group sequence provider"
+				return run(
+						NewInstance.action( providerClass, "the default group sequence provider" )
 				);
 			}
 		}
@@ -219,7 +224,7 @@ public AnnotationProcessingOptions getAnnotationProcessingOptions() {
 	private Set<ConstrainedElement> getFieldMetaData(Class<?> beanClass) {
 		Set<ConstrainedElement> propertyMetaData = newHashSet();
 
-		for ( Field field : ReflectionHelper.getDeclaredFields( beanClass ) ) {
+		for ( Field field : run( GetDeclaredFields.action ( beanClass ) ) ) {
 			// HV-172
 			if ( Modifier.isStatic( field.getModifiers() ) ||
 					annotationProcessingOptions.areMemberConstraintsIgnoredFor( field ) ||
@@ -268,7 +273,7 @@ private ConstrainedField findPropertyMetaData(Field field) {
 
 	private Set<ConstrainedExecutable> getConstructorMetaData(Class<?> clazz) {
 		List<ExecutableElement> declaredConstructors = ExecutableElement.forConstructors(
-				ReflectionHelper.getDeclaredConstructors( clazz )
+				run( GetDeclaredConstructors.action( clazz ) )
 		);
 
 		return getMetaData( declaredConstructors );
@@ -276,7 +281,7 @@ private ConstrainedField findPropertyMetaData(Field field) {
 
 	private Set<ConstrainedExecutable> getMethodMetaData(Class<?> clazz) {
 		List<ExecutableElement> declaredMethods = ExecutableElement.forMethods(
-				ReflectionHelper.getDeclaredMethods( clazz )
+				run( GetDeclaredMethods.action( clazz ) )
 		);
 
 		return getMetaData( declaredMethods );
@@ -608,4 +613,14 @@ public ConstraintType getPartition(ConstraintDescriptorImpl<?> v) {
 				type
 		);
 	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/metadata/raw/ConstrainedExecutable.java b/engine/src/main/java/org/hibernate/validator/internal/metadata/raw/ConstrainedExecutable.java
index 1ce0aa106..acbfd2407 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/metadata/raw/ConstrainedExecutable.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/metadata/raw/ConstrainedExecutable.java
@@ -18,17 +18,20 @@
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
 import javax.validation.metadata.ConstraintDescriptor;
 
 import org.hibernate.validator.internal.metadata.core.MetaConstraint;
 import org.hibernate.validator.internal.metadata.location.ConstraintLocation;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.SetAccessibility;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashMap;
@@ -142,7 +145,7 @@ public ConstrainedExecutable(
 		this.hasParameterConstraints = hasParameterConstraints( parameterMetaData ) || !crossParameterConstraints.isEmpty();
 
 		if ( isConstrained() ) {
-			ReflectionHelper.setAccessibility( location.getMember() );
+			run( SetAccessibility.action( location.getMember() ) );
 		}
 	}
 
@@ -350,4 +353,8 @@ else if ( !executable.equals( other.executable ) ) {
 		}
 		return true;
 	}
+
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/metadata/raw/ConstrainedField.java b/engine/src/main/java/org/hibernate/validator/internal/metadata/raw/ConstrainedField.java
index d1fd63367..a43374dda 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/metadata/raw/ConstrainedField.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/metadata/raw/ConstrainedField.java
@@ -17,12 +17,14 @@
 package org.hibernate.validator.internal.metadata.raw;
 
 import java.lang.reflect.Member;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.validator.internal.metadata.core.MetaConstraint;
 import org.hibernate.validator.internal.metadata.location.ConstraintLocation;
-import org.hibernate.validator.internal.util.ReflectionHelper;
+import org.hibernate.validator.internal.util.privilegedactions.SetAccessibility;
 
 /**
  * Represents a field of a Java type and all its associated meta-data relevant
@@ -54,7 +56,7 @@ public ConstrainedField(ConfigurationSource source,
 
 		Member member = location.getMember();
 		if ( member != null && isConstrained() ) {
-			ReflectionHelper.setAccessibility( member );
+			run( SetAccessibility.action( member ) );
 		}
 	}
 
@@ -88,4 +90,8 @@ else if ( !getLocation().getMember().equals( other.getLocation().getMember() ) )
 		}
 		return true;
 	}
+
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/ReflectionHelper.java b/engine/src/main/java/org/hibernate/validator/internal/util/ReflectionHelper.java
index 1e6bdbe20..162329264 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/ReflectionHelper.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/ReflectionHelper.java
@@ -16,8 +16,6 @@
 */
 package org.hibernate.validator.internal.util;
 
-import java.lang.annotation.Annotation;
-import java.lang.annotation.ElementType;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
@@ -27,37 +25,17 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
-import javax.validation.ValidationException;
-
 import org.hibernate.validator.internal.metadata.raw.ExecutableElement;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
-import org.hibernate.validator.internal.util.privilegedactions.ConstructorInstance;
-import org.hibernate.validator.internal.util.privilegedactions.GetAnnotationParameter;
-import org.hibernate.validator.internal.util.privilegedactions.GetClassLoader;
-import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredConstructor;
-import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredConstructors;
-import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredField;
-import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredFields;
-import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredMethod;
-import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredMethods;
-import org.hibernate.validator.internal.util.privilegedactions.GetMethod;
-import org.hibernate.validator.internal.util.privilegedactions.GetMethodFromPropertyName;
-import org.hibernate.validator.internal.util.privilegedactions.GetMethods;
-import org.hibernate.validator.internal.util.privilegedactions.LoadClass;
-import org.hibernate.validator.internal.util.privilegedactions.NewInstance;
-import org.hibernate.validator.internal.util.privilegedactions.SetAccessibility;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashMap;
-import static org.hibernate.validator.internal.util.logging.Messages.MESSAGES;
 
 /**
  * Some reflection utility methods. Where necessary calls will be performed as {@code PrivilegedAction} which is necessary
@@ -69,14 +47,10 @@
  */
 public final class ReflectionHelper {
 
-	private static final String PACKAGE_SEPARATOR = ".";
-	private static final String ARRAY_CLASS_NAME_PREFIX = "[L";
-	private static final String ARRAY_CLASS_NAME_SUFFIX = ";";
-
 	private static final String PROPERTY_ACCESSOR_PREFIX_GET = "get";
 	private static final String PROPERTY_ACCESSOR_PREFIX_IS = "is";
 	private static final String PROPERTY_ACCESSOR_PREFIX_HAS = "has";
-	private static final String[] PROPERTY_ACCESSOR_PREFIXES = {
+	public static final String[] PROPERTY_ACCESSOR_PREFIXES = {
 			PROPERTY_ACCESSOR_PREFIX_GET,
 			PROPERTY_ACCESSOR_PREFIX_IS,
 			PROPERTY_ACCESSOR_PREFIX_HAS
@@ -84,24 +58,6 @@
 
 	private static final Log log = LoggerFactory.make();
 
-	private static final Map<String, Class<?>> PRIMITIVE_NAME_TO_PRIMITIVE;
-
-	static {
-		Map<String, Class<?>> tmpMap = newHashMap( 9 );
-
-		tmpMap.put( boolean.class.getName(), boolean.class );
-		tmpMap.put( char.class.getName(), char.class );
-		tmpMap.put( double.class.getName(), double.class );
-		tmpMap.put( float.class.getName(), float.class );
-		tmpMap.put( long.class.getName(), long.class );
-		tmpMap.put( int.class.getName(), int.class );
-		tmpMap.put( short.class.getName(), short.class );
-		tmpMap.put( byte.class.getName(), byte.class );
-		tmpMap.put( Void.TYPE.getName(), Void.TYPE );
-
-		PRIMITIVE_NAME_TO_PRIMITIVE = Collections.unmodifiableMap( tmpMap );
-	}
-
 	private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPES;
 
 	static {
@@ -144,84 +100,6 @@
 	private ReflectionHelper() {
 	}
 
-	public static ClassLoader getClassLoaderFromContext() {
-		return run( GetClassLoader.fromContext() );
-	}
-
-	public static ClassLoader getClassLoaderFromClass(Class<?> clazz) {
-		return run( GetClassLoader.fromClass( clazz ) );
-	}
-
-	public static Class<?> loadClass(String className, Class<?> caller) {
-		return run( LoadClass.action( className, caller ) );
-	}
-
-	public static Class<?> loadClass(String className, String defaultPackage) {
-		return loadClass( className, defaultPackage, ReflectionHelper.class );
-	}
-
-	public static boolean isClassPresent(String className, Class<?> caller) {
-		try {
-			ReflectionHelper.loadClass( className, caller );
-			return true;
-		}
-		catch ( ValidationException e ) {
-			return false;
-		}
-	}
-
-	public static Class<?> loadClass(String className, String defaultPackage, Class<?> caller) {
-		if ( PRIMITIVE_NAME_TO_PRIMITIVE.containsKey( className ) ) {
-			return PRIMITIVE_NAME_TO_PRIMITIVE.get( className );
-		}
-
-		StringBuilder fullyQualifiedClass = new StringBuilder();
-		String tmpClassName = className;
-		if ( isArrayClassName( className ) ) {
-			fullyQualifiedClass.append( ARRAY_CLASS_NAME_PREFIX );
-			tmpClassName = getArrayElementClassName( className );
-		}
-
-		if ( isQualifiedClass( tmpClassName ) ) {
-			fullyQualifiedClass.append( tmpClassName );
-		}
-		else {
-			fullyQualifiedClass.append( defaultPackage );
-			fullyQualifiedClass.append( PACKAGE_SEPARATOR );
-			fullyQualifiedClass.append( tmpClassName );
-		}
-
-		if ( isArrayClassName( className ) ) {
-			fullyQualifiedClass.append( ARRAY_CLASS_NAME_SUFFIX );
-		}
-
-		return loadClass( fullyQualifiedClass.toString(), caller );
-	}
-
-	private static boolean isArrayClassName(String className) {
-		return className.startsWith( ARRAY_CLASS_NAME_PREFIX ) && className.endsWith( ARRAY_CLASS_NAME_SUFFIX );
-	}
-
-	private static String getArrayElementClassName(String className) {
-		return className.substring( 2, className.length() - 1 );
-	}
-
-	private static boolean isQualifiedClass(String clazz) {
-		return clazz.contains( PACKAGE_SEPARATOR );
-	}
-
-	public static <T> T newInstance(Class<T> clazz, String message) {
-		return run( NewInstance.action( clazz, message ) );
-	}
-
-	public static <T> T newConstructorInstance(Constructor<T> constructor, Object... initArgs) {
-		return run( ConstructorInstance.action( constructor, initArgs ) );
-	}
-
-	public static <T> T getAnnotationParameter(Annotation annotation, String parameterName, Class<T> type) {
-		return run( GetAnnotationParameter.action( annotation, parameterName, type ) );
-	}
-
 	/**
 	 * Returns the JavaBeans property name of the given member.
 	 * <p>
@@ -301,42 +179,6 @@ else if ( methodName.startsWith( PROPERTY_ACCESSOR_PREFIX_HAS ) && method.getRet
 		return false;
 	}
 
-	/**
-	 * Returns the member with the given name and type.
-	 *
-	 * @param clazz The class from which to retrieve the member. Cannot be {@code null}.
-	 * @param property The property name without "is", "get" or "has". Cannot be {@code null} or empty.
-	 * @param elementType The element type. Either {@code ElementType.FIELD} or {@code ElementType METHOD}.
-	 *
-	 * @return the member which matching the name and type or {@code null} if no such member exists.
-	 */
-	public static Member getMember(Class<?> clazz, String property, ElementType elementType) {
-		Contracts.assertNotNull( clazz, MESSAGES.classCannotBeNull() );
-
-		if ( property == null || property.length() == 0 ) {
-			throw log.getPropertyNameCannotBeNullOrEmptyException();
-		}
-
-		if ( !( ElementType.FIELD.equals( elementType ) || ElementType.METHOD.equals( elementType ) ) ) {
-			throw log.getElementTypeHasToBeFieldOrMethodException();
-		}
-
-		Member member = null;
-		if ( ElementType.FIELD.equals( elementType ) ) {
-			member = run( GetDeclaredField.action( clazz, property ) );
-		}
-		else {
-			String methodName = property.substring( 0, 1 ).toUpperCase() + property.substring( 1 );
-			for ( String prefix : PROPERTY_ACCESSOR_PREFIXES ) {
-				member = run( GetMethod.action( clazz, prefix + methodName ) );
-				if ( member != null ) {
-					break;
-				}
-			}
-		}
-		return member;
-	}
-
 	/**
 	 * @param member The <code>Member</code> instance for which to retrieve the type.
 	 *
@@ -420,10 +262,6 @@ public static Object getValue(Method method, Object object) {
 		}
 	}
 
-	public static void setAccessibility(Member member) {
-		run( SetAccessibility.action( member ) );
-	}
-
 	/**
 	 * Determines the type of elements of an <code>Iterable</code>, array or the value of a <code>Map</code>.
 	 *
@@ -565,128 +403,6 @@ public static Object getMappedValue(Object value, Object key) {
 		return map.get( key );
 	}
 
-	/**
-	 * Returns the declared field with the specified name or {@code null} if it does not exist.
-	 *
-	 * @param clazz The class to check.
-	 * @param fieldName The field name.
-	 *
-	 * @return Returns the declared field with the specified name or {@code null} if it does not exist.
-	 */
-	public static Field getDeclaredField(Class<?> clazz, String fieldName) {
-		return run( GetDeclaredField.action( clazz, fieldName ) );
-	}
-
-	/**
-	 * Returns the fields of the specified class.
-	 *
-	 * @param clazz The class for which to retrieve the fields.
-	 *
-	 * @return Returns the fields for this class.
-	 */
-	public static Field[] getDeclaredFields(Class<?> clazz) {
-		return run( GetDeclaredFields.action( clazz ) );
-	}
-
-	/**
-	 * Returns the method with the specified property name or {@code null} if it does not exist. This method will
-	 * prepend  'is' and 'get' to the property name and capitalize the first letter.
-	 *
-	 * @param clazz The class to check.
-	 * @param methodName The property name.
-	 *
-	 * @return Returns the method with the specified property or {@code null} if it does not exist.
-	 */
-	public static Method getMethodFromPropertyName(Class<?> clazz, String methodName) {
-		return run( GetMethodFromPropertyName.action( clazz, methodName ) );
-	}
-
-	/**
-	 * Returns the method with the specified name or {@code null} if it does not exist.
-	 *
-	 * @param clazz The class to check.
-	 * @param methodName The method name.
-	 *
-	 * @return Returns the method with the specified property or {@code null} if it does not exist.
-	 */
-	public static Method getMethod(Class<?> clazz, String methodName) {
-		return run( GetMethod.action( clazz, methodName ) );
-	}
-
-	/**
-	 * Returns the declared method with the specified name and parameter types or {@code null} if
-	 * it does not exist.
-	 *
-	 * @param clazz The class to check.
-	 * @param methodName The method name.
-	 * @param parameterTypes The method parameter types.
-	 *
-	 * @return Returns the declared method with the specified name or {@code null} if it does not exist.
-	 */
-	public static Method getDeclaredMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {
-		return run( GetDeclaredMethod.action( clazz, methodName, parameterTypes ) );
-	}
-
-	/**
-	 * Returns the declared methods of the specified class.
-	 *
-	 * @param clazz The class for which to retrieve the methods.
-	 *
-	 * @return Returns the declared methods for this class.
-	 */
-	public static Method[] getDeclaredMethods(Class<?> clazz) {
-		return run( GetDeclaredMethods.action( clazz ) );
-	}
-
-	/**
-	 * Returns the methods of the specified class (include inherited methods).
-	 *
-	 * @param clazz The class for which to retrieve the methods.
-	 *
-	 * @return Returns the methods for this class.
-	 */
-	public static Method[] getMethods(Class<?> clazz) {
-		return run( GetMethods.action( clazz ) );
-	}
-
-	/**
-	 * Returns the declared constructors of the specified class.
-	 *
-	 * @param clazz The class for which to retrieve the constructors.
-	 *
-	 * @return Returns the declared constructors for this class.
-	 */
-	public static Constructor<?>[] getDeclaredConstructors(Class<?> clazz) {
-		return run( GetDeclaredConstructors.action( clazz ) );
-	}
-
-	/**
-	 * Returns the declared constructor with the specified parameter types or {@code null} if
-	 * it does not exist.
-	 *
-	 * @param clazz The class to check.
-	 * @param params The constructor parameter types.
-	 * @param <T> The type of class to get the constructor for.
-	 *
-	 * @return Returns the declared constructor with the specified name or {@code null} if it does not exist.
-	 */
-	public static <T> Constructor<T> getDeclaredConstructor(Class<T> clazz, Class<?>... params) {
-		return run( GetDeclaredConstructor.action( clazz, params ) );
-	}
-
-	/**
-	 * Executes the given privileged action either directly or with privileges
-	 * enabled, depending on whether a security manager is around or not.
-	 *
-	 * @param <T> The return type of the privileged action to run.
-	 * @param action The action to run.
-	 *
-	 * @return The result of the privileged action's execution.
-	 */
-	private static <T> T run(PrivilegedAction<T> action) {
-		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
-	}
-
 	/**
 	 * Returns the auto-boxed type of a primitive type.
 	 *
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/ResourceLoaderHelper.java b/engine/src/main/java/org/hibernate/validator/internal/util/ResourceLoaderHelper.java
index d373e38c5..0a7ade05c 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/ResourceLoaderHelper.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/ResourceLoaderHelper.java
@@ -9,7 +9,7 @@
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,  
+* distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
@@ -18,9 +18,12 @@
 
 import java.io.BufferedInputStream;
 import java.io.InputStream;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetClassLoader;
 
 /**
  * Helper methods for loading resource files
@@ -50,18 +53,18 @@ public static InputStream getResettableInputStreamForPath(String path) {
 
 		boolean isContextCL = true;
 		// try the context class loader first
-		ClassLoader loader = ReflectionHelper.getClassLoaderFromContext();
+		ClassLoader loader = run( GetClassLoader.fromContext() );
 
 		if ( loader == null ) {
 			log.debug( "No default context class loader, fall back to Bean Validation's loader" );
-			loader = ReflectionHelper.getClassLoaderFromClass( ResourceLoaderHelper.class );
+			loader = run( GetClassLoader.fromClass( ResourceLoaderHelper.class ) );
 			isContextCL = false;
 		}
 		InputStream inputStream = loader.getResourceAsStream( inputPath );
 
 		// try the current class loader
 		if ( isContextCL && inputStream == null ) {
-			loader = ReflectionHelper.getClassLoaderFromClass( ResourceLoaderHelper.class );
+			loader = run( GetClassLoader.fromClass( ResourceLoaderHelper.class ) );
 			inputStream = loader.getResourceAsStream( inputPath );
 		}
 
@@ -75,4 +78,14 @@ else if ( inputStream.markSupported() ) {
 			return new BufferedInputStream( inputStream );
 		}
 	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private static <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/annotationfactory/AnnotationFactory.java b/engine/src/main/java/org/hibernate/validator/internal/util/annotationfactory/AnnotationFactory.java
index 0ce6e4490..9ee1f8613 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/annotationfactory/AnnotationFactory.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/annotationfactory/AnnotationFactory.java
@@ -21,8 +21,12 @@
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Proxy;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
-import org.hibernate.validator.internal.util.ReflectionHelper;
+import org.hibernate.validator.internal.util.privilegedactions.ConstructorInstance;
+import org.hibernate.validator.internal.util.privilegedactions.GetClassLoader;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredConstructor;
 
 /**
  * Creates live annotations (actually {@link AnnotationProxy} instances) from {@code AnnotationDescriptor}s.
@@ -37,7 +41,7 @@
 	public static <T extends Annotation> T create(AnnotationDescriptor<T> descriptor) {
 		@SuppressWarnings("unchecked")
 		Class<T> proxyClass = (Class<T>) Proxy.getProxyClass(
-				ReflectionHelper.getClassLoaderFromClass( descriptor.type() ),
+				run( GetClassLoader.fromClass( descriptor.type() ) ),
 				descriptor.type()
 		);
 		InvocationHandler handler = new AnnotationProxy( descriptor );
@@ -55,10 +59,20 @@
 	private static <T extends Annotation> T getProxyInstance(Class<T> proxyClass, InvocationHandler handler) throws
 			SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException,
 			IllegalAccessException, InvocationTargetException {
-		final Constructor<T> constructor = ReflectionHelper.getDeclaredConstructor(
+		final Constructor<T> constructor = run( GetDeclaredConstructor.action(
 				proxyClass,
 				InvocationHandler.class
-		);
-		return ReflectionHelper.newConstructorInstance( constructor, handler );
+		) );
+		return run( ConstructorInstance.action( constructor, handler ) );
+	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private static <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
 	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/annotationfactory/AnnotationProxy.java b/engine/src/main/java/org/hibernate/validator/internal/util/annotationfactory/AnnotationProxy.java
index 38decc589..25e6b2fab 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/annotationfactory/AnnotationProxy.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/annotationfactory/AnnotationProxy.java
@@ -21,6 +21,8 @@
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Map;
@@ -29,9 +31,10 @@
 import java.util.SortedSet;
 import java.util.TreeSet;
 
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredMethod;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredMethods;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashMap;
 
@@ -154,7 +157,7 @@ public String toString() {
 	private Map<String, Object> getAnnotationValues(AnnotationDescriptor<?> descriptor) {
 		Map<String, Object> result = newHashMap();
 		int processedValuesFromDescriptor = 0;
-		final Method[] declaredMethods = ReflectionHelper.getDeclaredMethods( annotationType );
+		final Method[] declaredMethods = run( GetDeclaredMethods.action( annotationType ) );
 		for ( Method m : declaredMethods ) {
 			if ( descriptor.containsElement( m.getName() ) ) {
 				result.put( m.getName(), descriptor.valueOf( m.getName() ) );
@@ -252,8 +255,7 @@ private boolean areEqual(Object o1, Object o2) {
 
 	private Object getAnnotationMemberValue(Annotation annotation, String name) {
 		try {
-			return ReflectionHelper.getDeclaredMethod( annotation.annotationType(), name )
-					.invoke( annotation );
+			return run( GetDeclaredMethod.action( annotation.annotationType(), name ) ).invoke( annotation );
 		}
 		catch ( IllegalAccessException e ) {
 			throw log.getUnableToRetrieveAnnotationParameterValueException( e );
@@ -265,4 +267,14 @@ private Object getAnnotationMemberValue(Annotation annotation, String name) {
 			throw log.getUnableToRetrieveAnnotationParameterValueException( e );
 		}
 	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/classhierarchy/ClassHierarchyHelper.java b/engine/src/main/java/org/hibernate/validator/internal/util/classhierarchy/ClassHierarchyHelper.java
index 4719067f1..0ebce78ff 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/classhierarchy/ClassHierarchyHelper.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/classhierarchy/ClassHierarchyHelper.java
@@ -16,14 +16,11 @@
 */
 package org.hibernate.validator.internal.util.classhierarchy;
 
-import java.lang.reflect.Method;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
 import org.hibernate.validator.internal.util.Contracts;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
@@ -130,26 +127,4 @@ private static boolean acceptedByAllFilters(Class<?> clazz, Iterable<Filter> fil
 			getImplementedInterfaces( currentInterfaceCasted, classes );
 		}
 	}
-
-	/**
-	 * Get a list of all methods wich the given class declares, implements,
-	 * overrides or inherits. Methods are added by adding first all methods of
-	 * the class itself and its implemented interfaces, then the super class and
-	 * its interfaces, etc.
-	 *
-	 * @param clazz the class for which to retrieve the methods
-	 *
-	 * @return set of all methods of the given class
-	 */
-	public static List<Method> getAllMethods(Class<?> clazz) {
-		Contracts.assertNotNull( clazz );
-
-		List<Method> methods = newArrayList();
-
-		for ( Class<?> hierarchyClass : getHierarchy( clazz ) ) {
-			Collections.addAll( methods, ReflectionHelper.getMethods( hierarchyClass ) );
-		}
-
-		return methods;
-	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredConstructor.java b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredConstructor.java
index da24fa80d..3918983b2 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredConstructor.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredConstructor.java
@@ -20,6 +20,8 @@
 import java.security.PrivilegedAction;
 
 /**
+ * Returns the declared constructor with the specified parameter types or {@code null} if it does not exist.
+ *
  * @author Emmanuel Bernard
  */
 public final class GetDeclaredConstructor<T> implements PrivilegedAction<Constructor<T>> {
@@ -35,6 +37,7 @@ private GetDeclaredConstructor(Class<T> clazz, Class<?>... params) {
 		this.params = params;
 	}
 
+	@Override
 	public Constructor<T> run() {
 		try {
 			return clazz.getDeclaredConstructor( params );
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredConstructors.java b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredConstructors.java
index 53230ac1b..0c970d8e0 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredConstructors.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredConstructors.java
@@ -20,6 +20,8 @@
 import java.security.PrivilegedAction;
 
 /**
+ * Returns the declared constructors of the specified class.
+ *
  * @author Gunnar Morling
  */
 public final class GetDeclaredConstructors implements PrivilegedAction<Constructor<?>[]> {
@@ -33,6 +35,7 @@ private GetDeclaredConstructors(Class<?> clazz) {
 		this.clazz = clazz;
 	}
 
+	@Override
 	public Constructor<?>[] run() {
 		return clazz.getDeclaredConstructors();
 	}
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredField.java b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredField.java
index cbc5e4d06..3617d6399 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredField.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredField.java
@@ -20,6 +20,8 @@
 import java.security.PrivilegedAction;
 
 /**
+ * Returns the declared field with the specified name or {@code null} if it does not exist.
+ *
  * @author Emmanuel Bernard
  */
 public final class GetDeclaredField implements PrivilegedAction<Field> {
@@ -35,6 +37,7 @@ private GetDeclaredField(Class<?> clazz, String fieldName) {
 		this.fieldName = fieldName;
 	}
 
+	@Override
 	public Field run() {
 		try {
 			final Field field = clazz.getDeclaredField( fieldName );
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredFields.java b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredFields.java
index ff1b233de..06cdce364 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredFields.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredFields.java
@@ -20,6 +20,8 @@
 import java.lang.reflect.Field;
 
 /**
+ * Returns the fields of the specified class.
+ *
  * @author Emmanuel Bernard
  */
 public final class GetDeclaredFields implements PrivilegedAction<Field[]> {
@@ -33,6 +35,7 @@ private GetDeclaredFields(Class<?> clazz) {
 		this.clazz = clazz;
 	}
 
+	@Override
 	public Field[] run() {
 		return clazz.getDeclaredFields();
 	}
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredMethod.java b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredMethod.java
index 4a609cde7..692e3de41 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredMethod.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredMethod.java
@@ -20,6 +20,8 @@
 import java.security.PrivilegedAction;
 
 /**
+ * Returns the declared method with the specified name and parameter types or {@code null} if it does not exist.
+ *
  * @author Kevin Pollet &lt;kevin.pollet@serli.com&gt; (C) 2011 SERLI
  */
 public final class GetDeclaredMethod implements PrivilegedAction<Method> {
@@ -37,6 +39,7 @@ private GetDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramet
 		this.parameterTypes = parameterTypes;
 	}
 
+	@Override
 	public Method run() {
 		try {
 			return clazz.getDeclaredMethod( methodName, parameterTypes );
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredMethods.java b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredMethods.java
index 309ba2241..f87b3c061 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredMethods.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetDeclaredMethods.java
@@ -20,6 +20,8 @@
 import java.lang.reflect.Method;
 
 /**
+ * Returns the declared methods of the specified class.
+ *
  * @author Emmanuel Bernard
  */
 public final class GetDeclaredMethods implements PrivilegedAction<Method[]> {
@@ -33,6 +35,7 @@ private GetDeclaredMethods(Class<?> clazz) {
 		this.clazz = clazz;
 	}
 
+	@Override
 	public Method[] run() {
 		return clazz.getDeclaredMethods();
 	}
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethod.java b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethod.java
index 90cbda591..db4a00a50 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethod.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethod.java
@@ -20,6 +20,8 @@
 import java.security.PrivilegedAction;
 
 /**
+ * Returns the method with the specified name or {@code null} if it does not exist.
+ *
  * @author Emmanuel Bernard
  */
 public final class GetMethod implements PrivilegedAction<Method> {
@@ -35,6 +37,7 @@ private GetMethod(Class<?> clazz, String methodName) {
 		this.methodName = methodName;
 	}
 
+	@Override
 	public Method run() {
 		try {
 			return clazz.getMethod(methodName);
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethodFromPropertyName.java b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethodFromPropertyName.java
index 63e530350..f4c7ee8fd 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethodFromPropertyName.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethodFromPropertyName.java
@@ -20,6 +20,9 @@
 import java.security.PrivilegedAction;
 
 /**
+ * Returns the method with the specified property name or {@code null} if it does not exist. This method will prepend
+ * 'is' and 'get' to the property name and capitalize the first letter.
+ *
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  */
@@ -36,6 +39,7 @@ private GetMethodFromPropertyName(Class<?> clazz, String property) {
 		this.property = property;
 	}
 
+	@Override
 	public Method run() {
 		try {
 			char[] string = property.toCharArray();
diff --git a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethods.java b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethods.java
index 58bc37714..bb9196c87 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethods.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/util/privilegedactions/GetMethods.java
@@ -20,6 +20,8 @@
 import java.lang.reflect.Method;
 
 /**
+ * Returns the methods of the specified class (include inherited methods).
+ *
  * @author Emmanuel Bernard
  */
 public final class GetMethods implements PrivilegedAction<Method[]> {
@@ -33,6 +35,7 @@ private GetMethods(Class<?> clazz) {
 		this.clazz = clazz;
 	}
 
+	@Override
 	public Method[] run() {
 		return clazz.getMethods();
 	}
diff --git a/engine/src/main/java/org/hibernate/validator/internal/xml/ClassLoadingHelper.java b/engine/src/main/java/org/hibernate/validator/internal/xml/ClassLoadingHelper.java
new file mode 100644
index 000000000..a7694b3f9
--- /dev/null
+++ b/engine/src/main/java/org/hibernate/validator/internal/xml/ClassLoadingHelper.java
@@ -0,0 +1,119 @@
+/*
+* JBoss, Home of Professional Open Source
+* Copyright 2014, Red Hat, Inc. and/or its affiliates, and individual contributors
+* by the @authors tag. See the copyright.txt in the distribution for a
+* full listing of individual contributors.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package org.hibernate.validator.internal.xml;
+
+import static org.hibernate.validator.internal.util.CollectionHelper.newHashMap;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.Collections;
+import java.util.Map;
+
+import org.hibernate.validator.internal.util.ReflectionHelper;
+import org.hibernate.validator.internal.util.privilegedactions.LoadClass;
+
+/**
+ * A helper for loading classes by names, as given in XML constraint mappings. Given names can be the names of primitive
+ * types, qualified names or unqualified names (in which case a given default package will be assumed).
+ *
+ * @author Gunnar Morling
+ */
+/*package*/ class ClassLoadingHelper {
+
+	private static final String PACKAGE_SEPARATOR = ".";
+	private static final String ARRAY_CLASS_NAME_PREFIX = "[L";
+	private static final String ARRAY_CLASS_NAME_SUFFIX = ";";
+
+	private static final Map<String, Class<?>> PRIMITIVE_NAME_TO_PRIMITIVE;
+
+	static {
+		Map<String, Class<?>> tmpMap = newHashMap( 9 );
+
+		tmpMap.put( boolean.class.getName(), boolean.class );
+		tmpMap.put( char.class.getName(), char.class );
+		tmpMap.put( double.class.getName(), double.class );
+		tmpMap.put( float.class.getName(), float.class );
+		tmpMap.put( long.class.getName(), long.class );
+		tmpMap.put( int.class.getName(), int.class );
+		tmpMap.put( short.class.getName(), short.class );
+		tmpMap.put( byte.class.getName(), byte.class );
+		tmpMap.put( Void.TYPE.getName(), Void.TYPE );
+
+		PRIMITIVE_NAME_TO_PRIMITIVE = Collections.unmodifiableMap( tmpMap );
+	}
+
+	private ClassLoadingHelper() {
+	}
+
+	/*package*/ static Class<?> loadClass(String className, String defaultPackage) {
+		return loadClass( className, defaultPackage, ReflectionHelper.class );
+	}
+
+	/*package*/ static Class<?> loadClass(String className, String defaultPackage, Class<?> caller) {
+		if ( PRIMITIVE_NAME_TO_PRIMITIVE.containsKey( className ) ) {
+			return PRIMITIVE_NAME_TO_PRIMITIVE.get( className );
+		}
+
+		StringBuilder fullyQualifiedClass = new StringBuilder();
+		String tmpClassName = className;
+		if ( isArrayClassName( className ) ) {
+			fullyQualifiedClass.append( ARRAY_CLASS_NAME_PREFIX );
+			tmpClassName = getArrayElementClassName( className );
+		}
+
+		if ( isQualifiedClass( tmpClassName ) ) {
+			fullyQualifiedClass.append( tmpClassName );
+		}
+		else {
+			fullyQualifiedClass.append( defaultPackage );
+			fullyQualifiedClass.append( PACKAGE_SEPARATOR );
+			fullyQualifiedClass.append( tmpClassName );
+		}
+
+		if ( isArrayClassName( className ) ) {
+			fullyQualifiedClass.append( ARRAY_CLASS_NAME_SUFFIX );
+		}
+
+		return loadClass( fullyQualifiedClass.toString(), caller );
+	}
+
+	private static Class<?> loadClass(String className, Class<?> caller) {
+		return run( LoadClass.action( className, caller ) );
+	}
+
+	private static boolean isArrayClassName(String className) {
+		return className.startsWith( ARRAY_CLASS_NAME_PREFIX ) && className.endsWith( ARRAY_CLASS_NAME_SUFFIX );
+	}
+
+	private static String getArrayElementClassName(String className) {
+		return className.substring( 2, className.length() - 1 );
+	}
+
+	private static boolean isQualifiedClass(String clazz) {
+		return clazz.contains( PACKAGE_SEPARATOR );
+	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private static <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
+}
diff --git a/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedExecutableBuilder.java b/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedExecutableBuilder.java
index 54473220a..05792110c 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedExecutableBuilder.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedExecutableBuilder.java
@@ -18,6 +18,8 @@
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -34,10 +36,11 @@
 import org.hibernate.validator.internal.metadata.raw.ConstrainedExecutable;
 import org.hibernate.validator.internal.metadata.raw.ConstrainedParameter;
 import org.hibernate.validator.internal.metadata.raw.ExecutableElement;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.StringHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredConstructor;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredMethod;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashMap;
@@ -73,10 +76,12 @@ private ConstrainedExecutableBuilder() {
 
 			String methodName = methodType.getName();
 
-			final Method method = ReflectionHelper.getDeclaredMethod(
-					beanClass,
-					methodName,
-					parameterTypes.toArray( new Class[parameterTypes.size()] )
+			final Method method = run(
+					GetDeclaredMethod.action(
+							beanClass,
+							methodName,
+							parameterTypes.toArray( new Class[parameterTypes.size()] )
+					)
 			);
 
 			if ( method == null ) {
@@ -136,9 +141,11 @@ private ConstrainedExecutableBuilder() {
 					defaultPackage
 			);
 
-			final Constructor<?> constructor = ReflectionHelper.getDeclaredConstructor(
-					beanClass,
-					constructorParameterTypes.toArray( new Class[constructorParameterTypes.size()] )
+			final Constructor<?> constructor = run(
+					GetDeclaredConstructor.action(
+							beanClass,
+							constructorParameterTypes.toArray( new Class[constructorParameterTypes.size()] )
+					)
 			);
 
 			if ( constructor == null ) {
@@ -317,7 +324,7 @@ private static boolean parseReturnValueType(ReturnValueType returnValueType,
 			String type = null;
 			try {
 				type = parameterType.getType();
-				Class<?> parameterClass = ReflectionHelper.loadClass( type, defaultPackage );
+				Class<?> parameterClass = ClassLoadingHelper.loadClass( type, defaultPackage );
 				parameterTypes.add( parameterClass );
 			}
 			catch ( ValidationException e ) {
@@ -327,4 +334,14 @@ private static boolean parseReturnValueType(ReturnValueType returnValueType,
 
 		return parameterTypes;
 	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private static <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
 }
diff --git a/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedFieldBuilder.java b/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedFieldBuilder.java
index 5278e07bc..7721f9a7b 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedFieldBuilder.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedFieldBuilder.java
@@ -17,6 +17,8 @@
 package org.hibernate.validator.internal.xml;
 
 import java.lang.reflect.Field;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -27,9 +29,9 @@
 import org.hibernate.validator.internal.metadata.location.ConstraintLocation;
 import org.hibernate.validator.internal.metadata.raw.ConfigurationSource;
 import org.hibernate.validator.internal.metadata.raw.ConstrainedField;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredField;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
@@ -103,12 +105,20 @@ private static Field findField(Class<?> beanClass, String fieldName, List<String
 			alreadyProcessedFieldNames.add( fieldName );
 		}
 
-		final Field field = ReflectionHelper.getDeclaredField( beanClass, fieldName );
+		final Field field = run( GetDeclaredField.action( beanClass, fieldName ) );
 		if ( field == null ) {
 			throw log.getBeanDoesNotContainTheFieldException( beanClass.getName(), fieldName );
 		}
 		return field;
 	}
-}
-
 
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private static <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
+}
diff --git a/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedGetterBuilder.java b/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedGetterBuilder.java
index aa371ee03..b4b4c6bf7 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedGetterBuilder.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedGetterBuilder.java
@@ -17,6 +17,8 @@
 package org.hibernate.validator.internal.xml;
 
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -29,9 +31,9 @@
 import org.hibernate.validator.internal.metadata.raw.ConfigurationSource;
 import org.hibernate.validator.internal.metadata.raw.ConstrainedExecutable;
 import org.hibernate.validator.internal.metadata.raw.ConstrainedParameter;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetMethodFromPropertyName;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
@@ -108,13 +110,21 @@ private static Method findGetter(Class<?> beanClass, String getterName, List<Str
 			alreadyProcessedGetterNames.add( getterName );
 		}
 
-		final Method method = ReflectionHelper.getMethodFromPropertyName( beanClass, getterName );
+		final Method method = run( GetMethodFromPropertyName.action( beanClass, getterName ) );
 		if ( method == null ) {
 			throw log.getBeanDoesNotContainThePropertyException( beanClass.getName(), getterName );
 		}
 
 		return method;
 	}
-}
-
 
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private static <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
+}
diff --git a/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedTypeBuilder.java b/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedTypeBuilder.java
index 9e6b4fc60..09d7c8b8a 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedTypeBuilder.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/xml/ConstrainedTypeBuilder.java
@@ -26,7 +26,6 @@
 import org.hibernate.validator.internal.metadata.location.ConstraintLocation;
 import org.hibernate.validator.internal.metadata.raw.ConfigurationSource;
 import org.hibernate.validator.internal.metadata.raw.ConstrainedType;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
@@ -91,7 +90,7 @@ public static ConstrainedType buildConstrainedType(ClassType classType,
 		List<Class<?>> groupSequence = newArrayList();
 		if ( groupSequenceType != null ) {
 			for ( String groupName : groupSequenceType.getValue() ) {
-				Class<?> group = ReflectionHelper.loadClass( groupName, defaultPackage );
+				Class<?> group = ClassLoadingHelper.loadClass( groupName, defaultPackage );
 				groupSequence.add( group );
 			}
 		}
diff --git a/engine/src/main/java/org/hibernate/validator/internal/xml/GroupConversionBuilder.java b/engine/src/main/java/org/hibernate/validator/internal/xml/GroupConversionBuilder.java
index 47242c880..023a909b3 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/xml/GroupConversionBuilder.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/xml/GroupConversionBuilder.java
@@ -19,8 +19,6 @@
 import java.util.List;
 import java.util.Map;
 
-import org.hibernate.validator.internal.util.ReflectionHelper;
-
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashMap;
 
 /**
@@ -37,13 +35,11 @@ private GroupConversionBuilder() {
 																  String defaultPackage) {
 		Map<Class<?>, Class<?>> groupConversionMap = newHashMap();
 		for ( GroupConversionType groupConversionType : groupConversionTypes ) {
-			Class<?> fromClass = ReflectionHelper.loadClass( groupConversionType.getFrom(), defaultPackage );
-			Class<?> toClass = ReflectionHelper.loadClass( groupConversionType.getTo(), defaultPackage );
+			Class<?> fromClass = ClassLoadingHelper.loadClass( groupConversionType.getFrom(), defaultPackage );
+			Class<?> toClass = ClassLoadingHelper.loadClass( groupConversionType.getTo(), defaultPackage );
 			groupConversionMap.put( fromClass, toClass );
 		}
 
 		return groupConversionMap;
 	}
 }
-
-
diff --git a/engine/src/main/java/org/hibernate/validator/internal/xml/MetaConstraintBuilder.java b/engine/src/main/java/org/hibernate/validator/internal/xml/MetaConstraintBuilder.java
index cb80ee595..c1f34af36 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/xml/MetaConstraintBuilder.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/xml/MetaConstraintBuilder.java
@@ -20,7 +20,10 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.List;
+
 import javax.validation.Payload;
 import javax.validation.ValidationException;
 import javax.xml.bind.JAXBElement;
@@ -29,11 +32,11 @@
 import org.hibernate.validator.internal.metadata.core.MetaConstraint;
 import org.hibernate.validator.internal.metadata.descriptor.ConstraintDescriptorImpl;
 import org.hibernate.validator.internal.metadata.location.ConstraintLocation;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.annotationfactory.AnnotationDescriptor;
 import org.hibernate.validator.internal.util.annotationfactory.AnnotationFactory;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetMethod;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
 
@@ -61,7 +64,7 @@ private MetaConstraintBuilder() {
 																			   ConstraintDescriptorImpl.ConstraintType constraintType) {
 		Class<A> annotationClass;
 		try {
-			annotationClass = (Class<A>) ReflectionHelper.loadClass( constraint.getAnnotation(), defaultPackage );
+			annotationClass = (Class<A>) ClassLoadingHelper.loadClass( constraint.getAnnotation(), defaultPackage );
 		}
 		catch ( ValidationException e ) {
 			throw log.getUnableToLoadConstraintAnnotationClassException( constraint.getAnnotation(), e );
@@ -117,7 +120,7 @@ private static void checkNameIsValid(String name) {
 	}
 
 	private static <A extends Annotation> Class<?> getAnnotationParameterType(Class<A> annotationClass, String name) {
-		Method m = ReflectionHelper.getMethod( annotationClass, name );
+		Method m = run( GetMethod.action( annotationClass, name ) );
 		if ( m == null ) {
 			throw log.getAnnotationDoesNotContainAParameterException( annotationClass.getName(), name );
 		}
@@ -249,7 +252,7 @@ else if ( returnType.getName().equals( String.class.getName() ) ) {
 			returnValue = value;
 		}
 		else if ( returnType.getName().equals( Class.class.getName() ) ) {
-			returnValue = ReflectionHelper.loadClass( value, defaultPackage, MetaConstraintBuilder.class );
+			returnValue = ClassLoadingHelper.loadClass( value, defaultPackage, MetaConstraintBuilder.class );
 		}
 		else {
 			try {
@@ -271,7 +274,7 @@ else if ( returnType.getName().equals( Class.class.getName() ) ) {
 
 		List<Class<?>> groupList = newArrayList();
 		for ( String groupClass : groupsType.getValue() ) {
-			groupList.add( ReflectionHelper.loadClass( groupClass, defaultPackage ) );
+			groupList.add( ClassLoadingHelper.loadClass( groupClass, defaultPackage ) );
 		}
 		return groupList.toArray( new Class[groupList.size()] );
 	}
@@ -284,7 +287,7 @@ else if ( returnType.getName().equals( Class.class.getName() ) ) {
 
 		List<Class<? extends Payload>> payloadList = newArrayList();
 		for ( String groupClass : payloadType.getValue() ) {
-			Class<?> payload = ReflectionHelper.loadClass( groupClass, defaultPackage );
+			Class<?> payload = ClassLoadingHelper.loadClass( groupClass, defaultPackage );
 			if ( !Payload.class.isAssignableFrom( payload ) ) {
 				throw log.getWrongPayloadClassException( payload.getName() );
 			}
@@ -294,6 +297,14 @@ else if ( returnType.getName().equals( Class.class.getName() ) ) {
 		}
 		return payloadList.toArray( new Class[payloadList.size()] );
 	}
-}
-
 
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private static <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
+}
diff --git a/engine/src/main/java/org/hibernate/validator/internal/xml/ValidationBootstrapParameters.java b/engine/src/main/java/org/hibernate/validator/internal/xml/ValidationBootstrapParameters.java
index b49b266b9..4305955aa 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/xml/ValidationBootstrapParameters.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/xml/ValidationBootstrapParameters.java
@@ -17,6 +17,8 @@
 package org.hibernate.validator.internal.xml;
 
 import java.io.InputStream;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -30,10 +32,11 @@
 import javax.validation.ValidationException;
 import javax.validation.spi.ValidationProvider;
 
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.ResourceLoaderHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.LoadClass;
+import org.hibernate.validator.internal.util.privilegedactions.NewInstance;
 import org.hibernate.validator.spi.valuehandling.ValidatedValueUnwrapper;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
@@ -141,9 +144,8 @@ public void setParameterNameProvider(ParameterNameProvider parameterNameProvider
 	private void setProviderClass(String providerFqcn) {
 		if ( providerFqcn != null ) {
 			try {
-				providerClass = (Class<? extends ValidationProvider<?>>) ReflectionHelper.loadClass(
-						providerFqcn,
-						this.getClass()
+				providerClass = (Class<? extends ValidationProvider<?>>) run(
+						LoadClass.action( providerFqcn, this.getClass() )
 				);
 				log.usingValidationProvider( providerFqcn );
 			}
@@ -157,10 +159,10 @@ private void setMessageInterpolator(String messageInterpolatorFqcn) {
 		if ( messageInterpolatorFqcn != null ) {
 			try {
 				@SuppressWarnings("unchecked")
-				Class<MessageInterpolator> messageInterpolatorClass = (Class<MessageInterpolator>) ReflectionHelper.loadClass(
-						messageInterpolatorFqcn, this.getClass()
+				Class<MessageInterpolator> messageInterpolatorClass = (Class<MessageInterpolator>) run(
+						LoadClass.action( messageInterpolatorFqcn, this.getClass() )
 				);
-				messageInterpolator = ReflectionHelper.newInstance( messageInterpolatorClass, "message interpolator" );
+				messageInterpolator = run( NewInstance.action( messageInterpolatorClass, "message interpolator" ) );
 				log.usingMessageInterpolator( messageInterpolatorFqcn );
 			}
 			catch ( ValidationException e ) {
@@ -173,10 +175,10 @@ private void setTraversableResolver(String traversableResolverFqcn) {
 		if ( traversableResolverFqcn != null ) {
 			try {
 				@SuppressWarnings("unchecked")
-				Class<TraversableResolver> clazz = (Class<TraversableResolver>) ReflectionHelper.loadClass(
-						traversableResolverFqcn, this.getClass()
+				Class<TraversableResolver> clazz = (Class<TraversableResolver>) run(
+						LoadClass.action( traversableResolverFqcn, this.getClass() )
 				);
-				traversableResolver = ReflectionHelper.newInstance( clazz, "traversable resolver" );
+				traversableResolver = run( NewInstance.action( clazz, "traversable resolver" ) );
 				log.usingTraversableResolver( traversableResolverFqcn );
 			}
 			catch ( ValidationException e ) {
@@ -189,10 +191,10 @@ private void setConstraintFactory(String constraintFactoryFqcn) {
 		if ( constraintFactoryFqcn != null ) {
 			try {
 				@SuppressWarnings("unchecked")
-				Class<ConstraintValidatorFactory> clazz = (Class<ConstraintValidatorFactory>) ReflectionHelper.loadClass(
-						constraintFactoryFqcn, this.getClass()
+				Class<ConstraintValidatorFactory> clazz = (Class<ConstraintValidatorFactory>) run (
+						LoadClass.action( constraintFactoryFqcn, this.getClass() )
 				);
-				constraintValidatorFactory = ReflectionHelper.newInstance( clazz, "constraint factory class" );
+				constraintValidatorFactory = run( NewInstance.action( clazz, "constraint factory class" ) );
 				log.usingConstraintFactory( constraintFactoryFqcn );
 			}
 			catch ( ValidationException e ) {
@@ -205,10 +207,10 @@ private void setParameterNameProvider(String parameterNameProviderFqcn) {
 		if ( parameterNameProviderFqcn != null ) {
 			try {
 				@SuppressWarnings("unchecked")
-				Class<ParameterNameProvider> clazz = (Class<ParameterNameProvider>) ReflectionHelper.loadClass(
-						parameterNameProviderFqcn, this.getClass()
+				Class<ParameterNameProvider> clazz = (Class<ParameterNameProvider>) run(
+						LoadClass.action( parameterNameProviderFqcn, this.getClass() )
 				);
-				parameterNameProvider = ReflectionHelper.newInstance( clazz, "parameter name provider class" );
+				parameterNameProvider = run( NewInstance.action( clazz, "parameter name provider class" ) );
 				log.usingParameterNameProvider( parameterNameProviderFqcn );
 			}
 			catch ( ValidationException e ) {
@@ -235,6 +237,16 @@ private void setConfigProperties(Map<String, String> properties) {
 		}
 	}
 
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
+
 	public void addValidatedValueHandler(ValidatedValueUnwrapper<?> handler) {
 		validatedValueHandlers.add( handler );
 	}
diff --git a/engine/src/main/java/org/hibernate/validator/internal/xml/XmlMappingParser.java b/engine/src/main/java/org/hibernate/validator/internal/xml/XmlMappingParser.java
index f902c386d..a5db48cfa 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/xml/XmlMappingParser.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/xml/XmlMappingParser.java
@@ -20,12 +20,15 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.annotation.Annotation;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+
 import javax.validation.ConstraintValidator;
 import javax.validation.ParameterNameProvider;
 import javax.xml.bind.JAXBContext;
@@ -43,9 +46,9 @@
 import org.hibernate.validator.internal.metadata.raw.ConstrainedExecutable;
 import org.hibernate.validator.internal.metadata.raw.ConstrainedField;
 import org.hibernate.validator.internal.metadata.raw.ConstrainedType;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.LoadClass;
 
 import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
 import static org.hibernate.validator.internal.util.CollectionHelper.newHashMap;
@@ -118,7 +121,7 @@ public final void parse(Set<InputStream> mappingStreams) {
 				);
 
 				for ( BeanType bean : mapping.getBean() ) {
-					Class<?> beanClass = ReflectionHelper.loadClass( bean.getClazz(), defaultPackage );
+					Class<?> beanClass = ClassLoadingHelper.loadClass( bean.getClazz(), defaultPackage );
 					checkClassHasNotBeenProcessed( processedClasses, beanClass );
 
 					// update annotation ignores
@@ -220,7 +223,7 @@ private void parseConstraintDefinitions(List<ConstraintDefinitionType> constrain
 				alreadyProcessedConstraintDefinitions.add( annotationClassName );
 			}
 
-			Class<?> clazz = ReflectionHelper.loadClass( annotationClassName, defaultPackage );
+			Class<?> clazz = ClassLoadingHelper.loadClass( annotationClassName, defaultPackage );
 			if ( !clazz.isAnnotation() ) {
 				throw log.getIsNotAnAnnotationException( annotationClassName );
 			}
@@ -235,11 +238,9 @@ private void parseConstraintDefinitions(List<ConstraintDefinitionType> constrain
 
 		for ( String validatorClassName : validatedByType.getValue() ) {
 			@SuppressWarnings("unchecked")
-			Class<? extends ConstraintValidator<A, ?>> validatorClass = (Class<? extends ConstraintValidator<A, ?>>) ReflectionHelper
-					.loadClass(
-							validatorClassName,
-							this.getClass()
-					);
+			Class<? extends ConstraintValidator<A, ?>> validatorClass = (Class<? extends ConstraintValidator<A, ?>>) run(
+					LoadClass.action( validatorClassName, this.getClass() )
+			);
 
 
 			if ( !ConstraintValidator.class.isAssignableFrom( validatorClass ) ) {
@@ -335,6 +336,16 @@ private String getSchemaResourceName(String schemaVersion) {
 		return schemaResource;
 	}
 
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
+
 	// JAXB closes the underlying input stream
 	private static class CloseIgnoringInputStream extends FilterInputStream {
 		public CloseIgnoringInputStream(InputStream in) {
diff --git a/engine/src/main/java/org/hibernate/validator/internal/xml/XmlParserHelper.java b/engine/src/main/java/org/hibernate/validator/internal/xml/XmlParserHelper.java
index 295349121..db578a4ab 100644
--- a/engine/src/main/java/org/hibernate/validator/internal/xml/XmlParserHelper.java
+++ b/engine/src/main/java/org/hibernate/validator/internal/xml/XmlParserHelper.java
@@ -19,8 +19,11 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLInputFactory;
@@ -32,11 +35,10 @@
 import javax.xml.validation.SchemaFactory;
 
 import org.xml.sax.SAXException;
-
 import org.hibernate.validator.internal.util.Contracts;
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.logging.Log;
 import org.hibernate.validator.internal.util.logging.LoggerFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetClassLoader;
 
 import static org.hibernate.validator.internal.util.logging.Messages.MESSAGES;
 
@@ -148,7 +150,7 @@ public Schema getSchema(String schemaResource) {
 	}
 
 	private Schema loadSchema(String schemaResource) {
-		ClassLoader loader = ReflectionHelper.getClassLoaderFromClass( XmlParserHelper.class );
+		ClassLoader loader = run( GetClassLoader.fromClass( XmlParserHelper.class ) );
 
 		URL schemaUrl = loader.getResource( schemaResource );
 		SchemaFactory sf = SchemaFactory.newInstance( javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI );
@@ -161,4 +163,14 @@ private Schema loadSchema(String schemaResource) {
 		}
 		return schema;
 	}
+
+	/**
+	 * Runs the given privileged action, using a privileged block if required.
+	 * <p>
+	 * <b>NOTE:</b> This must never be changed into a publicly available method to avoid execution of arbitrary
+	 * privileged actions within HV's protection domain.
+	 */
+	private <T> T run(PrivilegedAction<T> action) {
+		return System.getSecurityManager() != null ? AccessController.doPrivileged( action ) : action.run();
+	}
 }
diff --git a/engine/src/test/java/org/hibernate/validator/test/cfg/CascadingWithConstraintMappingTest.java b/engine/src/test/java/org/hibernate/validator/test/cfg/CascadingWithConstraintMappingTest.java
index 7b2aa0ad0..2c028356a 100644
--- a/engine/src/test/java/org/hibernate/validator/test/cfg/CascadingWithConstraintMappingTest.java
+++ b/engine/src/test/java/org/hibernate/validator/test/cfg/CascadingWithConstraintMappingTest.java
@@ -19,17 +19,17 @@
 
 import java.lang.reflect.Method;
 import java.util.Set;
+
 import javax.validation.ConstraintViolation;
 import javax.validation.Validator;
 
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
-
 import org.hibernate.validator.HibernateValidator;
 import org.hibernate.validator.HibernateValidatorConfiguration;
 import org.hibernate.validator.cfg.ConstraintMapping;
 import org.hibernate.validator.cfg.defs.NotNullDef;
-import org.hibernate.validator.internal.util.ReflectionHelper;
+import org.hibernate.validator.internal.util.privilegedactions.GetMethod;
 import org.hibernate.validator.testutil.TestForIssue;
 
 import static java.lang.annotation.ElementType.FIELD;
@@ -108,7 +108,7 @@ public void testProgrammaticCascadingMethodValidation() {
 
 		B b = new B();
 		b.c = new C();
-		Method method = ReflectionHelper.getMethod( B.class, "getC" );
+		Method method = GetMethod.action( B.class, "getC" ).run();
 
 		Set<ConstraintViolation<B>> violations = validator.forExecutables().validateReturnValue(
 				b, method, b.getC()
diff --git a/engine/src/test/java/org/hibernate/validator/test/internal/util/ReflectionHelperTest.java b/engine/src/test/java/org/hibernate/validator/test/internal/util/ReflectionHelperTest.java
index 0c514989b..9d564a7fa 100644
--- a/engine/src/test/java/org/hibernate/validator/test/internal/util/ReflectionHelperTest.java
+++ b/engine/src/test/java/org/hibernate/validator/test/internal/util/ReflectionHelperTest.java
@@ -16,7 +16,6 @@
 */
 package org.hibernate.validator.test.internal.util;
 
-import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -27,10 +26,6 @@
 import java.util.Map;
 import java.util.SortedMap;
 import java.util.TreeSet;
-import javax.validation.Payload;
-import javax.validation.ValidationException;
-import javax.validation.constraints.NotNull;
-import javax.validation.groups.Default;
 
 import org.testng.annotations.Test;
 
@@ -41,7 +36,6 @@
 import static org.testng.Assert.assertFalse;
 import static org.testng.Assert.assertNull;
 import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
 
 /**
  * Tests for the {@code ReflectionHelper}.
@@ -126,57 +120,6 @@ public void testGetIndexedValueForNull() {
 		assertNull( value );
 	}
 
-	@Test
-	public void testGetMessageParameter() {
-		NotNull testAnnotation = new NotNull() {
-			@Override
-			public String message() {
-				return "test";
-			}
-
-			@Override
-			public Class<?>[] groups() {
-				return new Class<?>[] { Default.class };
-			}
-
-			@Override
-			public Class<? extends Payload>[] payload() {
-				@SuppressWarnings("unchecked")
-				Class<? extends Payload>[] classes = new Class[] { };
-				return classes;
-			}
-
-			@Override
-			public Class<? extends Annotation> annotationType() {
-				return this.getClass();
-			}
-		};
-		String message = ReflectionHelper.getAnnotationParameter( testAnnotation, "message", String.class );
-		assertEquals( "test", message, "Wrong message" );
-
-		Class<?>[] group = ReflectionHelper.getAnnotationParameter( testAnnotation, "groups", Class[].class );
-		assertEquals( group[0], Default.class, "Wrong message" );
-
-		try {
-			ReflectionHelper.getAnnotationParameter( testAnnotation, "message", Integer.class );
-			fail();
-		}
-		catch ( ValidationException e ) {
-			assertTrue( e.getMessage().contains( "Wrong parameter type." ), "Wrong exception message" );
-		}
-
-		try {
-			ReflectionHelper.getAnnotationParameter( testAnnotation, "foo", Integer.class );
-			fail();
-		}
-		catch ( ValidationException e ) {
-			assertTrue(
-					e.getMessage().contains( "The specified annotation defines no parameter" ),
-					"Wrong exception message"
-			);
-		}
-	}
-
 	@Test
 	@TestForIssue(jiraKey = "HV-622")
 	public void testIsGetterMethod() throws Exception {
diff --git a/engine/src/test/java/org/hibernate/validator/test/internal/util/annotationfactory/AnnotationProxyTest.java b/engine/src/test/java/org/hibernate/validator/test/internal/util/annotationfactory/AnnotationProxyTest.java
index 7f0acd80c..b28590736 100644
--- a/engine/src/test/java/org/hibernate/validator/test/internal/util/annotationfactory/AnnotationProxyTest.java
+++ b/engine/src/test/java/org/hibernate/validator/test/internal/util/annotationfactory/AnnotationProxyTest.java
@@ -9,7 +9,7 @@
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,  
+* distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
@@ -25,10 +25,9 @@
 
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
-
-import org.hibernate.validator.internal.util.ReflectionHelper;
 import org.hibernate.validator.internal.util.annotationfactory.AnnotationDescriptor;
 import org.hibernate.validator.internal.util.annotationfactory.AnnotationFactory;
+import org.hibernate.validator.internal.util.privilegedactions.GetDeclaredMethods;
 
 /**
  * @author Gunnar Morling
@@ -273,7 +272,7 @@ public void testHashCode() {
 
 		AnnotationDescriptor<A> descriptor = new AnnotationDescriptor<A>( annotationType );
 
-		for ( Method method : ReflectionHelper.getDeclaredMethods( annotationType ) ) {
+		for ( Method method : GetDeclaredMethods.action( annotationType ).run() ) {
 			try {
 				descriptor.setValue( method.getName(), method.invoke( annotation ) );
 			}
diff --git a/engine/src/test/java/org/hibernate/validator/test/internal/util/classhierarchy/ClassHierarchyHelperTest.java b/engine/src/test/java/org/hibernate/validator/test/internal/util/classhierarchy/ClassHierarchyHelperTest.java
index d0b8118e2..5ab78a17c 100644
--- a/engine/src/test/java/org/hibernate/validator/test/internal/util/classhierarchy/ClassHierarchyHelperTest.java
+++ b/engine/src/test/java/org/hibernate/validator/test/internal/util/classhierarchy/ClassHierarchyHelperTest.java
@@ -16,7 +16,6 @@
 */
 package org.hibernate.validator.test.internal.util.classhierarchy;
 
-import java.lang.reflect.Method;
 import java.util.List;
 
 import org.testng.annotations.Test;
@@ -25,7 +24,6 @@
 import org.hibernate.validator.internal.util.classhierarchy.Filters;
 
 import static org.fest.assertions.Assertions.assertThat;
-import static org.testng.Assert.assertTrue;
 
 /**
  * Unit test for {@link ClassHierarchyHelper}.
@@ -35,13 +33,6 @@
  */
 public class ClassHierarchyHelperTest {
 
-	@Test
-	public void testGetAllMethods() throws Exception {
-		List<Method> methods = ClassHierarchyHelper.getAllMethods( Fubar.class );
-		assertTrue( methods.contains( Snafu.class.getMethod( "snafu" ) ) );
-		assertTrue( methods.contains( Susfu.class.getMethod( "susfu" ) ) );
-	}
-
 	@Test
 	public void testGetHierarchy() {
 		List<Class<? super Fubar>> hierarchy = ClassHierarchyHelper.getHierarchy( Fubar.class );
diff --git a/engine/src/test/java/org/hibernate/validator/test/internal/util/privilegedactions/GetAnnotationsParameterTest.java b/engine/src/test/java/org/hibernate/validator/test/internal/util/privilegedactions/GetAnnotationsParameterTest.java
new file mode 100644
index 000000000..b2b556a99
--- /dev/null
+++ b/engine/src/test/java/org/hibernate/validator/test/internal/util/privilegedactions/GetAnnotationsParameterTest.java
@@ -0,0 +1,91 @@
+/*
+* JBoss, Home of Professional Open Source
+* Copyright 2014, Red Hat, Inc. and/or its affiliates, and individual contributors
+* by the @authors tag. See the copyright.txt in the distribution for a
+* full listing of individual contributors.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+* http://www.apache.org/licenses/LICENSE-2.0
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package org.hibernate.validator.test.internal.util.privilegedactions;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+import java.lang.annotation.Annotation;
+
+import javax.validation.Payload;
+import javax.validation.ValidationException;
+import javax.validation.constraints.NotNull;
+import javax.validation.groups.Default;
+
+import org.hibernate.validator.internal.util.privilegedactions.GetAnnotationParameter;
+import org.testng.annotations.Test;
+
+/**
+ * Unit test for {@link GetAnnotationsParameter}.
+ *
+ * @author Gunnar Morling
+ *
+ */
+public class GetAnnotationsParameterTest {
+
+	@Test
+	public void testGetMessageParameter() {
+		NotNull testAnnotation = new NotNull() {
+			@Override
+			public String message() {
+				return "test";
+			}
+
+			@Override
+			public Class<?>[] groups() {
+				return new Class<?>[] { Default.class };
+			}
+
+			@Override
+			public Class<? extends Payload>[] payload() {
+				@SuppressWarnings("unchecked")
+				Class<? extends Payload>[] classes = new Class[] { };
+				return classes;
+			}
+
+			@Override
+			public Class<? extends Annotation> annotationType() {
+				return this.getClass();
+			}
+		};
+		String message = GetAnnotationParameter.action( testAnnotation, "message", String.class ).run();
+		assertEquals( "test", message, "Wrong message" );
+
+		Class<?>[] group = GetAnnotationParameter.action( testAnnotation, "groups", Class[].class ).run();
+		assertEquals( group[0], Default.class, "Wrong message" );
+
+		try {
+			GetAnnotationParameter.action( testAnnotation, "message", Integer.class ).run();
+			fail();
+		}
+		catch ( ValidationException e ) {
+			assertTrue( e.getMessage().contains( "Wrong parameter type." ), "Wrong exception message" );
+		}
+
+		try {
+			GetAnnotationParameter.action( testAnnotation, "foo", Integer.class ).run();
+			fail();
+		}
+		catch ( ValidationException e ) {
+			assertTrue(
+					e.getMessage().contains( "The specified annotation defines no parameter" ),
+					"Wrong exception message"
+			);
+		}
+	}
+}
