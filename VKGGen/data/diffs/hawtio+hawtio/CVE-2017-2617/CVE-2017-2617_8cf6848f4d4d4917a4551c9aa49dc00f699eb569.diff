diff --git a/hawtio-system/src/main/java/io/hawt/web/GitServlet.java b/hawtio-system/src/main/java/io/hawt/web/GitServlet.java
index fac8d4a752..a07c765b82 100644
--- a/hawtio-system/src/main/java/io/hawt/web/GitServlet.java
+++ b/hawtio-system/src/main/java/io/hawt/web/GitServlet.java
@@ -17,11 +17,27 @@
  */
 package io.hawt.web;
 
-import io.hawt.git.*;
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import io.hawt.git.GitFileManager;
+import io.hawt.git.GitFacade;
+import io.hawt.git.WriteCallback;
+import io.hawt.git.WriteContext;
+import io.hawt.git.GitHelper;
 import io.hawt.util.Files;
 import io.hawt.util.Function;
 import io.hawt.util.Strings;
 import io.hawt.util.Zips;
+import org.apache.commons.fileupload.FileUploadBase;
+import org.apache.commons.fileupload.FileUploadException;
 import org.eclipse.jgit.api.errors.GitAPIException;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.ServiceReference;
@@ -30,24 +46,18 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.servlet.ServletConfig;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.File;
-import java.io.IOException;
-import java.util.List;
-
 /**
  */
 public class GitServlet extends UploadServlet implements ServiceTrackerCustomizer {
     private static final transient Logger LOG = LoggerFactory.getLogger(GitServlet.class);
 
     private static final int DEFAULT_BUFFER_SIZE = 10240; // 10KB.
+    private static final String GIT_FILE_UPLOAD_PROPNAME = "hawtio.upload.git.filter";
 
     private BundleContext bundleContext;
     private ServiceTracker serviceTracker;
     private GitFileManager gitFacade;
+    private List<GlobalFileUploadFilter.MagicNumberFileFilter> gitFileUploadFilters;
 
     @Override
     public void init(ServletConfig config) throws ServletException {
@@ -160,7 +170,11 @@ public Object apply(WriteContext context) throws IOException, GitAPIException {
                 }
                 List<File> uploadedFiles = null;
                 try {
-                    uploadedFiles = uploadFiles(req, resp, file);
+                    if (isFileUploadFilterConfigured() && !(file.length() <= GlobalFileUploadFilter.getMaxFileSizeAllowed(gitFileUploadFilters))) {
+                        throw new FileUploadBase.FileUploadIOException(
+                            new FileUploadException("File exceeds its maximum permitted size of bytes."));
+                    }
+                    uploadedFiles = uploadFiles(req, resp, file, gitFileUploadFilters);
                 } catch (ServletException e) {
                     throw new IOException(e);
                 }
@@ -245,4 +259,24 @@ public String getPath() {
             return path;
         }
     }
+
+    private boolean isFileUploadFilterConfigured() {
+        boolean configured = false;
+        String config = System.getProperty(GIT_FILE_UPLOAD_PROPNAME);
+        try {
+            if (config != null) {
+                configured = true;
+                gitFileUploadFilters = GlobalFileUploadFilter.constructFilters(config, new ArrayList<>());
+            } else {
+                configured = false;
+                if (gitFileUploadFilters == null || gitFileUploadFilters.isEmpty()) {
+                    gitFileUploadFilters = new ArrayList<>();
+                }
+            }
+        } catch (RuntimeException e) {
+            LOG.warn("Error configuring filter {}", config);
+        }
+
+        return configured;
+    }
 }
diff --git a/hawtio-system/src/main/java/io/hawt/web/GlobalFileUploadFilter.java b/hawtio-system/src/main/java/io/hawt/web/GlobalFileUploadFilter.java
new file mode 100644
index 0000000000..83026d5bde
--- /dev/null
+++ b/hawtio-system/src/main/java/io/hawt/web/GlobalFileUploadFilter.java
@@ -0,0 +1,444 @@
+package io.hawt.web;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.Collections;
+import java.util.zip.ZipInputStream;
+
+import org.apache.commons.io.FileUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static java.lang.Math.toIntExact;
+
+public class GlobalFileUploadFilter {
+
+    private static final transient Logger LOG = LoggerFactory.getLogger(GlobalFileUploadFilter.class);
+    private static final String FILE_UPLOAD_PROPNAME = "hawtio.upload.filter";
+    public static final int ALLOWED_NUMBER_OF_UPLOADS = 10;
+    private static final String ZIP_SIGNATURE = "504B0304";
+    private List<MagicNumberFileFilter> filters;
+
+    public List<MagicNumberFileFilter> getFilterConfig() {
+        return Collections.unmodifiableList(getFilters());
+    }
+
+    public GlobalFileUploadFilter() {
+
+        String config = System.getProperty(FILE_UPLOAD_PROPNAME);
+        if (config != null) {
+            LOG.info("Configuring file upload using {} configurations", config);
+
+            try {
+                constructFilters(config, this.getFilters());
+            } catch (RuntimeException e) {
+                LOG.warn("Error configuring filter {}", config);
+            }
+        }
+    }
+
+    private static List<String> constructDefaultScriptingContent() {
+        // Scripting content search with offset 0
+        String[] scriptContentSearch = new String[]{"#!/usr/bin/python", "#!/usr/local/bin/python", "#!/bin/sh",
+            "#!/usr/bin/env python", "#!/bin/bash", "#!/usr/bin/bash", "#!/usr/local/bash", "#!/usr/local/bin/bash",
+            "#!/usr/bin/env bash", "=<?php", "=<?\\n", "=<?\\r", "#!/usr/local/bin/php", "#!/usr/bin/php",
+            "#!/usr/bin/pdmenu", "eval \"exec perl", "eval \"exec /bin/perl", "eval \"exec /usr/bin/perl",
+            "eval \"exec /usr/local/bin/perl", "eval 'exec perl", "eval 'exec /bin/perl", "eval 'exec /usr/bin/perl",
+            "eval 'exec /usr/local/bin/perl", "eval '(exit $?0)' && eval 'exec", "#!/usr/bin/env perl",
+            "#! /usr/bin/env perl", "#!/bin/node", "#!/usr/bin/node", "#!/bin/nodejs", "#!/usr/bin/nodejs",
+            "#!/usr/bin/env node", "#!/usr/bin/env nodejs", "@", "echo off", "rem", "set", "<html>", "#!/usr/bin/env ruby",
+            "#!/usr/bin/ruby", "#!", "<script>", "goscript", "//usr", "<%", "%>", "..", "/", "\\", "*", "?", "%", ";", "#",
+            "$", "&", "[", "]", "^", "`", "~", ">>", "<<", "...", "#include", "stdio.h", "perl"};
+
+        List<String> scriptingList = new ArrayList<>();
+        for (int i = 0; i <= scriptContentSearch.length - 1; i ++) {
+            scriptingList.add(scriptContentSearch[i]);
+        }
+
+        return scriptingList;
+    }
+
+    static List<MagicNumberFileFilter> constructFilters(String config, List<MagicNumberFileFilter> filters) {
+        String[] var0 = config.split("-");
+        for (int i = 0; i <= var0.length - 1; i++) {
+            MagicNumberFileFilter filter = new MagicNumberFileFilter();
+            String[] var1 = var0[i].split(",");
+            for (int j = 0; j <= var1.length - 1; j++) {
+                if (var1[j].toLowerCase().startsWith("signature=")) {
+                    String value = var1[j].substring(10);
+                    if (validateString(value)) {
+                        filter.setMagicNumbers(hexStringToByteArray(value));
+                    }
+                }
+
+                if (var1[j].toLowerCase().startsWith("offset=")) {
+                    String value = var1[j].toLowerCase().substring(7);
+                    if (validateString(value)) {
+                        filter.setByteOffset(Long.parseLong(value));
+                    }
+                }
+
+                if (var1[j].toLowerCase().startsWith("maxsize=")) {
+                    String value = var1[j].substring(8);
+                    if (validateString(value)) {
+                        filter.setMaxSize(value.trim());
+                    }
+
+                }
+
+                if (var1[j].toLowerCase().startsWith("exc=")) {
+                    List<String> excns = new ArrayList<>();
+                    String tmpValue = var1[j].substring(5);
+                    if (validateString(tmpValue) && tmpValue.charAt(tmpValue.length() - 1) == ']') {
+                        tmpValue = tmpValue.substring(0, tmpValue.length() - 1);
+                    }
+
+                    String[] vars = tmpValue.split("\\s+");
+                    for (int k = 0; k < vars.length; k ++) {
+                        excns.add(vars[k]);
+                    }
+
+                    filter.setExceptions(!excns.isEmpty() ? excns : new ArrayList<>());
+                }
+            }
+
+            filters.add(filter);
+        }
+
+        return filters;
+    }
+
+    private static boolean validateString(String tmpValue) {
+        return tmpValue != null && tmpValue.length() > 0;
+    }
+
+    protected static byte[] hexStringToByteArray(String s) {
+        int len = s.length();
+        byte[] data = new byte[len / 2];
+        for (int i = 0; i < len; i += 2) {
+            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
+                + Character.digit(s.charAt(i + 1), 16));
+        }
+        return data;
+    }
+
+    static long translateFileSize(String size) {
+
+        if (size.toLowerCase().trim().contains("bytes")) {
+            String normalized = size.toLowerCase().replace("bytes", "").trim();
+            return Long.parseLong(!normalized.equals("") ? normalized : "0");
+        }
+
+        if (size.toLowerCase().trim().contains("kb")) {
+            String normalized = size.toLowerCase().replace("kb", "").trim();
+            return 1024L * Long.parseLong(!normalized.equals("") ? normalized : "0");
+        }
+
+        if (size.toLowerCase().trim().contains("mb")) {
+            String normalized = size.toLowerCase().replace("mb", "").trim();
+            return 1048576L * Long.parseLong(!normalized.equals("") ? normalized : "0");
+        }
+
+        if (size.toLowerCase().trim().contains("gb")) {
+            String normalized = size.toLowerCase().replace("gb", "").trim();
+            return 1073741824L * Long.parseLong(!normalized.equals("") ? normalized : "0");
+        }
+
+        return 0L;
+    }
+
+    public static synchronized boolean accept(byte[] fileContent, List<MagicNumberFileFilter> filters) {
+        // By default all files are allowed unless configured via sys. prop
+        if (filters == null || filters.isEmpty()) {
+            return true;
+        }
+
+        boolean fileAccepted = false;
+        for (MagicNumberFileFilter magicNumberFileFilter : filters) {
+            if (magicNumberFileFilter.getMagicNumbers().length > 0 && fileContent.length >= magicNumberFileFilter.getByteOffset() +
+                magicNumberFileFilter.getMagicNumbers().length) {
+                byte[] fileMagicBytes = Arrays.copyOfRange(fileContent, toIntExact(magicNumberFileFilter.getByteOffset()),
+                    toIntExact(magicNumberFileFilter.getByteOffset()) + magicNumberFileFilter.getMagicNumbers().length);
+                boolean matched = Arrays.equals(magicNumberFileFilter.getMagicNumbers(), fileMagicBytes);
+                if (matched) {
+                    fileAccepted = true;
+                    //Individual file size check to ensure it complies with configs
+                    if (magicNumberFileFilter.getMaxSize() != null) {
+                        String fileSize = FileUtils.byteCountToDisplaySize(fileContent.length);
+                        if (translateFileSize(fileSize) <= translateFileSize(magicNumberFileFilter.getMaxSize())) {
+                            fileAccepted = true;
+                        } else {
+                            fileAccepted = false;
+                        }
+                    }
+
+                    /**
+                     * If this is a zip file inspect the content, at the moment hawtio should only
+                     * allow zip archive file to be uploaded
+                     */
+                    if (Arrays.equals(magicNumberFileFilter.getMagicNumbers(),
+                        hexStringToByteArray(ZIP_SIGNATURE)) && fileAccepted) {
+                        try {
+                            fileAccepted = unzip(fileContent, filters);
+                        } catch (IOException e) {
+                            e.printStackTrace();
+                        }
+                    }
+                }
+            } else if (magicNumberFileFilter.getExceptions() != null) {
+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream(fileContent.length);
+                outputStream.write(fileContent, 0, fileContent.length);
+                Set<String> excList = new HashSet<>();
+                for (String s: constructDefaultScriptingContent()) {
+                    if (magicNumberFileFilter.getExceptions() != null &&
+                        !magicNumberFileFilter.getExceptions().contains(s)) {
+                        excList.add(s);
+                    }
+                }
+                if (!isAsciiContentDangerous(outputStream, excList)) {
+                    fileAccepted = true;
+                }
+            }
+        }
+
+        return fileAccepted;
+    }
+
+    private static boolean unzip(byte[] fileContent, List<MagicNumberFileFilter> fileFilter) throws IOException {
+        long maxSize = 5 * 1048576L; // Default size of the unzipped data, 50MB
+        int tooMany = 100; // Max number of files
+        int buffer = 512;
+        ZipInputStream zipInputStream = new ZipInputStream(new ByteArrayInputStream(fileContent));
+        boolean safe = true;
+        int entries = 0;
+        long total = 0;
+        try {
+            while ((zipInputStream.getNextEntry()) != null) {
+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+                int count;
+                byte[] data = new byte[buffer];
+                boolean isAscii = true;
+                while (total + buffer <= maxSize && (count = zipInputStream.read(data, 0, buffer)) != -1) {
+                    if (isAscii) {
+                        isAscii = isAsciiFile(data, count); // Check if the stream is ascii.
+                    }
+
+                    outputStream.write(data, 0, count);
+                    total += count;
+                }
+
+                if (outputStream.toByteArray().length > 0) {
+                    // Check the entry file type
+                    byte[] entryContent = outputStream.toByteArray();
+                    boolean configured = accept(entryContent, fileFilter);
+                    if (configured) {
+                        continue; // valid file
+                    }
+
+                    if (isAscii) {
+                        if (!configured && isExceptionConfigured(fileFilter)) {
+                            Set<String> finalProhibitedList = getFinalProhibitedList(fileFilter);
+
+                            if (!isAsciiContentDangerous(outputStream, finalProhibitedList)) {
+                                safe = true;
+                            } else {
+                                safe = false;
+                            }
+                        }
+
+                        if (!configured && !isExceptionConfigured(fileFilter)) {
+                            if (!isAsciiContentDangerous(outputStream,
+                                new HashSet<>(constructDefaultScriptingContent()))) {
+                                safe = true;
+                            } else {
+                                safe = false;
+                            }
+                        }
+                    } else safe = false;
+                }
+
+                if (!safe) {
+                    return safe;
+                }
+
+                if (outputStream != null) {
+                    outputStream.close();
+                }
+            }
+
+            zipInputStream.closeEntry();
+            entries ++;
+            if (entries > tooMany) {
+                throw new IllegalStateException("Too many files to unzip");
+            }
+
+            if (total > maxSize) {
+                throw new IllegalStateException("File being unzipped is too big");
+            }
+        } finally {
+            zipInputStream.close();
+        }
+
+        return safe;
+    }
+
+    static boolean isAsciiFile(byte[] content, int len) {
+        for (int i = 0; i < len; i ++) {
+            if ((0x0080 & content[i]) != 0) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    static Set<String> getFinalProhibitedList(List<MagicNumberFileFilter> fileFilter) {
+        Set<String> finalProhibitedList = new HashSet<>();
+
+        // Checking for exceptions: Nested loop should not be inefficient
+        // as the filter usually does not grow unexpectedly
+        for (String s: constructDefaultScriptingContent()) {
+            for (MagicNumberFileFilter m: fileFilter) {
+                if (m.getExceptions() != null && !m.getExceptions().contains(s)) {
+                    finalProhibitedList.add(s);
+                }
+            }
+        }
+        return finalProhibitedList;
+    }
+
+    private static boolean isExceptionConfigured(List<MagicNumberFileFilter> fileFilter) {
+        boolean configured = true;
+        for (MagicNumberFileFilter filter: fileFilter) {
+            if (filter.getExceptions() == null) {
+                configured = false;
+            } else {
+                configured = true;
+            }
+        }
+        return configured;
+    }
+
+    static boolean isAsciiContentDangerous(ByteArrayOutputStream outputStream,
+                                           Set<String> finalProhibitedList) {
+        boolean dangerousContentDetected = false;
+
+        StringBuilder builder = new StringBuilder();
+        for (byte b: outputStream.toByteArray()) {
+            builder.append((char)b);
+        }
+
+        for (String s: finalProhibitedList) {
+            if (builder.toString().startsWith(s) || builder.toString().contains(s)) {
+                dangerousContentDetected = true; // script file detected
+            }
+        }
+
+        return dangerousContentDetected;
+    }
+
+    /**
+     * Getting the maximum file size allowed from the config
+     */
+    public static long getMaxFileSizeAllowed(List<MagicNumberFileFilter> filters) {
+        if (filters.size() == 0) {
+            return -1L; // Default file size unlimited
+        }
+
+        long maxSize = -1L;
+        try {
+            long[] fileSizes = new long[filters.size()];
+            for (int i = 0; i <= filters.size() - 1; i ++) {
+                fileSizes[i] = translateFileSize(filters.get(i).getMaxSize());
+            }
+
+            maxSize = fileSizes[0];
+            for (int j = 0; j <= fileSizes.length - 1; j ++) {
+                if (maxSize == fileSizes[j]) {
+                    continue;
+                }
+
+                if (fileSizes[j] > maxSize) {
+                    maxSize = fileSizes[j];
+                }
+            }
+        } catch (RuntimeException e) {
+            LOG.error("Error calculating max file size");
+        }
+
+        return maxSize;
+    }
+
+    public static GlobalFileUploadFilter newFileUploadFilter() {
+        return new GlobalFileUploadFilter();
+    }
+
+    private List<MagicNumberFileFilter> getFilters() {
+        if (this.filters == null) {
+            this.filters = new ArrayList<>();
+        }
+
+        return this.filters;
+    }
+
+    /**
+     * Hold a snapshot of values to be passed to an GlobalFileUploadFilter.
+     */
+    public static final class MagicNumberFileFilter {
+        private byte[] magicNumbers;
+        private long byteOffset;
+        private String maxSize;
+        private List<String> exceptions;
+
+        public MagicNumberFileFilter() {
+            this.magicNumbers = new byte[0];
+            this.maxSize = "200bytes";
+        }
+
+        public byte[] getMagicNumbers() {
+            return magicNumbers;
+        }
+
+        public void setMagicNumbers(byte[] magicNumbers) {
+            if (magicNumbers.length == 0) {
+                throw new IllegalArgumentException("The magic number must contain at least one byte");
+            }
+            this.magicNumbers = magicNumbers;
+        }
+
+        public long getByteOffset() {
+            return byteOffset;
+        }
+
+        public void setByteOffset(long byteOffset) {
+            if (byteOffset < 0L) {
+                throw new IllegalArgumentException("The offset cannot be negative");
+            }
+            this.byteOffset = byteOffset;
+        }
+
+        public String getMaxSize() {
+            return maxSize;
+        }
+
+        public void setMaxSize(String maxSize) {
+            if (maxSize != null) {
+                this.maxSize = maxSize;
+            }
+        }
+
+        public List<String> getExceptions() {
+            return exceptions;
+        }
+
+        public void setExceptions(List<String> exceptions) {
+            this.exceptions = exceptions;
+        }
+    }
+}
diff --git a/hawtio-system/src/main/java/io/hawt/web/UploadServlet.java b/hawtio-system/src/main/java/io/hawt/web/UploadServlet.java
index 157fdc9261..69861b370b 100644
--- a/hawtio-system/src/main/java/io/hawt/web/UploadServlet.java
+++ b/hawtio-system/src/main/java/io/hawt/web/UploadServlet.java
@@ -1,10 +1,10 @@
 package io.hawt.web;
 
-import java.io.File;
-import java.io.IOException;
-import java.io.PrintWriter;
+
+import java.io.*;
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
@@ -18,6 +18,7 @@
 import org.apache.commons.fileupload.ProgressListener;
 import org.apache.commons.fileupload.disk.DiskFileItemFactory;
 import org.apache.commons.fileupload.servlet.ServletFileUpload;
+import org.apache.commons.io.IOUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -34,14 +35,17 @@ protected void doPost(HttpServletRequest request, HttpServletResponse response)
         String uploadDirectory = UploadManager.UPLOAD_DIRECTORY;
         File uploadDir = new File(uploadDirectory);
 
-        uploadFiles(request, response, uploadDir);
+        GlobalFileUploadFilter globalFilter = GlobalFileUploadFilter.newFileUploadFilter();
+        uploadFiles(request, response, uploadDir, globalFilter.getFilterConfig());
     }
 
-    protected List<File> uploadFiles(HttpServletRequest request, HttpServletResponse response, File uploadDir) throws IOException, ServletException {
+    protected List<File> uploadFiles(HttpServletRequest request, HttpServletResponse response,
+                                     File uploadDir, List<GlobalFileUploadFilter.MagicNumberFileFilter> filters) throws IOException, ServletException {
         response.setContentType("text/html");
         final PrintWriter out = response.getWriter();
         List<File> uploadedFiles = new ArrayList<>();
         boolean isMultipart = ServletFileUpload.isMultipartContent(request);
+
         if (isMultipart) {
             ServletContext context = this.getServletConfig().getServletContext();
             if (!uploadDir.exists()) {
@@ -52,6 +56,8 @@ protected void doPost(HttpServletRequest request, HttpServletResponse response)
             }
             DiskFileItemFactory factory = UploadManager.newDiskFileItemFactory(context, uploadDir);
             ServletFileUpload upload = new ServletFileUpload(factory);
+            // Setting max file size allowed from config
+            upload.setFileSizeMax(GlobalFileUploadFilter.getMaxFileSizeAllowed(filters));
 
             String targetDirectory = null;
             List<File> files = new ArrayList<File>();
@@ -76,38 +82,46 @@ public void update(long pBytesRead, long pContentLength, int pItems) {
 
             try {
                 List<FileItem> items = upload.parseRequest(request);
+                if (items.size() > GlobalFileUploadFilter.ALLOWED_NUMBER_OF_UPLOADS) {
+                    response.sendError(HttpServletResponse.SC_FORBIDDEN, "Uploaded files exceed the maximum allowed number of files");
+                }
+
                 for (FileItem item : items) {
-                    if (item.isFormField()) {
-                        String name = item.getFieldName();
-                        String value = item.getString();
-                        LOG.info("Got form field {} with value {}", name, value);
-                        if (name.equals("parent")) {
-                            targetDirectory = value;
+                    if (fileAllowed(item, filters)) {
+                        if (item.isFormField()) {
+                            String name = item.getFieldName();
+                            String value = item.getString();
+                            LOG.info("Got form field {} with value {}", name, value);
+                            if (name.equals("parent")) {
+                                targetDirectory = value;
+                            }
+                        } else {
+                            String fieldName = item.getFieldName();
+                            String fileName = item.getName();
+                            String contentType = item.getContentType();
+                            long sizeInBytes = item.getSize();
+
+                            fileName = Strings.sanitize(fileName);
+
+                            LOG.info("Got file upload, fieldName: {} fileName: {} contentType: {} size: {}", new Object[]{fieldName, fileName, contentType, sizeInBytes});
+
+                            if (fileName.equals("")) {
+                                LOG.info("Skipping field " + fieldName + " no filename given");
+                                continue;
+                            }
+                            File target = new File(uploadDir, fileName);
+
+                            try {
+                                item.write(target);
+                                files.add(target);
+                                LOG.info("Wrote to file: {}", target.getAbsoluteFile());
+                            } catch (Exception e) {
+                                LOG.warn("Failed to write to {} due to {}", target, e);
+                                //throw new RuntimeException(e);
+                            }
                         }
                     } else {
-                        String fieldName = item.getFieldName();
-                        String fileName = item.getName();
-                        String contentType = item.getContentType();
-                        long sizeInBytes = item.getSize();
-
-                        fileName = Strings.sanitize(fileName);
-
-                        LOG.info("Got file upload, fieldName: {} fileName: {} contentType: {} size: {}", new Object[]{fieldName, fileName, contentType, sizeInBytes});
-
-                        if (fileName.equals("")) {
-                            LOG.info("Skipping field " + fieldName + " no filename given");
-                            continue;
-                        }
-                        File target = new File(uploadDir, fileName);
-
-                        try {
-                            item.write(target);
-                            files.add(target);
-                            LOG.info("Wrote to file: {}", target.getAbsoluteFile());
-                        } catch (Exception e) {
-                            LOG.warn("Failed to write to {} due to {}", target, e);
-                            //throw new RuntimeException(e);
-                        }
+                        throw new RuntimeException("File is not allowed to be uploaded");
                     }
                 }
             } catch (FileUploadException e) {
@@ -143,4 +157,11 @@ public void update(long pBytesRead, long pContentLength, int pItems) {
         return uploadedFiles;
     }
 
+    private boolean fileAllowed(FileItem fileItem, List<GlobalFileUploadFilter.MagicNumberFileFilter> filters) throws IOException {
+        InputStream inputStream = fileItem.getInputStream();
+        byte[] fileContent = IOUtils.toByteArray(inputStream, fileItem.getSize());
+        boolean result = GlobalFileUploadFilter.accept(fileContent, filters);
+        inputStream.close();
+        return result;
+    }
 }
diff --git a/hawtio-system/src/test/java/io/hawt/web/GitFileUploadFilterTest.java b/hawtio-system/src/test/java/io/hawt/web/GitFileUploadFilterTest.java
new file mode 100644
index 0000000000..3eabd957fd
--- /dev/null
+++ b/hawtio-system/src/test/java/io/hawt/web/GitFileUploadFilterTest.java
@@ -0,0 +1,76 @@
+package io.hawt.web;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.commons.io.IOUtils;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class GitFileUploadFilterTest {
+
+
+    List<GlobalFileUploadFilter.MagicNumberFileFilter> gitFilters;
+    private static final String GIT_CONFIG = "signature=504B0304,offset=0,maxSize=10mb,exc=[@ [ ] # * / & % ? ; $]";
+
+    @Before
+    public void setUp() {
+        gitFilters = new ArrayList<>(GlobalFileUploadFilter.constructFilters(GIT_CONFIG, new ArrayList<>()));
+    }
+
+    @Test
+    public void testFabricProfileUpload_GoodContent() throws IOException {
+        byte[] profileBytes = getFabricProfile();
+        boolean result = GlobalFileUploadFilter.accept(profileBytes, gitFilters);
+        assertTrue(result);
+    }
+
+    @Test
+    public void testFileContainsExceptions_1() {
+        String fileContent = "mem.pools.*.used";
+        byte[] fileByteContent = fileContent.getBytes();
+        Set<String> prohibitedList = GlobalFileUploadFilter.getFinalProhibitedList(gitFilters);
+        boolean result = GlobalFileUploadFilter.isAsciiContentDangerous(getFileContentByteStreams(fileByteContent), prohibitedList);
+        assertFalse(result);
+    }
+
+    @Test
+    public void testFabricProfileUpload_BadContent() throws IOException {
+        String fileContent = "rem   lets enable stand alone mode";
+        byte[] fileByteContent = fileContent.getBytes();
+        Set<String> prohibitedList = GlobalFileUploadFilter.getFinalProhibitedList(gitFilters);
+        boolean result = GlobalFileUploadFilter.isAsciiContentDangerous(getFileContentByteStreams(fileByteContent), prohibitedList);
+        assertTrue(result);
+    }
+
+    @Test
+    public void testShouldPreventExcessiveFileSize() throws IOException {
+        String GIT_CONFIG = "signature=504B0304,offset=0,maxSize=20kb,exc=[@ [ ] # * / & % ? ; $]";
+        byte[] profileBytes = getFabricProfile();
+        List<GlobalFileUploadFilter.MagicNumberFileFilter> filters =
+            GlobalFileUploadFilter.constructFilters(GIT_CONFIG, new ArrayList<>());
+        long maxFileSizeAllowed = GlobalFileUploadFilter.getMaxFileSizeAllowed(filters);
+        assertTrue(!(profileBytes.length <= maxFileSizeAllowed));
+
+    }
+
+    private ByteArrayOutputStream getFileContentByteStreams(byte[] fileByteContent) {
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(fileByteContent.length);
+        outputStream.write(fileByteContent, 0, fileByteContent.length);
+        return outputStream;
+    }
+
+    private byte[] getFabricProfile() throws IOException {
+        File profile = new File("src/test/resources/data/default.zip");
+        FileInputStream profileInputStream = new FileInputStream(profile);
+        return IOUtils.toByteArray(profileInputStream);
+    }
+}
diff --git a/hawtio-system/src/test/java/io/hawt/web/GlobalFileUploadFilterTest.java b/hawtio-system/src/test/java/io/hawt/web/GlobalFileUploadFilterTest.java
new file mode 100644
index 0000000000..dc86349ea7
--- /dev/null
+++ b/hawtio-system/src/test/java/io/hawt/web/GlobalFileUploadFilterTest.java
@@ -0,0 +1,262 @@
+package io.hawt.web;
+
+import java.io.IOException;
+import java.io.FileInputStream;
+import java.io.File;
+import java.io.ObjectOutputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.zip.ZipInputStream;
+
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.IOUtils;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class GlobalFileUploadFilterTest {
+
+    @Test
+    public void testPreventsJavaSerializedFileUpload() throws IOException {
+        System.setProperty("hawtio.upload.filter", "signature=D0CF11E0A1B11AE1,offset=2,maxSize=250kb");
+        GlobalFileUploadFilter uploadFilter = GlobalFileUploadFilter.newFileUploadFilter();
+        UploadServlet uploadServlet = new UploadServlet();
+        byte[] bytes = serialize(uploadServlet);
+        assertFalse(uploadFilter.accept(bytes, uploadFilter.getFilterConfig()));
+    }
+
+    @Test
+    public void testAllowsJavaSerializedFileUpload() throws IOException {
+        System.setProperty("hawtio.upload.filter", "signature=ACED,offset=0,maxSize=250bytes");
+        GlobalFileUploadFilter uploadFilter = GlobalFileUploadFilter.newFileUploadFilter();
+        UploadServlet uploadServlet = new UploadServlet();
+        byte[] bytes = serialize(uploadServlet);
+        assertTrue(uploadFilter.accept(bytes, uploadFilter.getFilterConfig()));
+    }
+
+    @Test
+    public void testAllowsTarFileUploadButBlocksJarFileWithSizeRestriction() throws IOException {
+        System.setProperty("hawtio.upload.filter",
+            "signature=7573746172,offset=257,maxSize=10kb-signature=504B0304,offset=0,maxSize=1kb");
+
+        GlobalFileUploadFilter uploadFilter = GlobalFileUploadFilter.newFileUploadFilter();
+
+        File jarFile = new File("src/test/resources/data/jar-file-1.0.jar");
+        assertNotNull(jarFile);
+        FileInputStream jarInputStream = new FileInputStream(jarFile);
+        byte[] jarBytes = IOUtils.toByteArray(jarInputStream);
+        assertFalse(uploadFilter.accept(jarBytes, uploadFilter.getFilterConfig()));
+        jarInputStream.close();
+
+        File tarFile = new File("src/test/resources/data/test.tar");
+        assertNotNull(jarFile);
+
+        FileInputStream tarInputStream = new FileInputStream(tarFile);
+        byte[] tarBytes = IOUtils.toByteArray(tarInputStream);
+        assertTrue(uploadFilter.accept(tarBytes, uploadFilter.getFilterConfig()));
+        tarInputStream.close();
+    }
+
+    @Test
+    public void testAllowsJavaSerializedFileExceedsFileSizeUpload() throws IOException {
+        System.setProperty("hawtio.upload.filter", "signature=ACED,offset=0,maxSize=100bytes");
+        GlobalFileUploadFilter uploadFilter = GlobalFileUploadFilter.newFileUploadFilter();
+        UploadServlet uploadServlet = new UploadServlet();
+        byte[] bytes = serialize(uploadServlet);
+        assertFalse(uploadFilter.accept(bytes, uploadFilter.getFilterConfig()));
+    }
+
+    @Test
+    public void testGetsFileSize() throws IOException {
+        UploadServlet uploadServlet = new UploadServlet();
+        byte[] bytes = serialize(uploadServlet);
+        assertEquals("134 bytes", FileUtils.byteCountToDisplaySize(bytes.length));
+    }
+
+    @Test
+    public void testMaxFileSize() {
+        String configs = "signature=7573746172,offset=257,maxSize=10kb-signature=504B0304,offset=0,maxSize=1kb-" +
+            "signature=504B0304,offset=0,maxSize=25mb";
+        List<GlobalFileUploadFilter.MagicNumberFileFilter> filters =
+            GlobalFileUploadFilter.constructFilters(configs, new ArrayList<>());
+        long max = GlobalFileUploadFilter.getMaxFileSizeAllowed(filters);
+        assertEquals(26214400L, max);
+    }
+
+    @Test
+    public void testExceptions() {
+        String configs = "signature=7573746172,offset=257,maxSize=10kb,exc=[` ^ ...]-signature=504B0304,offset=0,maxSize=1kb-" +
+            "signature=504B0304,offset=0,maxSize=25mb,exc=[@ ? %]";
+        List<String> _1expected = new ArrayList<>(Arrays.asList("@", "?", "%"));
+        List<String> _2expected = new ArrayList<>(Arrays.asList("`", "^", "..."));
+        List<GlobalFileUploadFilter.MagicNumberFileFilter> filters =
+            GlobalFileUploadFilter.constructFilters(configs, new ArrayList<>());
+        for (GlobalFileUploadFilter.MagicNumberFileFilter filter: filters) {
+            if (filter.getMaxSize().equals("25mb")) {
+                for (String s: filter.getExceptions()) {
+                    _1expected.contains(s);
+                }
+            }
+
+            if (filter.getMaxSize().equals("10kb")) {
+                for (String s: filter.getExceptions()) {
+                    _2expected.contains(s);
+                }
+            }
+        }
+
+    }
+
+    @Test
+    public void testTreanslateFileSize() {
+
+        long byteSize = GlobalFileUploadFilter.translateFileSize("100 Bytes");
+        assertEquals(100L, byteSize);
+
+        long byteSize_1 = GlobalFileUploadFilter.translateFileSize("Bytes");
+        assertEquals(0L, byteSize_1);
+
+        long kiloByteSize = GlobalFileUploadFilter.translateFileSize("97 KB");
+        assertEquals(99328L, kiloByteSize);
+
+        long megaByteSize = GlobalFileUploadFilter.translateFileSize("25 mb");
+        assertEquals(26214400L, megaByteSize);
+
+        long gigaByteSize = GlobalFileUploadFilter.translateFileSize("14 GB");
+        assertEquals(15032385536L, gigaByteSize);
+    }
+
+    @Test
+    public void testInspectGoodZipEntryPasses() throws IOException {
+        System.setProperty("hawtio.upload.filter", "signature=504B0304,offset=0,maxSize=1kb");
+        File goodZip = new File("src/test/resources/data/goodcontent.zip");
+        FileInputStream jarInputStream = new FileInputStream(goodZip);
+        byte[] goodZipBytes = IOUtils.toByteArray(jarInputStream);
+        GlobalFileUploadFilter filter = GlobalFileUploadFilter.newFileUploadFilter();
+        boolean b = GlobalFileUploadFilter.accept(goodZipBytes, filter.getFilterConfig());
+        assertTrue(b);
+    }
+
+    @Test
+    public void testInspectBadZipEntryFails() throws IOException {
+        System.setProperty("hawtio.upload.filter", "signature=504B0304,offset=0,maxSize=200kb");
+        File goodZip = new File("src/test/resources/data/badcontent.zip");
+        FileInputStream jarInputStream = new FileInputStream(goodZip);
+        byte[] goodZipBytes = IOUtils.toByteArray(jarInputStream);
+        GlobalFileUploadFilter filter = GlobalFileUploadFilter.newFileUploadFilter();
+        boolean b = GlobalFileUploadFilter.accept(goodZipBytes, filter.getFilterConfig());
+        assertFalse(b);
+    }
+
+    @Test
+    public void testInspectExceptions() throws IOException {
+        System.setProperty("hawtio.upload.filter", "signature=504B0304,offset=0,maxSize=200kb,exc=[@ [ ]]");
+        File zipContainsException = new File("src/test/resources/data/exception.zip");
+        FileInputStream zipInputStream = new FileInputStream(zipContainsException);
+        byte[] goodZipBytes = IOUtils.toByteArray(zipInputStream);
+        GlobalFileUploadFilter filter = GlobalFileUploadFilter.newFileUploadFilter();
+        boolean b = GlobalFileUploadFilter.accept(goodZipBytes, filter.getFilterConfig());
+        assertTrue(b);
+    }
+
+    @Test
+    public void testConfiguredZipContent() throws IOException {
+        System.setProperty("hawtio.upload.filter", "signature=504B0304,offset=0,maxSize=200kb-signature=CAFEBABE,offset=0,maxSize=550bytes");
+        File zipContainAllowed = new File("src/test/resources/data/allowedContent.zip");
+        FileInputStream zipInputStream = new FileInputStream(zipContainAllowed);
+        byte[] zipBytes = IOUtils.toByteArray(zipInputStream);
+        GlobalFileUploadFilter filter = GlobalFileUploadFilter.newFileUploadFilter();
+        boolean b = GlobalFileUploadFilter.accept(zipBytes, filter.getFilterConfig());
+        assertTrue(b);
+    }
+
+    @Test
+    public void testExceptionsOnly() {
+        System.setProperty("hawtio.upload.filter", "exc=[@ [ ]]");
+        String fileContent = "@{toJson(result.server.name)} result.results['contexts'].results}";
+        GlobalFileUploadFilter filter = GlobalFileUploadFilter.newFileUploadFilter();
+        boolean result = GlobalFileUploadFilter.accept(fileContent.getBytes(), filter.getFilterConfig());
+        assertTrue(result);
+    }
+
+    @Test
+    public void testBlocksZipUploadNonConfiguredItemAndGenericBinaryItem() throws IOException {
+        File zipContainNotAllowed = new File("src/test/resources/data/allowedContent.zip");
+        System.setProperty("hawtio.upload.filter", "signature=504B0304,offset=0,maxSize=10mb,exc=[@ [ ] # * / & % ? ; $]");
+        byte[] zipContainNotAllowedBytes = IOUtils.toByteArray(new FileInputStream(zipContainNotAllowed));
+        List<GlobalFileUploadFilter.MagicNumberFileFilter> filters =
+            GlobalFileUploadFilter.constructFilters(System.getProperty("hawtio.upload.filter"), new ArrayList<>());
+        boolean result = GlobalFileUploadFilter.accept(zipContainNotAllowedBytes, filters);
+        assertFalse(result);
+
+    }
+
+//    @Test
+//    public void testBlocksZipUploadNonConfiguredItemAndAsciiBinaryItem() throws IOException {
+//
+//    }
+
+    @Test
+    public void testAsciiContent_1() throws IOException {
+        UploadServlet uploadServlet = new UploadServlet();
+        byte[] bytes = serialize(uploadServlet);
+        byte[] buffer = new byte[512];
+        boolean isAscii = true;
+        int len;
+        ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);
+        while ((len = inputStream.read(buffer, 0, buffer.length)) != -1) {
+            if (isAscii) {
+                isAscii = GlobalFileUploadFilter.isAsciiFile(buffer, len);
+            }
+        }
+
+        assertFalse(isAscii);
+    }
+
+    @Test
+    public void testAsciiContent_2() throws IOException {
+        File zipContainAscii = new File("src/test/resources/data/allowedContent.zip");
+        int len;
+        byte[] buffer = new byte[512];
+        boolean isAscii = true;
+        ZipInputStream stream = new ZipInputStream(new FileInputStream(zipContainAscii));
+        while ((stream.getNextEntry()) != null) {
+            while ((len = stream.read(buffer, 0, buffer.length)) != -1) {
+                if (isAscii) {
+                    isAscii = GlobalFileUploadFilter.isAsciiFile(buffer, len);
+                }
+            }
+        }
+
+        assertFalse(isAscii);
+    }
+
+    @Test
+    public void testAsciiContent_3() throws IOException {
+        File zipContainAscii = new File("src/test/resources/data/badcontent.zip");
+        int len;
+        byte[] buffer = new byte[512];
+        boolean isAscii = true;
+        ZipInputStream stream = new ZipInputStream(new FileInputStream(zipContainAscii));
+        while ((stream.getNextEntry()) != null) {
+            while ((len = stream.read(buffer, 0, buffer.length)) != -1) {
+                if (isAscii) {
+                    isAscii = GlobalFileUploadFilter.isAsciiFile(buffer, len);
+                }
+            }
+        }
+
+        assertTrue(isAscii);
+    }
+
+    private byte[] serialize(Object object) throws IOException {
+        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        ObjectOutputStream out = new ObjectOutputStream(bout);
+        out.writeObject(object);
+        out.flush();
+        return bout.toByteArray();
+    }
+}
diff --git a/hawtio-system/src/test/resources/data/allowedContent.zip b/hawtio-system/src/test/resources/data/allowedContent.zip
new file mode 100644
index 0000000000..5f253be7d7
Binary files /dev/null and b/hawtio-system/src/test/resources/data/allowedContent.zip differ
diff --git a/hawtio-system/src/test/resources/data/badcontent.zip b/hawtio-system/src/test/resources/data/badcontent.zip
new file mode 100644
index 0000000000..bee501ca34
Binary files /dev/null and b/hawtio-system/src/test/resources/data/badcontent.zip differ
diff --git a/hawtio-system/src/test/resources/data/default.zip b/hawtio-system/src/test/resources/data/default.zip
new file mode 100644
index 0000000000..10b5b6478b
Binary files /dev/null and b/hawtio-system/src/test/resources/data/default.zip differ
diff --git a/hawtio-system/src/test/resources/data/exception.zip b/hawtio-system/src/test/resources/data/exception.zip
new file mode 100644
index 0000000000..8b1eef4d58
Binary files /dev/null and b/hawtio-system/src/test/resources/data/exception.zip differ
diff --git a/hawtio-system/src/test/resources/data/goodcontent.zip b/hawtio-system/src/test/resources/data/goodcontent.zip
new file mode 100644
index 0000000000..840f1b5d5b
Binary files /dev/null and b/hawtio-system/src/test/resources/data/goodcontent.zip differ
diff --git a/hawtio-system/src/test/resources/data/jar-file-1.0.jar b/hawtio-system/src/test/resources/data/jar-file-1.0.jar
new file mode 100644
index 0000000000..43acd6a52a
Binary files /dev/null and b/hawtio-system/src/test/resources/data/jar-file-1.0.jar differ
diff --git a/hawtio-system/src/test/resources/data/setenv.zip b/hawtio-system/src/test/resources/data/setenv.zip
new file mode 100644
index 0000000000..ddb8a18335
Binary files /dev/null and b/hawtio-system/src/test/resources/data/setenv.zip differ
diff --git a/hawtio-system/src/test/resources/data/test.tar b/hawtio-system/src/test/resources/data/test.tar
new file mode 100644
index 0000000000..aa8624179b
Binary files /dev/null and b/hawtio-system/src/test/resources/data/test.tar differ
