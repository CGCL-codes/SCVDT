diff --git a/build.xml b/build.xml
index 9cc77423b7..f2ee5550c2 100644
--- a/build.xml
+++ b/build.xml
@@ -70,11 +70,13 @@
     <patternset id="all.tests">
         <include name="org/jgroups/tests/**Test**"/>
         <include name="org/jgroups/blocks/**Test**"/>
+        <include name="org/jgroups/protocols/**Test**"/>
     </patternset>
 
     <patternset id="junit.excludes">
         <exclude name="**/DistributedQueueTest*"/>
         <exclude name="**/ChannelTestBase*"/>
+        <exclude name="**/EncryptTest*"/>
     </patternset>
 
 
diff --git a/conf/asym-encrypt.xml b/conf/asym-encrypt.xml
new file mode 100644
index 0000000000..6792a89db5
--- /dev/null
+++ b/conf/asym-encrypt.xml
@@ -0,0 +1,28 @@
+
+<config>
+    <UDP mcast_recv_buf_size="64000" mcast_send_buf_size="32000" mcast_port="45566" ucast_recv_buf_size="64000"
+        use_incoming_packet_handler="false" mcast_addr="228.8.8.8"
+        loopback="true" ucast_send_buf_size="32000" ip_ttl="32"/>
+    <PING timeout="2000" num_initial_members="3"/>
+    <MERGE2 max_interval="10000" min_interval="5000"/>
+    <FD timeout="2000" max_tries="3" shun="true"/>
+    <VERIFY_SUSPECT timeout="1500"/>
+
+    <!-- Asymmetric encryption using public/private encryption to fetch the shared secret key -->
+    <ASYM_ENCRYPT
+            encrypt_entire_message="true"
+            sym_keylength="128"
+            sym_algorithm="AES/ECB/PKCS5Padding"
+            asym_keylength="512"
+            asym_algorithm="RSA"/>
+
+    <pbcast.NAKACK gc_lag="50" retransmit_timeout="600,1200,2400,4800"/>
+    <UNICAST timeout="1200,2400,3600"/>
+    <pbcast.STABLE stability_delay="1000" desired_avg_gossip="20000" max_bytes="0"/>
+    <FRAG2 frag_size="8192"  />
+    <!-- AUTH below is required by ASYM_ENCRYPT -->
+    <AUTH auth_class="org.jgroups.auth.MD5Token"
+          auth_value="chris"
+          token_hash="MD5"/>
+    <pbcast.GMS print_local_addr="true" join_timeout="3000" shun="true"/>
+</config>
diff --git a/conf/jg-magic-map.xml b/conf/jg-magic-map.xml
index 7460616ffe..7701639d57 100644
--- a/conf/jg-magic-map.xml
+++ b/conf/jg-magic-map.xml
@@ -42,4 +42,5 @@
     <class id="66" name="org.jgroups.blocks.PullPushAdapter$PullHeader"/>
     <class id="67" name="org.jgroups.protocols.AuthHeader"/>
     <class id="68" name="org.jgroups.protocols.MERGE3$CoordAnnouncement"/>
+    <class id="69" name="org.jgroups.protocols.EncryptHeader"/>
 </magic-number-class-mapping>
diff --git a/conf/sym-encrypt.xml b/conf/sym-encrypt.xml
new file mode 100644
index 0000000000..62b7451b13
--- /dev/null
+++ b/conf/sym-encrypt.xml
@@ -0,0 +1,29 @@
+
+<config>
+    <UDP mcast_recv_buf_size="64000" mcast_send_buf_size="32000" mcast_port="45566" ucast_recv_buf_size="64000"
+        use_incoming_packet_handler="false" mcast_addr="228.8.8.8"
+        loopback="true" ucast_send_buf_size="32000" ip_ttl="32"/>
+    <PING timeout="2000" num_initial_members="3"/>
+    <MERGE2 max_interval="10000" min_interval="5000"/>
+    <FD timeout="2000" max_tries="3" shun="true"/>
+    <VERIFY_SUSPECT timeout="1500"/>
+
+    <!-- Symmetric encryption with a keystore -->
+    <SYM_ENCRYPT
+        provider="SunJCE"
+        sym_algorithm="AES"
+        encrypt_entire_message="true"
+        keystore_name="/home/bela/JGroups/keystore/defaultStore.keystore"
+        store_password="changeit" alias="myKey"/>
+
+
+    <pbcast.NAKACK gc_lag="50" retransmit_timeout="600,1200,2400,4800"/>
+    <UNICAST timeout="1200,2400,3600"/>
+    <pbcast.STABLE stability_delay="1000" desired_avg_gossip="20000" max_bytes="0"/>
+    <FRAG2 frag_size="8192"  />
+    <!-- AUTH below is optional -->
+    <AUTH auth_class="org.jgroups.auth.MD5Token"
+          auth_value="chris"
+          token_hash="MD5"/>
+    <pbcast.GMS print_local_addr="true" join_timeout="3000" shun="true"/>
+</config>
diff --git a/doc/design/MaliciousAttacks.txt b/doc/design/MaliciousAttacks.txt
new file mode 100644
index 0000000000..c2528fb732
--- /dev/null
+++ b/doc/design/MaliciousAttacks.txt
@@ -0,0 +1,91 @@
+
+Use of encryption and authentication protocols to fend off malicious attacks
+============================================================================
+Author: Bela Ban, April 2016
+JIRA:   https://issues.jboss.org/browse/JGRP-2021
+
+The following discussion refers to the changes made in JGroups 4.0. These have been backported to the 2.6 branch, but
+the syntax looks different. However, the concepts are the same.
+
+
+
+Types of attacks handled
+------------------------
+Malicious attacks essentially include (1) non-authorized nodes being able to join a cluster and (2) non-members being
+able to communicate with cluster members.
+
+(1) is handled by AUTH which allows only authenticated nodes to join a cluster.
+
+(2) is handled by the encryption protocol (SYM_ENCRYPT or ASYM_ENCRYPT) which encrypts messages between cluster
+members such that a non-member cannot understand them.
+
+
+
+Authentication
+--------------
+Authentication is performed by AUTH. Its main use is to make sure only authenticated members can join a cluster.
+Other scenarios where a check is performed are:
+* Merging: make sure only authenticated members can merge into a new cluster
+* View installation (if enabled): views and merge views can only be installed by authenticated members
+
+So authentication makes sure that rogue nodes will never be able to be members of a cluster, be it via joining or
+merging. Note that while AUTH is optional with SYM_ENCRYPT, it is required by ASYM_ENCRYPT: there's a sanity check that
+will prevent a member to start if ASYM_ENCRYPT is present but AUTH is absent.
+
+
+
+Authorization
+-------------
+There is currently no authorization in JGroups. Once a member is admitted to the cluster (via authentication),
+it can send and receive messages to anyone.
+
+
+
+Encryption
+----------
+This is based on a shared secret key that all members of a cluster have. The key is either acquired from a shared
+keystore (symmetric encryption, below) or a new joiner fetches it from the coordinator via public/private key exchange
+(asymmetric encryption, below).
+
+A sent message is encrypted with the shared secret key by the sender and decrypted with the same secret key by the
+receiver(s).
+
+By default, the entire message (including the headers) is encrypted, but it is also possible to only encrypt the payload
+(this is configurable). If the headers are not encrypted, it is possible to use replay attacks, because the
+sequence numbers (seqnos) of a message are seen. For example, if a seqno is 50, then an attacker might copy the message,
+and increment the seqno. This is prevented by copying and _signing_ the message.
+
+A message can be signed, which is a hash over the encrypted message, encrypted with the secret key. If the hash shipped
+with a message doesn't match the hash computed over the received message, the message will be discarded by a receiver,
+and no attempt is made to decrypt it.
+
+The cost of encrypting the entire message includes serializing the entire message (including headers, flags, destination
+address etc) and encrypting it into the buffer of a new message (to the same destination). If message signing is enabled,
+the cost of computing a hashcode and encrypting it is added to the above cost.
+
+Attributes present in both symmetric and asymmetric encryption include sign_msgs and encrypt_entire_message.
+
+
+Symmetric encryption
+--------------------
+This is done by SYM_ENCRYPT. The configuration includes mainly attributes that define the keystore, e.g. keystore_name
+(name of the keystore, needs to be found on the classpath), store_password, key_password and alias.
+
+
+Asymmetric encryption
+---------------------
+Contrary to SYM_ENCRYPT, the secret key is not fetched from a shared keystore, but from the current coordinator C. After
+new member P joined the cluster (passing the join check done by AUTH), P sends a request to get the secret key
+(including P's public key) to C.
+
+C then sends the secret key back to P, encrypted with P's public key, and P decrypts it with its private key
+and installs it. From then on, P encrypts and decrypts messages using the secret key.
+
+When a member leaves, C can optionally (based on change_key_on_leave) create a new secret key, and every cluster member
+needs to fetch it again, using the public/private key exchange described above.
+
+
+
+
+
+
diff --git a/src/org/jgroups/Message.java b/src/org/jgroups/Message.java
index 94d1287437..7223331920 100644
--- a/src/org/jgroups/Message.java
+++ b/src/org/jgroups/Message.java
@@ -58,6 +58,7 @@
     public static final byte OOB       = 1;
     public static final byte LOW_PRIO  = 2; // not yet sure if we want this flag...
     public static final byte HIGH_PRIO = 4; // not yet sure if we want this flag...
+    public static final byte NO_RELIABILITY = 8;
 
     private byte flags=0;
 
@@ -357,6 +358,23 @@ public Message copy() {
      * @return Message with specified data
      */
     public Message copy(boolean copy_buffer) {
+        return copy(copy_buffer, true);
+    }
+
+   /**
+    * Create a copy of the message. If offset and length are used (to refer to another buffer), the
+    * copy will contain only the subset offset and length point to, copying the subset into the new
+    * copy.<p/>
+    * Note that for headers, only the arrays holding references to the headers are copied, not the headers themselves !
+    * The consequence is that the headers array of the copy hold the *same* references as the original, so do *not*
+    * modify the headers ! If you want to change a header, copy it and call {@link Message#putHeader(short,Header)} again.
+    * 
+    * @param copy_buffer
+    * @param copy_headers
+    *           Copy the headers
+    * @return Message with specified data
+    */
+    public Message copy(boolean copy_buffer, boolean copy_headers) {
         Message retval=new Message(false);
         retval.dest_addr=dest_addr;
         retval.src_addr=src_addr;
@@ -368,11 +386,10 @@ public Message copy(boolean copy_buffer) {
             retval.setBuffer(buf, offset, length);
         }
 
-        retval.headers=createHeaders(headers);
+        retval.headers=copy_headers? createHeaders(headers) : createHeaders(3);
         return retval;
     }
 
-
     protected Object clone() throws CloneNotSupportedException {
         return copy();
     }
@@ -675,6 +692,13 @@ private String flagsToString() {
                 first=false;
             sb.append("HIGH_PRIO");
         }
+        if(isFlagSet(NO_RELIABILITY)) {
+            if(!first)
+                sb.append("|");
+            else
+                first=false;
+            sb.append("NO_RELIABILITY");
+        }
         return sb.toString();
     }
 
diff --git a/src/org/jgroups/View.java b/src/org/jgroups/View.java
index 196e76bd79..3eb6d4bb01 100644
--- a/src/org/jgroups/View.java
+++ b/src/org/jgroups/View.java
@@ -6,6 +6,7 @@
 import org.jgroups.util.Util;
 
 import java.io.*;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Vector;
@@ -72,7 +73,6 @@ public View(Address creator, long id, Vector<Address> members) {
         this(new ViewId(creator, id), members);
     }
 
-
     /**
      * returns the view ID of this view
      * if this view was created with the empty constructur, null will be returned
@@ -93,6 +93,8 @@ public Address getCreator() {
         return vid != null ? vid.getCoordAddress() : null;
     }
 
+    public Address getCoord() {return !members.isEmpty()? members.get(0) : null;}
+
     /**
      * Returns a reference to the List of members (ordered)
      * Do NOT change this list, hence your will invalidate the view
@@ -104,6 +106,13 @@ public Address getCreator() {
         return Util.unmodifiableVector(members);
     }
 
+    /** Returns the underlying list. The caller <em>must not</em> modify the contents. Should not be used by
+     *  application code ! This method may be removed at any time, so don't use it !
+     */
+    public Vector<Address> getMembersRaw() {
+           return members;
+    }
+
     /**
      * returns true, if this view contains a certain member
      *
@@ -115,6 +124,16 @@ public boolean containsMember(Address mbr) {
         return !(mbr == null || members == null) && members.contains(mbr);
     }
 
+    public boolean containsMembers(Collection<Address> mbrs) {
+        if(mbrs == null || members == null)
+            return false;
+        for(Address mbr: mbrs) {
+            if(!containsMember(mbr))
+                return false;
+        }
+        return true;
+    }
+
 
     public boolean equals(Object obj) {
         if(!(obj instanceof View))
diff --git a/src/org/jgroups/auth/AuthToken.java b/src/org/jgroups/auth/AuthToken.java
index 6199be99b9..b9dc4bbb2f 100644
--- a/src/org/jgroups/auth/AuthToken.java
+++ b/src/org/jgroups/auth/AuthToken.java
@@ -20,6 +20,11 @@
 
     public void setAuth(AUTH auth) {this.auth=auth;}
 
+    public void init() throws Exception {}
+    public void start() throws Exception {}
+    public void stop() {}
+    public void destroy() {}
+
     /**
      * Used to return the full package and class name of the implementation.  This is used by the AUTH protocol to create an instance of the implementation.
      * @return a java.lang.String object of the package and class name
diff --git a/src/org/jgroups/demos/KeyStoreGenerator.java b/src/org/jgroups/demos/KeyStoreGenerator.java
index 53eda30632..f299982fcd 100644
--- a/src/org/jgroups/demos/KeyStoreGenerator.java
+++ b/src/org/jgroups/demos/KeyStoreGenerator.java
@@ -5,6 +5,7 @@
 import java.io.FileOutputStream;
 import java.io.OutputStream;
 import java.security.KeyStore;
+import java.security.NoSuchAlgorithmException;
 
 import javax.crypto.KeyGenerator;
 import javax.crypto.SecretKey;
@@ -121,6 +122,17 @@ public static SecretKey initSymKey() throws Exception
 		return secretKey;
 		
 	}
+
+    public static SecretKey createSecretKey() throws Exception {
+        return createSecretKey(symAlg, keySize);
+    }
+
+    public static SecretKey createSecretKey(String sym_alg, int key_size) throws NoSuchAlgorithmException {
+        // KeyGenerator keyGen=KeyGenerator.getInstance(getAlgorithm(sym_alg));
+        KeyGenerator keyGen=KeyGenerator.getInstance(sym_alg);
+        keyGen.init(key_size);
+        return keyGen.generateKey();
+    }
 	
 	private static String getAlgorithm(String s)
 	{
diff --git a/src/org/jgroups/protocols/ASYM_ENCRYPT.java b/src/org/jgroups/protocols/ASYM_ENCRYPT.java
new file mode 100644
index 0000000000..b6d6dfb1a3
--- /dev/null
+++ b/src/org/jgroups/protocols/ASYM_ENCRYPT.java
@@ -0,0 +1,417 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.util.AsciiString;
+import org.jgroups.util.Util;
+
+import javax.crypto.Cipher;
+import javax.crypto.KeyGenerator;
+import javax.crypto.SecretKey;
+import javax.crypto.spec.SecretKeySpec;
+import java.security.*;
+import java.security.spec.X509EncodedKeySpec;
+import java.util.Arrays;
+import java.util.Properties;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+
+/**
+ * Encrypts and decrypts communication in JGroups by using a secret key distributed to all cluster members by the
+ * key server (coordinator) using asymmetric (public/private key) encryption.<br>
+ *
+ * The secret key is identical for all cluster members and is used to encrypt messages when sending and decrypt them
+ * when receiving messages.
+ *
+ * This protocol is typically placed under {@link org.jgroups.protocols.pbcast.NAKACK}, so that most important
+ * headers are encrypted as well, to prevent replay attacks.<br>
+ *
+ * The current keyserver (always the coordinator) generates a secret key. When a new member joins, it asks the keyserver
+ * for the secret key. The keyserver encrypts the secret key with the joiner's public key and the joiner decrypts it with
+ * its private key and then installs it and starts encrypting and decrypting messages with the secret key.<br>
+ *
+ * View changes that identify a new keyserver will result in a new secret key being generated and then distributed to
+ * all cluster members. This overhead can be substantial in an application with a reasonable member churn.<br>
+ *
+ * This protocol is suited to an application that does not ship with a known key but instead it is generated and
+ * distributed by the keyserver.
+ *
+ * Since messages can only get encrypted and decrypted when the secret key was received from the keyserver, messages
+ * other then join and merge requests/responses are dropped when the secret key isn't yet available. Join and merge
+ * requests / responses are handled by {@link AUTH}.
+ *
+ * @author Bela Ban
+ * @author Steve Woodcock
+ */
+public class ASYM_ENCRYPT extends EncryptBase {
+
+    // When a member leaves the view, change the secret key, preventing old members from eavesdropping"
+    protected boolean                              change_key_on_leave=true;
+    protected volatile Address                     key_server_addr;
+    // True if this member is the current key server, false otherwise
+    protected volatile boolean                     is_key_server;
+    protected KeyPair                              key_pair; // to store own's public/private Key
+    protected Cipher                               asym_cipher;  // decrypting cypher for secret key requests
+    // queue all up msgs until the secret key has been received/created
+    // whether or not to queue received messages (until the secret key was received)
+    protected volatile boolean                     queue_up_msgs=true;
+    // queues a bounded number of messages received during a null secret key (or fetching the key from a new coord)
+    protected final BlockingQueue<Message>         up_queue=new ArrayBlockingQueue<Message>(100);
+
+    protected volatile long                        last_key_request;
+
+    public KeyPair getKeyPair()                         {return key_pair;}
+    public Cipher  getAsymCipher()                      {return asym_cipher;}
+    public Address getKeyServerAddr()                   {return key_server_addr;}
+    public void    setKeyServerAddr(Address key_srv)    {this.key_server_addr=key_srv;}
+
+    // Number of received messages currently queued
+    public int numQueuedMessages() {return up_queue.size();}
+
+    public String getName()
+    {
+        return "ASYM_ENCRYPT";
+    }
+
+    public boolean setProperties(Properties props)
+    {
+        String str;
+
+        super.setProperties(props);
+
+        str=props.getProperty("change_key_on_leave");
+        if(str != null)
+        {
+            change_key_on_leave=Boolean.valueOf(str).booleanValue();
+            props.remove("change_key_on_leave");
+        }
+
+        if (!props.isEmpty())
+        {
+
+            if (log.isErrorEnabled())
+                log.error("these properties are not recognized:" + props);
+            return false;
+        }
+
+        return true;
+    }
+
+    // Triggers a request for the secret key to the current keyserver
+    public void sendKeyRequest() {
+        if(key_server_addr == null) {
+            log.error(String.format("%s: key server is currently not set", local_addr));
+            return;
+        }
+        sendKeyRequest(key_server_addr);
+    }
+
+    public void init() throws Exception {
+        initKeyPair();
+        super.init();
+    }
+
+    public void stop() {
+        drainUpQueue();
+        super.stop();
+    }
+
+    public Object down(Event evt) {
+        if(evt.getType() == Event.MSG) {
+            Message msg=(Message)evt.getArg();
+            if(skip(msg))
+                return down_prot.down(evt);
+        }
+        return super.down(evt);
+    }
+
+    public Object up(Event evt) {
+        if(evt.getType() == Event.MSG) {
+            Message msg=(Message)evt.getArg();
+            if(skip(msg))
+                return up_prot.up(evt);
+        }
+        return super.up(evt);
+    }
+
+
+
+    /** Checks if a message needs to be encrypted/decrypted. Join and merge requests/responses don't need to be
+     * encrypted as they're authenticated by {@link AUTH} */
+    protected static boolean skip(Message msg) {
+        GMS.GmsHeader hdr=(GMS.GmsHeader)msg.getHeader(GMS.name);
+        if(hdr == null) return false;
+        switch(hdr.getType()) {
+            case GMS.GmsHeader.JOIN_REQ:
+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
+            case GMS.GmsHeader.JOIN_RSP:
+            case GMS.GmsHeader.MERGE_REQ:
+            case GMS.GmsHeader.MERGE_RSP:
+            case GMS.GmsHeader.VIEW_ACK:
+            case GMS.GmsHeader.INSTALL_MERGE_VIEW:
+                return true;
+        }
+        return false;
+    }
+
+
+    @Override protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+        switch(hdr.getType()) {
+            case EncryptHeader.SECRET_KEY_REQ:
+                handleSecretKeyRequest(msg);
+                break;
+            case EncryptHeader.SECRET_KEY_RSP:
+                handleSecretKeyResponse(msg, hdr.getVersion());
+                break;
+            default:
+                log.warn(String.format("%s: received unknown encrypt header of type %d", local_addr, hdr.getType()));
+                break;
+        }
+        return null;
+    }
+
+    @Override protected boolean process(Message msg) {
+        if(queue_up_msgs || secret_key == null) {
+            up_queue.offer(msg);
+            log.trace(String.format("%s: queuing %s message from %s as secret key hasn't been retrieved from keyserver %s yet, hdrs: %s",
+                      local_addr, msg.getDest() == null? "mcast" : "unicast", msg.getSrc(), key_server_addr, msg.printHeaders()));
+            if(last_key_request == 0 || System.currentTimeMillis() - last_key_request > 2000) {
+                last_key_request=System.currentTimeMillis();
+                sendKeyRequest();
+            }
+            return false;
+        }
+        return true;
+    }
+
+    protected void handleSecretKeyRequest(final Message msg) {
+        if(!inView(msg.getSrc(), "%s: key requester %s is not in current view %s; ignoring key request"))
+            return;
+        log.debug(String.format("%s: received key request from %s", local_addr, msg.getSrc()));
+        try {
+            PublicKey tmpKey=generatePubKey(msg.getBuffer());
+            sendSecretKey(secret_key, tmpKey, msg.getSrc());
+        }
+        catch(Exception e) {
+            log.warn(String.format("%s: unable to reconstitute peer's public key", local_addr));
+        }
+    }
+
+
+    protected void handleSecretKeyResponse(final Message msg, final byte[] key_version) {
+        if(!inView(msg.getSrc(), "%s: ignoring secret key sent by %s which is not in current view %s"))
+            return;
+        try {
+            SecretKey tmp=decodeKey(msg.getBuffer());
+            if(tmp == null)
+                sendKeyRequest(key_server_addr); // unable to understand response, let's try again
+            else {
+                // otherwise set the returned key as the shared key
+                log.debug(String.format("%s: received secret key from keyserver %s", local_addr, msg.getSrc()));
+                setKeys(tmp, key_version);
+            }
+        }
+        catch(Exception e) {
+            log.warn(local_addr + ": unable to process received public key", e);
+        }
+    }
+
+
+    /** Initialise the symmetric key if none is supplied in a keystore */
+    protected SecretKey createSecretKey() throws Exception {
+        KeyGenerator keyGen=null;
+        // see if we have a provider specified
+        if(provider != null && !provider.trim().isEmpty())
+            keyGen=KeyGenerator.getInstance(getAlgorithm(sym_algorithm), provider);
+        else
+            keyGen=KeyGenerator.getInstance(getAlgorithm(sym_algorithm));
+        // generate the key using the defined init properties
+        keyGen.init(sym_keylength);
+        return keyGen.generateKey();
+    }
+
+
+
+    /** Generates the public/private key pair from the init params */
+    protected void initKeyPair() throws Exception {
+        // generate keys according to the specified algorithms
+        // generate publicKey and Private Key
+        KeyPairGenerator KpairGen=null;
+        if(provider != null && !provider.trim().isEmpty())
+            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asym_algorithm), provider);
+        else
+            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asym_algorithm));
+        KpairGen.initialize(asym_keylength,new SecureRandom());
+        key_pair=KpairGen.generateKeyPair();
+
+        // set up the Cipher to decrypt secret key responses encrypted with our key
+        if(provider != null && !provider.trim().isEmpty())
+            asym_cipher=Cipher.getInstance(asym_algorithm, provider);
+        else
+            asym_cipher=Cipher.getInstance(asym_algorithm);
+        asym_cipher.init(Cipher.DECRYPT_MODE, key_pair.getPrivate());
+    }
+
+
+    @Override protected synchronized void handleView(View v) {
+        boolean left_mbrs=change_key_on_leave && this.view != null && !v.containsMembers(this.view.getMembersRaw());
+        super.handleView(v);
+
+        Address tmpKeyServer=v.getCoord(); // the coordinator is the keyserver
+        if(tmpKeyServer.equals(local_addr)) {
+            if(!is_key_server || left_mbrs)
+                becomeKeyServer(tmpKeyServer, left_mbrs);
+        }
+        else
+            handleNewKeyServer(tmpKeyServer, v instanceof MergeView, left_mbrs);
+    }
+
+
+    protected void becomeKeyServer(Address tmpKeyServer, boolean left_mbrs) {
+        if(log.isDebugEnabled()) {
+            if(!is_key_server)
+                log.debug(String.format("%s: I'm the new key server", local_addr));
+            else if(left_mbrs)
+                log.debug(String.format("%s: creating new secret key because members left", local_addr));
+        }
+        key_server_addr=tmpKeyServer;
+        is_key_server=true;
+        try {
+            this.secret_key=createSecretKey();
+            initSymCiphers(sym_algorithm, secret_key);
+            drainUpQueue();
+        }
+        catch(Exception ex) {
+            log.error(local_addr + ": failed creating secret key and initializing ciphers", ex);
+        }
+    }
+
+    /** If the keyserver changed, send a request for the secret key to the keyserver */
+    protected void handleNewKeyServer(Address newKeyServer, boolean merge_view, boolean left_mbrs) {
+        if(keyServerChanged(newKeyServer) || merge_view || left_mbrs) {
+            secret_key=null;
+            sym_version=null;
+            queue_up_msgs=true;
+            key_server_addr=newKeyServer;
+            is_key_server=false;
+            log.debug(String.format("%s: sending request for secret key to the new keyserver %s", local_addr, key_server_addr));
+            sendKeyRequest(key_server_addr);
+        }
+    }
+
+    protected boolean keyServerChanged(Address newKeyServer) {
+        return !equals(key_server_addr, newKeyServer);
+    }
+
+
+
+    protected void setKeys(SecretKey key, byte[] version) throws Exception {
+        if(Arrays.equals(this.sym_version, version))
+            return;
+        Cipher decoding_cipher=secret_key != null? decoding_ciphers.take() : null;
+        // put the previous key into the map, keep the cipher: no leak, as we'll clear decoding_ciphers in initSymCiphers()
+        if(decoding_cipher != null)
+            key_map.put(new AsciiString(version), decoding_cipher);
+        secret_key=key;
+        initSymCiphers(key.getAlgorithm(), key);
+        sym_version=version;
+        drainUpQueue();
+    }
+
+
+    protected void sendSecretKey(SecretKey secret_key, PublicKey public_key, Address source) throws Exception {
+        byte[] encryptedKey=encryptSecretKey(secret_key, public_key);
+        Message newMsg=new Message(source, local_addr, encryptedKey);
+        newMsg.putHeader(getName(), new EncryptHeader(EncryptHeader.SECRET_KEY_RSP, getSymVersion()));
+        log.debug(String.format("%s: sending secret key to %s", local_addr, source));
+        down_prot.down(new Event(Event.MSG,newMsg));
+    }
+
+    /** Encrypts the current secret key with the requester's public key (the requester will decrypt it with its private key) */
+    protected byte[] encryptSecretKey(SecretKey secret_key, PublicKey public_key) throws Exception {
+        Cipher tmp;
+        if (provider != null && !provider.trim().isEmpty())
+            tmp=Cipher.getInstance(asym_algorithm, provider);
+        else
+            tmp=Cipher.getInstance(asym_algorithm);
+        tmp.init(Cipher.ENCRYPT_MODE, public_key);
+
+        // encrypt current secret key
+        return tmp.doFinal(secret_key.getEncoded());
+    }
+
+
+    /** send client's public key to server and request server's public key */
+    protected void sendKeyRequest(Address key_server) {
+        Message newMsg=new Message(key_server, local_addr, key_pair.getPublic().getEncoded());
+        newMsg.putHeader(getName(),new EncryptHeader(EncryptHeader.SECRET_KEY_REQ, sym_version));
+        down_prot.down(new Event(Event.MSG,newMsg));
+    }
+
+
+    protected SecretKeySpec decodeKey(byte[] encodedKey) throws Exception {
+        byte[] keyBytes;
+
+        synchronized(this) {
+            keyBytes=asym_cipher.doFinal(encodedKey);
+        }
+
+        try {
+            SecretKeySpec keySpec=new SecretKeySpec(keyBytes, getAlgorithm(sym_algorithm));
+            Cipher temp;
+            if (provider != null && !provider.trim().isEmpty())
+                temp=Cipher.getInstance(sym_algorithm, provider);
+            else
+                temp=Cipher.getInstance(sym_algorithm);
+            temp.init(Cipher.SECRET_KEY, keySpec);
+            return keySpec;
+        }
+        catch(Exception e) {
+            log.error("Failed to decode key", e);
+            return null;
+        }
+    }
+
+    // doesn't have to be 100% correct: leftover messages wll be delivered later and will be discarded as dupes, as
+    // retransmission is likely to have kicked in before anyway
+    protected void drainUpQueue() {
+        queue_up_msgs=false;
+        Message queued_msg;
+        while((queued_msg=up_queue.poll()) != null) {
+            try {
+                Message decrypted_msg=decryptMessage(null, queued_msg.copy());
+                if(decrypted_msg != null)
+                    up_prot.up(new Event(Event.MSG, decrypted_msg));
+            }
+            catch(Exception ex) {
+                log.error(String.format("failed decrypting message from %s: %s", queued_msg.getSrc(), ex));
+            }
+        }
+    }
+
+
+    @Override protected void handleUnknownVersion() {
+        if(!is_key_server)
+            sendKeyRequest(key_server_addr);
+    }
+
+    /** Used to reconstitute public key sent in byte form from peer */
+    protected PublicKey generatePubKey(byte[] encodedKey) {
+        PublicKey pubKey=null;
+        try {
+            KeyFactory KeyFac=KeyFactory.getInstance(getAlgorithm(asym_algorithm));
+            X509EncodedKeySpec x509KeySpec=new X509EncodedKeySpec(encodedKey);
+            pubKey=KeyFac.generatePublic(x509KeySpec);
+        }
+        catch(Exception e) {
+            e.printStackTrace();
+        }
+        return pubKey;
+    }
+
+    protected static boolean equals(Object a, Object b) {
+        return (a == b) || (a != null && a.equals(b));
+    }
+
+}
diff --git a/src/org/jgroups/protocols/AUTH.java b/src/org/jgroups/protocols/AUTH.java
index 220ca7d0fc..924e3c83e0 100644
--- a/src/org/jgroups/protocols/AUTH.java
+++ b/src/org/jgroups/protocols/AUTH.java
@@ -1,53 +1,95 @@
 package org.jgroups.protocols;
 
 
-import org.jgroups.Address;
-import org.jgroups.Event;
-import org.jgroups.Message;
+import org.jgroups.*;
 import org.jgroups.auth.AuthToken;
+import org.jgroups.conf.ClassConfigurator;
 import org.jgroups.protocols.pbcast.GMS;
 import org.jgroups.protocols.pbcast.JoinRsp;
 import org.jgroups.stack.Protocol;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.Properties;
 
 
 /**
- * The AUTH protocol adds a layer of authentication to JGroups
+ * The AUTH protocol adds a layer of authentication to JGroups. It intercepts join and merge requests and rejects them
+ * if the joiner or merger is not permitted to join a or merge into a cluster. AUTH should be placed right below
+ * {@link GMS} in the configuration.
  * @author Chris Mills
+ * @author Bela Ban
  */
-public class AUTH extends Protocol{
+public class AUTH extends Protocol {
 
     static final String NAME = "AUTH";
 
-    /**
-     * used on the coordinator to authentication joining member requests against
-     */
-    private AuthToken serverSideToken = null;
+    /** Interface to provide callbacks for handling up events */
+    public interface UpHandler {
+        /**
+         * Called when an up event has been received
+         * @param evt the event
+         * @return true if the event should be passed up, else false
+         */
+        boolean handleUpEvent(Event evt);
+    }
+
+
+    /** Used on the coordinator to authentication joining member requests against */
+    protected AuthToken             auth_token;
+
+    /** List of UpHandler which are called when an up event has been received. Usually used by AuthToken impls */
+    protected final List<UpHandler> up_handlers=new ArrayList<UpHandler>();
+
+    protected Address               local_addr;
+
 
-    public AUTH(){
+    public AUTH() {}
+
+    protected volatile boolean      authenticate_coord=true;
+    
+    // Do join or merge responses from the coordinator also need to be authenticated
+    public void setAuthCoord( boolean authenticateCoord) {
+        this.authenticate_coord= authenticateCoord;
     }
 
-    public boolean setProperties(Properties props) {
+    public String    getAuthClass()                {return auth_token != null? auth_token.getClass().getName() : null;}
+    public AuthToken getAuthToken()                {return auth_token;}
+    public void      setAuthToken(AuthToken token) {this.auth_token=token;}
+    public void      register(UpHandler handler)   {up_handlers.add(handler);}
+    public void      unregister(UpHandler handler) {up_handlers.remove(handler);}
+    public Address   getAddress()                  {return local_addr;}
 
-        String authClassString = props.getProperty("auth_class");
 
-        if(authClassString != null){
+    public boolean setProperties(Properties props) {
+        String str;
+
+        str = props.getProperty("auth_class");
+        if(str != null){
             props.remove("auth_class");
 
             try{
-                Object obj = Class.forName(authClassString).newInstance();
-                serverSideToken = (AuthToken) obj;
-                serverSideToken.setAuth(this);
-                serverSideToken.setValue(props);
+                Object obj = Class.forName(str).newInstance();
+                auth_token = (AuthToken) obj;
+                auth_token.setAuth(this);
+                auth_token.setValue(props);
             }catch(Exception e){
                 if(log.isFatalEnabled()){
-                    log.fatal("Failed to create server side token (" + authClassString + ")");
+                    log.fatal("Failed to create server side token (" + str + ")");
                     log.fatal(e);
                 }
                 return false;
             }
         }
 
+        str=props.getProperty("authenticate_coord");
+        if(str != null)
+        {
+            authenticate_coord=Boolean.valueOf(str).booleanValue();
+            props.remove("authenticate_coord");
+        }
+
         if(!props.isEmpty()) {
             //this should never happen as everything is read in to the AuthToken instance
             if(log.isErrorEnabled()){
@@ -61,146 +103,182 @@ public boolean setProperties(Properties props) {
     public final String getName() {
         return AUTH.NAME;
     }
-    /**
-     * Used to create a failed JOIN_RSP message to pass back down the stack
-     * @param joiner The Address of the requesting member
-     * @param message The failure message to send back to the joiner
-     * @return An Event containing a GmsHeader with a JoinRsp object
-     */
-    private Event createFailureEvent(Address joiner, String message){
-        Message msg = new Message(joiner, null, null);
 
-        if(log.isDebugEnabled()){
-            log.debug("Creating JoinRsp with failure message - " + message);
-        }
-        JoinRsp joinRes = new JoinRsp(message);
-        //need to specify the error message on the JoinRsp object once it's been changed
+    public void init() throws Exception {
+        super.init();
+        if(auth_token == null)
+            throw new IllegalStateException("no authentication mechanism configured");
+        auth_token.init();
+    }
 
-        GMS.GmsHeader gmsHeader = new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP, joinRes);
-        msg.putHeader(GMS.name, gmsHeader);
+    public void start() throws Exception {
+        super.start();
+        if(auth_token != null)
+            auth_token.start();
+    }
 
-        if(log.isDebugEnabled()){
-            log.debug("GMSHeader created for failure JOIN_RSP");
-        }
+    public void stop() {
+        if(auth_token != null)
+            auth_token.stop();
+        super.stop();
+    }
 
-        return new Event(Event.MSG, msg);
+    public void destroy() {
+        if(auth_token != null)
+            auth_token.destroy();
+        super.destroy();
     }
 
     /**
-     * An event was received from the layer below. Usually the current layer will want to examine
-     * the event type and - depending on its type - perform some computation
-     * (e.g. removing headers from a MSG event type, or updating the internal membership list
-     * when receiving a VIEW_CHANGE event).
-     * Finally the event is either a) discarded, or b) an event is sent down
-     * the stack using <code>down_prot.down()</code> or c) the event (or another event) is sent up
-     * the stack using <code>up_prot.up()</code>.
+     * An event was received from the layer below. Usually the current layer will want to examine the event type and
+     * - depending on its type - perform some computation (e.g. removing headers from a MSG event type, or updating
+     * the internal membership list when receiving a VIEW_CHANGE event).
+     * Finally the event is either a) discarded, or b) an event is sent down the stack using {@code down_prot.down()}
+     * or c) the event (or another event) is sent up the stack using {@code up_prot.up()}.
      */
     public Object up(Event evt) {
-        GMS.GmsHeader hdr = isJoinMessage(evt);
-        if((hdr != null) && (hdr.getType() == GMS.GmsHeader.JOIN_REQ || hdr.getType() == GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER)){
-            if(log.isDebugEnabled()){
-                log.debug("AUTH got up event");
-            }
-            //we found a join message - now try and get the AUTH Header
-            Message msg = (Message)evt.getArg();
-
-            if((msg.getHeader(AUTH.NAME) != null) && (msg.getHeader(AUTH.NAME) instanceof AuthHeader)){
-                AuthHeader authHeader = (AuthHeader)msg.getHeader(AUTH.NAME);
-
-                if(authHeader != null){
-                    //Now we have the AUTH Header we need to validate it
-                    if(this.serverSideToken.authenticate(authHeader.getToken(), msg)){
-                        //valid token
-                        if(log.isDebugEnabled()){
-                            log.debug("AUTH passing up event");
-                        }
-                        up_prot.up(evt);
-                    }else{
-                        //invalid token
-                        if(log.isWarnEnabled()){
-                            log.warn("AUTH failed to validate AuthHeader token");
-                        }
-                        sendRejectionMessage(msg.getSrc(), createFailureEvent(msg.getSrc(), "Authentication failed"));
-                    }
-                }else{
-                    //Invalid AUTH Header - need to send failure message
-                    if(log.isWarnEnabled()){
-                        log.warn("AUTH failed to get valid AuthHeader from Message");
-                    }
-                    sendRejectionMessage(msg.getSrc(), createFailureEvent(msg.getSrc(), "Failed to find valid AuthHeader in Message"));
-                }
-            }else{
-                if(log.isDebugEnabled()){
-                    log.debug("No AUTH Header Found");
+        switch(evt.getType()) {
+            case Event.MSG:
+                Message msg=(Message)evt.getArg();
+
+                // If we have a join or merge request --> authenticate, else pass up
+                GMS.GmsHeader gms_hdr=getGMSHeader(evt);
+                if(gms_hdr != null && needsAuthentication(gms_hdr)) {
+                    AuthHeader auth_hdr=(AuthHeader)msg.getHeader(AUTH.NAME);
+                    if(auth_hdr == null)
+                        throw new IllegalStateException(String.format("found %s from %s but no AUTH header", gms_hdr, msg.getSrc()));
+                    if(!handleAuthHeader(gms_hdr, auth_hdr, msg)) // authentication failed
+                        return null;    // don't pass up
                 }
-                //should be a failure
-                sendRejectionMessage(msg.getSrc(), createFailureEvent(msg.getSrc(), "Failed to find an AuthHeader in Message"));
-            }
-        } else {
-            return up_prot.up(evt);
+                break;
         }
-        return null;
+        if(!callUpHandlers(evt))
+            return null;
+
+        return up_prot.up(evt);
     }
 
 
-    private void sendRejectionMessage(Address dest, Event join_rsp) {
-        if(dest == null) {
-            log.error("destination is null, cannot send JOIN rejection message to null destination");
-            return;
-        }
-        down_prot.down(join_rsp);
-    }
 
     /**
      * An event is to be sent down the stack. The layer may want to examine its type and perform
      * some action on it, depending on the event's type. If the event is a message MSG, then
      * the layer may need to add a header to it (or do nothing at all) before sending it down
-     * the stack using <code>down_prot.down()</code>. In case of a GET_ADDRESS event (which tries to
+     * the stack using {@code down_prot.down()}. In case of a GET_ADDRESS event (which tries to
      * retrieve the stack's address from one of the bottom layers), the layer may need to send
-     * a new response event back up the stack using <code>up_prot.up()</code>.
+     * a new response event back up the stack using {@code up_prot.up()}.
      */
     public Object down(Event evt) {
-        GMS.GmsHeader hdr = isJoinMessage(evt);
-        if((hdr != null) && (hdr.getType() == GMS.GmsHeader.JOIN_REQ || hdr.getType() == GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER)){
-            if(log.isDebugEnabled()){
-                log.debug("AUTH got down event");
-            }
-            //we found a join request message - now add an AUTH Header
-            Message msg = (Message)evt.getArg();
-            AuthHeader authHeader = new AuthHeader();
-            authHeader.setToken(this.serverSideToken);
-            msg.putHeader(AUTH.NAME, authHeader);
-
-            if(log.isDebugEnabled()){
-                log.debug("AUTH passing down event");
-            }
+        GMS.GmsHeader hdr = getGMSHeader(evt);
+        if(hdr != null && needsAuthentication(hdr)) {
+            // we found a join request message - now add an AUTH Header
+            Message msg=(Message)evt.getArg();
+            msg.putHeader(AUTH.NAME, new AuthHeader(this.auth_token));
         }
 
-        if((hdr != null) && (hdr.getType() == GMS.GmsHeader.JOIN_RSP)){
-            if(log.isDebugEnabled()){
-                log.debug(hdr.toString());
+        if(evt.getType() == Event.SET_LOCAL_ADDRESS)
+            local_addr=(Address)evt.getArg();
+
+        return down_prot.down(evt);
+    }
+
+
+
+    protected boolean needsAuthentication(GMS.GmsHeader hdr) {
+        switch(hdr.getType()) {
+            case GMS.GmsHeader.JOIN_REQ:
+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
+            case GMS.GmsHeader.MERGE_REQ:
+                return true;
+            case GMS.GmsHeader.JOIN_RSP:
+            case GMS.GmsHeader.MERGE_RSP:
+            case GMS.GmsHeader.INSTALL_MERGE_VIEW:
+                return this.authenticate_coord;
+            default:
+                return false;
+        }
+    }
+
+
+    /**
+     * Handles a GMS header
+     * @param gms_hdr
+     * @param msg
+     * @return true if the message should be passed up, or else false
+     */
+    protected boolean handleAuthHeader(GMS.GmsHeader gms_hdr, AuthHeader auth_hdr, Message msg) {
+        if(needsAuthentication(gms_hdr)) {
+            if(this.auth_token.authenticate(auth_hdr.getToken(), msg))
+                return true; //  authentication passed, send message up the stack
+            else {
+                log.warn(String.format("%s: failed to validate AuthHeader (token: %s) from %s; dropping message",
+                         local_addr, auth_token.getClass().getSimpleName(), msg.getSrc()));
+                sendRejectionMessage(gms_hdr.getType(), msg.getSrc(), "authentication failed");
+                return false;
             }
         }
+        return true;
+    }
+
+
+    protected void sendRejectionMessage(byte type, Address dest, String error_msg) {
+        switch(type) {
+            case GMS.GmsHeader.JOIN_REQ:
+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
+                sendJoinRejectionMessage(dest, error_msg);
+                break;
+            case GMS.GmsHeader.MERGE_REQ:
+                sendMergeRejectionMessage(dest);
+                break;
+        }
+    }
 
-        return down_prot.down(evt);
+    protected void sendJoinRejectionMessage(Address dest, String error_msg) {
+        if(dest == null)
+            return;
+
+        JoinRsp joinRes=new JoinRsp(error_msg); // specify the error message on the JoinRsp
+        Message msg = new Message(dest);
+        msg.putHeader(GMS.name, new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP, joinRes));
+        if(this.authenticate_coord)
+            msg.putHeader(AUTH.NAME, new AuthHeader(this.auth_token));
+        down_prot.down(new Event(Event.MSG, msg));
+    }
+
+    protected void sendMergeRejectionMessage(Address dest) {
+        GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.MERGE_RSP);
+        hdr.setMergeRejected(true);
+        Message msg=new Message(dest);
+        msg.setFlag(Message.OOB);
+        msg.putHeader(GMS.name, hdr);
+        if(this.authenticate_coord)
+            msg.putHeader(AUTH.NAME, new AuthHeader(this.auth_token));
+        log.debug("merge response=" + hdr);
+        down_prot.down(new Event(Event.MSG, msg));
+    }
+
+    protected boolean callUpHandlers(Event evt) {
+        boolean pass_up=true;
+        for(UpHandler handler: up_handlers) {
+            if(!handler.handleUpEvent(evt))
+                pass_up=false;
+        }
+        return pass_up;
     }
 
     /**
-     * Used to check if the message type is a Gms message
+     * Get the header from a GMS message
      * @param evt The event object passed in to AUTH
      * @return A GmsHeader object or null if the event contains a message of a different type
      */
-    private static GMS.GmsHeader isJoinMessage(Event evt){
-        Message msg;
-        switch(evt.getType()){
-          case Event.MSG:
-                msg = (Message)evt.getArg();
-                Object obj = msg.getHeader("GMS");
-                if(obj == null || !(obj instanceof GMS.GmsHeader)){
-                    return null;
-                }
-                return (GMS.GmsHeader)obj;
-        }
+    protected static GMS.GmsHeader getGMSHeader(Event evt){
+        return evt.getType() == Event.MSG? getGMSHeader((Message)evt.getArg()) : null;
+    }
+
+    protected static GMS.GmsHeader getGMSHeader(Message msg){
+        Header hdr = msg.getHeader(GMS.name);
+        if(hdr instanceof GMS.GmsHeader)
+            return (GMS.GmsHeader)hdr;
         return null;
     }
 }
diff --git a/src/org/jgroups/protocols/AuthHeader.java b/src/org/jgroups/protocols/AuthHeader.java
index b75f5b2063..719e6f1bbd 100644
--- a/src/org/jgroups/protocols/AuthHeader.java
+++ b/src/org/jgroups/protocols/AuthHeader.java
@@ -16,6 +16,11 @@
 
     public AuthHeader(){
     }
+
+    public AuthHeader(AuthToken token) {
+        this.token=token;
+    }
+
     /**
      * Sets the token value to that of the passed in token object
      * @param token the new authentication token
diff --git a/src/org/jgroups/protocols/DISCARD.java b/src/org/jgroups/protocols/DISCARD.java
index 50eaf1ac78..68b282bd4a 100644
--- a/src/org/jgroups/protocols/DISCARD.java
+++ b/src/org/jgroups/protocols/DISCARD.java
@@ -42,6 +42,13 @@
 
     protected boolean use_gui=false;
 
+    public boolean isDiscardAll() {
+        return discard_all;
+    }
+
+    public void setDiscardAll(boolean discard_all) {
+        this.discard_all=discard_all;
+    }
 
     /**
      * All protocol names have to be unique !
diff --git a/src/org/jgroups/protocols/EncryptBase.java b/src/org/jgroups/protocols/EncryptBase.java
new file mode 100644
index 0000000000..f76e7b01c7
--- /dev/null
+++ b/src/org/jgroups/protocols/EncryptBase.java
@@ -0,0 +1,464 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.*;
+
+import javax.crypto.Cipher;
+import javax.crypto.SecretKey;
+import java.security.MessageDigest;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.Properties;
+import java.util.WeakHashMap;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.zip.Adler32;
+import java.util.zip.CRC32;
+import java.util.zip.Checksum;
+
+/**
+ * Super class of symmetric ({@link SYM_ENCRYPT}) and asymmetric ({@link ASYM_ENCRYPT}) encryption protocols.
+ * @author Bela Ban
+ */
+public abstract class EncryptBase extends Protocol {
+    protected static final String DEFAULT_SYM_ALGO="AES";
+
+
+    /* -----------------------------------------    Properties     -------------------------------------------------- */
+    // Cryptographic Service Provider
+    protected String                        provider;
+
+    // Cipher engine transformation for asymmetric algorithm. Default is RSA
+    protected String                        asym_algorithm="RSA";
+
+    // Cipher engine transformation for symmetric algorithm. Default is AES
+    protected String                        sym_algorithm=DEFAULT_SYM_ALGO;
+
+    // Initial public/private key length. Default is 512
+    protected int                           asym_keylength=512;
+
+    // Initial key length for matching symmetric algorithm. Default is 128
+    protected int                           sym_keylength=128;
+
+    // Number of ciphers in the pool to parallelize encrypt and decrypt requests
+    protected int                           cipher_pool_size=8;
+
+    // If true, the entire message (including payload and headers) is encrypted, else only the payload
+    protected boolean                       encrypt_entire_message=true;
+
+    // If true, all messages are digitally signed by adding an encrypted checksum of the encrypted
+    // message to the header. Ignored if encrypt_entire_message is false
+    protected boolean                       sign_msgs=true;
+
+    // When sign_msgs is true, by default CRC32 is used to create the checksum. If use_adler is
+    // true, Adler32 will be used
+    protected boolean                       use_adler;
+
+    protected volatile Address              local_addr;
+
+    protected volatile View                 view;
+
+    // Cipher pools used for encryption and decryption. Size is cipher_pool_size
+    protected BlockingQueue<Cipher>         encoding_ciphers, decoding_ciphers;
+
+    // version filed for secret key
+    protected volatile byte[]               sym_version;
+
+    // shared secret key to encrypt/decrypt messages
+    protected volatile SecretKey            secret_key;
+
+    // map to hold previous keys so we can decrypt some earlier messages if we need to
+    protected final Map<AsciiString,Cipher> key_map=new WeakHashMap<AsciiString,Cipher>();
+
+    public int       getAsymKeylength()                 {return asym_keylength;}
+    public void      setAsymKeylength(int len)          {this.asym_keylength=len;}
+    public int       getSymKeylength()                  {return sym_keylength;}
+    public void      setSymKeylength(int len)           {this.sym_keylength=len;}
+    public SecretKey getSecretKey()                     {return secret_key;}
+    public void      setSecretKey(SecretKey key)        {this.secret_key=key;}
+    public String    getSymAlgorithm()                  {return sym_algorithm;}
+    public void      setSymAlgorithm(String alg)        {this.sym_algorithm=alg;}
+    public String    getAsymAlgorithm()                 {return asym_algorithm;}
+    public void      setAsymAlgorithm(String alg)       {this.asym_algorithm=alg;}
+    public byte[]    getSymVersion()                    {return sym_version;}
+    public void      setSymVersion(byte[] v)            {this.sym_version=Arrays.copyOf(v, v.length);}
+    public void      setLocalAddress(Address addr)      {this.local_addr=addr;}
+    public boolean   getEncryptEntireMessage()          {return encrypt_entire_message;}
+    public void      setEncryptEntireMessage(boolean b) {this.encrypt_entire_message=b;}
+    public boolean   getSignMessages()                  {return this.sign_msgs;}
+    public void      setSignMessages(boolean flag)      {this.sign_msgs=flag;}
+    public boolean   getAdler()                         {return use_adler;}
+    public void      setAdler(boolean flag)             {this.use_adler=flag;}
+    public String    getVersion()                       {return Util.byteArrayToHexString(sym_version);}
+
+    public boolean setProperties(Properties props)
+    {
+        String str;
+
+        super.setProperties(props);
+
+        str = props.getProperty("provider");
+        if (str != null)
+        {
+            provider = str;
+            props.remove("provider");
+
+            if (log.isInfoEnabled())
+                log.info("Provider used is " + provider);
+        }
+
+        // asymmetric algorithm name
+        str = props.getProperty("asym_algorithm");
+        if (str != null)
+        {
+            asym_algorithm = str;
+            props.remove("asym_algorithm");
+
+            if (log.isInfoEnabled())
+                log.info("Asym algo used is " + asym_algorithm);
+        }
+
+        // symmetric algorithm name
+        str = props.getProperty("sym_algorithm");
+        if (str != null)
+        {
+            sym_algorithm = str;
+            props.remove("sym_algorithm");
+
+            if (log.isInfoEnabled())
+                log.info("Sym algo used is " + sym_algorithm);
+        }
+
+        // asymmetric key length
+        str = props.getProperty("asym_keylength");
+        if (str != null)
+        {
+            asym_keylength = Integer.parseInt(str);
+            props.remove("asym_keylength");
+
+            if (log.isInfoEnabled())
+                log.info("Asym keylength used is " + asym_keylength);
+        }
+
+        // asymmetric key length
+        str = props.getProperty("sym_keylength");
+        if (str != null)
+        {
+            sym_keylength = Integer.parseInt(str);
+            props.remove("sym_keylength");
+
+            if (log.isInfoEnabled())
+                log.info("Sym keylength used is " + sym_keylength);
+        }
+
+        // cipher pool size
+        str = props.getProperty("cipher_pool_size");
+        if (str != null)
+        {
+            cipher_pool_size = Integer.parseInt(str);
+            props.remove("cipher_pool_size");
+        }
+
+        str=props.getProperty("encrypt_entire_message");
+        if(str != null)
+        {
+            encrypt_entire_message=Boolean.valueOf(str).booleanValue();
+            props.remove("encrypt_entire_message");
+        }
+
+        str=props.getProperty("sign_msgs");
+        if(str != null)
+        {
+            sign_msgs=Boolean.valueOf(str).booleanValue();
+            props.remove("sign_msgs");
+        }
+
+        str=props.getProperty("use_adler");
+        if(str != null)
+        {
+            use_adler=Boolean.valueOf(str).booleanValue();
+            props.remove("use_adler");
+        }
+
+        return true;
+    }
+
+
+    public void init() throws Exception {
+        int tmp=Util.getNextHigherPowerOfTwo(cipher_pool_size);
+        if(tmp != cipher_pool_size) {
+            log.warn(String.format("%s: setting cipher_pool_size (%d) to %d (power of 2) for faster modulo operation", local_addr, cipher_pool_size, tmp));
+            cipher_pool_size=tmp;
+        }
+        encoding_ciphers=new ArrayBlockingQueue<Cipher>(cipher_pool_size);
+        decoding_ciphers=new ArrayBlockingQueue<Cipher>(cipher_pool_size);
+        initSymCiphers(sym_algorithm, secret_key);
+    }
+
+
+    public Object down(Event evt) {
+        switch(evt.getType()) {
+            case Event.MSG:
+                Message msg=(Message)evt.getArg();
+                try {
+                    if(secret_key == null) {
+                        log.trace(String.format("%s: discarded %s message to %s as secret key is null, hdrs: %s",
+                                  local_addr, msg.getDest() == null? "mcast" : "unicast", msg.getDest(), msg.printHeaders()));
+                        return null;
+                    }
+                    encryptAndSend(msg);
+                }
+                catch(Exception e) {
+                    log.warn(local_addr + ": unable to send message down", e);
+                }
+                return null;
+
+            case Event.VIEW_CHANGE:
+                handleView((View)evt.getArg());
+                break;
+        }
+        return down_prot.down(evt);
+    }
+
+
+    public Object up(Event evt) {
+        switch(evt.getType()) {
+            case Event.VIEW_CHANGE:
+                handleView((View)evt.getArg());
+                break;
+            case Event.SET_LOCAL_ADDRESS:
+                local_addr=(Address)evt.getArg();
+                break;
+            case Event.MSG:
+                Message msg=(Message)evt.getArg();
+                try {
+                    return handleUpMessage(msg);
+                }
+                catch(Exception e) {
+                    log.warn(local_addr + ": exception occurred decrypting message", e);
+                }
+                return null;
+        }
+        return up_prot.up(evt);
+    }
+
+
+
+
+    /** Initialises the ciphers for both encryption and decryption using the generated or supplied secret key */
+    protected synchronized void initSymCiphers(String algorithm, SecretKey secret) throws Exception {
+        if(secret == null)
+            return;
+        encoding_ciphers.clear();
+        decoding_ciphers.clear();
+        for(int i=0; i < cipher_pool_size; i++ ) {
+            encoding_ciphers.add(createCipher(Cipher.ENCRYPT_MODE, secret, algorithm));
+            decoding_ciphers.add(createCipher(Cipher.DECRYPT_MODE, secret, algorithm));
+        };
+
+        //set the version
+        MessageDigest digest=MessageDigest.getInstance("MD5");
+        digest.reset();
+        digest.update(secret.getEncoded());
+
+        byte[] tmp=digest.digest();
+        sym_version=Arrays.copyOf(tmp, tmp.length);
+        log.debug(String.format("%s: created %d symmetric ciphers with secret key (%d bytes)", local_addr, cipher_pool_size, sym_version.length));
+    }
+
+
+    protected Cipher createCipher(int mode, SecretKey secret_key, String algorithm) throws Exception {
+        Cipher cipher=provider != null && !provider.trim().isEmpty()?
+          Cipher.getInstance(algorithm, provider) : Cipher.getInstance(algorithm);
+        cipher.init(mode, secret_key);
+        return cipher;
+    }
+
+
+    protected Object handleUpMessage(Message msg) throws Exception {
+        EncryptHeader hdr=(EncryptHeader)msg.getHeader(getName());
+        if(hdr == null) {
+            log.error(String.format("%s: received message without encrypt header from %s; dropping it", local_addr, msg.getSrc()));
+            return null;
+        }
+        switch(hdr.getType()) {
+            case EncryptHeader.ENCRYPT:
+                return handleEncryptedMessage(msg);
+            default:
+                return handleUpEvent(msg,hdr);
+        }
+    }
+
+
+    protected Object handleEncryptedMessage(Message msg) throws Exception {
+        if(!process(msg))
+            return null;
+
+        // try and decrypt the message - we need to copy msg as we modify its
+        // buffer (http://jira.jboss.com/jira/browse/JGRP-538)
+        Message tmpMsg=decryptMessage(null, msg.copy()); // need to copy for possible xmits
+        if(tmpMsg != null)
+            return up_prot.up(new Event(Event.MSG, tmpMsg));
+        log.warn(String.format("%s: unrecognized cipher; discarding message from %s", local_addr, msg.getSrc()));
+        return null;
+    }
+
+    protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+        return null;
+    }
+
+    /** Whether or not to process this received message */
+    protected boolean process(Message msg) {return true;}
+
+    protected void handleView(View view) {
+        this.view=view;
+    }
+
+    protected boolean inView(Address sender, String error_msg) {
+        View curr_view=this.view;
+        if(curr_view == null || curr_view.containsMember(sender))
+            return true;
+        log.error(String.format(error_msg, local_addr, sender, curr_view));
+        return false;
+    }
+
+    protected Checksum createChecksummer() {return use_adler? new Adler32() : new CRC32();}
+
+
+    /** Does the actual work for decrypting - if version does not match current cipher then tries the previous cipher */
+    protected Message decryptMessage(Cipher cipher, Message msg) throws Exception {
+        EncryptHeader hdr=(EncryptHeader)msg.getHeader(getName());
+        if(hdr.getVersion() == null)
+            return null;
+        if(!Arrays.equals(hdr.getVersion(), sym_version)) {
+            cipher=key_map.get(new AsciiString(hdr.getVersion()));
+            if(cipher == null) {
+                handleUnknownVersion();
+                return null;
+            }
+            log.trace(String.format("%s: decrypting msg from %s using previous cipher version", local_addr, msg.getSrc()));
+            return _decrypt(cipher, msg, hdr);
+        }
+        return _decrypt(cipher, msg, hdr);
+    }
+
+    protected Message _decrypt(final Cipher cipher, Message msg, EncryptHeader hdr) throws Exception {
+        byte[] decrypted_msg;
+
+        if(!encrypt_entire_message && msg.getLength() == 0)
+            return msg;
+
+        if(encrypt_entire_message && sign_msgs) {
+            byte[] signature=hdr.getSignature();
+            if(signature == null) {
+                log.error(String.format("%s: dropped message from %s as the header did not have a checksum", local_addr, msg.getSrc()));
+                return null;
+            }
+
+            long msg_checksum=decryptChecksum(cipher, signature, 0, signature.length);
+            long actual_checksum=computeChecksum(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+            if(actual_checksum != msg_checksum) {
+                log.error(String.format("%s: dropped message from %s as the message's checksum (%d) did not match the computed checksum (%d)",
+                          local_addr, msg.getSrc(), msg_checksum, actual_checksum));
+                return null;
+            }
+        }
+
+        if(cipher == null)
+            decrypted_msg=code(msg.getRawBuffer(), msg.getOffset(), msg.getLength(), true);
+        else
+            decrypted_msg=cipher.doFinal(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+
+        if(!encrypt_entire_message) {
+            msg.setBuffer(decrypted_msg);
+            return msg;
+        }
+
+        Message ret=(Message)Util.streamableFromByteBuffer(Message.class,decrypted_msg,0,decrypted_msg.length);
+        if(ret.getDest() == null)
+            ret.setDest(msg.getDest());
+        if(ret.getSrc() == null)
+            ret.setSrc(msg.getSrc());
+        return ret;
+    }
+
+
+    protected void encryptAndSend(Message msg) throws Exception {
+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, getSymVersion());
+        if(encrypt_entire_message) {
+            if(msg.getSrc() == null)
+                msg.setSrc(local_addr);
+
+            byte [] serialized_msg=Util.streamableToByteBuffer(msg);
+            byte[] encrypted_msg=code(serialized_msg,0,serialized_msg.length,false);
+
+            if(sign_msgs) {
+                long checksum=computeChecksum(encrypted_msg, 0, encrypted_msg.length);
+                byte[] checksum_array=encryptChecksum(checksum);
+                hdr.setSignature(checksum_array);
+            }
+
+            // exclude existing headers, they will be seen again when we decrypt and unmarshal the msg at the receiver
+            Message tmp=msg.copy(false, false);
+            tmp.setBuffer(encrypted_msg);
+            tmp.putHeader(getName(),hdr);
+            down_prot.down(new Event(Event.MSG, tmp));
+            return;
+        }
+
+        // copy neeeded because same message (object) may be retransmitted -> prevent double encryption
+        Message msgEncrypted=msg.copy(false);
+        msgEncrypted.putHeader(getName(), hdr);
+        if(msg.getLength() > 0)
+            msgEncrypted.setBuffer(code(msg.getRawBuffer(),msg.getOffset(),msg.getLength(),false));
+        down_prot.down(new Event(Event.MSG,msgEncrypted));
+    }
+
+
+    protected byte[] code(byte[] buf, int offset, int length, boolean decode) throws Exception {
+        BlockingQueue<Cipher> queue=decode? decoding_ciphers : encoding_ciphers;
+        Cipher cipher=queue.take();
+        try {
+            return cipher.doFinal(buf, offset, length);
+        }
+        finally {
+            queue.offer(cipher);
+        }
+    }
+
+    protected long computeChecksum(byte[] input, int offset, int length) {
+        Checksum checksummer=createChecksummer();
+        checksummer.update(input, offset, length);
+        return checksummer.getValue();
+    }
+
+    protected byte[] encryptChecksum(long checksum) throws Exception {
+        byte[] checksum_array=new byte[Global.LONG_SIZE];
+        Bits.writeLong(checksum, checksum_array, 0);
+        return code(checksum_array, 0, checksum_array.length, false);
+    }
+
+    protected long decryptChecksum(final Cipher cipher, byte[] input, int offset, int length) throws Exception {
+        byte[] decrypted_checksum;
+        if(cipher == null)
+            decrypted_checksum=code(input, offset, length, true);
+        else
+            decrypted_checksum=cipher.doFinal(input, offset, length);
+        return Bits.readLong(decrypted_checksum, 0);
+    }
+
+
+    /* Get the algorithm name from "algorithm/mode/padding"  taken from original ENCRYPT */
+    protected static String getAlgorithm(String s) {
+        int index=s.indexOf('/');
+        return index == -1? s : s.substring(0, index);
+    }
+
+
+    /** Called when the version shipped in the header can't be found */
+    protected void handleUnknownVersion() {}
+
+
+
+}
diff --git a/src/org/jgroups/protocols/EncryptHeader.java b/src/org/jgroups/protocols/EncryptHeader.java
new file mode 100644
index 0000000000..201cdd8fc1
--- /dev/null
+++ b/src/org/jgroups/protocols/EncryptHeader.java
@@ -0,0 +1,80 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Global;
+import org.jgroups.Header;
+import org.jgroups.util.Streamable;
+import org.jgroups.util.Util;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * @author Bela Ban
+ * @since  3.6.10
+ */
+public class EncryptHeader extends Header implements Streamable {
+    public static final byte ENCRYPT        = 1 << 0;
+    public static final byte SECRET_KEY_REQ = 1 << 1;
+    public static final byte SECRET_KEY_RSP = 1 << 2;
+
+    protected byte   type;
+    protected byte[] version;
+    protected byte[] signature; // the encrypted checksum
+
+
+    public EncryptHeader() {}
+
+
+    public EncryptHeader(byte type, byte[] version) {
+        this.type=type;
+        this.version=version;
+    }
+
+    public byte          getType()           {return type;}
+    public byte[]        getVersion()        {return version;}
+    public byte[]        getSignature()         {return signature;}
+    public void setSignature(byte[] s) {this.signature=s;}
+
+    public void writeExternal(java.io.ObjectOutput out) throws IOException
+    {
+        out.writeByte(type);
+        out.writeObject(version);
+        out.writeObject(signature);
+    }
+
+
+    public void readExternal(java.io.ObjectInput in) throws IOException, ClassNotFoundException
+    {
+        type = in.readByte();
+        version = (byte [])in.readObject();
+        signature = (byte [])in.readObject();
+    }
+
+    public void writeTo(DataOutputStream out) throws IOException {
+        out.writeByte(type);
+        Util.writeByteBuffer(version, out);
+        Util.writeByteBuffer(signature, out);
+    }
+
+    public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {
+        type=in.readByte();
+        version=Util.readByteBuffer(in);
+        signature=Util.readByteBuffer(in);
+    }
+
+    public String toString() {
+        return String.format("[%s version=%s]", typeToString(type), (version != null? version.length + " bytes" : "n/a"));
+    }
+
+    public int size() {return Global.BYTE_SIZE + Util.size(version) + Util.size(signature) /*+ Util.size(payload) */;}
+
+    protected static String typeToString(byte type) {
+        switch(type) {
+            case ENCRYPT:        return "ENCRYPT";
+            case SECRET_KEY_REQ: return "SECRET_KEY_REQ";
+            case SECRET_KEY_RSP: return "SECRET_KEY_RSP";
+            default:             return "<unrecognized type " + type;
+        }
+    }
+}
diff --git a/src/org/jgroups/protocols/SYM_ENCRYPT.java b/src/org/jgroups/protocols/SYM_ENCRYPT.java
new file mode 100644
index 0000000000..115e571c3c
--- /dev/null
+++ b/src/org/jgroups/protocols/SYM_ENCRYPT.java
@@ -0,0 +1,187 @@
+package org.jgroups.protocols;
+
+import org.jgroups.util.Util;
+
+import javax.crypto.SecretKey;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.KeyStore;
+import java.security.NoSuchAlgorithmException;
+import java.security.cert.CertificateException;
+import java.util.Properties;
+
+/**
+ * Encrypts and decrypts communication in JGroups by using a secret key shared by all cluster members.<p>
+ *
+ * The secret key is identical for all cluster members and is injected into this protocol at startup, e.g. by reading
+ * it from a keystore. Messages are sent by encrypting them with the secret key and received by decrypting them with
+ * the secret key. Note that all cluster members must be shipped with the same keystore file<p>
+ *
+ * This protocol is typically placed under {@link org.jgroups.protocols.pbcast.NAKACK}, so that most important
+ * headers are encrypted as well, to prevent replay attacks.<p>
+ *
+ * A possible configuration looks like this:<br><br>
+ * {@code <SYM_ENCRYPT key_store_name="defaultStore.keystore" store_password="changeit" alias="myKey"/>}
+ * <br>
+ * <br>
+ * In order to use SYM_ENCRYPT layer in this manner, it is necessary to have the secret key already generated in a
+ * keystore file. The directory containing the keystore file must be on the application's classpath. You cannot create a
+ * secret key keystore file using the keytool application shipped with the JDK. A java file called KeyStoreGenerator is
+ * included in the demo package that can be used from the command line (or IDE) to generate a suitable keystore.
+ *
+ * @author Bela Ban
+ * @author Steve Woodcock
+ */
+public class SYM_ENCRYPT extends EncryptBase {
+
+    /* -----------------------------------------    Properties     -------------------------------------------------- */
+    // File on classpath that contains keystore repository
+    protected String   keystore_name;
+
+    // Password used to check the integrity/unlock the keystore. Change the default
+    protected String   store_password="changeit"; // JDK default
+
+    // Password for recovering the key. Change the default"
+    protected String   key_password; // allows to assign keypwd=storepwd if not set (https://issues.jboss.org/browse/JGRP-1375)
+
+
+    // Alias used for recovering the key. Change the default"
+    protected String   alias="mykey"; // JDK default
+
+
+    public String getKeystoreName()                      {return this.keystore_name;}
+    public void   setKeystoreName(String n)              {this.keystore_name=n;}
+    public String getAlias()                             {return alias;}
+    public void   setAlias(String a)                     {this.alias=a;}
+    public String getStorePassword()                     {return store_password;}
+    public void   setStorePassword(String pwd)           {this.store_password=pwd;}
+
+
+    public String getName()
+    {
+        return "SYM_ENCRYPT";
+    }
+
+    public boolean setProperties(Properties props)
+    {
+        String str;
+
+        super.setProperties(props);
+
+        // key store name
+        str = props.getProperty("keystore_name");
+        if (str != null)
+        {
+            keystore_name = str;
+            props.remove("keystore_name");
+
+            if (log.isInfoEnabled())
+                log.info("keystore_name used is " + keystore_name);
+        }
+
+        // key store password
+        str = props.getProperty("store_password");
+        if (str != null)
+        {
+            store_password = str;
+            props.remove("store_password");
+
+            if (log.isInfoEnabled())
+                log.info("store_password used is not null");
+        }
+
+        // key password
+        str = props.getProperty("key_password");
+        if (str != null)
+        {
+            key_password = str;
+            props.remove("key_password");
+
+            if (log.isInfoEnabled())
+                log.info("key_password used is not null");
+        } else if (store_password != null)
+        {
+            key_password = store_password;
+
+            if (log.isInfoEnabled())
+                log.info("key_password used is same as store_password");
+        }
+
+        // key aliase
+        str = props.getProperty("alias");
+        if (str != null)
+        {
+            alias = str;
+            props.remove("alias");
+
+            if (log.isInfoEnabled())
+                log.info("alias used is " + alias);
+        }
+
+        if (!props.isEmpty())
+        {
+
+            if (log.isErrorEnabled())
+                log.error("these properties are not recognized:" + props);
+            return false;
+        }
+
+        return true;
+    }
+
+
+    public void init() throws Exception {
+        readSecretKeyFromKeystore();
+        super.init();
+    }
+
+    /**
+     * Initialisation if a supplied key is defined in the properties. This supplied key must be in a keystore which
+     * can be generated using the keystoreGenerator file in demos. The keystore must be on the classpath to find it.
+     */
+    protected void readSecretKeyFromKeystore() throws Exception {
+        InputStream inputStream=null;
+        // must not use default keystore type - as it does not support secret keys
+        KeyStore store=KeyStore.getInstance("JCEKS");
+
+        SecretKey tempKey=null;
+        try {
+            if(this.secret_key == null) { // in case the secret key was set before, e.g. via injection in a unit test
+                // load in keystore using this thread's classloader
+                inputStream=Thread.currentThread().getContextClassLoader().getResourceAsStream(keystore_name);
+                if(inputStream == null)
+                    inputStream=new FileInputStream(keystore_name);
+                // we can't find a keystore here -
+                if(inputStream == null)
+                    throw new Exception("Unable to load keystore " + keystore_name + " ensure file is on classpath");
+                // we have located a file lets load the keystore
+                try {
+                    store.load(inputStream, store_password.toCharArray());
+                    // loaded keystore - get the key
+                    tempKey=(SecretKey)store.getKey(alias, key_password.toCharArray());
+                }
+                catch(IOException e) {
+                    throw new Exception("Unable to load keystore " + keystore_name + ": " + e);
+                }
+                catch(NoSuchAlgorithmException e) {
+                    throw new Exception("No Such algorithm " + keystore_name + ": " + e);
+                }
+                catch(CertificateException e) {
+                    throw new Exception("Certificate exception " + keystore_name + ": " + e);
+                }
+
+                if(tempKey == null)
+                    throw new Exception("Unable to retrieve key '" + alias + "' from keystore " + keystore_name);
+                this.secret_key=tempKey;
+                if(sym_algorithm.equals(DEFAULT_SYM_ALGO))
+                    sym_algorithm=tempKey.getAlgorithm();
+            }
+        }
+        finally {
+            Util.close(inputStream);
+        }
+    }
+
+
+}
diff --git a/src/org/jgroups/protocols/UNICAST.java b/src/org/jgroups/protocols/UNICAST.java
index f278d738b8..32a9001e6c 100644
--- a/src/org/jgroups/protocols/UNICAST.java
+++ b/src/org/jgroups/protocols/UNICAST.java
@@ -295,7 +295,7 @@ public Object up(Event evt) {
                 msg=(Message)evt.getArg();
                 dst=msg.getDest();
 
-                if(dst == null || dst.isMulticastAddress())  // only handle unicast messages
+                if(dst == null || dst.isMulticastAddress() || msg.isFlagSet(Message.NO_RELIABILITY))  // only handle unicast messages
                     break;  // pass up
 
                 // changed from removeHeader(): we cannot remove the header because if we do loopback=true at the
@@ -338,7 +338,7 @@ public Object down(Event evt) {
                 Address dst=msg.getDest();
 
                 /* only handle unicast messages */
-                if (dst == null || dst.isMulticastAddress()) {
+                if (dst == null || dst.isMulticastAddress() || msg.isFlagSet(Message.NO_RELIABILITY)) {
                     break;
                 }
 
diff --git a/src/org/jgroups/protocols/pbcast/ClientGmsImpl.java b/src/org/jgroups/protocols/pbcast/ClientGmsImpl.java
index 0bc254e28f..c716cbb3fa 100644
--- a/src/org/jgroups/protocols/pbcast/ClientGmsImpl.java
+++ b/src/org/jgroups/protocols/pbcast/ClientGmsImpl.java
@@ -67,6 +67,7 @@ private void join(Address mbr, boolean joinWithStateTransfer) {
         Address coord=null;
         JoinRsp rsp=null;
         View tmp_view;
+        long join_attempts=0;
         leaving=false;
 
         join_promise.reset();
@@ -134,8 +135,15 @@ private void join(Address mbr, boolean joinWithStateTransfer) {
                 if(rsp == null)
                     rsp=join_promise.getResult(gms.join_timeout);
                 if(rsp == null) {
+                    join_attempts++;
                     if(log.isWarnEnabled())
                         log.warn("join(" + mbr + ") sent to " + coord + " timed out (after " + gms.join_timeout + " ms), retrying");
+                    if(gms.max_join_attempts != 0 && join_attempts >= gms.max_join_attempts) {
+                        if(log.isWarnEnabled())
+                            log.warn("Too many JOIN attempts: becoming singleton");
+                        becomeSingletonMember(mbr);
+                        return;
+                    }
                 }
                 else {
                     // 1. check whether JOIN was rejected
diff --git a/src/org/jgroups/protocols/pbcast/GMS.java b/src/org/jgroups/protocols/pbcast/GMS.java
index 6209b5d192..542e846634 100644
--- a/src/org/jgroups/protocols/pbcast/GMS.java
+++ b/src/org/jgroups/protocols/pbcast/GMS.java
@@ -41,6 +41,8 @@
     long                      join_timeout=5000;
     long                      leave_timeout=5000;
     long                      merge_timeout=5000;           // time to wait for all MERGE_RSPS
+    /** Number of join attempts before we give up and become a singleton. Zero means 'never give up */
+    long                      max_join_attempts=0;
     private final Object      impl_mutex=new Object();       // synchronizes event entry into impl
     private final Hashtable<String,GmsImpl>   impls=new Hashtable<String,GmsImpl>(3);
     private boolean           shun=false;
@@ -122,6 +124,8 @@ public String getName() {
     public long getJoinRetryTimeout() {return -1;}
     /** @deprecated */
     public void setJoinRetryTimeout(long t) {}
+    public long getMaxJoinAttempts() {return max_join_attempts;}
+    public void setMaxJoinAttempts(long t) {max_join_attempts=t;}
     public boolean isShun() {return shun;}
     public void setShun(boolean s) {shun=s;}
 
@@ -969,6 +973,12 @@ public boolean setProperties(Properties props) {
             props.remove("resume_task_timeout");
         }
 
+        str=props.getProperty("max_join_attempts");
+        if(str != null) {
+            max_join_attempts=Long.parseLong(str);
+            props.remove("max_join_attempts");
+        }
+
         str=props.getProperty("disable_initial_coord");
         if(str != null) {
             disable_initial_coord=Boolean.valueOf(str).booleanValue();
@@ -1122,6 +1132,10 @@ public Address getMember() {
             return mbr;
         }
 
+        public void setMergeRejected(boolean merge_rejected) {
+            this.merge_rejected=merge_rejected;
+        }
+
         public String toString() {
             StringBuilder sb=new StringBuilder("GmsHeader");
             sb.append('[' + type2String(type) + ']');
diff --git a/src/org/jgroups/protocols/pbcast/NAKACK.java b/src/org/jgroups/protocols/pbcast/NAKACK.java
index 5d42b87428..0f2a819a9e 100644
--- a/src/org/jgroups/protocols/pbcast/NAKACK.java
+++ b/src/org/jgroups/protocols/pbcast/NAKACK.java
@@ -102,7 +102,7 @@
     private boolean leaving=false;
     private boolean started=false;
     private TimeScheduler timer=null;
-    private static final String name="NAKACK";
+    public static final String name="NAKACK";
 
     private long xmit_reqs_received;
     private long xmit_reqs_sent;
@@ -598,7 +598,7 @@ public Object down(Event evt) {
             case Event.MSG:
                 Message msg=(Message)evt.getArg();
                 Address dest=msg.getDest();
-                if(dest != null && !dest.isMulticastAddress()) {
+                if((dest != null && !dest.isMulticastAddress()) || msg.isFlagSet(Message.NO_RELIABILITY)) {
                     break; // unicast address: not null and not mcast, pass down unchanged
                 }
                 send(evt, msg);
@@ -687,6 +687,8 @@ public Object up(Event evt) {
 
         case Event.MSG:
             Message msg=(Message)evt.getArg();
+            if(msg.isFlagSet(Message.NO_RELIABILITY))
+                break;
             NakAckHeader hdr=(NakAckHeader)msg.getHeader(name);
             if(hdr == null)
                 break;  // pass up (e.g. unicast msg)
diff --git a/src/org/jgroups/util/AsciiString.java b/src/org/jgroups/util/AsciiString.java
new file mode 100644
index 0000000000..4b98563347
--- /dev/null
+++ b/src/org/jgroups/util/AsciiString.java
@@ -0,0 +1,84 @@
+package org.jgroups.util;
+
+/**
+ * Simple string implemented as a byte[] array. Each character's higher 8 bits are truncated and
+ * only the lower 8 bits are stored. AsciiString is mutable for efficiency reasons, but the chars array should never
+ * be changed !
+ * @author Bela Ban
+ * @since  3.5
+ */
+public class AsciiString implements Comparable<AsciiString> {
+    protected final byte[] val;
+
+    public AsciiString() {
+        val=new byte[]{};
+    }
+
+    public AsciiString(String str) {
+        int length=str != null? str.length() : 0;
+        this.val=new byte[length];
+        for(int i=0; i < length; i++)
+            val[i]=(byte)str.charAt(i);
+    }
+
+    public AsciiString(AsciiString str) {
+        this.val=str.val;
+    }
+
+    public AsciiString(byte[] val) {
+        this.val=val; // mutable, used only for creation
+    }
+
+    public AsciiString(int length) {
+        this.val=new byte[length];
+    }
+
+    public byte[] chars() {return val;} // mutable
+
+    public int length() {
+        return val.length;
+    }
+
+    public int compareTo(AsciiString str) {
+        if(str == null) return 1;
+        if(chars().hashCode() == str.val.hashCode())
+            return 0;
+
+        int len1=val.length;
+        int len2=str.val.length;
+        int lim=Math.min(len1, len2);
+        byte[] v1=val;
+        byte[] v2=str.val;
+
+        int k = 0;
+        while (k < lim) {
+            byte c1 =v1[k];
+            byte c2 =v2[k];
+            if (c1 != c2)
+                return c1 > c2? 1 : -1;
+            k++;
+        }
+        return len1 > len2? 1 : len1 < len2? -1 : 0;
+    }
+
+
+
+    public boolean equals(Object obj) {
+        return obj instanceof AsciiString && compareTo((AsciiString)obj) == 0;
+    }
+
+    public int hashCode() {
+        int h=0;
+        for(int i=0; i < val.length; i++)
+            h=31 * h + val[i];
+        return h;
+    }
+
+    public String toString() {
+        return new String(val);
+    }
+
+
+
+
+}
diff --git a/src/org/jgroups/util/Bits.java b/src/org/jgroups/util/Bits.java
new file mode 100644
index 0000000000..39e34c8aa0
--- /dev/null
+++ b/src/org/jgroups/util/Bits.java
@@ -0,0 +1,773 @@
+package org.jgroups.util;
+
+import org.jgroups.Global;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/**
+ * Class (similar to (and partly copied from) java.nio.Bits) containing helper methods to encode variables
+ * (e.g. ints, long, List&lt;Address&gt; etc) to memory (byte buffer) or output streams and read variables
+ * from memory or input streams.<p/>
+ * The write methods write a type (e.g. an int or a char) to a buffer ({@link ByteBuffer} or output stream, using
+ * <a href="https://developers.google.com/protocol-buffers/docs/encoding">variable-length encoding</a>. If
+ * there are not enough byte in the buffer to write a type, a {@link java.nio.BufferOverflowException} is thrown.
+ * If the variable cannot be written to the output stream, an IOException is thrown.
+ * <p/>
+ * The read methods read a variable-length encoded type from a buffer or input stream. If there are fewer bytes in
+ * the buffer than needed to read the type, a {@link java.nio.BufferUnderflowException} is thrown. If the read fails,
+ * an IOException is thrown.
+ * <p/>
+ * The size() methods return the number of bytes used to encode the given type with variable-length encoding.
+ * <p/>
+ * There are additional helper methods to write/read custom JGroups types, e.g. address lists, Views etc
+ * <p/>
+ * Note that methods to read/write atomic types (char, int etc) should only be used if variable-length encoding is
+ * desired; otherwise {@link DataOutput#writeInt(int)} or {@link ByteBuffer#putInt(int)} should be used instead.
+ * <p/>
+ * At the time of writing this (Feb 2014), most methods have not yet been implemented.
+ * @author Bela Ban
+ * @author Sanne Grinovero
+ * @since  3.5
+ */
+public final class Bits {
+
+	private Bits() {
+		throw new InstantiationError( "Must not instantiate this class" );
+	}
+
+    // -------------------- char ------------------------ //
+
+    // No compression of chars as they only use 2 bytes
+    public static char makeChar(byte[] buf, int offset) {
+        return (char) ((buf[offset + 1] & 0xFF) + (buf[offset] << 8));
+    }
+
+    public static void writeChar(char c, byte[] buf, int offset) {
+        buf[offset+1]=(byte)c;
+        buf[offset]=(byte)(c >>> 8);
+    }
+
+    public static char readChar(byte[] buf, int offset) {
+        return makeChar(buf, offset);
+    }
+
+    // -------------------- short ----------------------- //
+
+    // No implementations as encoding a char doesn't use much space
+
+    public static short makeShort(byte a, byte b) {
+        return (short)((a << 8) | (b & 0xff));
+    }
+
+    public static short makeShort(byte a) {
+        return (short) (a & 0xff);
+    }
+
+    public static void writeShort(short s, byte[] buf, int offset) {
+        buf[offset+1]=(byte)s;
+        buf[offset]=(byte)(s >>> 8);
+    }
+
+    public static short readShort(byte[] buf, int offset) {
+        return (short)((buf[offset+1] & 0xFF) + (buf[offset] << 8));
+    }
+
+    // --------------------- int ------------------------ //
+
+
+    /**
+     * Writes an int to a ByteBuffer
+     * @param num the int to be written
+     * @param buf the buffer
+     */
+    public static void writeInt(int num, ByteBuffer buf) {
+        if(num == 0) {
+            buf.put((byte)0);
+            return;
+        }
+        final byte bytes_needed=bytesRequiredFor(num);
+        buf.put(bytes_needed);
+        for(int i=0; i < bytes_needed; i++)
+            buf.put(getByteAt(num, i));
+    }
+
+    /**
+     * Writes an int to an output stream
+     * @param num the int to be written
+     * @param out the output stream
+     */
+    public static void writeInt(int num, DataOutput out) throws IOException {
+        if(num == 0) {
+            out.write(0);
+            return;
+        }
+        final byte bytes_needed=bytesRequiredFor(num);
+        out.write(bytes_needed);
+        for(int i=0; i < bytes_needed; i++)
+            out.write(getByteAt(num, i));
+    }
+
+    public static void writeInt(int num, byte[] buf, int offset) {
+        buf[offset+3]=(byte)num;
+        buf[offset+2]=(byte)(num >>>  8);
+        buf[offset+1]=(byte)(num >>> 16);
+        buf[offset]=(byte)(num >>> 24);
+    }
+
+    public static void writeIntCompressed(int num, byte[] buf, int offset) {
+        if(num == 0) {
+            buf[offset]=0;
+            return;
+        }
+        final byte bytes_needed=bytesRequiredFor(num);
+        buf[offset++]=bytes_needed;
+        for(int i=0; i < bytes_needed; i++)
+            buf[offset++]=getByteAt(num, i);
+    }
+
+
+    /**
+     * Reads an int from a buffer.
+     * @param buf the buffer
+     * @return the int read from the buffer
+     */
+    public static int readInt(ByteBuffer buf) {
+        byte len=buf.get();
+        if(len == 0)
+            return 0;
+        byte[] retval=new byte[len];
+        buf.get(retval, 0, len);
+        return makeInt(retval, 0, len);
+    }
+
+    /**
+     * Reads an int from an input stream
+     * @param in the input stream
+     * @return the int read from the input stream
+     */
+    public static int readInt(DataInput in) throws IOException {
+        byte len=in.readByte();
+        if(len == 0)
+            return 0;
+        byte[] buf=new byte[len];
+        in.readFully(buf, 0, len);
+        return makeInt(buf, 0, len);
+    }
+
+    public static int readInt(byte[] buf, int offset) {
+        return ((buf[offset+3] & 0xFF)) +
+          ((buf[offset+2] & 0xFF) <<  8) +
+          ((buf[offset+1] & 0xFF) << 16) +
+          ((buf[offset]) << 24);
+    }
+
+    public static int readIntCompressed(byte[] buf, int offset) {
+        byte len=buf[offset++];
+        if(len == 0)
+            return 0;
+        byte[] buffer=new byte[len];
+        for(int i=0; i < len; i++)
+            buffer[i]=buf[offset++];
+        return makeInt(buffer, 0, len);
+    }
+
+
+    /**
+     * Computes the size of a variable-length encoded int
+     * @param num the int
+     * @return the number of bytes needed to variable-length encode num
+     */
+    public static int size(int num) {
+        return (byte)(num == 0? 1 : bytesRequiredFor(num) +1);
+    }
+
+
+
+
+    // -------------------- long ------------------------ //
+
+    /**
+     * Writes a long to a ByteBuffer
+     * @param num the long to be written
+     * @param buf the buffer
+     */
+    public static void writeLong(long num, ByteBuffer buf) {
+        if(num == 0) {
+            buf.put((byte)0);
+            return;
+        }
+        final byte bytes_needed=bytesRequiredFor(num);
+        buf.put(bytes_needed);
+        for(int i=0; i < bytes_needed; i++)
+            buf.put(getByteAt(num, i));
+    }
+
+    /**
+     * Writes a long to out in variable-length encoding. Note that currently variable-length encoding is <em>not</em>
+     * used (a similar mechanism is used); this will be implemented later.
+     * @param num the long
+     * @param out the output stream to write num to
+     * @throws IOException
+     */
+    public static void writeLong(final long num, final DataOutput out) throws IOException {
+        if(num == 0) {
+            out.write(0);
+            return;
+        }
+        final byte bytes_needed=bytesRequiredFor(num);
+        out.write(bytes_needed);
+        for(int i=0; i < bytes_needed; i++)
+            out.write(getByteAt(num, i));
+    }
+
+    public static void writeLong(long num, byte[] buf, int offset) {
+        buf[offset+7]=(byte)num;
+        buf[offset+6]=(byte)(num >>>  8);
+        buf[offset+5]=(byte)(num >>> 16);
+        buf[offset+4]=(byte)(num >>> 24);
+        buf[offset+3]=(byte)(num >>> 32);
+        buf[offset+2]=(byte)(num >>> 40);
+        buf[offset+1]=(byte)(num >>> 48);
+        buf[offset]=(byte)(num >>> 56);
+    }
+
+    public static void writeLongCompressed(long num, byte[] buf, int offset) {
+        if(num == 0) {
+            buf[offset]=0;
+            return;
+        }
+        final byte bytes_needed=bytesRequiredFor(num);
+        buf[offset++]=bytes_needed;
+        for(int i=0; i < bytes_needed; i++)
+            buf[offset++]=getByteAt(num, i);
+    }
+
+
+
+    /**
+     * Reads a long from a buffer.
+     * @param buf the buffer
+     * @return the long read from the buffer
+     */
+    public static long readLong(ByteBuffer buf) {
+        byte len=buf.get();
+        if(len == 0)
+            return 0;
+        byte[] retval=new byte[len];
+        buf.get(retval, 0, len);
+        return makeLong(retval, 0, len);
+    }
+
+    /**
+     * Reads a variable-length encoded long from an input stream.  Note that currently variable-length encoding is <em>not</em>
+     * used (a similar mechanism is used); this will be implemented later.
+     * @param in the input stream
+     * @return the long read from the input stream
+     * @throws IOException
+     */
+    public static long readLong(DataInput in) throws IOException {
+        byte len=in.readByte();
+        if(len == 0)
+            return 0;
+        byte[] buf=new byte[len];
+        in.readFully(buf, 0, len);
+        return makeLong(buf, 0, len);
+    }
+
+    public static long readLong(byte[] buf, int offset) {
+        return ((buf[offset+7] & 0xFFL)) +
+          ((buf[offset+6] & 0xFFL) <<  8) +
+          ((buf[offset+5] & 0xFFL) << 16) +
+          ((buf[offset+4] & 0xFFL) << 24) +
+          ((buf[offset+3] & 0xFFL) << 32) +
+          ((buf[offset+2] & 0xFFL) << 40) +
+          ((buf[offset+1] & 0xFFL) << 48) +
+          (((long) buf[offset])    << 56);
+    }
+
+    public static long readLongCompressed(byte[] buf, int offset) {
+        byte len=buf[offset++];
+        if(len == 0)
+            return 0;
+        byte[] buffer=new byte[len];
+        for(int i=0; i < len; i++)
+            buffer[i]=buf[offset++];
+        return makeLong(buffer, 0, len);
+    }
+
+    /**
+     * Computes the size of a variable-length encoded long.  Note that this is <em>not</em> currently using
+     * variable-length encoding (will be implemented later).
+     * @param num the long
+     * @return the number of bytes needed to variable-length encode num
+     */
+    public static int size(long num) {
+        return (byte)(num == 0? 1 : bytesRequiredFor(num) +1);
+    }
+
+
+
+
+
+    // ------------------ long seq ---------------------- //
+
+    /**
+     * Writes 2 sequence numbers (seqnos) in compressed format to buf.
+     * The seqnos are non-negative and hr is guaranteed to be &gt;= hd.
+     * <p/>
+     * Once variable-length encoding has been implemented, this method will probably get dropped as we can simply
+     * write the 2 longs individually.
+     * @param hd the highest delivered seqno. Guaranteed to be a positive number
+     * @param hr the highest received seqno. Guaranteed to be a positive number. Greater than or equal to hd
+     * @param buf the buffer to write to
+     */
+    public static void writeLongSequence(long hd, long hr, ByteBuffer buf) {
+        if(hr < hd)
+            throw new IllegalArgumentException("hr (" + hr + ") has to be >= hd (" + hd + ")");
+
+        if(hd == 0 && hr == 0) {
+            buf.put((byte)0);
+            return;
+        }
+
+        long delta=hr - hd;
+
+        // encode highest_delivered followed by delta
+        byte bytes_for_hd=bytesRequiredFor(hd), bytes_for_delta=bytesRequiredFor(delta);
+        byte bytes_needed=encodeLength(bytes_for_hd, bytes_for_delta);
+        buf.put(bytes_needed);
+
+        for(int i=0; i < bytes_for_hd; i++)
+            buf.put(getByteAt(hd, i));
+
+        for(int i=0; i < bytes_for_delta; i++)
+            buf.put(getByteAt(delta, i));
+    }
+
+    /**
+     * Writes 2 sequence numbers (seqnos) in compressed format to an output stream.
+     * The seqnos are non-negative and hr is guaranteed to be &gt;= hd.
+     * <p/>
+     * Once variable-length encoding has been implemented, this method will probably get dropped as we can simply
+     * write the 2 longs individually.
+     * @param hd the highest delivered seqno. Guaranteed to be a positive number
+     * @param hr the highest received seqno. Guaranteed to be a positive number. Greater than or equal to hd
+     * @param out the output stream to write to
+     */
+    public static void writeLongSequence(long hd, long hr, DataOutput out) throws IOException {
+        if(hr < hd)
+            throw new IllegalArgumentException("hr (" + hr + ") has to be >= hd (" + hd + ")");
+
+        if(hd == 0 && hr == 0) {
+            out.write(0);
+            return;
+        }
+
+        long delta=hr - hd;
+
+        // encode highest_delivered followed by delta
+        byte bytes_for_hd=bytesRequiredFor(hd), bytes_for_delta=bytesRequiredFor(delta);
+        byte bytes_needed=encodeLength(bytes_for_hd, bytes_for_delta);
+        out.write(bytes_needed);
+
+        for(int i=0; i < bytes_for_hd; i++)
+            out.write(getByteAt(hd, i));
+
+        for(int i=0; i < bytes_for_delta; i++)
+            out.write(getByteAt(delta, i));
+    }
+
+    /**
+     * Reads 2 compressed longs from buf.
+     * <p/>
+     * Once variable-length encoding has been implemented, this method will probably get dropped as we can simply
+     * read the 2 longs individually.
+     * @param buf the buffer to read from
+     * @return an array of 2 longs (hd and hr)
+     */
+    public static long[] readLongSequence(ByteBuffer buf) {
+        byte len=buf.get();
+        if(len == 0)
+            return new long[]{0,0};
+
+        byte[] lengths=decodeLength(len);
+        long[] seqnos=new long[2];
+        byte[] retval=new byte[lengths[0] + lengths[1]];
+        buf.get(retval, 0, retval.length);
+        seqnos[0]=makeLong(retval, 0, lengths[0]);
+        seqnos[1]=makeLong(retval, lengths[0], lengths[1]) + seqnos[0];
+        return seqnos;
+    }
+
+    /**
+     * Reads 2 compressed longs from in.
+     * Reads 2 compressed longs from buf.
+     * <p/>
+     * Once variable-length encoding has been implemented, this method will probably get dropped as we can simply
+     * read the 2 longs individually.
+     * @param in the input stream to read from
+     * @return an array of 2 longs (hd and hr)
+     */
+    public static long[] readLongSequence(DataInput in) throws IOException {
+        byte len=in.readByte();
+        if(len == 0)
+            return new long[]{0,0};
+
+        byte[] lengths=decodeLength(len);
+        long[] seqnos=new long[2];
+        byte[] buf=new byte[lengths[0] + lengths[1]];
+        in.readFully(buf, 0, buf.length);
+        seqnos[0]=makeLong(buf, 0, lengths[0]);
+        seqnos[1]=makeLong(buf, lengths[0], lengths[1]) + seqnos[0];
+        return seqnos;
+    }
+
+
+
+    public static byte size(long hd, long hr) {
+        if(hd == 0 && hr == 0)
+            return 1;
+
+        byte num_bytes_for_hd=bytesRequiredFor(hd), num_bytes_for_delta=bytesRequiredFor(hr - hd);
+        return (byte)(num_bytes_for_hd + num_bytes_for_delta + 1);
+    }
+
+    public static long makeLong(byte[] buf, int offset, int bytes_to_read) {
+        long retval=0;
+        for(int i=0; i < bytes_to_read; i++) {
+            byte b=buf[offset + i];
+            retval |= ((long)b & 0xff) << (i * 8);
+        }
+        return retval;
+    }
+
+    public static int makeInt(byte[] buf, int offset, int bytes_to_read) {
+        int retval=0;
+        for(int i=0; i < bytes_to_read; i++) {
+            byte b=buf[offset + i];
+            retval |= ((int)b & 0xff) << (i * 8);
+        }
+        return retval;
+    }
+
+
+
+    // -------------------- float ----------------------- //
+
+    /**
+     * Writes a float to a ByteBuffer
+     * @param num the float to be written
+     * @param buf the buffer
+     */
+    public static void writeFloat(float num, ByteBuffer buf) {
+        writeInt(Float.floatToIntBits(num), buf);
+    }
+
+    /**
+     * Writes a float to an output stream
+     * @param num the float to be written
+     * @param out the output stream
+     */
+    public static void writeFloat(float num, DataOutput out) throws IOException {
+        writeInt(Float.floatToIntBits(num), out);
+    }
+
+    public static void writeFloat(float num, byte[] buf, int offset) {
+        writeInt(Float.floatToIntBits(num), buf, offset);
+    }
+
+    /**
+     * Reads a a float from a buffer.
+     * @param buf the buffer
+     * @return the float read from the buffer
+     */
+    public static float readFloat(ByteBuffer buf) {
+        return Float.intBitsToFloat(readInt(buf));
+    }
+
+    /**
+     * Reads a a float from an input stream.
+     * @param in the input stream
+     * @return the float read from the input stream
+     */
+    public static float readFloat(DataInput in) throws IOException {
+        return Float.intBitsToFloat(readInt(in));
+    }
+
+    public static float readFloat(byte[] buf, int offset) {
+        return Float.intBitsToFloat(readInt(buf, offset));
+    }
+
+
+    /**
+     * Computes the size of a variable-length encoded float
+     * @param num the float
+     * @return the number of bytes needed to variable-length encode num
+     */
+    public static int size(float num) {
+        return size(Float.floatToIntBits(num));
+    }
+
+
+
+    // -------------------- double ---------------------- //
+
+    /**
+     * Writes a double to a ByteBuffer
+     * @param num the double to be written
+     * @param buf the buffer
+     */
+    public static void writeDouble(double num, ByteBuffer buf) {
+        writeLong(Double.doubleToLongBits(num), buf);
+    }
+
+    /**
+     * Writes a double to an output stream
+     * @param num the double to be written
+     * @param out the output stream
+     */
+    public static void writeDouble(double num, DataOutput out) throws IOException {
+        writeLong(Double.doubleToLongBits(num), out);
+    }
+
+    public static void writeDouble(double num, byte[] buf, int offset) {
+        writeLong(Double.doubleToLongBits(num), buf, offset);
+    }
+
+
+    /**
+     * Reads a double from a buffer.
+     * @param buf the buffer
+     * @return the double read from the buffer
+     */
+    public static double readDouble(ByteBuffer buf) {
+        return Double.longBitsToDouble(readLong(buf));
+    }
+
+    /**
+     * Reads a double from an input stream
+     * @param in the input stream
+     * @return the double read from the input stream
+     */
+    public static double readDouble(DataInput in) throws IOException {
+        return Double.longBitsToDouble(readLong(in));
+    }
+
+    public static double readDouble(byte[] buf, int offset) {
+        return Double.longBitsToDouble(readLong(buf, offset));
+    }
+
+    /**
+     * Computes the size of a variable-length encoded double
+     * @param num the double
+     * @return the number of bytes needed to variable-length encode num
+     */
+    public static int size(double num) {
+        return size(Double.doubleToLongBits(num));
+    }
+
+
+
+
+    // -------------------- String ---------------------- //
+
+    /**
+     * Writes a string to buf. The length of the string is written first, followed by the chars (as single-byte values).
+     * Multi-byte values are truncated: only the lower byte of each multi-byte char is written, similar to
+     * {@link DataOutput#writeChars(String)}.
+     * @param s the string
+     * @param buf the buffer
+     */
+    public static void writeString(String s, ByteBuffer buf) {
+        buf.put((byte)(s != null? 1 : 0));
+        if(s != null) {
+            byte[] bytes=s.getBytes();
+            writeInt(bytes.length, buf);
+            buf.put(bytes);
+        }
+    }
+
+    /**
+     * Writes a string to buf. The length of the string is written first, followed by the chars (as single-byte values).
+     * Multi-byte values are truncated: only the lower byte of each multi-byte char is written, similar to
+     * {@link DataOutput#writeChars(String)}.
+     * @param s the string
+     * @param out the output stream
+     */
+    public static void writeString(String s, DataOutput out) throws IOException {
+        if(s != null) {
+            out.write(1);
+            out.writeUTF(s);
+        }
+        else
+            out.write(0);
+    }
+
+    /**
+     * Reads a string from buf. The length is read first, followed by the chars. Each char is a single byte
+     * @param buf the buffer
+     * @return the string read from buf
+     */
+    public static String readString(ByteBuffer buf) {
+        if(buf.get() == 0)
+            return null;
+        int len=readInt(buf);
+        byte[] bytes=new byte[len];
+        buf.get(bytes);
+        return new String(bytes);
+    }
+
+    /**
+     * Reads a string from buf. The length is read first, followed by the chars. Each char is a single byte
+     * @param in the input stream
+     * @return the string read from buf
+     */
+    public static String readString(DataInput in) throws IOException {
+        int b=in.readByte();
+        if(b == 1)
+            return in.readUTF();
+        return null;
+    }
+
+
+    /**
+     * Measures the number of bytes required to encode a string, taking multibyte characters into account. Measures
+     * strings written by {@link DataOutput#writeUTF(String)}.
+     * @param str the string
+     * @return the number of bytes required for encoding str
+     */
+    public static int sizeUTF(String str) {
+        int len=str != null? str.length() : 0, utflen=2;
+        if(len == 0)
+            return utflen;
+        for(int i = 0; i < len; i++) {
+           int  c=str.charAt(i);
+            if((c >= 0x0001) && (c <= 0x007F))
+                utflen++;
+            else if (c > 0x07FF)
+                utflen += 3;
+            else
+                utflen += 2;
+        }
+        return utflen;
+    }
+
+    public static int size(String str) {
+        if(str == null)
+            return Global.BYTE_SIZE;
+        byte[] bytes=str.getBytes();
+        return Global.BYTE_SIZE + size(bytes.length) + bytes.length;
+    }
+
+
+
+    // ------------------ AsciiString ------------------- //
+    /**
+     * Writes an AsciiString to buf. The length of the string is written first, followed by the chars (as single-byte values).
+     * @param s the string
+     * @param buf the buffer
+     */
+    public static void writeAsciiString(AsciiString s, ByteBuffer buf) {
+        short length=(short)(s != null? s.length() : -1);
+        buf.putShort(length);
+        if(s != null)
+            buf.put(s.chars());
+    }
+
+    /**
+     * Writes an AsciiString to buf. The length of the string is written first, followed by the chars (as single-byte values).
+     * @param s the string
+     * @param out the output stream
+     */
+    public static void writeAsciiString(AsciiString s, DataOutput out) throws IOException {
+        short length=(short)(s != null? s.length() : -1);
+        out.writeShort(length);
+        if(s != null)
+            out.write(s.chars());
+    }
+
+    /**
+     * Reads an AsciiString from buf. The length is read first, followed by the chars. Each char is a single byte
+     * @param buf the buffer
+     * @return the string read from buf
+     */
+    public static AsciiString readAsciiString(ByteBuffer buf) {
+        short len=buf.getShort();
+        if(len < 0)
+            return null;
+        AsciiString retval=new AsciiString(len);
+        buf.get(retval.chars());
+        return retval;
+    }
+
+    /**
+     * Reads an AsciiString from buf. The length is read first, followed by the chars. Each char is a single byte
+     * @param in the input stream
+     * @return the string read from buf
+     */
+    public static AsciiString readAsciiString(DataInput in) throws IOException {
+        short len=in.readShort();
+        if(len < 0)
+            return null;
+        AsciiString retval=new AsciiString(len);
+        in.readFully(retval.chars());
+        return retval;
+    }
+
+
+    /**
+     * Measures the number of bytes required to encode an AsciiSring.
+     * @param str the string
+     * @return the number of bytes required for encoding str
+     */
+    public static int size(AsciiString str) {
+        return str == null? Global.SHORT_SIZE : Global.SHORT_SIZE + str.length();
+    }
+
+
+
+    /**
+     * Encodes the number of bytes needed into a single byte. The first number is encoded in the first nibble (the
+     * first 4 bits), the second number in the second nibble
+     * @param len1 The number of bytes needed to store a long. Must be between 0 and 8
+     * @param len2 The number of bytes needed to store a long. Must be between 0 and 8
+     * @return The byte storing the 2 numbers len1 and len2
+     */
+    protected static byte encodeLength(byte len1, byte len2) {
+        byte retval=len2;
+        retval |= (len1 << 4);
+        return retval;
+    }
+
+    protected static byte[] decodeLength(byte len) {
+        return new byte[]{(byte)((len & 0xff) >> 4),(byte)(len & ~0xf0)}; // 0xf0 is the first nibble set (11110000)
+    }
+
+    protected static byte bytesRequiredFor(long number) {
+        if(number >> 56 != 0) return 8;
+        if(number >> 48 != 0) return 7;
+        if(number >> 40 != 0) return 6;
+        if(number >> 32 != 0) return 5;
+        if(number >> 24 != 0) return 4;
+        if(number >> 16 != 0) return 3;
+        if(number >>  8 != 0) return 2;
+        return 1;
+    }
+
+    protected static byte bytesRequiredFor(int number) {
+        if(number >> 24 != 0) return 4;
+        if(number >> 16 != 0) return 3;
+        if(number >>  8 != 0) return 2;
+        return 1;
+    }
+
+
+    static protected byte getByteAt(long num, int index) {
+        return (byte)((num >> (index * 8)));
+    }
+
+
+}
diff --git a/src/org/jgroups/util/MyReceiver.java b/src/org/jgroups/util/MyReceiver.java
new file mode 100644
index 0000000000..27622a88e5
--- /dev/null
+++ b/src/org/jgroups/util/MyReceiver.java
@@ -0,0 +1,35 @@
+package org.jgroups.util;
+
+import org.jgroups.Message;
+import org.jgroups.ReceiverAdapter;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * Generic receiver for a JChannel
+ * @author Bela Ban
+ * @since  3.3
+ */
+public class MyReceiver<T> extends ReceiverAdapter {
+    protected final List<T> list=new CopyOnWriteArrayList<T>();
+    protected String        name;
+    protected boolean       verbose;
+    protected boolean       raw_msgs;
+
+    public void receive(Message msg) {
+        T obj=raw_msgs? (T)msg : (T)msg.getObject();
+        list.add(obj);
+        if(verbose) {
+            System.out.println((name() != null? name() + ":" : "") + " received message from " + msg.getSrc() + ": " + obj);
+        }
+    }
+
+    public MyReceiver    rawMsgs(boolean flag) {this.raw_msgs=flag; return this;}
+    public List<T>       list()                {return list;}
+    public MyReceiver<T> verbose(boolean flag) {verbose=flag; return this;}
+    public String        name()                {return name;}
+    public MyReceiver<T> name(String name)     {this.name=name; return this;}
+    public MyReceiver<T> reset()               {list.clear(); return this;}
+    public int           size()                {return list.size();}
+}
diff --git a/src/org/jgroups/util/Util.java b/src/org/jgroups/util/Util.java
index 4ae2465779..23d09bd8c1 100644
--- a/src/org/jgroups/util/Util.java
+++ b/src/org/jgroups/util/Util.java
@@ -446,7 +446,6 @@ public static Streamable streamableFromByteBuffer(Class cl, byte[] buffer, int o
         return result;
     }
 
-
     public static byte[] collectionToByteBuffer(Collection c) throws Exception {
         byte[] result=null;
         final ByteArrayOutputStream out_stream=new ByteArrayOutputStream(512);
@@ -2643,6 +2642,64 @@ public static String sha(String source) {
         }
     }
 
+    public static String byteArrayToHexString(byte[] b) {
+        if(b == null)
+            return "null";
+        StringBuilder sb = new StringBuilder(b.length * 2);
+        for (int i = 0; i < b.length; i++){
+            int v = b[i] & 0xff;
+            if (v < 16) { sb.append('0'); }
+            sb.append(Integer.toHexString(v));
+        }
+        return sb.toString().toUpperCase();
+    }
+
+    public static int getNextHigherPowerOfTwo(int num) {
+        if(num <= 0) return 1;
+        int highestBit=Integer.highestOneBit(num);
+        return num <= highestBit? highestBit : highestBit << 1;
+    }
+
+    public static int size(byte[] buf) {
+        return buf == null? Global.BYTE_SIZE : Global.BYTE_SIZE + Global.INT_SIZE + buf.length;
+    }
+
+    /**
+     * Blocks until all channels have the same view
+     * @param timeout How long to wait (max in ms)
+     * @param interval Check every interval ms
+     * @param channels The channels which should form the view. The expected view size is channels.length.
+     * Must be non-null
+     */
+    public static void waitUntilAllChannelsHaveSameSize(long timeout, long interval, Channel... channels) throws TimeoutException {
+        int size=channels.length;
+
+        if(interval >= timeout || timeout <= 0)
+            throw new IllegalArgumentException("interval needs to be smaller than timeout or timeout needs to be > 0");
+        long target_time=System.currentTimeMillis() + timeout;
+        while(System.currentTimeMillis() <= target_time) {
+            boolean all_channels_have_correct_size=true;
+            for(Channel ch: channels) {
+                View view=ch.getView();
+                if(view == null || view.size() != size) {
+                    all_channels_have_correct_size=false;
+                    break;
+                }
+            }
+            if(all_channels_have_correct_size)
+                return;
+            Util.sleep(interval);
+        }
+        View[] views=new View[channels.length];
+        StringBuilder sb=new StringBuilder();
+        for(int i=0; i < channels.length; i++) {
+            views[i]=channels[i].getView();
+            sb.append(channels[i].getLocalAddress()).append(": ").append(views[i]).append("\n");
+        }
+        for(View view: views)
+            if(view == null || view.size() != size)
+                throw new TimeoutException("Timeout " + timeout + " kicked in, views are:\n" + sb);
+    }
 
 }
 
diff --git a/tests/junit-functional/org/jgroups/tests/SizeTest.java b/tests/junit-functional/org/jgroups/tests/SizeTest.java
index 7bb315c322..e8f51b259a 100644
--- a/tests/junit-functional/org/jgroups/tests/SizeTest.java
+++ b/tests/junit-functional/org/jgroups/tests/SizeTest.java
@@ -398,6 +398,10 @@ public void testEncryptHeader() throws Exception {
         _testSize(hdr);
         hdr=new ENCRYPT.EncryptHeader((short)2, "Hello world");
         _testSize(hdr);
+        EncryptHeader hdr2=new EncryptHeader((byte)1, new byte[]{'b','e', 'l', 'a'});
+        _testSize(hdr2);
+        hdr2=new EncryptHeader((byte)2, "Hello world".getBytes());
+        _testSize(hdr2);
     }
 
     public void testIpAddress() throws Exception {
diff --git a/tests/junit/org/jgroups/protocols/ASYM_ENCRYPT_Test.java b/tests/junit/org/jgroups/protocols/ASYM_ENCRYPT_Test.java
new file mode 100644
index 0000000000..69670c378e
--- /dev/null
+++ b/tests/junit/org/jgroups/protocols/ASYM_ENCRYPT_Test.java
@@ -0,0 +1,297 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.auth.MD5Token;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.JoinRsp;
+import org.jgroups.protocols.pbcast.NAKACK;
+import org.jgroups.protocols.pbcast.STABLE;
+import org.jgroups.stack.ProtocolStack;
+import org.jgroups.util.Util;
+
+import javax.crypto.SecretKey;
+import java.util.Arrays;
+import java.util.Vector;
+import java.util.Properties;
+
+/**
+ * Tests use cases for {@link ASYM_ENCRYPT} described in https://issues.jboss.org/browse/JGRP-2021.
+ * @author Bela Ban
+ * @since  4.0
+ */
+public class ASYM_ENCRYPT_Test extends EncryptTest {
+    protected String getProtocolName()
+    {
+        return "ASYM_ENCRYPT";
+    }
+
+    /**
+     * A non-member sends a {@link EncryptHeader#SECRET_KEY_REQ} request to the key server. Asserts that the rogue member
+     * doesn't get the secret key. If it did, it would be able to decrypt all messages from cluster members!
+     */
+    public void nonMemberGetsSecretKeyFromKeyServer() throws Exception {
+        Util.close(rogue);
+
+        rogue=new JChannel(getTestStack());
+        DISCARD discard=new DISCARD();
+        discard.setDiscardAll(true);
+        rogue.getProtocolStack().insertProtocol(discard, ProtocolStack.ABOVE, TP.class);
+        CustomENCRYPT encrypt=new CustomENCRYPT();
+        encrypt.setProperties(new Properties());
+        encrypt.init();
+
+        rogue.getProtocolStack().insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK.class);
+        rogue.connect(cluster_name); // creates a singleton cluster
+
+        assert rogue.getView().size() == 1;
+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);
+        Vector<Address> members = new Vector<Address>();
+        members.add(a.getLocalAddress());
+        members.add(b.getLocalAddress());
+        members.add(c.getLocalAddress());
+        members.add(rogue.getLocalAddress());
+        View rogue_view=new View(a.getLocalAddress(), a.getView().getVid().getId(), members);
+        gms.installView(rogue_view);
+
+
+        // now fabricate a KEY_REQUEST message and send it to the key server (A)
+        Message newMsg=new Message(a.getLocalAddress(), rogue.getLocalAddress(), encrypt.getKeyPair().getPublic().getEncoded());
+        newMsg.putHeader(encrypt.getName(),new EncryptHeader(EncryptHeader.SECRET_KEY_REQ, encrypt.getSymVersion()));
+
+        discard.setDiscardAll(false);
+        System.out.printf("-- sending KEY_REQUEST to key server %s\n", a.getLocalAddress());
+        encrypt.getDownProtocol().down(new Event(Event.MSG, newMsg));
+        for(int i=0; i < 10; i++) {
+            SecretKey secret_key=encrypt.key;
+            if(secret_key != null)
+                break;
+            Util.sleep(500);
+        }
+
+        discard.setDiscardAll(true);
+        Vector<Address> rogueMember = new Vector<Address>();
+        rogueMember.add(rogue.getLocalAddress());
+        gms.installView(new View(rogue.getLocalAddress(), 20, rogueMember));
+        System.out.printf("-- secret key is %s (should be null)\n", encrypt.key);
+        assert encrypt.key == null : String.format("should not have received secret key %s", encrypt.key);
+    }
+
+
+
+    /** Verifies that a non-member (non-coord) cannot send a JOIN-RSP to a member */
+    public void nonMemberInjectingJoinResponse() throws Exception {
+        Util.close(rogue);
+        rogue=create();
+        ProtocolStack stack=rogue.getProtocolStack();
+        AUTH auth=(AUTH)stack.findProtocol(AUTH.class);
+        auth.setAuthToken(new MD5Token("unknown_pwd"));
+        GMS gms=(GMS)stack.findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(1);
+        DISCARD discard=new DISCARD();
+        discard.setDiscardAll(true);
+        stack.insertProtocol(discard, ProtocolStack.ABOVE, TP.class);
+        rogue.connect(cluster_name);
+        assert rogue.getView().size() == 1;
+        discard.setDiscardAll(false);
+        stack.removeProtocol("NAKACK");
+        stack.removeProtocol("UNICAST");
+
+        Vector<Address> members = new Vector<Address>();
+        members.add(a.getLocalAddress());
+        members.add(b.getLocalAddress());
+        members.add(c.getLocalAddress());
+        members.add(rogue.getLocalAddress());
+        View rogue_view=new View(a.getLocalAddress(), a.getView().getVid().getId() +5, members);
+        JoinRsp join_rsp=new JoinRsp(rogue_view, null);
+        GMS.GmsHeader gms_hdr=new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP, join_rsp);
+        Message rogue_join_rsp=new Message(b.getLocalAddress(), rogue.getLocalAddress(), null);
+        rogue_join_rsp.putHeader(GMS.name, gms_hdr);
+        rogue_join_rsp.setFlag(Message.NO_RELIABILITY); // bypasses NAKACK / UNICAST
+        rogue.down(new Event(Event.MSG, rogue_join_rsp));
+        for(int i=0; i < 10; i++) {
+            if(b.getView().size() > 3)
+                break;
+            Util.sleep(500);
+        }
+        assert b.getView().size() == 3 : String.format("B's view is %s, but should be {A,B,C}", b.getView());
+    }
+
+
+
+    /** The rogue node has an incorrect {@link AUTH} config (secret) and can thus not join */
+    public void rogueMemberCannotJoinDueToAuthRejection() throws Exception {
+        Util.close(rogue);
+        rogue=create();
+        AUTH auth=(AUTH)rogue.getProtocolStack().findProtocol(AUTH.class);
+        auth.setAuthToken(new MD5Token("unknown_pwd"));
+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(2);
+        rogue.connect(cluster_name);
+        System.out.printf("Rogue's view is %s\n", rogue.getView());
+        assert rogue.getView().size() == 1 : String.format("rogue should have a singleton view of itself, but doesn't: %s", rogue.getView());
+    }
+
+
+    public void mergeViewInjectionByNonMember() throws Exception {
+        Util.close(rogue);
+        rogue=create();
+        AUTH auth=(AUTH)rogue.getProtocolStack().findProtocol(AUTH.class);
+        auth.setAuthToken(new MD5Token("unknown_pwd"));
+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(1);
+        rogue.connect(cluster_name);
+
+        Vector<Address> members = new Vector<Address>();
+        members.add(a.getLocalAddress());
+        members.add(b.getLocalAddress());
+        members.add(c.getLocalAddress());
+        members.add(rogue.getLocalAddress());
+        MergeView merge_view=new MergeView(a.getLocalAddress(), a.getView().getVid().getId()+5, members, null);
+        GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.INSTALL_MERGE_VIEW, merge_view);
+        Message merge_view_msg=new Message(null);
+        merge_view_msg.putHeader(GMS.name, hdr);
+        merge_view_msg.setFlag(Message.NO_RELIABILITY);
+        System.out.printf("** %s: trying to install MergeView %s in all members\n", rogue.getLocalAddress(), merge_view);
+        rogue.down(new Event(Event.MSG, merge_view_msg));
+
+        // check if A, B or C installed the MergeView sent by rogue:
+        for(int i=0; i < 10; i++) {
+            boolean rogue_views_installed=false;
+
+            for(JChannel ch: Arrays.asList(a,b,c))
+                if(ch.getView().containsMember(rogue.getLocalAddress()))
+                    rogue_views_installed=true;
+            if(rogue_views_installed)
+                break;
+            Util.sleep(500);
+        }
+        for(JChannel ch: Arrays.asList(a,b,c))
+            System.out.printf("%s: %s\n", ch.getLocalAddress(), ch.getView());
+        for(JChannel ch: Arrays.asList(a,b,c))
+            assert !ch.getView().containsMember(rogue.getLocalAddress());
+    }
+
+
+    /** Tests that when {ABC} -> {AB}, neither A nor B can receive a message from non-member C */
+    public void testMessagesByLeftMember() throws Exception {
+        Vector<Address> members = new Vector<Address>();
+        members.add(a.getLocalAddress());
+        members.add(b.getLocalAddress());
+        View view=new View(a.getLocalAddress(), a.getView().getVid().getId()+1, members);
+        for(JChannel ch: Arrays.asList(a,b)) {
+            GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);
+            gms.installView(view);
+        };
+        printView(a,b,c);
+        c.getProtocolStack().removeProtocol("NAKACK"); // to prevent A and B from discarding C as non-member
+
+        Util.sleep(1000); // give members time to handle the new view
+        c.send(new Message(null, null, "hello world from left member C!"));
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 0 || rb.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert ra.size() == 0 : String.format("A: received msgs from non-member C: %s", print(ra.list()));
+        assert rb.size() == 0 : String.format("B: received msgs from non-member C: %s", print(rb.list()));
+    }
+
+    /** Tests that a left member C cannot decrypt messages from the cluster */
+    public void testEavesdroppingByLeftMember() throws Exception {
+        printSymVersion(a,b,c);
+        Vector<Address> members = new Vector<Address>();
+        members.add(a.getLocalAddress());
+        members.add(b.getLocalAddress());
+        View view=new View(a.getLocalAddress(), a.getView().getVid().getId()+1, members);
+         for(JChannel ch: Arrays.asList(a,b)) {
+            GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);
+            gms.installView(view);
+        };
+        printView(a,b,c);
+        c.getProtocolStack().removeProtocol("NAKACK"); // to prevent A and B from discarding C as non-member
+        Util.waitUntilAllChannelsHaveSameSize(10000, 500, a,b);
+
+        // somewhat of a kludge as we don't have UNICAST: if we didn't remove C's connection to A, C might retransmit
+        // the JOIN-REQ to A and get added to the cluster, so the code below would fail as C would be able to eavesdrop
+        // on A and B
+        UNICAST uni=(UNICAST)c.getProtocolStack().findProtocol(UNICAST.class);
+        uni.removeConnection(a.getLocalAddress());
+        Util.sleep(5000); // give members time to handle the new view
+
+        printView(a,b,c);
+        printSymVersion(a,b,c);
+        a.send(new Message(null, null, "hello from A"));
+        b.send(new Message(null, null, "hello from B"));
+
+        for(int i=0; i < 10; i++) {
+            if(rc.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert rc.size() == 0 : String.format("C: received msgs from cluster: %s", print(rc.list()));
+    }
+
+
+    protected JChannel create() throws Exception {
+        JChannel ch=new JChannel(getTestStack());
+        ProtocolStack stack=ch.getProtocolStack();
+        EncryptBase encrypt=createENCRYPT();
+        stack.insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK.class);
+        AUTH auth=new AUTH();
+        auth.setAuthCoord(true);
+        auth.setAuthToken(new MD5Token("mysecret")); // .setAuthCoord(false);
+        stack.insertProtocol(auth, ProtocolStack.BELOW, GMS.class);
+        GMS gms = (GMS)stack.findProtocol(GMS.class);
+        gms.setJoinTimeout(1000); // .setValue("view_ack_collection_timeout", 10);
+        STABLE stable=((STABLE)stack.findProtocol(STABLE.class));
+        stable.setDesiredAverageGossip(1000);
+        stable.setMaxBytes(500);
+        return ch;
+    }
+
+    protected void printSymVersion(JChannel ... channels) {
+        for(JChannel ch: channels) {
+            ASYM_ENCRYPT encr=(ASYM_ENCRYPT)ch.getProtocolStack().findProtocol(ASYM_ENCRYPT.class);
+            byte[] sym_version=encr.getSymVersion();
+            System.out.printf("sym-version %s: %s\n", ch.getLocalAddress(), Util.byteArrayToHexString(sym_version));
+        }
+    }
+
+    protected void printView(JChannel ... channels) {
+        for(JChannel ch: channels)
+            System.out.printf("%s: %s\n", ch.getLocalAddress(), ch.getView());
+    }
+
+
+    // Note that setting encrypt_entire_message to true is critical here, or else some of the tests in this
+    // unit test would fail!
+    protected ASYM_ENCRYPT createENCRYPT() throws Exception {
+        ASYM_ENCRYPT encrypt=new ASYM_ENCRYPT();
+        Properties props=new Properties();
+        props.put("encrypt_entire_message", "true");
+        props.put("sign_msgs", "true");
+        encrypt.setProperties(props);
+        encrypt.init();
+        return encrypt;
+    }
+
+
+
+    protected static class CustomENCRYPT extends ASYM_ENCRYPT {
+        protected SecretKey key;
+
+        protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+            if(hdr.getType() == EncryptHeader.SECRET_KEY_RSP) {
+                try {
+                    key=decodeKey(msg.getBuffer());
+                    System.out.printf("received secret key %s !\n", key);
+                }
+                catch(Exception e) {
+                    e.printStackTrace();
+                }
+            }
+            return super.handleUpEvent(msg, hdr);
+        }
+    }
+}
diff --git a/tests/junit/org/jgroups/protocols/EncryptTest.java b/tests/junit/org/jgroups/protocols/EncryptTest.java
new file mode 100644
index 0000000000..f9e66bbb89
--- /dev/null
+++ b/tests/junit/org/jgroups/protocols/EncryptTest.java
@@ -0,0 +1,354 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.demos.KeyStoreGenerator;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.NAKACK;
+import org.jgroups.protocols.pbcast.NakAckHeader;
+import org.jgroups.protocols.pbcast.STABLE;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.Buffer;
+import org.jgroups.util.MyReceiver;
+import org.jgroups.util.Util;
+
+import junit.framework.TestCase;
+import javax.crypto.SecretKey;
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Vector;
+import java.util.Properties;
+
+import static java.util.Arrays.asList;
+
+
+/**
+ * Base class for tests {@link SYM_ENCRYPT_Test} and {@link ASYM_ENCRYPT_Test}
+ * @author Bela Ban
+ * @since  4.0
+ */
+
+public abstract class EncryptTest extends TestCase {
+    protected JChannel            a,b,c,rogue;
+    protected MyReceiver<Message> ra, rb, rc, r_rogue;
+    protected String              cluster_name;
+
+	protected void setUp() throws Exception {
+        this.cluster_name="jgroups.ENCRYPT_TEST";
+        a=create();
+        a.connect(cluster_name);
+        a.setReceiver(ra=new MyReceiver<Message>().name("A").rawMsgs(true));
+
+        b=create();
+        b.connect(cluster_name);
+        b.setReceiver(rb=new MyReceiver<Message>().name("B").rawMsgs(true));
+
+        c=create();
+        c.connect(cluster_name);
+        c.setReceiver(rc=new MyReceiver<Message>().name("C").rawMsgs(true));
+
+        Util.waitUntilAllChannelsHaveSameSize(10000, 500, a,b,c);
+        rogue=createRogue();
+        rogue.connect(cluster_name);
+        for(JChannel ch: asList(a,b,c))
+            System.out.printf("%s: %s\n", ch.getLocalAddress(), ch.getView());
+        System.out.println("");
+    }
+
+	protected void tearDown() throws Exception {
+        Util.close(c, b, a, rogue);
+    }
+
+    protected abstract JChannel create() throws Exception;
+    protected abstract String getProtocolName();
+
+
+    /** Tests A,B or C sending messages and their reception by everyone in cluster {A,B,C} */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testRegularMessageReception() throws Exception {
+        a.send(new Message(null, null, "Hello from A"));
+        b.send(new Message(null, null, "Hello from B"));
+        c.send(new Message(null, null, "Hello from C"));
+        for(int i=0; i < 20; i++) {
+            if(ra.size() == 3 && rb.size() == 3 && rc.size() == 3)
+                break;
+            stable(a,b,c);
+            Util.sleep(1000);
+        }
+        for(MyReceiver r: asList(ra,rb,rc))
+            System.out.printf("%s: %s\n", r.name(), print(r.list()));
+        assertSize(3);
+    }
+
+    /** Same as above, but all messages are 0-length */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testRegularMessageReceptionWithEmptyMessages() throws Exception {
+        a.send(new Message(null));
+        b.send(new Message(null));
+        c.send(new Message(null));
+        for(int i=0; i < 20; i++) {
+            if(ra.size() == 3 && rb.size() == 3 && rc.size() == 3)
+                break;
+            stable(a,b,c);
+            Util.sleep(100);
+        }
+        for(MyReceiver r: asList(ra,rb,rc))
+            System.out.printf("%s: %s\n", r.name(), print(r.list()));
+        assertSize(3);
+    }
+
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testChecksum() throws Exception {
+        EncryptBase encrypt=(EncryptBase)a.getProtocolStack().findProtocol(EncryptBase.class);
+
+        byte[] buffer="Hello world".getBytes();
+        long checksum=encrypt.computeChecksum(buffer, 0, buffer.length);
+        byte[] checksum_array=encrypt.encryptChecksum(checksum);
+
+        long actual_checksum=encrypt.decryptChecksum(null, checksum_array, 0, checksum_array.length);
+        assert checksum == actual_checksum : String.format("checksum: %d, actual: %d", checksum, actual_checksum);
+    }
+
+
+    /** A rogue member should not be able to join a cluster */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testRogueMemberJoin() throws Exception {
+        Util.close(rogue);
+        rogue=new JChannel(getTestStack());
+        rogue.getProtocolStack().removeProtocol(getProtocolName());
+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(1);
+        rogue.connect(cluster_name);
+        for(int i=0; i < 10; i++) {
+            if(a.getView().size() > 3)
+                break;
+            Util.sleep(500);
+        }
+        for(JChannel ch: asList(a,b,c))
+            System.out.printf("%s: view is %s\n", ch.getLocalAddress(), ch.getView());
+        for(JChannel ch: asList(a,b,c)) {
+            View view=ch.getView();
+            assert view.size() == 3 : "view should be {A,B,C}: " + view;
+        }
+    }
+
+
+    /** Test that A,B,C do NOT receive any message sent by a rogue node which is not member of {A,B,C} */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testMessageSendingByRogue() throws Exception {
+        rogue.send(new Message(null, null, "message from rogue"));  // tests single messages
+        Util.sleep(500);
+        for(int i=1; i <= 100; i++)              // tests message batches
+            rogue.send(new Message(null, null, "msg #" + i + " from rogue"));
+
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 0 || rb.size() > 0 || rc.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert ra.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(ra.list()));
+        assert rb.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rb.list()));
+        assert rc.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rc.list()));
+    }
+
+
+    /**
+     * R sends a message that has an encryption header and is encrypted with R's secret key (which of course is different
+     * from the cluster members' shared key as R doesn't know it). The cluster members should drop R's message as they
+     * shouldn't be able to decrypt it.
+     */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testMessageSendingByRogueUsingEncryption() throws Exception {
+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT();
+        Properties props=new Properties();
+        props.put("keystore_name", "/tmp/ignored.keystore");
+        props.put("encrypt_entire_message", "true");
+        props.put("sign_msgs", "true");
+        encrypt.setProperties(props);
+
+        SecretKey secret_key=KeyStoreGenerator.createSecretKey(encrypt.getSymAlgorithm(), encrypt.getSymKeylength());
+        encrypt.setSecretKey(secret_key);
+        encrypt.init();
+
+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, encrypt.getSymVersion());
+        Message msg=new Message(null);
+        msg.putHeader(encrypt.getName(), hdr);
+
+        byte[] buf="hello from rogue".getBytes();
+        byte[] encrypted_buf=encrypt.code(buf, 0, buf.length, false);
+        msg.setBuffer(encrypted_buf);
+        long checksum=encrypt.computeChecksum(encrypted_buf, 0, encrypted_buf.length);
+        byte[] tmp=encrypt.encryptChecksum(checksum);
+        hdr.setSignature(tmp);
+
+        rogue.send(msg);
+
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 0 || rb.size() > 0 || rc.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert ra.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(ra.list()));
+        assert rb.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rb.list()));
+        assert rc.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rc.list()));
+    }
+
+
+    /**
+     * Tests that the non-member does NOT receive messages from cluster {A,B,C}. The de-serialization of a message's
+     * payload (encrypted with the secret key of the rogue non-member) will fail, so the message is never passed up
+     * to the application.
+     */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testMessageReceptionByRogue() throws Exception {
+        rogue.setReceiver(r_rogue=new MyReceiver().rawMsgs(true));
+        a.setReceiver(null); b.setReceiver(null); c.setReceiver(null);
+        a.send(new Message(null, null, "Hello from A"));
+        b.send(new Message(null, null, "Hello from B"));
+        c.send(new Message(null, null, "Hello from C"));
+        for(int i=0; i < 10; i++) {
+            // retransmissions will add dupes to rogue as it doesn't have dupe elimination, so we could have more than
+            // 3 messages!
+            if(r_rogue.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+
+        // the non-member may have received some cluster messages, if the encrypted messages coincidentally didn't
+        // cause a deserialization exception, but it will not be able to read their contents:
+        if(r_rogue.size() > 0) {
+            System.out.printf("Rogue non-member received %d message(s), but it should not be able to read deserialize " +
+                                "the contents (this should throw exceptions below):\n", r_rogue.size());
+            for(Message msg: r_rogue.list()) {
+                try {
+                    String payload=(String)msg.getObject();
+                    assert !payload.startsWith("Hello from");
+                }
+                catch(Exception t) {
+                    System.out.printf("caught exception trying to de-serialize garbage payload into a string: %s\n", t);
+                }
+            };
+        }
+    }
+
+
+    /**
+     * Tests the scenario where the non-member R captures a message from some cluster member in {A,B,C}, then
+     * increments the NAKACK seqno and resends that message. The message must not be received by {A,B,C};
+     * it should be discarded.
+     */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testCapturingOfMessageByNonMemberAndResending() throws Exception {
+        rogue.setReceiver(new ReceiverAdapter() {
+            public void receive(Message msg) {
+                System.out.printf("rogue: modifying and resending msg %s, hdrs: %s\n", msg, msg.printHeaders());
+                rogue.setReceiver(null); // to prevent recursive cycle
+                try {
+                    NakAckHeader hdr=(NakAckHeader)msg.getHeader(NAKACK.name);
+                    if(hdr != null) {
+                        long seqno=hdr.seqno;
+                        hdr.seqno = seqno+1;
+                    }
+                    else {
+                        System.out.printf("Rogue was not able to get the %s header, fabricating one with seqno=50\n", NAKACK.class.getSimpleName());
+                        NakAckHeader hdr2=new NakAckHeader(NakAckHeader.MSG, 50);
+                        msg.putHeader(NAKACK.name, hdr2);
+                    }
+
+                    rogue.send(msg);
+                }
+                catch(Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        });
+
+        a.send(new Message(null, null, "Hello world from A"));
+
+        // everybody in {A,B,C} should receive this message, but NOT the rogue's resent message
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 1 || rb.size() > 1 || rc.size() > 1)
+                break; // this should NOT happen
+            Util.sleep(500);
+        }
+
+        for(MyReceiver r: asList(ra,rb,rc))
+            System.out.printf("%s: %s\n", r.name(), print(r.list()));
+        assert ra.size() == 1 : String.format("received msgs from non-member: '%s'; this should not be the case", print(ra.list()));
+        assert rb.size() == 1 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rb.list()));
+        assert rc.size() == 1 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rc.list()));
+    }
+
+
+
+    /**
+     * Tests the case where a non-member installs a new view {rogue,A,B,C}, making itself the coordinator and therefore
+     * controlling admission of new members to the cluster etc...
+     */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testRogueViewInstallation() throws Exception {
+        final Address rogue_addr=rogue.getLocalAddress();
+        Vector<Address> members = new Vector<Address>();
+        members.add(rogue_addr);
+        members.add(a.getLocalAddress());
+        members.add(b.getLocalAddress());
+        members.add(c.getLocalAddress());
+        View rogue_view=new View(rogue_addr, a.getView().getVid().getId()+1, members);
+
+        Message view_change_msg=new Message();
+        GMS.GmsHeader hdr = new GMS.GmsHeader(GMS.GmsHeader.VIEW, rogue_view);
+        view_change_msg.putHeader(GMS.name, hdr);
+
+        rogue.send(view_change_msg);
+
+        for(int i=0; i < 10; i++) {
+            if(a.getView().size() > 3)
+                break;
+            Util.sleep(500);
+        }
+        for(JChannel ch: asList(a,b,c)) {
+            View view=ch.getView();
+            System.out.printf("%s: view is %s\n", ch.getLocalAddress(), view);
+            assert !view.containsMember(rogue_addr) : "view contains rogue member: " + view;
+        };
+    }
+
+
+    protected static JChannel createRogue() throws Exception {
+        return new JChannel("SHARED_LOOPBACK");
+    }
+
+
+    protected void assertSize(int expected_size) {
+        for(MyReceiver r: asList(ra,rb,rc))
+        assert r.size() == expected_size : String.format("expected size: %d, actual size of %s: %d", expected_size, r.name(), r.size());
+    }
+
+    protected static String print(List<Message> msgs) {
+        StringBuilder sb=new StringBuilder();
+        for(Message msg: msgs)
+            sb.append(msg.getObject()).append(" ");
+        return sb.toString();
+    }
+
+    protected static String print(byte[] buf, int offset, int length) {
+        StringBuilder sb=new StringBuilder("encrypted string: ");
+        for(int i=0; i < length; i++) {
+            int ch=buf[offset+i];
+            sb.append(ch).append(' ');
+        }
+        return sb.toString();
+    }
+
+
+    protected static void stable(JChannel ... channels) {
+        for(JChannel ch: channels) {
+            STABLE stable=(STABLE)ch.getProtocolStack().findProtocol(STABLE.class);
+            stable.runMessageGarbageCollection();
+        }
+    }
+
+    public static String getTestStack() {
+        return "SHARED_LOOPBACK:PING:pbcast.NAKACK:UNICAST:pbcast.STABLE:pbcast.GMS(join_timeout=1000):FRAG2(frag_size=8000)";
+	}
+}
diff --git a/tests/junit/org/jgroups/protocols/SYM_ENCRYPT_Test.java b/tests/junit/org/jgroups/protocols/SYM_ENCRYPT_Test.java
new file mode 100644
index 0000000000..193d17c236
--- /dev/null
+++ b/tests/junit/org/jgroups/protocols/SYM_ENCRYPT_Test.java
@@ -0,0 +1,52 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Global;
+import org.jgroups.JChannel;
+import org.jgroups.protocols.pbcast.NAKACK;
+import org.jgroups.stack.ProtocolStack;
+import org.jgroups.util.Util;
+
+import java.util.Properties;
+
+/**
+ * Tests use cases for {@link SYM_ENCRYPT} described in https://issues.jboss.org/browse/JGRP-2021.
+ * Make sure you create the keystore before running this test (ant make-keystore).
+ * @author Bela Ban
+ * @since  4.0
+ */
+public class SYM_ENCRYPT_Test extends EncryptTest {
+    protected static final String DEF_PWD="changeit";
+ 
+    protected String getProtocolName()
+    {
+        return "SYM_ENCRYPT";
+    }
+
+    protected JChannel create() throws Exception {
+        JChannel ch=new JChannel(getTestStack());
+        SYM_ENCRYPT encrypt;
+        try {
+            encrypt=createENCRYPT("keystore/defaultStore.keystore", DEF_PWD);
+        }
+        catch(Throwable t) {
+            encrypt=createENCRYPT("defaultStore.keystore", DEF_PWD);
+        }
+        ch.getProtocolStack().insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK.class);
+        return ch;
+    }
+
+    // Note that setting encrypt_entire_message to true is critical here, or else some of the tests in this
+    // unit test would fail!
+    protected SYM_ENCRYPT createENCRYPT(String keystore_name, String store_pwd) throws Exception {
+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT();
+        Properties props=new Properties();
+        props.put("keystore_name", keystore_name);
+        props.put("alias", "myKey");
+        props.put("store_password", store_pwd);
+        props.put("encrypt_entire_message", "true");
+        props.put("sign_msgs", "true");
+        encrypt.setProperties(props);
+        encrypt.init();
+        return encrypt;
+    }
+}
