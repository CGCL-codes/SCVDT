diff --git a/conf/EncryptKeyStore.xml b/conf/EncryptKeyStore.xml
deleted file mode 100644
index 278eb8afe5..0000000000
--- a/conf/EncryptKeyStore.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<!-- ************ JGroups Protocol Stack Configuration ************** -->
-<!-- generated by XmlConfigurator on Sun Jul 11 18:11:47 BST 2004 -->
-<!-- input file: jGroupsEncryptedServerConfig.xml -->
- 
-<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-        xmlns="urn:org:jgroups"
-        xsi:schemaLocation="urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd">
-    <UDP/>
-    <PING/>
-    <MERGE3/>
-    <FD/>
-    <VERIFY_SUSPECT/>
-    <pbcast.NAKACK2/>
-    <UNICAST3/>
-    <pbcast.STABLE/>
-    <FRAG2/>
-    <ENCRYPT key_store_name="defaultStore.keystore" store_password="changeit" alias="myKey"/>
-    <pbcast.GMS/>
-    <pbcast.STATE_TRANSFER/>
-</config>
diff --git a/conf/EncryptNoKeyStore.xml b/conf/EncryptNoKeyStore.xml
deleted file mode 100644
index 763467b331..0000000000
--- a/conf/EncryptNoKeyStore.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<!-- ************ JGroups Protocol Stack Configuration ************** -->
-<!-- generated by XmlConfigurator on Sun Jul 11 18:11:47 BST 2004 -->
-<!-- input file: jGroupsEncryptedServerConfig.xml -->
-
-<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-        xmlns="urn:org:jgroups"
-        xsi:schemaLocation="urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd">
-    <UDP/>
-    <PING/>
-    <MERGE3/>
-    <FD/>
-    <VERIFY_SUSPECT/>
-    <pbcast.NAKACK2/>
-    <UNICAST3/>
-    <pbcast.STABLE/>
-    <FRAG2/>
-    <pbcast.GMS/>
-    <ENCRYPT sym_init="56" sym_algorithm="Blowfish" asym_init="512" asym_algorithm="RSA"/>
-    <pbcast.STATE_TRANSFER/>
-</config>
diff --git a/conf/asym-encrypt.xml b/conf/asym-encrypt.xml
new file mode 100644
index 0000000000..8b9a93d34d
--- /dev/null
+++ b/conf/asym-encrypt.xml
@@ -0,0 +1,29 @@
+
+<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+        xmlns="urn:org:jgroups"
+        xsi:schemaLocation="urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd">
+    <UDP />
+    <PING/>
+    <MERGE3/>
+    <FD_ALL timeout="5000"/>
+    <FD_SOCK/>
+    <VERIFY_SUSPECT/>
+
+    <!-- Asymmetric encryption using public/private encryption to fetch the shared secret key -->
+    <ASYM_ENCRYPT
+            encrypt_entire_message="true"
+            sym_keylength="128"
+            sym_algorithm="AES/ECB/PKCS5Padding"
+            asym_keylength="512"
+            asym_algorithm="RSA"/>
+
+    <pbcast.NAKACK2/>
+    <UNICAST3/>
+    <pbcast.STABLE/>
+    <FRAG2/>
+    <!-- AUTH below is required by ASYM_ENCRYPT -->
+    <AUTH auth_class="org.jgroups.auth.MD5Token"
+          auth_value="chris"
+          token_hash="MD5"/>
+    <pbcast.GMS join_timeout="2000" />
+</config>
diff --git a/conf/encrypt-entire-message.xml b/conf/encrypt-entire-message.xml
deleted file mode 100644
index 61869a4a42..0000000000
--- a/conf/encrypt-entire-message.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<!-- ************ JGroups Protocol Stack Configuration ************** -->
-<!-- This encrypts the entire message, even UNICAST3 and NAKACK headers (to reveal sequence numbers).
-     Note that ENCRYPT could be placed even lower, e.g. just above UDP -->
-
-<config xmlns="urn:org:jgroups"
-        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-        xsi:schemaLocation="urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd">
-    <UDP/>
-    <PING/>
-    <MERGE3/>
-    <FD/>
-    <VERIFY_SUSPECT/>
-    <pbcast.NAKACK2/>
-    <UNICAST3/>
-    <pbcast.STABLE/>
-    <FRAG2/>
-    <pbcast.GMS/>
-    <ENCRYPT encrypt_entire_message="false" sym_init="128" sym_algorithm="AES/ECB/PKCS5Padding" asym_init="512" asym_algorithm="RSA"/>
-</config>
\ No newline at end of file
diff --git a/conf/encrypt.xml b/conf/encrypt.xml
index 5a59936d39..5770ffa72c 100644
--- a/conf/encrypt.xml
+++ b/conf/encrypt.xml
@@ -1,19 +1,36 @@
-<!-- ************ JGroups Protocol Stack Configuration ************** -->
-<!-- generated by XmlConfigurator on Mon Apr 26 11:19:00 PDT 2004 -->
-<!-- input file: encrypt.old.xml -->
 
 <config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="urn:org:jgroups"
         xsi:schemaLocation="urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd">
-    <UDP/>
+    <UDP />
     <PING/>
     <MERGE3/>
-    <FD/>
+    <FD_ALL timeout="5000"/>
+    <FD_SOCK/>
     <VERIFY_SUSPECT/>
+
+    <!-- Symmetric encryption with a keystore -->
+    <!--SYM_ENCRYPT
+        provider="SunJCE"
+        sym_algorithm="AES"
+        encrypt_entire_message="true"
+        keystore_name="/home/bela/JGroups/keystore/defaultStore.keystore" 
+        store_password="changeit" alias="myKey"/-->
+    <!-- Asymmetric encryption using public/private encryption to fetch the shared secret key -->
+    <ASYM_ENCRYPT
+            encrypt_entire_message="true"
+            sym_keylength="128"
+            sym_algorithm="AES/ECB/PKCS5Padding"
+            asym_keylength="512"
+            asym_algorithm="RSA"/>
+
     <pbcast.NAKACK2/>
     <UNICAST3/>
     <pbcast.STABLE/>
     <FRAG2/>
-    <pbcast.GMS/>
-    <ENCRYPT encrypt_entire_message="false" sym_init="128" sym_algorithm="AES/ECB/PKCS5Padding" asym_init="512" asym_algorithm="RSA"/>
-</config>
\ No newline at end of file
+
+    <AUTH auth_class="org.jgroups.auth.MD5Token"
+          auth_value="chris"
+          token_hash="MD5"/>
+    <pbcast.GMS join_timeout="2000" />
+</config>
diff --git a/conf/jg-magic-map.xml b/conf/jg-magic-map.xml
index 90c96e23c0..dfb1425aae 100644
--- a/conf/jg-magic-map.xml
+++ b/conf/jg-magic-map.xml
@@ -22,7 +22,6 @@
     <class id="53"  name="org.jgroups.protocols.COMPRESS$CompressHeader"/>
     <class id="54"  name="org.jgroups.protocols.FcHeader"/>
     <class id="56"  name="org.jgroups.protocols.TpHeader"/>
-    <class id="57"  name="org.jgroups.protocols.ENCRYPT$EncryptHeader"/>
     <class id="58"  name="org.jgroups.protocols.SEQUENCER$SequencerHeader"/>
     <class id="61"  name="org.jgroups.protocols.FD_ALL$HeartbeatHeader"/>
     <class id="62"  name="org.jgroups.protocols.FD_ALL2$HeartbeatHeader"/>
@@ -65,5 +64,6 @@
     <class id="112" name="org.jgroups.protocols.SaslHeader"/>
     <class id="113" name="org.jgroups.protocols.SEQUENCER2$SequencerHeader"/>
     <class id="115" name="org.jgroups.protocols.ABP$ABPHeader"/>
+    <class id="116"  name="org.jgroups.protocols.EncryptHeader"/>
 </magic-number-class-mapping>
 
diff --git a/conf/jg-protocol-ids.xml b/conf/jg-protocol-ids.xml
index 26e4543e0d..86c1b61ffe 100644
--- a/conf/jg-protocol-ids.xml
+++ b/conf/jg-protocol-ids.xml
@@ -20,7 +20,6 @@
     <class id="21" name="org.jgroups.protocols.UDP"/>
     <class id="22" name="org.jgroups.protocols.TCP"/>
     <class id="24" name="org.jgroups.protocols.TUNNEL"/>
-    <class id="25" name="org.jgroups.protocols.ENCRYPT"/>
     <class id="26" name="org.jgroups.protocols.SEQUENCER"/>
     <class id="29" name="org.jgroups.protocols.FD_ALL"/>
     <class id="30" name="org.jgroups.protocols.FD_ALL2"/>
@@ -61,6 +60,8 @@
     <class id="73" name="org.jgroups.protocols.ABP"/>
     <class id="74" name="org.jgroups.protocols.TCP_NIO2"/>
     <class id="75" name="org.jgroups.protocols.TP"/>
+    <class id="76" name="org.jgroups.protocols.SYM_ENCRYPT"/>
+    <class id="77" name="org.jgroups.protocols.ASYM_ENCRYPT"/>
 
     <!-- IDs reserved for building blocks -->
     <class id="200" name="org.jgroups.blocks.RequestCorrelator"/> <!-- ID should be the same as Global.BLOCKS_START_ID -->
diff --git a/conf/sym-encrypt.xml b/conf/sym-encrypt.xml
new file mode 100644
index 0000000000..fb5af81175
--- /dev/null
+++ b/conf/sym-encrypt.xml
@@ -0,0 +1,30 @@
+
+
+
+<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+        xmlns="urn:org:jgroups"
+        xsi:schemaLocation="urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd">
+    <UDP />
+    <PING/>
+    <MERGE3/>
+    <FD_ALL timeout="5000"/>
+    <FD_SOCK/>
+    <VERIFY_SUSPECT/>
+
+    <!-- Symmetric encryption with a keystore -->
+    <SYM_ENCRYPT
+        provider="SunJCE"
+        sym_algorithm="AES"
+        encrypt_entire_message="true"
+        keystore_name="/home/bela/JGroups/keystore/defaultStore.keystore" 
+        store_password="changeit" alias="myKey"/>
+    <pbcast.NAKACK2/>
+    <UNICAST3/>
+    <pbcast.STABLE/>
+    <FRAG2/>
+    <!-- AUTH below is optional -->
+    <AUTH auth_class="org.jgroups.auth.MD5Token"
+          auth_value="chris"
+          token_hash="MD5"/>
+    <pbcast.GMS join_timeout="2000" />
+</config>
diff --git a/doc/ENCRYPT.html b/doc/ENCRYPT.html
deleted file mode 100644
index c024d6fc52..0000000000
--- a/doc/ENCRYPT.html
+++ /dev/null
@@ -1,204 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
- </head>
-<body>
-
-<blockquote>
-<blockquote>
-<blockquote>
-<h1>
-<b>Encryption Protocol Document</b></h1>
-</blockquote>
-</blockquote>
-</blockquote>
-<b>(Author : Steve Woodcock)</b>
-<h1>
-<b>Introduction</b></h1>
-The encryption protocol provides encryption of messages in JGroups that are generated by applications.
-There are a few requirements in order to make use of the Encryption layer.
-<ul>
-<li> A suitable Security provider is required. (see security provider instructions later)
-<li> The java.security properties need to be configured (see installation guide).
-</ul>  
-
-<br>&nbsp;
-The Encrypt layer can be used in one of two ways (the options are mutually exclusive so all participants in a JGroup must have the same settings).
-<ul>
-  <li> Option 1. Configured with a secretKey in a keystore so it can be used at any 
-  layer in JGroups without the need for a coordinator,  or if you want protection against passive 
-  monitoring but do not want the key exchange overhead and complexity. In this mode all nodes must be distributed with 
-  the same keystore file. <b>Due to issues with Sun's JCE you cannot use this option with JDK1.3</b>
-  <p>
-  <li> Option 2. Configured with only algorithms and key sizes. The Encrypt Layer in this mode should be used between the 
-  FRAG and PBCast layers in the stack. The coordinator chooses the
-  secretkey which it distributes amongst all the peers. In this form no keystore exists as the keys are 
- the key is generated and distributed by the controller using a public/private key exchange. View changes that identify a new controller will result in a new session key 
-  being generated and then distributed to all peers. This overhead can be substantial in a an application with 
-  a reasonable peer churn. 
- </ul>
-<h1>
-<b>Installation</b></h1>
-The following steps need to be followed to make sure that ENCRYPT protocol can be used
-<br>&nbsp;
-<h2>Installing a Security Provider</h2>
-
-First you need to download an appropriate security provider. A good option is an organisation called bouncycastle, who 
-provide an open-source clean room implementation of the JCE. You can find them at www.bouncycastle.org.<br>
-You must download the correct jar file for the JDK you are using - at the time of writing 
-the 1.3 version is: jce-jdk13-124.jar and the 1.4 version is: bcprov-jdk14-124.jar. <br>
-You do not have to use the bouncycastle provider - others available include those from Phaos Technology,
-RSA and Wedgetail Communications. See the appropriate documentation for each provider.
-<p>
-If you are using 1.3 you must also install the SUN JCE provider (current version 1.2.2) to give access to the JCEKS keystore 
-formats. This can be downloaded from the www.javasoft.com site. The following instructions are for JDK1.3 and 1.4.<p>
-
-
-Assuming <b>$JAVA_HOME</b> to be the JDK the installation root.<p>
-
-
-<h3>JDK 1.3</h3>
-Download the SunJCE file.<br>
-Unzip the file and place the jar files contained in the jce/lib folder in the 
-<b>$JAVA_HOME/jre/lib/ext </b>directory<br>
-
-
-Place the bouncycastle provider in the <b>$JAVA_HOME/jre/lib/ext</b> directory.<p>
-
-Next configure the security file to add the new providers.
-<ul>
-<li>Open the <b>java.security</b> file in <b>$JAVA_HOME/jre/lib/security</b>.</li>
-
-<li>
-Search for <b>security.provider.{list}</b> in the opened file.</li>
-
-<li>
-Add the SunJCE provider as provider 2, and
-add the bouncycastle provider as the last.<br>
-</li>
-<li>
-You should end up with the entries similar to that shown below.
-<br>
-security.provider.1=sun.security.provider.Sun<br>
-security.provider.2=com.sun.crypto.provider.SunJCE<br>
-security.provider.3=com.sun.rsajca.Provider<br>
-security.provider.4=org.bouncycastle.jce.provider.BouncyCastleProvider<br>
-</li>
-</ul>
-
-<h3>JDK 1.4</h3>
-The JDK1.4 already includes the SunJCE files, so you only need to configure the bouncycastle provider.<br>
-
-
-Place the bouncycastle provider in the $JAVA_HOME/jre/lib/ext directory.<p>
-
-Next configure the security file to add the new providers.
-<ul>
-<li>Open the <b>java.security</b> file in <b>$JAVA_HOME/jre/lib/security</b>.</li>
-
-<li>
-Search for <b>security.provider.{list}</b> in the opened file.</li>
-
-<li>
-Add the bouncycastle provider as the last.<br>
-</li>
-<li>
-You should end up with similar entries as shown below.
-<br>
-security.provider.1=sun.security.provider.Sun<br>
-security.provider.2=com.sun.net.ssl.internal.ssl.Provider<br>
-security.provider.3=com.sun.rsajca.Provider<br>
-security.provider.4=com.sun.crypto.provider.SunJCE<br>
-security.provider.5=sun.security.jgss.SunProvider<br>
-security.provider.6=org.bouncycastle.jce.provider.BouncyCastleProvider<br>
-</li>
-</ul>
-<h2>Configure the Encrypt Protocol</h2>
-
-<h2>Option 1 - Using a shared keystore (JDK1.4 Only)</h2><br>
-  This is the simplest option and can be used by simply inserting the Encryption layer
-  at any point in the JGroup stack - it will encrypt all Events of a type MSG that 
-  have a non-null message buffer. The format of the JGroup XML entry in this form is:<p>
-  <b>
-  &lt;ENCRYPT key_store_name="defaultStore.keystore" store_password="changeit" alias="myKey"/&gt;<br>
-  </b><p>
-  An example bare-bones.xml file showing the keystore version can be found in the conf 
-  directory in a file called <b>EncryptKeyStore.xml</b> - you will need to generate a keystore - see the KeyStoreGenerator file in the demo directory or use the makeKeystore target in the build file.<br>
-  In order to use the Encrypt layer in this manner it is necessary to have the secretKey already generated 
-  in a keystore file. The directory containing the keystore file must be on the application's classpath.
-  You cannot create a SecretKey keystore file using the keytool application shipped with the JDK.
-  A java file called KeyStoreGenerator is included in the demo
-  package that can be used from the command line (or IDE) to generate a suitable keystore.
-  <p>
-  <b>IMPORTANT- A keystore generated under each version of the 1.4 JDK can be incompatible with other JDK versions.
-  Make sure you generate the keystore with the same JDK version as you are going to use at runtime. This is important for 1.4.2_04 and 1.4.2_05.</b><p>
-  
-  <h2>Option 2 - Dynamic Key Generation (JDK1.3/1.4)</h2><br>
-  This option is suited to an application that does not ship with a shared key but instead it is generated 
-  and distributed by the controller. The secret key is first generated by the Controller (in JGroup terms). When a view change 
-  occurs a peer will request the secret key by sending a key request with its own public key. The controller
-  encrypts the secret key with this key and sends it back to the peer who then decrypts it and installs the
-  key as its own secret key. 
-  <br>All encryption and decryption of Messages is done using this key. When a peer receives 
-  a view change that shows a different keyserver it will repeat this process - the view change event 
-  also trigger the encrypt layer to queue up and down messages until the new key is installed. 
-  The previous keys are retained so that messages sent before the view change that are queued can be decrypted 
-  if the key is different.
-  <br>
-  An example <b>EncryptNoKeyStore.xml</b> is included in the conf directory as a guide.
-  <p><p>
-  <br> Note: the current version does not support the concept of perfect forward encryption (PFE)
-  which means that if a peer leaves the group, the keys are re-generated preventing the departed peer from
-  decrypting future messages if it chooses to listen in on the group. This is not included as it really requires 
-  a suitable authentication scheme as well to make this feature useful as there is nothing to stop the peer rejoining and receiving the new
-  key. A future release will address this issue.
- 
-<h1>
-<b>Demo</b></h1>
-To test the usage of the protocol use any demo and change the xml config file to include the encrypt protocol.
-
-Starting up an application using the keystore option will result in an output similar to:
-<p>
-<blockquote>
-04-Aug-2004 21:11:38 org.jgroups.protocols.ENCRYPT setProperties<br>
-INFO: key_store_name used is defaultStore1_4.keystore<br>
-04-Aug-2004 21:11:38 org.jgroups.protocols.ENCRYPT setProperties<br>
-INFO: store_password used is not null<br>
-04-Aug-2004 21:11:39 org.jgroups.protocols.ENCRYPT setProperties<br>
-INFO: key_password used is same as store_password<br>
-04-Aug-2004 21:11:39 org.jgroups.protocols.ENCRYPT setProperties<br>
-INFO: alias used is myKey<br>
-04-Aug-2004 21:11:39 org.jgroups.protocols.ENCRYPT initSymCiphers<br>
-INFO:  Initializing symmetric ciphers<br>
-04-Aug-2004 21:11:39 org.jgroups.protocols.ENCRYPT initSymCiphers<br>
-INFO:  Initialized symmetric ciphers with secret key version �;ٺ�8=fԱ;qe2�<br>
-</blockquote>
-If you want to confirm the encryption/decryption messages then set the logging level to debug 
-for the protocol.
-
-<p>
-If you are using the encryption without a keystore you should see output similar to:
-<blockquote>
-05-Aug-2004 13:43:52 org.jgroups.protocols.ENCRYPT initSymKey<br>
-INFO:  Symmetric key generated<br>
-05-Aug-2004 13:43:53 org.jgroups.protocols.ENCRYPT initKeyPair<br>
-INFO:  asym algo initialized<br>
-05-Aug-2004 13:43:53 org.jgroups.protocols.ENCRYPT initSymCiphers<br>
-INFO:  Initializing symmetric ciphers<br>
-05-Aug-2004 13:43:53 org.jgroups.protocols.ENCRYPT initSymCiphers<br>
-INFO:  Initialized symmetric ciphers with secret key version �~6��Ɨ/h%ڤĹ<br>
-................<br>
-Later in the output you should see logging identifying that the JGroups peer has become the
-keyServer - this will be the same peer that is the group coordinator.<p>
-05-Aug-2004 13:43:55 org.jgroups.protocols.ENCRYPT up<br>
-INFO: handling view change event<br>
-05-Aug-2004 13:43:55 org.jgroups.protocols.ENCRYPT becomeKeyServer<br>
-INFO: I have become key server<br>
-
-</blockquote>
-<p>
-Note: the key version is an MD5 hash of the key in an encoded form from which you cannot get 
-the original key data.
-</body>
-</html>
diff --git a/doc/ENCRYPT1_4.html b/doc/ENCRYPT1_4.html
deleted file mode 100644
index 76b7776725..0000000000
--- a/doc/ENCRYPT1_4.html
+++ /dev/null
@@ -1,166 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-   <meta name="GENERATOR" content="Mozilla/4.79 [en] (X11; U; SunOS 5.8 sun4u) [Netscape]">
-</head>
-<body>
-
-<blockquote>
-<blockquote>
-<blockquote>
-<h1>
-<b>Encryption Protocol Document</b></h1>
-</blockquote>
-</blockquote>
-</blockquote>
-<b>(Author : Mandar Shinde)</b>
-<h1>
-<b>Introduction</b></h1>
-This document is required to be read by both the developers and the users.
-The
-<br>ENCRYPT protocol will not work by directly compiling the javagroups
-source
-<br>and then using the required "encrypt.xml" file. Since an external provider
-needs
-<br>to be used (JDK1.4 does not provider for RSA as of now), hence this
-provider
-<br>needs to be added to the users/developers security list.
-<br>&nbsp;
-<h1>
-<b>Installation</b></h1>
-The following steps need to be followed to make sure that ENCRYPT protocol
-<br>can ne used
-<br>&nbsp;
-<ul>
-<li>
-Make sure that JDK1.4 is installed, ENCRYPT will not work with any other<br>
-version under JDK1.4.</li>
-
-<li>
-After installation JDK1.4, set <b>$JAVA_HOME</b> to the installation root.</li>
-
-<li>
-<b>cd $JAVA_HOME/jre/lib/security</b>. Open <b>java.security</b> file.</li>
-
-<li>
-Search for <b>security.provider.{list}</b> in the opened file.</li>
-
-<li>
-At the end of the list <b>add</b> <b><i>Provider.{list+1}=org.bouncycastle.jce.provider.BouncyCastleProvider</i></b>.</li>
-
-<li>
-The above provider is the default provider that comes along with Javagroups;&nbsp;<br>
-users can use their own providers by adding the right provider jars in
-the classpath<br>
-and adding the provider to the required list.</li>
-
-<li>
-The <i>encrypt.xml </i>file is the default configuration on top of <i>default.xml.
-</i>Any stack can use the&nbsp;<br>
-<b>Encrypt protocol</b> by adding this stack below GMS.<br>
-&lt;protocol></li>
-
-<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&lt;protocol-name> Encryption Protocol &lt;/protocol-name>
-<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&lt;description> Protocol provides encryption to all communication &lt;/description>
-<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&lt;class-name>org.jgroups.protocols.ENCRYPT1_4&lt;/class-name>
-<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&lt;protocol-params>
-<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&lt;protocol-param name="asymInit" value="512"/>
-<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&lt;protocol-param name="symInit" value="56"/>
-<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&lt;protocol-param name="asymAlgorithm" value="RSA"/>
-<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&lt;protocol-param name="symAlgorithm" value="DES/ECB/PKCS5Padding"/>
-<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&lt;/protocol-params>
-<br>&lt;/protocol></ul>
-
-<h1>
-<b>Demo</b></h1>
-To test the usage of the protocol use any demo; I have used the Draw demo
-for this purpose;.
-<ul>
-<li>
-First up uncomment the Print protocol and comment the Encrypt protocol
-from the&nbsp;<br>
-encrypt.xml file. When the Draw demo is used, the user will see the deserialized<br>
-messages being exchanged between the 2 members.</li>
-
-<li>
-Now, uncomment the Encrypt protocol (leave the Print Protocol intact)&nbsp;
-from the protocol&nbsp;<br>
-stack. Run the same demo as above; the user will see that an ioexception
-will thrown while&nbsp;<br>
-deserializing the message because it has been encrypted by the Encrypt
-protocol.</li>
-</ul>
-<b></b>
-<h1>
-<b>How does Encrypt protocol <i>work</i></b> ?</h1>
-The mechanism used by this protocol is the oldest know way for high performing
-peer communication
-<br>protocols.&nbsp; To understand the working a couple algos need to be
-detailed; these are very basic in
-<br>today's encryption world.
-<br><b>Asymmetric algo:</b> this algo uses a set of keys; a <i><b>public-key</b>
-</i>and a <i><b>private-key</b>. </i>The<b> public-key</b> is
-<br>public; it is published to the public. The <b>private-key</b> is known
-only to the entity which makes the
-<br>public-key available. Any other entity will <b><i>encrypt a message
-</i></b>using the former&nbsp; <b><i>public-key </i></b>and the
-<br>former will&nbsp; <b><i>decrypt&nbsp; the message </i></b>using the<b><i>
-private-key.</i></b>
-<br><b>Symmetric algo</b>: this algo is the simplest known where a set
-of communication peers know a single
-<br>shared <b><i>secret-key(private-key) </i></b>and <b><i>ecrypt/decrypt
-</i></b>messages to communicate with each other.
-<br><b>Final algo : </b>It is obvious that the asym algo seems more powerful
-than the symm algo. But, the asym
-<br>algorithm is very expensive and the symm algorithm has a basic fault
-on how to distribute the key. A
-<br>combination where the asym algo is used only for handshake and distribute
-the shared key is the best bet.
-<br>Only when a member leaves does it require to re-generate a shared key.
-<br>&nbsp;
-<h1>
-<b>Step-by-Step</b></h1>
-
-<ol>
-<li>
-The first-member in the group becomes the admin and <i>generates</i> the
-<i>shared-key</i>.</li>
-
-<li>
-When a new peer requests to join, the <i>new-member</i> publishes its public-key.</li>
-
-<li>
-Using the <i>public-key</i> the admin encodes its <i>shared-key</i>.</li>
-
-<li>
-Using its own <i>private-key</i>, client decodes the <i>shared-key</i>.</li>
-
-<li>
-New member lets the admin know, it is <i>ready</i>.</li>
-
-<li>
-Members use <i>shared-key to encrypt/decrypt messages</i>.</li>
-
-<li>
-When member leaves, admin <i>regenerates</i> <i>shared-key</i>. If admin
-leaves, another member becomes admin&nbsp;<br>
-and regenerates key.</li>
-</ol>
-
-<ul>&nbsp;
-<br>&nbsp;
-<br>&nbsp;
-<br>&nbsp;</ul>
-
-</body>
-</html>
diff --git a/doc/design/MaliciousAttacks.txt b/doc/design/MaliciousAttacks.txt
new file mode 100644
index 0000000000..f73f4a961b
--- /dev/null
+++ b/doc/design/MaliciousAttacks.txt
@@ -0,0 +1,91 @@
+
+Use of encryption and authentication protocols to fend off malicious attacks
+============================================================================
+Author: Bela Ban, April 2016
+JIRA:   https://issues.jboss.org/browse/JGRP-2021
+
+The following discussion refers to the changes made in JGroups 4.0. These have been backported to the 3.6 branch, but
+the syntax looks different. However, the concepts are the same.
+
+
+
+Types of attacks handled
+------------------------
+Malicious attacks essentially include (1) non-authorized nodes being able to join a cluster and (2) non-members being
+able to communicate with cluster members.
+
+(1) is handled by AUTH which allows only authenticated nodes to join a cluster.
+
+(2) is handled by the encryption protocol (SYM_ENCRYPT or ASYM_ENCRYPT) which encrypts messages between cluster
+members such that a non-member cannot understand them.
+
+
+
+Authentication
+--------------
+Authentication is performed by AUTH. Its main use is to make sure only authenticated members can join a cluster.
+Other scenarios where a check is performed are:
+* Merging: make sure only authenticated members can merge into a new cluster
+* View installation (if enabled): views and merge views can only be installed by authenticated members
+
+So authentication makes sure that rogue nodes will never be able to be members of a cluster, be it via joining or
+merging. Note that while AUTH is optional with SYM_ENCRYPT, it is required by ASYM_ENCRYPT: there's a sanity check that
+will prevent a member to start if ASYM_ENCRYPT is present but AUTH is absent.
+
+
+
+Authorization
+-------------
+There is currently no authorization in JGroups. Once a member is admitted to the cluster (via authentication),
+it can send and receive messages to anyone.
+
+
+
+Encryption
+----------
+This is based on a shared secret key that all members of a cluster have. The key is either acquired from a shared
+keystore (symmetric encryption, below) or a new joiner fetches it from the coordinator via public/private key exchange
+(asymmetric encryption, below).
+
+A sent message is encrypted with the shared secret key by the sender and decrypted with the same secret key by the
+receiver(s).
+
+By default, the entire message (including the headers) is encrypted, but it is also possible to only encrypt the payload
+(this is configurable). If the headers are not encrypted, it is possible to use replay attacks, because the
+sequence numbers (seqnos) of a message are seen. For example, if a seqno is 50, then an attacker might copy the message,
+and increment the seqno. This is prevented by copying and _signing_ the message.
+
+A message can be signed, which is a hash over the encrypted message, encrypted with the secret key. If the hash shipped
+with a message doesn't match the hash computed over the received message, the message will be discarded by a receiver,
+and no attempt is made to decrypt it.
+
+The cost of encrypting the entire message includes serializing the entire message (including headers, flags, destination
+address etc) and encrypting it into the buffer of a new message (to the same destination). If message signing is enabled,
+the cost of computing a hashcode and encrypting it is added to the above cost.
+
+Attributes present in both symmetric and asymmetric encryption include sign_msgs and encrypt_entire_message.
+
+
+Symmetric encryption
+--------------------
+This is done by SYM_ENCRYPT. The configuration includes mainly attributes that define the keystore, e.g. keystore_name
+(name of the keystore, needs to be found on the classpath), store_password, key_password and alias.
+
+
+Asymmetric encryption
+---------------------
+Contrary to SYM_ENCRYPT, the secret key is not fetched from a shared keystore, but from the current coordinator C. After
+new member P joined the cluster (passing the join check done by AUTH), P sends a request to get the secret key
+(including P's public key) to C.
+
+C then sends the secret key back to P, encrypted with P's public key, and P decrypts it with its private key
+and installs it. From then on, P encrypts and decrypts messages using the secret key.
+
+When a member leaves, C can optionally (based on change_key_on_leave) create a new secret key, and every cluster member
+needs to fetch it again, using the public/private key exchange described above.
+
+
+
+
+
+
diff --git a/doc/manual/protocols.adoc b/doc/manual/protocols.adoc
index b4f41d2593..367d45024c 100644
--- a/doc/manual/protocols.adoc
+++ b/doc/manual/protocols.adoc
@@ -1487,149 +1487,163 @@ Read more about flushing in <<Flushing>>.
 
 ${FLUSH}
 
-[[Misc]]
 
+[[Security]]
+=== Security
 
-=== Misc
+Security is used to prevent (1) non-authorized nodes being able to join a cluster and (2) non-members being
+able to communicate with cluster members.
 
-[[STATS]]
+(1) is handled by AUTH or SASL which allows only authenticated nodes to join a cluster.
 
+(2) is handled by the encryption protocol (SYM_ENCRYPT or ASYM_ENCRYPT) which encrypts messages between cluster
+members such that a non-member cannot understand them.
 
-==== Statistics
 
-STATS exposes various statistics, e.g. number of received multicast and unicast messages, number of
-                bytes sent etc. It should be placed directly over the transport
-            
 
-${STATS}
+[[ENCRYPT]]
+==== Encryption
 
-[[Security]]
+Encryption is based on a shared secret key that all members of a cluster have. The key is either acquired from a shared
+keystore (symmetric encryption) or a new joiner fetches it from the coordinator via public/private key exchange
+(asymmetric encryption).
 
+A sender encrypts a message with the shared secret key and the receivers decrypt it with the same secret key.
 
-==== Security
+By default, the entire message (including the headers) is encrypted, but it is also possible to only encrypt the payload
+(this is configurable). If the headers are not encrypted, it is possible to use replay attacks, because the
+sequence numbers (seqnos) of a message are seen. For example, if a seqno is 50, then an attacker might copy the message,
+and increment the seqno. This is prevented by copying and _signing_ the message.
 
-JGroups provides protocols to encrypt cluster traffic (ENCRYPT), and to make sure that only
-                authorized members can join a cluster (AUTH and SASL).
-            
+A message can be signed, which is a hash over the encrypted message, encrypted with the secret key. If the hash shipped
+with a message doesn't match the hash computed over the received message, the message will be discarded by a receiver,
+and no attempt is made to decrypt it.
 
-[[ENCRYPT]]
+The cost of encrypting the entire message includes serializing the entire message (including headers, flags, destination
+address etc) and encrypting it into the buffer of a new message (to the same destination). If message signing is enabled,
+the cost of computing a hashcode and encrypting it is added to the above cost.
 
+Attributes present in both symmetric and asymmetric encryption include `sign_msgs` and `encrypt_entire_message`.
 
-===== ENCRYPT
+[[SYM_ENCRYPT]]
+===== SYM_ENCRYPT
 
-A detailed description of ENCRYPT is found in the JGroups source (__JGroups/doc/ENCRYPT.html__).
-Encryption by default only encrypts the message body, but doesn't encrypt message headers.
-To encrypt the entire message (including all headers, plus destination and source addresses),
-the property ++$$encrypt_entire_message$$++ has to be set to true.
-Also, ENCRYPT has to be below any protocols whose headers we want to encrypt, e.g.
+This is done by SYM_ENCRYPT. The configuration includes mainly attributes that define the keystore, e.g. `keystore_name`
+(name of the keystore, needs to be found on the classpath), `store_password`, `key_password` and `alias`.
 
+SYM_ENCRYPT uses store type JCEKS (for details between JKS and JCEKS see here), however `keytool` uses JKS, therefore
+a keystore generated with keytool will not be accessible.
+
+To generate a keystore compatible with JCEKS, use the following command line options to keytool:
 
-[source,xml]
 ----
-<config ... >
-    <UDP />
-    <PING />
-    <MERGE2 />
-    <FD />
-    <VERIFY_SUSPECT />
-    <pbcast.NAKACK />
-    <UNICAST />
-    <pbcast.STABLE />
-    <FRAG2 />
-    <pbcast.GMS />
-    <ENCRYPT encrypt_entire_message="false"
-             sym_init="128" sym_algorithm="AES/ECB/PKCS5Padding"
-             asym_init="512" asym_algorithm="RSA"/>
-</config>
+keytool -genseckey -alias myKey -keypass changeit -storepass changeit  -keyalg Blowfish -keysize 56 -keystore defaultStore.keystore -storetype  JCEKS
 ----
 
-Note that ENCRYPT sits below NAKACK and UNICAST, so the sequence numbers for these 2 protocols will
-                    be encrypted. Had ENCRYPT been placed below UNICAST but above NAKACK, then only UNICAST's headers
-                    (including sequence numbers) would have been encrypted, but not NAKACKs.
-                
+SYM_ENCRYPT could then be configured as follows:
 
-Note that it doesn't make too much sense to place ENCRYPT even lower in the stack, because then
-                    almost all traffic (even merge or discovery traffic) will be encrypted, which may be somewhat of
-                    a performance drag.
-                    
 
-When we encrypt an entire message, we have to marshal the message into a byte buffer first and
-                    then encrypt it. This entails marshalling and copying of the byte buffer, which is not so good
-                    performance wise...
-                
 
+[source,xml]
+----
+<SYM_ENCRYPT sym_algorithm="AES"
+             encrypt_entire_message="true"
+             key_store_name="defaultStore.keystore"
+             store_password="changeit"
+             alias="myKey"/>
+----
 
+Note that defaultStore.keystore will have to be found in the claspath.
 
-.Using a key store
-ENCRYPT uses store type JCEKS (for details between JKS and JCEKS see here), however
-                        +keytool+ uses JKS, therefore a keystore generated with keytool will not be accessible.
-                    
+NOTE: Both SYM_ENCRYPT and ASYM_ENCRYPT should be placed directly under NAKACK2
+(see link:https://github.com/belaban/JGroups/tree/master/conf[sample configurations], e.g. sym-encrypt.xml or
+asym-encrypt.xml).
 
-To generate a keystore compatible with JCEKS, use the following command line options to keytool:
-                    
 
+${SYM_ENCRYPT}
 
-----
 
-keytool -genseckey -alias myKey -keypass changeit -storepass changeit  -keyalg Blowfish -keysize 56 -keystore defaultStore.keystore -storetype  JCEKS
-                    
-----
 
-ENCRYPT could then be configured as follows:
-                    
+[[ASYM_ENCRYPT]]
+===== ASYM_ENCRYPT
+Contrary to SYM_ENCRYPT, the secret key is not fetched from a shared keystore, but from the current coordinator C. After
+new member P joined the cluster (passing the join check done by AUTH), P sends a request to get the secret key
+(including P's public key) to C.
 
+C then sends the secret key back to P, encrypted with P's public key, and P decrypts it with its private key
+and installs it. From then on, P encrypts and decrypts messages using the secret key.
 
+When a member leaves, C can optionally (based on `change_key_on_leave`) create a new secret key, and every cluster member
+needs to fetch it again, using the public/private key exchange described above.
+
+A stack configured to use asymmetric encryption could look like this:
 [source,xml]
 ----
-
-<ENCRYPT key_store_name="defaultStore.keystore"
-         store_password="changeit"
-         alias="myKey"/>
-                    
+    ...
+    <VERIFY_SUSPECT/>
+    <ASYM_ENCRYPT encrypt_entire_message="true"
+             sym_keylength="128"
+             sym_algorithm="AES/ECB/PKCS5Padding"
+             asym_keylength="512"
+             asym_algorithm="RSA"/>
+
+    <pbcast.NAKACK2/>
+    <UNICAST3/>
+    <pbcast.STABLE/>
+    <FRAG2/>
+    <AUTH auth_class="org.jgroups.auth.MD5Token"
+          auth_value="chris"
+          token_hash="MD5"/>
+    <pbcast.GMS join_timeout="2000" />
 ----
 
-Note that defaultStore.keystore will have to be found in the claspath.
-                    
+The configuration snippet shows ASYM_ENCRYPT positioned just below NAKACK2, so that headers of the important
+retransmission protocols NAKACK2 and UNICAST3 are encrypted, too. Note that AUTH should be part of the configuration, or
+else unauthenticated nodes would be able to acquire the secret key from the coordinator.
 
+${ASYM_ENCRYPT}
 
-NOTE: If asymmetric encryption is used (no shared key via keystore), ENCRYPT has to be placed somewhere _above_ GMS,
-      or else the JOIN process would not function (as the JOIN response would get dropped).
 
-${ENCRYPT}
 
-[[AUTH]]
 
 
-===== AUTH
+[[AUTH]]
+==== AUTH
+Authentication is performed by AUTH. Its main use is to make sure only authenticated members can join a cluster.
+Other scenarios where a check is performed are:
+* Merging: make sure only authenticated members can merge into a new cluster
+* View installation (if enabled): views and merge views can only be installed by authenticated members
 
-AUTH is used to provide a layer of authentication to JGroups.  This allows you to define pluggable
-                    security that defines if a node should be allowed to join a cluster.  AUTH sits below the GMS
-                    protocol and listens for JOIN REQUEST messages.  When a JOIN REQUEST is received it tries to find
-                    an AuthHeader object, inside of which should be an implementation of the AuthToken object.
-                
+So authentication makes sure that rogue nodes will never be able to be members of a cluster, be it via joining or
+merging. Note that while AUTH is optional with SYM_ENCRYPT, it is required by ASYM_ENCRYPT: there's a sanity check that
+will prevent a member to start if ASYM_ENCRYPT is present but AUTH is absent.
+
+AUTH provides pluggable security that defines if a node should be allowed to join a cluster.
+AUTH sits below the GMS protocol and listens for JOIN REQUEST messages.  When a JOIN REQUEST is received it tries to find
+an AuthHeader object, inside of which should be an implementation of the AuthToken object.
 
 AuthToken is an abstract class, implementations of which are responsible for providing the
-                    actual authentication mechanism.  Some basic implementations of AuthToken are provide in the
-                    org.jgroups.auth package (SimpleToken, MD5Token and X509Token).  Effectivly all these implementations
-                    do is encrypt a string (found in the jgroups config) and pass that on the JOIN REQUEST.
-                
+actual authentication mechanism.  Some basic implementations of AuthToken are provide in the
+org.jgroups.auth package (SimpleToken, MD5Token and X509Token).  Effectivly all these implementations
+do is encrypt a string (found in the jgroups config) and pass that on the JOIN REQUEST.
+
 
 When authentication is successful, the message is simply passed up the stack to the GMS protocol.
-                    When it fails, the AUTH protocol creates a JOIN RESPONSE message with a failure string and passes
-                    it back down the stack.  This failure string informs the client of the reason for failure.
-                    Clients will then fail to join the group and will throw a SecurityException.
-                    If this error string is null then authentication is considered to have passed.
-                
+When it fails, the AUTH protocol creates a JOIN RESPONSE message with a failure string and passes
+it back down the stack.  This failure string informs the client of the reason for failure.
+Clients will then fail to join the group and will throw a SecurityException.
+If this error string is null then authentication is considered to have passed.
+
 
 For more information refer to the wiki at http://community.jboss.org/wiki/JGroupsAUTH[AUTH].
-                
+
 
 ${AUTH}
 
 [[SASL]]
 
 
-===== SASL
+==== SASL
 
 SASL is an alternative to the AUTH protocol which provides a layer of authentication to JGroups by allowing the
                     use of one of the SASL mechanisms made available by the JDK. SASL sits below the GMS
@@ -1638,17 +1652,17 @@ SASL is an alternative to the AUTH protocol which provides a layer of authentica
                     of challenge/response messages which, if successful, culminates in allowing the new node to join the cluster. The actual
                     validation logic required by the SASL mech must be provided by the user in the form of a standard javax.security.auth.CallbackHandler
                     implementation.
-                
+
 
 When authentication is successful, the message is simply passed up the stack to the GMS protocol.
                     When it fails, the SASL protocol creates a JOIN / MERGE RESPONSE message with a failure string and passes
                     it back down the stack.  This failure string informs the client of the reason for failure.
                     Clients will then fail to join the group and will throw a SecurityException.
                     If this error string is null then authentication is considered to have passed.
-                
+
 
 SASL can be (minimally) configured as follows:
-                
+
 
 
 [source,xml]
@@ -1660,19 +1674,19 @@ SASL can be (minimally) configured as follows:
     <pbcast.NAKACK />
     <UNICAST3 />
     <pbcast.STABLE />
-    <SASL mech="DIGEST-MD5" 
-        client_callback_handler="org.example.ClientCallbackHandler" 
+    <SASL mech="DIGEST-MD5"
+        client_callback_handler="org.example.ClientCallbackHandler"
         server_callback_handler="org.example.ServerCallbackHandler"/>
     <pbcast.GMS />
-    
+
 </config>
-                
+
 ----
 
 The +mech+ property specifies the SASL mech you want to use, as defined by RFC-4422. You will also need to provide two
-                    callback handlers, one used when the node is running as coordinator (++$$server_callback_handler$$++) and one used in all other 
-                    cases (++$$client_callback_handler$$++). Refer to the JDK's SASL reference guide for more details: link:$$http://docs.oracle.com/javase/7/docs/technotes/guides/security/sasl/sasl-refguide.html$$[] 
-                
+                    callback handlers, one used when the node is running as coordinator (++$$server_callback_handler$$++) and one used in all other
+                    cases (++$$client_callback_handler$$++). Refer to the JDK's SASL reference guide for more details: link:$$http://docs.oracle.com/javase/7/docs/technotes/guides/security/sasl/sasl-refguide.html$$[]
+
 The JGroups package comes with a simple properties-based CallbackHandler which can be used when a more complex Kerberos/LDAP approach is not needed. To use this set both the (++$$server_callback_handler$$++) and
                     the (++$$client_callback_handler$$++) to org.jgroups.auth.sasl.SimpleAuthorizingCallbackHandler. This CallbackHandler can be configured either programmatically by passing to the constructor an
                     instance of java.util.Properties containing the appropriate properties, or via standard Java system properties (i.e. set on the command-line using the -DpropertyName=propertyValue notation.
@@ -1686,6 +1700,24 @@ The JGroups package comes with a simple properties-based CallbackHandler which c
 
 ${SASL}
 
+
+
+
+
+[[Misc]]
+=== Misc
+
+[[STATS]]
+==== Statistics
+
+STATS exposes various statistics, e.g. number of received multicast and unicast messages, number of
+                bytes sent etc. It should be placed directly over the transport
+            
+
+${STATS}
+
+
+
 [[COMPRESS]]
 
 
diff --git a/src/org/jgroups/Event.java b/src/org/jgroups/Event.java
index 020cbca3da..2802a1cbcf 100644
--- a/src/org/jgroups/Event.java
+++ b/src/org/jgroups/Event.java
@@ -88,14 +88,10 @@ public Event(int type, Object arg) {
         this.arg=arg;
     }
 
-    public final int getType() {
-        return type;
-    }
-
-
-    public Object getArg() {
-        return arg;
-    }
+    public int                  type()    {return type;}
+    public int                  getType() {return type;}
+    public <T extends Object> T arg()     {return (T)arg;}
+    public <T extends Object> T getArg()  {return (T)arg;}
 
 
 
diff --git a/src/org/jgroups/Message.java b/src/org/jgroups/Message.java
index 886ff396e0..0ade54e2a3 100644
--- a/src/org/jgroups/Message.java
+++ b/src/org/jgroups/Message.java
@@ -498,24 +498,9 @@ public Message putHeader(short id, Header hdr) {
         return this;
     }
 
-   /**
-    * Puts a header given a key into the map, only if the key doesn't exist yet
-    */
-    public Message putHeaderIfAbsent(short id, Header hdr) {
-        if(id <= 0)
-            throw new IllegalArgumentException("An ID of " + id + " is invalid");
-        if(hdr != null)
-            hdr.setProtId(id);
-        synchronized(this) {
-            Header[] resized_array=Headers.putHeader(this.headers, id, hdr, false);
-            if(resized_array != null)
-                this.headers=resized_array;
-        }
-        return this;
-    }
 
 
-    public Header getHeader(short id) {
+    public <T extends Header> T getHeader(short id) {
         if(id <= 0)
             throw new IllegalArgumentException("An ID of " + id + " is invalid. Add the protocol which calls " +
                                                  "getHeader() to jg-protocol-ids.xml");
diff --git a/src/org/jgroups/View.java b/src/org/jgroups/View.java
index b10999c74d..d87641dacf 100644
--- a/src/org/jgroups/View.java
+++ b/src/org/jgroups/View.java
@@ -104,9 +104,9 @@ public static View create(Address coord, long id, Address ... members) {
      * if this view was created with the empty constructur, null will be returned
      * @return the creator of this view in form of an Address object
      */
-    public Address getCreator() {
-        return view_id.getCreator();
-    }
+    public Address getCreator() {return view_id.getCreator();}
+
+    public Address getCoord() {return members.length > 0? members[0] : null;}
 
     /**
      * Returns the member list
@@ -137,6 +137,17 @@ public boolean containsMember(Address mbr) {
         return false;
     }
 
+    /** Returns true if all mbrs are elements of this view, false otherwise */
+    public boolean containsMembers(Address ... mbrs) {
+        if(mbrs == null || members == null)
+            return false;
+        for(Address mbr: mbrs) {
+            if(!containsMember(mbr))
+                return false;
+        }
+        return true;
+    }
+
 
     public int compareTo(View o) {
         return view_id.compareTo(o.view_id);
@@ -197,7 +208,6 @@ public int serializedSize() {
      * Returns a list of members which left from view one to two
      * @param one
      * @param two
-     * @return
      */
     public static List<Address> leftMembers(View one, View two) {
         if(one == null || two == null)
diff --git a/src/org/jgroups/blocks/RequestCorrelator.java b/src/org/jgroups/blocks/RequestCorrelator.java
index 9a065742e9..3dfa2a9bbb 100644
--- a/src/org/jgroups/blocks/RequestCorrelator.java
+++ b/src/org/jgroups/blocks/RequestCorrelator.java
@@ -226,19 +226,19 @@ public void done(long id) {
     public boolean receive(Event evt) {
         switch(evt.getType()) {
             case Event.VIEW_CHANGE: // adjust number of responses to wait for
-                receiveView((View)evt.getArg());
+                receiveView(evt.getArg());
                 break;
 
             case Event.SET_LOCAL_ADDRESS:
-                setLocalAddress((Address)evt.getArg());
+                setLocalAddress(evt.getArg());
                 break;
 
             case Event.MSG:
-                if(receiveMessage((Message)evt.getArg()))
+                if(receiveMessage(evt.getArg()))
                     return true; // message was consumed, don't pass it up
                 break;
             case Event.SITE_UNREACHABLE:
-                SiteMaster site_master=(SiteMaster)evt.getArg();
+                SiteMaster site_master=evt.getArg();
                 String site=site_master.getSite();
                 setSiteUnreachable(site);
                 break; // let others have a stab at this event, too
@@ -292,7 +292,7 @@ public void receiveView(View new_view) {
      * @return true if the message was consumed, don't pass it further up, else false
      */
     public boolean receiveMessage(Message msg) {
-        Header hdr=(Header)msg.getHeader(this.corr_id);
+        Header hdr=msg.getHeader(this.corr_id);
 
         // Check if the message was sent by a request correlator with the same name;
         // there may be multiple request correlators in the same protocol stack
@@ -316,7 +316,7 @@ public boolean receiveMessage(Message msg) {
 
     public void receiveMessageBatch(MessageBatch batch) {
         for(Message msg : batch) {
-            Header hdr=(Header)msg.getHeader(this.corr_id);
+            Header hdr=msg.getHeader(this.corr_id);
             if(hdr == null || hdr.corrId != this.corr_id) // msg was sent by a different request corr in the same stack
                 continue;
 
diff --git a/src/org/jgroups/demos/KeyStoreGenerator.java b/src/org/jgroups/demos/KeyStoreGenerator.java
index 67794d0c1c..76c7375940 100644
--- a/src/org/jgroups/demos/KeyStoreGenerator.java
+++ b/src/org/jgroups/demos/KeyStoreGenerator.java
@@ -1,14 +1,12 @@
 
 package org.jgroups.demos;
 
-import org.jgroups.util.Util;
-
+import javax.crypto.KeyGenerator;
+import javax.crypto.SecretKey;
 import java.io.FileOutputStream;
 import java.io.OutputStream;
 import java.security.KeyStore;
-
-import javax.crypto.KeyGenerator;
-import javax.crypto.SecretKey;
+import java.security.NoSuchAlgorithmException;
 
 /**
  * Generates a keystore file that has a SecretKey in it. It is not possible to
@@ -31,7 +29,6 @@
  * 
  */
 public final class KeyStoreGenerator {
-
     static String symAlg="AES";
     static int keySize=128;
     static String keyStoreName="defaultStore.keystore";
@@ -43,66 +40,38 @@ private KeyStoreGenerator() {
 	}
 
     public static void main(String[] args) {
-
         int i=0;
         String arg=null;
 
         while(i < args.length && args[i].startsWith("-")) {
             arg=args[i++];
-            System.out.println("Found arg of " + arg);
             if(arg.equalsIgnoreCase("--alg")) {
-                if(i < args.length) {
-                    symAlg=args[i++];
-                }
-                else {
-                    System.out.println("No Algorithm supplied using default of " + symAlg);
-                }
+                symAlg=args[i++];
+                continue;
             }
-            else if(arg.equalsIgnoreCase("--size")) {
-                if(i < args.length) {
-                    keySize=Integer.parseInt(args[i++]);
-                }
-                else {
-                    System.out.println("No Size supplied using default of " + keySize);
-                }
+            if(arg.equalsIgnoreCase("--size")) {
+                keySize=Integer.parseInt(args[i++]);
+                continue;
             }
-            else if(arg.equalsIgnoreCase("--storeName")) {
-
-                if(i < args.length) {
-                    keyStoreName=args[i++];
-                }
-                else {
-                    System.out.println("No keystore supplied using default of " + keyStoreName);
-                }
+            if(arg.equalsIgnoreCase("--storeName")) {
+                keyStoreName=args[i++];
+                continue;
             }
-            else if(arg.equalsIgnoreCase("--storePass")) {
-                if(i < args.length) {
+            if(arg.equalsIgnoreCase("--storePass")) {
                     storePass=args[i++];
-                }
-                else {
-                    System.out.println("No password supplied using default of " + storePass);
-                }
+                continue;
             }
-            else if(arg.equalsIgnoreCase("--alias")) {
-                if(i < args.length) {
-                    alias=args[i++];
-                }
-                else {
-                    System.out.println("No alias supplied using default of " + alias);
-                }
+            if(arg.equalsIgnoreCase("--alias")) {
+                alias=args[i++];
+                continue;
             }
+            help();
+            return;
         }
-        System.out.println("Creating file '" + keyStoreName
-                           + "' using Algorithm '"
-                           + symAlg
-                           + "' size '"
-                           + keySize
-                           + "'");
+        System.out.printf("Creating file '%s' using algorithm '%s' size '%d'\n", keyStoreName, symAlg, keySize);
 
-        OutputStream stream=null;
-        try {
-            stream=new FileOutputStream(keyStoreName);
-            SecretKey key=initSymKey();
+        try(OutputStream stream=new FileOutputStream(keyStoreName)) {
+            SecretKey key=createSecretKey();
             KeyStore store=KeyStore.getInstance("JCEKS");
             store.load(null, null);
             store.setKeyEntry(alias, key, storePass.toCharArray(), null);
@@ -112,29 +81,29 @@ else if(arg.equalsIgnoreCase("--alias")) {
         catch(Exception e) {
             e.printStackTrace();
         }
-        finally {
-            try {
-                Util.close(stream);
-            }
-            catch(Exception e) {
-
-            }
-        }
         System.out.println("Finished keystore creation");
     }
 
-    public static SecretKey initSymKey() throws Exception {
-        KeyGenerator keyGen=KeyGenerator.getInstance(getAlgorithm(symAlg));
-        keyGen.init(keySize);
-        return keyGen.generateKey();
+    protected static void help() {
+        System.out.println("KeyStoreGenerator [-help] [--alg algorithm] [--size size] [--storeName name] " +
+                             "[--storePass password] [--alias alias]");
+    }
 
+    public static SecretKey createSecretKey() throws Exception {
+        return createSecretKey(symAlg, keySize);
+    }
+
+    public static SecretKey createSecretKey(String sym_alg, int key_size) throws NoSuchAlgorithmException {
+        // KeyGenerator keyGen=KeyGenerator.getInstance(getAlgorithm(sym_alg));
+        KeyGenerator keyGen=KeyGenerator.getInstance(sym_alg);
+        keyGen.init(key_size);
+        return keyGen.generateKey();
     }
 
     private static String getAlgorithm(String s) {
         int index=s.indexOf('/');
         if(index == -1)
             return s;
-
         return s.substring(0, index);
     }
 }
diff --git a/src/org/jgroups/fork/ForkChannel.java b/src/org/jgroups/fork/ForkChannel.java
index f6dbfdad00..740541cd50 100644
--- a/src/org/jgroups/fork/ForkChannel.java
+++ b/src/org/jgroups/fork/ForkChannel.java
@@ -45,8 +45,8 @@
      * @param create_fork_if_absent If true, and FORK doesn't exist, a new FORK protocol will be created and inserted
      *                              into the main-stack at the given position. If false, and FORK doesn't exist, an
      *                              exception will be thrown
-     * @param position The position at which the newly created FORK will be inserted. {@link ProtocolStack#ABOVE} or
-     *                 {@link ProtocolStack#BELOW} are accepted. Ignored if create_fork_if_absent is false.
+     * @param position The position at which the newly created FORK will be inserted. {@link ProtocolStack.Position#ABOVE} or
+     *                 {@link ProtocolStack.Position#BELOW} are accepted. Ignored if create_fork_if_absent is false.
      * @param neighbor The class of the neighbor protocol below or above which the newly created FORK protocol will
      *                 be inserted. Ignored if create_fork_if_absent is false.
      * @param protocols A list of protocols (<em>from bottom to top</em> !) to insert as the fork_stack in FORK under the
@@ -58,7 +58,7 @@
      * @throws Exception
      */
     public ForkChannel(final JChannel main_channel, String fork_stack_id, String fork_channel_id,
-                       boolean create_fork_if_absent, int position, Class<? extends Protocol> neighbor,
+                       boolean create_fork_if_absent, ProtocolStack.Position position, Class<? extends Protocol> neighbor,
                        Protocol ... protocols) throws Exception {
 
         super(false);
@@ -97,7 +97,7 @@ public ForkChannel(final JChannel main_channel, String fork_stack_id, String for
      */
     public ForkChannel(final JChannel main_channel, String fork_stack_id, String fork_channel_id,
                        Protocol ... protocols) throws Exception {
-        this(main_channel, fork_stack_id, fork_channel_id, false, 0, null, protocols);
+        this(main_channel, fork_stack_id, fork_channel_id, false, ProtocolStack.Position.ABOVE, null, protocols);
     }
 
     @Override
@@ -213,7 +213,7 @@ public Object down(Event evt) {
     @Override
     public ForkChannel send(Message msg) throws Exception {
         checkClosedOrNotConnected();
-        FORK.ForkHeader hdr=(FORK.ForkHeader)msg.getHeader(FORK.ID);
+        FORK.ForkHeader hdr=msg.getHeader(FORK.ID);
         if(hdr != null)
             hdr.setForkChannelId(fork_channel_id);
         else {
@@ -270,7 +270,7 @@ protected ForkChannel setLocalAddress(Address local_addr) {
     /**
      * Creates a new FORK protocol, or returns the existing one, or throws an exception. Never returns null.
      */
-    protected static FORK getFORK(JChannel ch, int position, Class<? extends Protocol> neighbor,
+    protected static FORK getFORK(JChannel ch, ProtocolStack.Position position, Class<? extends Protocol> neighbor,
                                   boolean create_fork_if_absent) throws Exception {
         ProtocolStack stack=ch.getProtocolStack();
         FORK fork=stack.findProtocol(FORK.class);
@@ -287,7 +287,7 @@ protected static FORK getFORK(JChannel ch, int position, Class<? extends Protoco
 
 
     protected void setHeader(Message msg) {
-        FORK.ForkHeader hdr=(FORK.ForkHeader)msg.getHeader(FORK.ID);
+        FORK.ForkHeader hdr=msg.getHeader(FORK.ID);
         if(hdr != null)
             hdr.setForkChannelId(fork_channel_id);
         else
diff --git a/src/org/jgroups/protocols/ASYM_ENCRYPT.java b/src/org/jgroups/protocols/ASYM_ENCRYPT.java
new file mode 100644
index 0000000000..04811ca31c
--- /dev/null
+++ b/src/org/jgroups/protocols/ASYM_ENCRYPT.java
@@ -0,0 +1,410 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.annotations.MBean;
+import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.ManagedOperation;
+import org.jgroups.annotations.Property;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.util.AsciiString;
+import org.jgroups.util.MessageBatch;
+import org.jgroups.util.Util;
+
+import javax.crypto.Cipher;
+import javax.crypto.KeyGenerator;
+import javax.crypto.SecretKey;
+import javax.crypto.spec.SecretKeySpec;
+import java.security.*;
+import java.security.spec.X509EncodedKeySpec;
+import java.util.Arrays;
+import java.util.Objects;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+
+/**
+ * Encrypts and decrypts communication in JGroups by using a secret key distributed to all cluster members by the
+ * key server (coordinator) using asymmetric (public/private key) encryption.<br>
+ *
+ * The secret key is identical for all cluster members and is used to encrypt messages when sending and decrypt them
+ * when receiving messages.
+ *
+ * This protocol is typically placed under {@link org.jgroups.protocols.pbcast.NAKACK2}, so that most important
+ * headers are encrypted as well, to prevent replay attacks.<br>
+ *
+ * The current keyserver (always the coordinator) generates a secret key. When a new member joins, it asks the keyserver
+ * for the secret key. The keyserver encrypts the secret key with the joiner's public key and the joiner decrypts it with
+ * its private key and then installs it and starts encrypting and decrypting messages with the secret key.<br>
+ *
+ * View changes that identify a new keyserver will result in a new secret key being generated and then distributed to
+ * all cluster members. This overhead can be substantial in an application with a reasonable member churn.<br>
+ *
+ * This protocol is suited to an application that does not ship with a known key but instead it is generated and
+ * distributed by the keyserver.
+ *
+ * Since messages can only get encrypted and decrypted when the secret key was received from the keyserver, messages
+ * other then join and merge requests/responses are dropped when the secret key isn't yet available. Join and merge
+ * requests / responses are handled by {@link AUTH}.
+ *
+ * @author Bela Ban
+ * @author Steve Woodcock
+ */
+@MBean(description="Asymmetric encryption protocol. The secret key for encryption and decryption of messages is fetched " +
+  "from a key server (the coordinator) via asymmetric encryption")
+public class ASYM_ENCRYPT extends Encrypt {
+    protected static final short                   GMS_ID=ClassConfigurator.getProtocolId(GMS.class);
+
+    @Property(description="When a member leaves the view, change the secret key, preventing old members from eavesdropping",
+      writable=false)
+    protected boolean                              change_key_on_leave=true;
+    protected volatile Address                     key_server_addr;
+    @ManagedAttribute(description="True if this member is the current key server, false otherwise")
+    protected volatile boolean                     is_key_server;
+    protected KeyPair                              key_pair; // to store own's public/private Key
+    protected Cipher                               asym_cipher;  // decrypting cypher for secret key requests
+    // queue all up msgs until the secret key has been received/created
+    @ManagedAttribute(description="whether or not to queue received messages (until the secret key was received)")
+    protected volatile boolean                     queue_up_msgs=true;
+    // queues a bounded number of messages received during a null secret key (or fetching the key from a new coord)
+    protected final BlockingQueue<Message>         up_queue=new ArrayBlockingQueue<>(100);
+
+    protected volatile long                        last_key_request;
+
+
+    public KeyPair      keyPair()                         {return key_pair;}
+    public Cipher       asymCipher()                      {return asym_cipher;}
+    public Address      keyServerAddr()                   {return key_server_addr;}
+    public ASYM_ENCRYPT keyServerAddr(Address key_srv)    {this.key_server_addr=key_srv; return this;}
+
+    @ManagedAttribute(description="Number of received messages currently queued")
+    public int numQueuedMessages() {return up_queue.size();}
+
+    @ManagedOperation(description="Triggers a request for the secret key to the current keyserver")
+    public void sendKeyRequest() {
+        if(key_server_addr == null) {
+            log.error("%s: key server is currently not set", local_addr);
+            return;
+        }
+        sendKeyRequest(key_server_addr);
+    }
+
+    public void init() throws Exception {
+        initKeyPair();
+        super.init();
+    }
+
+    public void stop() {
+        drainUpQueue();
+        super.stop();
+    }
+
+    public Object down(Event evt) {
+        if(evt.type() == Event.MSG) {
+            Message msg=evt.arg();
+            if(skip(msg))
+                return down_prot.down(evt);
+        }
+        return super.down(evt);
+    }
+
+    public Object up(Event evt) {
+        if(evt.type() == Event.MSG) {
+            Message msg=evt.arg();
+            if(skip(msg))
+                return up_prot.up(evt);
+        }
+        return super.up(evt);
+    }
+
+    public void up(MessageBatch batch) {
+        for(Message msg: batch) {
+            if(skip(msg)) {
+                try {
+                    up_prot.up(new Event(Event.MSG, msg));
+                    batch.remove(msg);
+                }
+                catch(Throwable t) {
+                    log.error("failed passing up message from %s: %s, ex=%s", msg.src(), msg.printHeaders(), t);
+                }
+            }
+        }
+        if(!batch.isEmpty())
+            super.up(batch); // decrypt the rest of the messages in the batch (if any)
+    }
+
+
+
+    /** Checks if a message needs to be encrypted/decrypted. Join and merge requests/responses don't need to be
+     * encrypted as they're authenticated by {@link AUTH} */
+    protected static boolean skip(Message msg) {
+        GMS.GmsHeader hdr=msg.getHeader(GMS_ID);
+        if(hdr == null) return false;
+        switch(hdr.getType()) {
+            case GMS.GmsHeader.JOIN_REQ:
+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
+            case GMS.GmsHeader.JOIN_RSP:
+            case GMS.GmsHeader.MERGE_REQ:
+            case GMS.GmsHeader.MERGE_RSP:
+            case GMS.GmsHeader.VIEW_ACK:
+            case GMS.GmsHeader.INSTALL_MERGE_VIEW:
+                return true;
+        }
+        return false;
+    }
+
+
+    @Override protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+        switch(hdr.type()) {
+            case EncryptHeader.SECRET_KEY_REQ:
+                handleSecretKeyRequest(msg);
+                break;
+            case EncryptHeader.SECRET_KEY_RSP:
+                handleSecretKeyResponse(msg, hdr.version());
+                break;
+            default:
+                log.warn("%s: received unknown encrypt header of type %d", local_addr, hdr.type());
+                break;
+        }
+        return null;
+    }
+
+    @Override protected boolean process(Message msg) {
+        if(queue_up_msgs || secret_key == null) {
+            up_queue.offer(msg);
+            log.trace("%s: queuing %s message from %s as secret key hasn't been retrieved from keyserver %s yet, hdrs: %s",
+                      local_addr, msg.dest() == null? "mcast" : "unicast", msg.src(), key_server_addr, msg.printHeaders());
+            if(last_key_request == 0 || System.currentTimeMillis() - last_key_request > 2000) {
+                last_key_request=System.currentTimeMillis();
+                sendKeyRequest();
+            }
+            return false;
+        }
+        return true;
+    }
+
+    protected void handleSecretKeyRequest(final Message msg) {
+        if(!inView(msg.src(), "key requester %s is not in current view %s; ignoring key request"))
+            return;
+        log.debug("%s: received key request from %s", local_addr, msg.getSrc());
+        try {
+            PublicKey tmpKey=generatePubKey(msg.getBuffer());
+            sendSecretKey(secret_key, tmpKey, msg.getSrc());
+        }
+        catch(Exception e) {
+            log.warn("%s: unable to reconstitute peer's public key", local_addr);
+        }
+    }
+
+
+    protected void handleSecretKeyResponse(final Message msg, final byte[] key_version) {
+        if(!inView(msg.src(), "ignoring secret key sent by %s which is not in current view %s"))
+            return;
+        try {
+            SecretKey tmp=decodeKey(msg.getBuffer());
+            if(tmp == null)
+                sendKeyRequest(key_server_addr); // unable to understand response, let's try again
+            else {
+                // otherwise set the returned key as the shared key
+                log.debug("%s: received secret key from keyserver %s", local_addr, msg.getSrc());
+                setKeys(tmp, key_version);
+            }
+        }
+        catch(Exception e) {
+            log.warn("%s: unable to process received public key", local_addr, e);
+        }
+    }
+
+
+    /** Initialise the symmetric key if none is supplied in a keystore */
+    protected SecretKey createSecretKey() throws Exception {
+        KeyGenerator keyGen=null;
+        // see if we have a provider specified
+        if(provider != null && !provider.trim().isEmpty())
+            keyGen=KeyGenerator.getInstance(getAlgorithm(sym_algorithm), provider);
+        else
+            keyGen=KeyGenerator.getInstance(getAlgorithm(sym_algorithm));
+        // generate the key using the defined init properties
+        keyGen.init(sym_keylength);
+        return keyGen.generateKey();
+    }
+
+
+
+    /** Generates the public/private key pair from the init params */
+    protected void initKeyPair() throws Exception {
+        // generate keys according to the specified algorithms
+        // generate publicKey and Private Key
+        KeyPairGenerator KpairGen=null;
+        if(provider != null && !provider.trim().isEmpty())
+            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asym_algorithm), provider);
+        else
+            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asym_algorithm));
+        KpairGen.initialize(asym_keylength,new SecureRandom());
+        key_pair=KpairGen.generateKeyPair();
+
+        // set up the Cipher to decrypt secret key responses encrypted with our key
+        if(provider != null && !provider.trim().isEmpty())
+            asym_cipher=Cipher.getInstance(asym_algorithm, provider);
+        else
+            asym_cipher=Cipher.getInstance(asym_algorithm);
+        asym_cipher.init(Cipher.DECRYPT_MODE, key_pair.getPrivate());
+    }
+
+
+    @Override protected synchronized void handleView(View v) {
+        boolean left_mbrs=change_key_on_leave && this.view != null && !v.containsMembers(this.view.getMembersRaw());
+        super.handleView(v);
+        Address tmpKeyServer=v.getCoord(); // the coordinator is the keyserver
+        if(tmpKeyServer.equals(local_addr)) {
+            if(!is_key_server || left_mbrs)
+                becomeKeyServer(tmpKeyServer, left_mbrs);
+        }
+        else
+            handleNewKeyServer(tmpKeyServer, v instanceof MergeView, left_mbrs);
+    }
+
+
+    protected void becomeKeyServer(Address tmpKeyServer, boolean left_mbrs) {
+        if(log.isDebugEnabled()) {
+            if(!is_key_server)
+                log.debug("%s: I'm the new key server", local_addr);
+            else if(left_mbrs)
+                log.debug("%s: creating new secret key because members left", local_addr);
+        }
+        key_server_addr=tmpKeyServer;
+        is_key_server=true;
+        try {
+            this.secret_key=createSecretKey();
+            initSymCiphers(sym_algorithm, secret_key);
+            drainUpQueue();
+        }
+        catch(Exception ex) {
+            log.error("%s: failed creating secret key and initializing ciphers", local_addr, ex);
+        }
+    }
+
+    /** If the keyserver changed, send a request for the secret key to the keyserver */
+    protected void handleNewKeyServer(Address newKeyServer, boolean merge_view, boolean left_mbrs) {
+        if(keyServerChanged(newKeyServer) || merge_view || left_mbrs) {
+            secret_key=null;
+            sym_version=null;
+            queue_up_msgs=true;
+            key_server_addr=newKeyServer;
+            is_key_server=false;
+            log.debug("%s: sending request for secret key to the new keyserver %s", local_addr, key_server_addr);
+            sendKeyRequest(key_server_addr);
+        }
+    }
+
+	protected boolean keyServerChanged(Address newKeyServer) {
+		return !Objects.equals(key_server_addr, newKeyServer);
+	}
+
+
+
+    protected void setKeys(SecretKey key, byte[] version) throws Exception {
+        if(Arrays.equals(this.sym_version, version))
+            return;
+
+        Cipher decoding_cipher=secret_key != null? decoding_ciphers.take() : null;
+        // put the previous key into the map, keep the cipher: no leak, as we'll clear decoding_ciphers in initSymCiphers()
+        if(decoding_cipher != null)
+            key_map.put(new AsciiString(version), decoding_cipher);
+        secret_key=key;
+        initSymCiphers(key.getAlgorithm(), key);
+        sym_version=version;
+        drainUpQueue();
+    }
+
+
+    protected void sendSecretKey(SecretKey secret_key, PublicKey public_key, Address source) throws Exception {
+        byte[] encryptedKey=encryptSecretKey(secret_key, public_key);
+        Message newMsg=new Message(source, local_addr, encryptedKey)
+          .putHeader(this.id, new EncryptHeader(EncryptHeader.SECRET_KEY_RSP, symVersion()));
+        log.debug("%s: sending secret key to %s", local_addr, source);
+        down_prot.down(new Event(Event.MSG,newMsg));
+    }
+
+    /** Encrypts the current secret key with the requester's public key (the requester will decrypt it with its private key) */
+    protected byte[] encryptSecretKey(SecretKey secret_key, PublicKey public_key) throws Exception {
+        Cipher tmp;
+        if (provider != null && !provider.trim().isEmpty())
+            tmp=Cipher.getInstance(asym_algorithm, provider);
+        else
+            tmp=Cipher.getInstance(asym_algorithm);
+        tmp.init(Cipher.ENCRYPT_MODE, public_key);
+
+        // encrypt current secret key
+        return tmp.doFinal(secret_key.getEncoded());
+    }
+
+
+    /** send client's public key to server and request server's public key */
+    protected void sendKeyRequest(Address key_server) {
+        Message newMsg=new Message(key_server, local_addr, key_pair.getPublic().getEncoded())
+          .putHeader(this.id,new EncryptHeader(EncryptHeader.SECRET_KEY_REQ, sym_version));
+        down_prot.down(new Event(Event.MSG,newMsg));
+    }
+
+
+    protected SecretKeySpec decodeKey(byte[] encodedKey) throws Exception {
+        byte[] keyBytes;
+
+        synchronized(this) {
+            keyBytes=asym_cipher.doFinal(encodedKey);
+        }
+
+        try {
+            SecretKeySpec keySpec=new SecretKeySpec(keyBytes, getAlgorithm(sym_algorithm));
+            Cipher temp;
+            if (provider != null && !provider.trim().isEmpty())
+                temp=Cipher.getInstance(sym_algorithm, provider);
+            else
+                temp=Cipher.getInstance(sym_algorithm);
+            temp.init(Cipher.SECRET_KEY, keySpec);
+            return keySpec;
+        }
+        catch(Exception e) {
+            log.error(Util.getMessage("FailedDecodingKey"), e);
+            return null;
+        }
+    }
+
+    // doesn't have to be 100% correct: leftover messages wll be delivered later and will be discarded as dupes, as
+    // retransmission is likely to have kicked in before anyway
+    protected void drainUpQueue() {
+        queue_up_msgs=false;
+        Message queued_msg;
+        while((queued_msg=up_queue.poll()) != null) {
+            try {
+                Message decrypted_msg=decryptMessage(null, queued_msg.copy());
+                if(decrypted_msg != null)
+                    up_prot.up(new Event(Event.MSG, decrypted_msg));
+            }
+            catch(Exception ex) {
+                log.error("failed decrypting message from %s: %s", queued_msg.src(), ex);
+            }
+        }
+    }
+
+
+    @Override protected void handleUnknownVersion() {
+        if(!is_key_server)
+            sendKeyRequest(key_server_addr);
+    }
+
+    /** Used to reconstitute public key sent in byte form from peer */
+    protected PublicKey generatePubKey(byte[] encodedKey) {
+        PublicKey pubKey=null;
+        try {
+            KeyFactory KeyFac=KeyFactory.getInstance(getAlgorithm(asym_algorithm));
+            X509EncodedKeySpec x509KeySpec=new X509EncodedKeySpec(encodedKey);
+            pubKey=KeyFac.generatePublic(x509KeySpec);
+        }
+        catch(Exception e) {
+            e.printStackTrace();
+        }
+        return pubKey;
+    }
+
+}
diff --git a/src/org/jgroups/protocols/AUTH.java b/src/org/jgroups/protocols/AUTH.java
index f17a140869..2c4f92f67b 100644
--- a/src/org/jgroups/protocols/AUTH.java
+++ b/src/org/jgroups/protocols/AUTH.java
@@ -19,7 +19,9 @@
 
 
 /**
- * The AUTH protocol adds a layer of authentication to JGroups
+ * The AUTH protocol adds a layer of authentication to JGroups. It intercepts join and merge requests and rejects them
+ * if the joiner or merger is not permitted to join a or merge into a cluster. AUTH should be placed right below
+ * {@link GMS} in the configuration.
  * @author Chris Mills
  * @author Bela Ban
  */
@@ -41,16 +43,16 @@
         /**
          * Called when an up event has been received
          * @param evt the event
-         * @return true if the event should be pass up, else false
+         * @return true if the event should be passed up, else false
          */
         boolean handleUpEvent(Event evt);
     }
 
 
     /** Used on the coordinator to authentication joining member requests against */
-    protected AuthToken             auth_token=null;
+    protected AuthToken             auth_token;
 
-    protected static final short    gms_id=ClassConfigurator.getProtocolId(GMS.class);
+    protected static final short    GMS_ID=ClassConfigurator.getProtocolId(GMS.class);
 
     /** List of UpHandler which are called when an up event has been received. Usually used by AuthToken impls */
     protected final List<UpHandler> up_handlers=new ArrayList<>();
@@ -60,14 +62,14 @@
 
     public AUTH() {name="AUTH";}
 
-    private volatile boolean authenticateCoord = false;
+    protected volatile boolean      authenticate_coord=true;
     
-   @Property(name="authenticate_coord")
-   public void setAuthCoord( boolean authenticateCoord) {
-	   this.authenticateCoord = authenticateCoord;
-   }
+    @Property(description="Do join or merge responses from the coordinator also need to be authenticated")
+    public AUTH setAuthCoord( boolean authenticateCoord) {
+        this.authenticate_coord= authenticateCoord; return this;
+    }
 
-    @Property(name="auth_class")
+    @Property(name="auth_class",description="The fully qualified name of the class implementing the AuthToken interface")
     public void setAuthClass(String class_name) throws Exception {
         Object obj=Class.forName(class_name).newInstance();
         auth_token=(AuthToken)obj;
@@ -76,9 +78,9 @@ public void setAuthClass(String class_name) throws Exception {
 
     public String    getAuthClass()                {return auth_token != null? auth_token.getClass().getName() : null;}
     public AuthToken getAuthToken()                {return auth_token;}
-    public void      setAuthToken(AuthToken token) {this.auth_token=token;}
-    public void      register(UpHandler handler)   {up_handlers.add(handler);}
-    public void      unregister(UpHandler handler) {up_handlers.remove(handler);}
+    public AUTH      setAuthToken(AuthToken token) {this.auth_token=token; return this;}
+    public AUTH      register(UpHandler handler)   {up_handlers.add(handler); return this;}
+    public AUTH      unregister(UpHandler handler) {up_handlers.remove(handler);return this;}
     public Address   getAddress()                  {return local_addr;}
     public PhysicalAddress getPhysicalAddress()    {return getTransport().getPhysicalAddress();}
 
@@ -92,6 +94,8 @@ public void setAuthClass(String class_name) throws Exception {
 
     public void init() throws Exception {
         super.init();
+        if(auth_token == null)
+            throw new IllegalStateException("no authentication mechanism configured");
         if(auth_token instanceof X509Token) {
             X509Token tmp=(X509Token)auth_token;
             tmp.setCertificate();
@@ -118,25 +122,23 @@ public void destroy() {
     }
 
     /**
-     * An event was received from the layer below. Usually the current layer will want to examine
-     * the event type and - depending on its type - perform some computation
-     * (e.g. removing headers from a MSG event type, or updating the internal membership list
-     * when receiving a VIEW_CHANGE event).
-     * Finally the event is either a) discarded, or b) an event is sent down
-     * the stack using <code>down_prot.down()</code> or c) the event (or another event) is sent up
-     * the stack using <code>up_prot.up()</code>.
+     * An event was received from the layer below. Usually the current layer will want to examine the event type and
+     * - depending on its type - perform some computation (e.g. removing headers from a MSG event type, or updating
+     * the internal membership list when receiving a VIEW_CHANGE event).
+     * Finally the event is either a) discarded, or b) an event is sent down the stack using {@code down_prot.down()}
+     * or c) the event (or another event) is sent up the stack using {@code up_prot.up()}.
      */
     public Object up(Event evt) {
         switch(evt.getType()) {
             case Event.MSG:
-                Message msg=(Message)evt.getArg();
+                Message msg=evt.getArg();
 
                 // If we have a join or merge request --> authenticate, else pass up
                 GMS.GmsHeader gms_hdr=getGMSHeader(evt);
                 if(gms_hdr != null && needsAuthentication(gms_hdr)) {
-                    AuthHeader auth_hdr=(AuthHeader)msg.getHeader(id);
+                    AuthHeader auth_hdr=msg.getHeader(id);
                     if(auth_hdr == null)
-                        throw new IllegalStateException("found GMS join or merge request but no AUTH header");
+                        throw new IllegalStateException(String.format("found %s from %s but no AUTH header", gms_hdr, msg.src()));
                     if(!handleAuthHeader(gms_hdr, auth_hdr, msg)) // authentication failed
                         return null;    // don't pass up
                 }
@@ -153,9 +155,9 @@ public void up(MessageBatch batch) {
             // If we have a join or merge request --> authenticate, else pass up
             GMS.GmsHeader gms_hdr=getGMSHeader(msg);
             if(gms_hdr != null && needsAuthentication(gms_hdr)) {
-                AuthHeader auth_hdr=(AuthHeader)msg.getHeader(id);
+                AuthHeader auth_hdr=msg.getHeader(id);
                 if(auth_hdr == null) {
-                    log.warn("found GMS join or merge request but no AUTH header");
+                    log.warn("%s: found GMS join or merge request from %s but no AUTH header", local_addr, batch.sender());
                     sendRejectionMessage(gms_hdr.getType(), batch.sender(), "join or merge without an AUTH header");
                     batch.remove(msg);
                 }
@@ -172,21 +174,20 @@ else if(!handleAuthHeader(gms_hdr, auth_hdr, msg)) // authentication failed
      * An event is to be sent down the stack. The layer may want to examine its type and perform
      * some action on it, depending on the event's type. If the event is a message MSG, then
      * the layer may need to add a header to it (or do nothing at all) before sending it down
-     * the stack using <code>down_prot.down()</code>. In case of a GET_ADDRESS event (which tries to
+     * the stack using {@code down_prot.down()}. In case of a GET_ADDRESS event (which tries to
      * retrieve the stack's address from one of the bottom layers), the layer may need to send
-     * a new response event back up the stack using <code>up_prot.up()</code>.
+     * a new response event back up the stack using {@code up_prot.up()}.
      */
     public Object down(Event evt) {
         GMS.GmsHeader hdr = getGMSHeader(evt);
         if(hdr != null && needsAuthentication(hdr)) {
             // we found a join request message - now add an AUTH Header
-            Message msg = (Message)evt.getArg();
-            AuthHeader authHeader = new AuthHeader(this.auth_token);
-            msg.putHeader(this.id, authHeader);
+            Message msg=evt.getArg();
+            msg.putHeader(this.id, new AuthHeader(this.auth_token));
         }
 
         if(evt.getType() == Event.SET_LOCAL_ADDRESS)
-            local_addr=(Address)evt.getArg();
+            local_addr=evt.getArg();
 
         return down_prot.down(evt);
     }
@@ -194,17 +195,18 @@ public Object down(Event evt) {
 
 
     protected boolean needsAuthentication(GMS.GmsHeader hdr) {
-    	switch(hdr.getType()) {
-        case GMS.GmsHeader.JOIN_REQ:
-        case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
-        case GMS.GmsHeader.MERGE_REQ:
-            return true;
-        case GMS.GmsHeader.JOIN_RSP:
-        case GMS.GmsHeader.MERGE_RSP:
-        	return this.authenticateCoord;
-        default:
-            return false;
-            }
+        switch(hdr.getType()) {
+            case GMS.GmsHeader.JOIN_REQ:
+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
+            case GMS.GmsHeader.MERGE_REQ:
+                return true;
+            case GMS.GmsHeader.JOIN_RSP:
+            case GMS.GmsHeader.MERGE_RSP:
+            case GMS.GmsHeader.INSTALL_MERGE_VIEW:
+                return this.authenticate_coord;
+            default:
+                return false;
+        }
     }
 
 
@@ -215,17 +217,17 @@ protected boolean needsAuthentication(GMS.GmsHeader hdr) {
      * @return true if the message should be passed up, or else false
      */
     protected boolean handleAuthHeader(GMS.GmsHeader gms_hdr, AuthHeader auth_hdr, Message msg) {
-    	if ( needsAuthentication(gms_hdr)) {
-            if(this.auth_token.authenticate(auth_hdr.getToken(), msg)) {
+        if(needsAuthentication(gms_hdr)) {
+            if(this.auth_token.authenticate(auth_hdr.getToken(), msg))
                 return true; //  authentication passed, send message up the stack
-            } else {
-                log.warn("failed to validate AuthHeader token from " + msg.getSrc() + ", token: " + auth_token);
+            else {
+                log.warn("%s: failed to validate AuthHeader (token: %s) from %s; dropping message",
+                         local_addr, auth_token.getClass().getSimpleName(), msg.src());
                 sendRejectionMessage(gms_hdr.getType(), msg.getSrc(), "authentication failed");
                 return false;
             }
-    	} else {
-    		return true;
-    	}
+        }
+        return true;
     }
 
 
@@ -238,9 +240,6 @@ protected void sendRejectionMessage(byte type, Address dest, String error_msg) {
             case GMS.GmsHeader.MERGE_REQ:
                 sendMergeRejectionMessage(dest);
                 break;
-            default:
-                log.error("type " + type + " unknown");
-                break;
         }
     }
 
@@ -249,17 +248,19 @@ protected void sendJoinRejectionMessage(Address dest, String error_msg) {
             return;
 
         JoinRsp joinRes=new JoinRsp(error_msg); // specify the error message on the JoinRsp
-        Message msg = new Message(dest).putHeader(gms_id, new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP))
+        Message msg = new Message(dest).putHeader(GMS_ID, new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP))
           .setBuffer(GMS.marshal(joinRes));
+        if(this.authenticate_coord)
+            msg.putHeader(this.id, new AuthHeader(this.auth_token));
         down_prot.down(new Event(Event.MSG, msg));
     }
 
     protected void sendMergeRejectionMessage(Address dest) {
-        Message msg=new Message(dest).setFlag(Message.Flag.OOB);
-        GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.MERGE_RSP);
-        hdr.setMergeRejected(true);
-        msg.putHeader(gms_id, hdr);
-        if(log.isDebugEnabled()) log.debug("merge response=" + hdr);
+        GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.MERGE_RSP).setMergeRejected(true);
+        Message msg=new Message(dest).setFlag(Message.Flag.OOB).putHeader(GMS_ID, hdr);
+        if(this.authenticate_coord)
+            msg.putHeader(this.id, new AuthHeader(this.auth_token));
+        log.debug("merge response=%s", hdr);
         down_prot.down(new Event(Event.MSG, msg));
     }
 
@@ -282,7 +283,7 @@ protected boolean callUpHandlers(Event evt) {
     }
 
     protected static GMS.GmsHeader getGMSHeader(Message msg){
-        Header hdr = msg.getHeader(gms_id);
+        Header hdr = msg.getHeader(GMS_ID);
         if(hdr instanceof GMS.GmsHeader)
             return (GMS.GmsHeader)hdr;
         return null;
diff --git a/src/org/jgroups/protocols/DISCARD.java b/src/org/jgroups/protocols/DISCARD.java
index 0784200817..f3dcd6edf6 100644
--- a/src/org/jgroups/protocols/DISCARD.java
+++ b/src/org/jgroups/protocols/DISCARD.java
@@ -168,13 +168,13 @@ public void stop() {
 
     public Object up(Event evt) {
         if(evt.getType() == Event.SET_LOCAL_ADDRESS) {
-            localAddress=(Address)evt.getArg();
+            localAddress=evt.getArg();
             if(discard_dialog != null)
                 discard_dialog.setTitle("Discard dialog (" + localAddress + ")");
         }
 
         if(evt.getType() == Event.MSG) {
-            Message msg=(Message)evt.getArg();
+            Message msg=evt.getArg();
             if(shouldDropUpMessage(msg, msg.getSrc()))
                 return null;
         }
@@ -200,7 +200,7 @@ public Object down(Event evt) {
 
         switch(evt.getType()) {
             case Event.MSG:
-                msg=(Message)evt.getArg();
+                msg=evt.getArg();
                 Address dest=msg.getDest();
                 boolean multicast=dest == null;
 
@@ -238,7 +238,7 @@ public Object down(Event evt) {
                 }
                 break;
             case Event.VIEW_CHANGE:
-                View view=(View)evt.getArg();
+                View view=evt.getArg();
                 List<Address> mbrs=view.getMembers();
                 members.clear();
                 members.addAll(mbrs);
@@ -248,7 +248,7 @@ public Object down(Event evt) {
                 break;
 
             case Event.SET_LOCAL_ADDRESS:
-                localAddress=(Address)evt.getArg();
+                localAddress=evt.getArg();
                 if(discard_dialog != null)
                     discard_dialog.setTitle("Discard dialog (" + localAddress + ")");
                 break;
@@ -351,6 +351,7 @@ else if(command.startsWith("stop")) {
                         ((JCheckBox)c).setSelected(false);
                     }
                 }
+                ignoredMembers.clear();
             }
         }
 
diff --git a/src/org/jgroups/protocols/ENCRYPT.java b/src/org/jgroups/protocols/ENCRYPT.java
deleted file mode 100644
index 0fb5179eaf..0000000000
--- a/src/org/jgroups/protocols/ENCRYPT.java
+++ /dev/null
@@ -1,1050 +0,0 @@
-package org.jgroups.protocols;
-
-import org.jgroups.*;
-import org.jgroups.annotations.MBean;
-import org.jgroups.annotations.Property;
-import org.jgroups.stack.Protocol;
-import org.jgroups.util.AsciiString;
-import org.jgroups.util.Buffer;
-import org.jgroups.util.MessageBatch;
-import org.jgroups.util.Util;
-
-import javax.crypto.Cipher;
-import javax.crypto.KeyGenerator;
-import javax.crypto.SecretKey;
-import javax.crypto.spec.SecretKeySpec;
-import java.io.*;
-import java.security.*;
-import java.security.cert.CertificateException;
-import java.security.spec.X509EncodedKeySpec;
-import java.util.*;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-import java.util.function.BiFunction;
-
-/**
- * ENCRYPT layer. Encrypt and decrypt communication in JGroups
- * 
- * This class can be used in two ways:
- * <ul>
- * <li> Option 1. Configured with a secretKey in a keystore so it can be used at
- * any layer in JGroups without the need for a coordinator, or if you want
- * protection against passive monitoring but do not want the key exchange
- * overhead and complexity. In this mode all nodes must be distributed with the
- * same keystore file.
- * <li> Option 2. Configured with algorithms and key sizes. The ENCRYPT layer in
- * this mode sould be placed above the GMS protocol in the configuration. The
- * coordinator then chooses the secretkey which it distributes amongst all the
- * peers. In this form, no keystore exists as the keys are distributed using a
- * public/private key exchange. View changes that identify a new controller will
- * result in a new session key being generated and then distributed to all
- * peers. This overhead can be substantial in a an application with a reasonable
- * peer churn.
- * </ul>
- * <p>
- * <p>
- * Each message is identified as encrypted with a specific encryption header
- * which identifies the type of encrypt header and an MD5 digest that identifies
- * the version of the key being used to encrypt/decrypt the messages.
- * <p>
- * <p>
- * <h2>Option 1</h2>
- * <br>
- * This is the simplest option and can be used by simply inserting the
- * Encryption layer at any point in the JGroups stack - it will encrypt all
- * Events of a type MSG that have a non-null message buffer. The format of the
- * entry in this form is:<br>
- * &lt;ENCRYPT key_store_name="defaultStore.keystore" store_password="changeit"
- * alias="myKey"/&gt;<br>
- * An example showing the keystore version can be found in
- * the conf in a file called EncryptKeyStore.xml - along with a
- * defaultStore.keystore file.<br>
- * In order to use the ENCRYPT layer in this manner, it is necessary to have the
- * secretKey already generated in a keystore file. The directory containing the
- * keystore file must be on the application's classpath. You cannot create a
- * SecretKey keystore file using the keytool application shipped with the JDK. A
- * java file called KeyStoreGenerator is included in the demo package that can
- * be used from the command line (or IDE) to generate a suitable keystore.
- * <p>
- * <p>
- * <h2>Option 2</h2>
- * <br>
- * This option is suited to an application that does not ship with a known key
- * but instead it is generated and distributed by the controller. The secret key
- * is first generated by the controller (in JGroups terms). When a view change
- * occurs, a peer will request the secret key by sending a key request with its
- * own public key. The controller encrypts the secret key with this key and
- * sends it back to the peer who then decrypts it and installs the key as its
- * own secret key. <br>
- * All encryption and decryption of messages is done using this key. When a peer
- * receives a view change that shows a different keyserver, it will repeat this
- * process - the view change event also trigger the ENCRYPT layer to queue up
- * and down messages until the new key is installed. The previous keys are
- * retained so that messages sent before the view change that are queued can be
- * decrypted if the key is different. <br>
- * An example EncryptNoKeyStore.xml is included in the conf file as a guide.
- * <p>
- * <p>
- * <br>
- * Note: the current version does not support the concept of perfect forward
- * encryption (PFE) which means that if a peer leaves the group the keys are
- * re-generated preventing the departed peer from decrypting future messages if
- * it chooses to listen in on the group. This is not included as it really
- * requires a suitable authentication scheme as well to make this feature useful
- * as there is nothing to stop the peer rejoining and receiving the new key. A
- * future release will address this issue.
- * 
- * @author Steve Woodcock
- * @author Bela Ban
- */
-@MBean(description="Protocol which encrypts and decrypts cluster traffic")
-public class ENCRYPT extends Protocol {
-    private static final String DEFAULT_SYM_ALGO="AES";
-    Address local_addr;
-    Address keyServerAddr;
-    boolean keyServer=false; //used to see whether we are the key server
-    
-    /* -----------------------------------------    Properties     -------------------------------------------------- */
-
-    // encryption properties in no supplied key mode
-    @Property(name="asym_provider", description="Cryptographic Service Provider. Default is Bouncy Castle Provider")
-    String asymProvider=null;
-
-    @Property(name="sym_provider", description="Cryptographic Service Provider. Default is Bouncy Castle Provider")
-    String symProvider=null;
-
-    @Property(name="asym_algorithm", description="Cipher engine transformation for asymmetric algorithm. Default is RSA")
-    protected String asymAlgorithm="RSA";
-
-    @Property(name="sym_algorithm", description="Cipher engine transformation for symmetric algorithm. Default is AES")
-    String symAlgorithm=DEFAULT_SYM_ALGO;
-
-    @Property(name="asym_init", description="Initial public/private key length. Default is 512")
-    int asymInit=512;
-
-    @Property(name="sym_init", description="Initial key length for matching symmetric algorithm. Default is 128")
-    int symInit=128;
-
-    @Property(name="change_keys", description="Generate new symmetric keys on every view change. Default is false. " +
-      "Set this to true when using asymmetric encryption, to handle merging (JGRP-1907)")
-    boolean changeKeysOnViewChange=false;
-
-    // properties for functioning in supplied key mode
-    private boolean suppliedKey=false;
-
-    @Property(name="key_store_name", description="File on classpath that contains keystore repository")
-    String keyStoreName;
-
-    @Property(name="store_password",
-              description="Password used to check the integrity/unlock the keystore. Change the default",
-              exposeAsManagedAttribute=false)
-    protected String storePassword="changeit"; //JDK default
-
-    @Property(name="key_password", description="Password for recovering the key. Change the default",
-              exposeAsManagedAttribute=false)
-    private String keyPassword=null; // allows to assign keypwd=storepwd if not set (https://issues.jboss.org/browse/JGRP-1375)
-
-
-    @Property(name="alias", description="Alias used for recovering the key. Change the default",exposeAsManagedAttribute=false)
-    protected String alias="mykey"; // JDK default
-
-    @Property(description="Number of ciphers in the pool to parallelize encrypt and decrypt requests",writable=false)
-    protected int cipher_pool_size=8;
-
-
-    // public/private Key
-    KeyPair Kpair; // to store own's public/private Key
-
-    //	 for client to store server's public Key
-    // PublicKey serverPubKey;
-
-    // Cipher pools used for encryption and decryption. Size is cipher_pool_size
-    protected Cipher[] encoding_ciphers, decoding_ciphers;
-
-    // Locks to synchronize access to the cipher pools
-    protected Lock[] encoding_locks, decoding_locks;
-
-    protected final AtomicInteger cipher_index=new AtomicInteger(0); // the cipher and lock to select
-
-    // version filed for secret key
-    protected byte[] symVersion;
-
-    // dhared secret key to encrypt/decrypt messages
-    protected SecretKey secretKey;
-
-    // map to hold previous keys so we can decrypt some earlier messages if we need to
-    final Map<AsciiString,Cipher> keyMap=new WeakHashMap<>();
-
-    // queues to buffer data while we are swapping shared key or obtaining key for first time
-    private boolean queue_up=true;
-    private boolean queue_down=false;
-
-    // queue to hold upcoming messages while key negotiation is happening
-    private final BlockingQueue<Message> upMessageQueue=new LinkedBlockingQueue<>();
-
-    //	 queue to hold downcoming messages while key negotiation is happening
-    private final BlockingQueue<Message> downMessageQueue=new LinkedBlockingQueue<>();
-    // decrypting cypher for secret key requests
-    private Cipher asymCipher;
-
-    /** determines whether to encrypt the entire message, or just the buffer */
-    @Property
-    protected boolean encrypt_entire_message=false;
-
-
-
-
-    protected int getNextIndex() {
-        // same as mod, but (apparently, I'm told) more efficient. Size needs to be a power ot 2
-        int current_index=cipher_index.getAndIncrement();
-        return current_index & (cipher_pool_size-1);
-    }
-
-    public int       getAsymInit()          {return asymInit;}
-    public SecretKey getDesKey()            {return secretKey;}
-    public KeyPair   getKpair()             {return Kpair;}
-    public Cipher    getAsymCipher()        {return asymCipher;}
-    public String    getSymAlgorithm()      {return symAlgorithm;}
-    public int       getSymInit()           {return symInit;}
-    public String    getAsymAlgorithm()     {return asymAlgorithm;}
-    public byte[]    getSymVersion()        {return symVersion;}
-    public SecretKey getSecretKey()         {return secretKey;}
-    public Cipher    getSymDecodingCipher() {return decoding_ciphers[getNextIndex()];}
-    public Cipher    getSymEncodingCipher() {return encoding_ciphers[getNextIndex()];}
-    public Address   getKeyServerAddr()     {return keyServerAddr;}
-    private void     setSymVersion(byte[] symVersion)        {this.symVersion=Arrays.copyOf(symVersion, symVersion.length);}
-    private void     setSecretKey(SecretKey secretKey)       {this.secretKey=secretKey;}
-    protected void   setLocalAddress(Address local_addr)     {this.local_addr=local_addr;}
-    protected void   setKeyServerAddr(Address keyServerAddr) {this.keyServerAddr=keyServerAddr;}
-
-
-    /*
-      * GetAlgorithm: Get the algorithm name from "algorithm/mode/padding"
-      *  taken m original ENCRYPT file
-      */
-    private static String getAlgorithm(String s) {
-        int index=s.indexOf('/');
-        if(index == -1)
-            return s;
-
-        return s.substring(0, index);
-    }
-
-
-
-    public void init() throws Exception {
-        if(keyPassword == null && storePassword != null) {
-            keyPassword=storePassword;
-            log.debug("key_password used is same as store_password");
-        }
-        if(keyStoreName == null) {
-            initSymKey();
-            initKeyPair();
-        }
-        else
-            initConfiguredKey();
-
-        if(cipher_pool_size <= 0) {
-            log.warn("cipher_pool_size of %d is invalid; setting it to 1", cipher_pool_size);
-            cipher_pool_size=1;
-        }
-
-        int tmp=Util.getNextHigherPowerOfTwo(cipher_pool_size);
-        if(tmp != cipher_pool_size) {
-            log.warn("setting cipher_pool_size (%d) to %d (power of 2) for faster modulo operation", cipher_pool_size, tmp);
-            cipher_pool_size=tmp;
-        }
-
-        encoding_ciphers=new Cipher[cipher_pool_size];
-        encoding_locks=new Lock[cipher_pool_size];
-        decoding_ciphers=new Cipher[cipher_pool_size];
-        decoding_locks=new Lock[cipher_pool_size];
-
-        initSymCiphers(symAlgorithm, getSecretKey());
-    }
-
-    /**
-     * Initialisation if a supplied key is defined in the properties. This
-     * supplied key must be in a keystore which can be generated using the
-     * keystoreGenerator file in demos. The keystore must be on the classpath to
-     * find it.
-     * 
-     * @throws KeyStoreException
-     * @throws Exception
-     * @throws IOException
-     * @throws NoSuchAlgorithmException
-     * @throws CertificateException
-     * @throws UnrecoverableKeyException
-     */
-    private void initConfiguredKey() throws Exception {
-        InputStream inputStream=null;
-        // must not use default keystore type - as does not support secret keys
-        KeyStore store=KeyStore.getInstance("JCEKS");
-
-        SecretKey tempKey=null;
-        try {
-            // load in keystore using this thread's classloader
-            inputStream=Thread.currentThread()
-                              .getContextClassLoader()
-                              .getResourceAsStream(keyStoreName);
-            if(inputStream == null)
-                inputStream=new FileInputStream(keyStoreName);
-            // we can't find a keystore here -
-            if(inputStream == null) {
-                throw new Exception("Unable to load keystore " + keyStoreName
-                                    + " ensure file is on classpath");
-            }
-            // we have located a file lets load the keystore
-            try {
-                store.load(inputStream, storePassword.toCharArray());
-                // loaded keystore - get the key
-                tempKey=(SecretKey)store.getKey(alias, keyPassword.toCharArray());
-            }
-            catch(IOException e) {
-                throw new Exception("Unable to load keystore " + keyStoreName + ": " + e);
-            }
-            catch(NoSuchAlgorithmException e) {
-                throw new Exception("No Such algorithm " + keyStoreName + ": " + e);
-            }
-            catch(CertificateException e) {
-                throw new Exception("Certificate exception " + keyStoreName + ": " + e);
-            }
-
-            if(tempKey == null)
-                throw new Exception("Unable to retrieve key '" + alias + "' from keystore " + keyStoreName);
-            //set the key here
-            setSecretKey(tempKey);
-
-            if(symAlgorithm.equals(DEFAULT_SYM_ALGO))
-                symAlgorithm=tempKey.getAlgorithm();
-
-            // set the fact we are using a supplied key
-            suppliedKey=true;
-            queue_down=queue_up=false;
-        }
-        finally {
-            Util.close(inputStream);
-        }
-
-    }
-
-    /**
-     * Used to initialise the symmetric key if none is supplied in a keystore.
-     * 
-     * @throws Exception
-     */
-    public void initSymKey() throws Exception {
-        KeyGenerator keyGen=null;
-        // see if we have a provider specified
-        if(symProvider != null && !symProvider.trim().isEmpty())
-            keyGen=KeyGenerator.getInstance(getAlgorithm(symAlgorithm), symProvider);
-        else
-            keyGen=KeyGenerator.getInstance(getAlgorithm(symAlgorithm));
-        // generate the key using the defined init properties
-        keyGen.init(symInit);
-        secretKey=keyGen.generateKey();
-
-        setSecretKey(secretKey);
-        log.debug("symmetric key generated ");
-    }
-
-    /**
-     * Initialises the Ciphers for both encryption and decryption using the
-     * generated or supplied secret key.
-     * 
-     * @param algorithm
-     * @param secret
-     * @throws Exception
-     */
-    private void initSymCiphers(String algorithm, SecretKey secret) throws Exception {
-        log.debug("initializing symmetric ciphers (pool size=%d)",cipher_pool_size);
-
-        for(int i=0; i < cipher_pool_size; i++) {
-            encoding_ciphers[i]=symProvider != null && !symProvider.trim().isEmpty()?
-              Cipher.getInstance(algorithm, symProvider) : Cipher.getInstance(algorithm);
-            encoding_ciphers[i].init(Cipher.ENCRYPT_MODE, secret);
-
-            decoding_ciphers[i]=symProvider != null && !symProvider.trim().isEmpty()?
-              Cipher.getInstance(algorithm, symProvider) : Cipher.getInstance(algorithm);
-            decoding_ciphers[i].init(Cipher.DECRYPT_MODE, secret);
-
-            encoding_locks[i]=new ReentrantLock();
-            decoding_locks[i]=new ReentrantLock();
-        }
-
-
-        //set the version
-        MessageDigest digest=MessageDigest.getInstance("MD5");
-        digest.reset();
-        digest.update(secret.getEncoded());
-
-        byte[] tmp=digest.digest();
-        symVersion=Arrays.copyOf(tmp, tmp.length);
-        // symVersion = byteArrayToHexString(digest.digest());
-        log.debug("initialized symmetric ciphers with secret key (" + symVersion.length + " bytes)");
-    }
-
-   /* public static String byteArrayToHexString(byte[] b){
-        StringBuilder sb = new StringBuilder(b.length * 2);
-        for (int i = 0; i < b.length; i++){
-            int v = b[i] & 0xff;
-            if (v < 16) { sb.append('0'); }
-            sb.append(Integer.toHexString(v));
-        }
-        return sb.toString().toUpperCase();
-    }*/
-
-    /**
-     * Generates the public/private key pair from the init params
-     * 
-     * @throws Exception
-     */
-    public void initKeyPair() throws Exception {
-        // generate keys according to the specified algorithms
-        // generate publicKey and Private Key
-        KeyPairGenerator KpairGen=null;
-        if(asymProvider != null && !asymProvider.trim().isEmpty())
-            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asymAlgorithm), asymProvider);
-        else
-            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asymAlgorithm));
-        KpairGen.initialize(asymInit,new SecureRandom());
-        Kpair=KpairGen.generateKeyPair();
-
-        // set up the Cipher to decrypt secret key responses encrypted with our key
-
-        if(asymProvider != null && !asymProvider.trim().isEmpty())
-            asymCipher=Cipher.getInstance(asymAlgorithm, asymProvider);
-        else
-            asymCipher=Cipher.getInstance(asymAlgorithm);
-
-        asymCipher.init(Cipher.DECRYPT_MODE,Kpair.getPrivate());
-        log.debug("asym algo initialized");
-    }
-
-
-    public Object up(Event evt) {
-        switch(evt.getType()) {
-            case Event.VIEW_CHANGE:
-                View view=(View)evt.getArg();
-                log.debug("new view: " + view);
-                if(!suppliedKey)
-                    handleViewChange(view, false);
-                break;
-            case Event.TMP_VIEW:
-                view=(View)evt.getArg();
-                if(!suppliedKey)
-                    handleViewChange(view, true);
-                break;
-            // we try and decrypt all messages
-            case Event.MSG:
-                try {
-                    return handleUpMessage(evt);
-                }
-                catch(Exception e) {
-                    log.warn("exception occurred decrypting message", e);
-                }
-                return null;
-        }
-        return up_prot.up(evt);
-    }
-
-
-    public void up(MessageBatch batch) {
-        Decrypter decrypter=new Decrypter();
-        batch.map(decrypter);
-        decrypter.unlock();
-        if(!batch.isEmpty())
-            up_prot.up(batch);
-    }
-
-
-
-    private synchronized void handleViewChange(View view, boolean makeServer) {
-    	if(makeServer)
-    		initializeNewSymmetricKey(view instanceof MergeView);
-
-        // if view is a bit broken set me as keyserver
-        List<Address> members = view.getMembers();
-        if (members == null || members.isEmpty() || members.get(0) == null) { 
-            becomeKeyServer(local_addr, false);
-            return;
-        }
-        // otherwise get keyserver from view controller
-        Address tmpKeyServer=view.getMembers().get(0);
-
-        //I am  keyserver - either first member of group or old key server is no more and
-        // I have been voted new controller
-        if(makeServer || (tmpKeyServer.equals(local_addr)))
-            becomeKeyServer(tmpKeyServer, makeServer);
-        else
-            handleNewKeyServer(tmpKeyServer, view instanceof MergeView);
-    }
-
-	private void initializeNewSymmetricKey(boolean merge_view) {
-		try {
-			if ( changeKeysOnViewChange || !keyServer || merge_view) {
-                log.debug("initalizing new ciphers");
-				initSymKey();
-				initSymCiphers(getSymAlgorithm(), getSecretKey());
-			}
-
-		} catch (Exception e) {
-			log.error(Util.getMessage("CouldNotInitializeNewCiphers"), e);
-			if ( e instanceof RuntimeException) {
-				throw (RuntimeException)e;
-			} else {
-				throw new IllegalStateException(e);
-			}
-		}
-	}
-
-    /**
-     * Handles becoming server - resetting queue settings and setting keyserver
-     * address to be local address.
-     * 
-     * @param tmpKeyServer
-     */
-    private void becomeKeyServer(Address tmpKeyServer, boolean forced) {
-        keyServerAddr=tmpKeyServer;
-        keyServer=true;
-        if(log.isDebugEnabled() && !forced)
-            log.debug("%s: I have become the new key server", local_addr);
-        queue_down=false;
-        queue_up=false;
-    }
-
-    /**
-     * Sets up the peer for a new keyserver - this is setting queueing to buffer
-     * messages until we have a new secret key from the key server and sending a
-     * key request to the new keyserver.
-     * 
-     * @param newKeyServer
-     */
-    private void handleNewKeyServer(Address newKeyServer, boolean merge_view) {
-    	
-    	if ( changeKeysOnViewChange || keyServerChanged(newKeyServer) || merge_view) {
-            // start queueing until we have new key
-            // to make sure we are not sending with old key
-            queue_up=true;
-            queue_down=true;
-            // set new keyserver address
-            keyServerAddr=newKeyServer;
-            keyServer=false;
-            log.debug("%s: %s has become the new key server, sending key request to it", local_addr, keyServerAddr);
-            sendKeyRequest();
-    	}
-    }
-
-	private boolean keyServerChanged(Address newKeyServer) {
-		return !Objects.equals(keyServerAddr, newKeyServer);
-	}
-
-
-    private Object handleUpMessage(Event evt) throws Exception {
-        Message msg=(Message)evt.getArg();
-        EncryptHeader hdr;
-        if(msg == null || (msg.getLength() == 0 && !encrypt_entire_message) || ((hdr=(EncryptHeader)msg.getHeader(this.id)) == null))
-            return up_prot.up(evt);
-
-        if(log.isTraceEnabled())
-            log.trace("header received %s", hdr);
-
-        switch(hdr.getType()) {
-            case EncryptHeader.ENCRYPT:
-                return handleEncryptedMessage(msg, evt, hdr);
-            default:
-                handleUpEvent(msg,hdr);
-                return null;
-        }
-    }
-
-
-
-    @SuppressWarnings("UnusedParameters")
-    protected Object handleEncryptedMessage(Message msg, Event evt, EncryptHeader hdr) throws Exception {
-        // if queueing then pass into queue to be dealt with later
-        if(queue_up) {
-            log.trace("queueing up message as no session key established: %s", msg);
-            upMessageQueue.put(msg);
-            return null;
-        }
-
-        // make sure we pass up any queued messages first
-        // could be more optimised but this can wait we only need this if not using supplied key
-        if(!suppliedKey)
-            drainUpQueue();
-
-        // try and decrypt the message - we need to copy msg as we modify its
-        // buffer (http://jira.jboss.com/jira/browse/JGRP-538)
-        Message tmpMsg=decryptMessage(null, msg.copy()); // need to copy for possible xmits
-        if(tmpMsg != null)
-            return up_prot.up(new Event(Event.MSG, tmpMsg));
-        log.warn("unrecognised cipher; discarding message");
-        return null;
-    }
-
-    protected void handleUpEvent(Message msg, EncryptHeader hdr) {
-        // check if we had some sort of encrypt control header if using supplied key we should not process it
-        if(suppliedKey) {
-            log.warn("we received an encrypt header of %s while in configured mode",hdr.getType());
-            return;
-        }
-
-        // see what sort of encrypt control message we have received
-        switch(hdr.getType()) {
-            // if a key request
-            case EncryptHeader.KEY_REQUEST:
-                log.debug("received a key request from peer %s", msg.getSrc());
-
-                // if a key request send response key back
-                try {
-                    // extract peer's public key
-                    PublicKey tmpKey=generatePubKey(msg.getBuffer());
-                    // send back the secret key we have
-                    sendSecretKey(getSecretKey(), tmpKey, msg.getSrc());
-                }
-                catch(Exception e) {
-                    log.warn("unable to reconstitute peer's public key");
-                }
-                break;
-            case EncryptHeader.SECRETKEY:
-                log.debug("received a secretkey response from keyserver %s", msg.getSrc());
-
-                try {
-                    SecretKey tmp=decodeKey(msg.getBuffer());
-                    if(tmp == null)
-                        sendKeyRequest(); // unable to understand response, let's try again
-                    else {
-                        // otherwise lets set the returned key as the shared key
-                        setKeys(tmp, hdr.getVersion());
-                        log.debug("decoded secretkey response");
-                    }
-                }
-                catch(Exception e) {
-                    log.warn("unable to process received public key", e);
-                }
-                break;
-            default:
-                log.warn("received ignored encrypt header of %s", hdr.getType());
-                break;
-        }
-    }
-
-
-    /**
-     * used to drain the up queue - synchronized so we can call it safely
-     * despite access from potentially two threads at once
-     */
-    private void drainUpQueue() {
-        if(log.isTraceEnabled()) {
-            int size=upMessageQueue.size();
-            if(size > 0)
-                log.trace("draining %d messages from the up queue", size);
-        }
-        while(true) {
-            try {
-                Message tmp=upMessageQueue.poll(0L, TimeUnit.MILLISECONDS);
-                if(tmp == null)
-                    break;
-                Message msg=decryptMessage(null, tmp.copy()); // need to copy for possible xmits
-                if(msg != null)
-                    up_prot.up(new Event(Event.MSG, msg));
-            }
-            catch(Throwable t) {
-                log.error(Util.getMessage("FailedDecryptingAndSendingMessageUpWhenDrainingQueue"), t);
-            }
-        }
-    }
-
-
-    private void drainDownQueue() {
-        if(log.isTraceEnabled()) {
-            int size=downMessageQueue.size();
-            if(size > 0)
-                log.trace("draining %d messages from the down queue", size);
-        }
-        while(true) {
-            try {
-                Message tmp=downMessageQueue.poll(0L, TimeUnit.MILLISECONDS);
-                if(tmp == null)
-                    break;
-                encryptAndSend(tmp);
-            }
-            catch(Throwable t) {
-                log.error(Util.getMessage("FailedSendingMessageDownWhenDrainingQueue"), t);
-            }
-        }
-    }
-
-
-    /**
-     * Sets the keys for the app. and drains the queues - the drains could be
-     * called att he same time as the up/down messages calling in to the class
-     * so we may have an extra call to the drain methods but this slight expense
-     * is better than the alternative of waiting until the next message to
-     * trigger the drains which may never happen.
-     * 
-     * @param key
-     * @param version
-     * @throws Exception
-     */
-    private void setKeys(SecretKey key, byte[] version) throws Exception {
-
-        // put the previous key into the map
-        // if the keys are already there then they will overwrite
-        keyMap.put(new AsciiString(getSymVersion()), getSymDecodingCipher());
-
-        setSecretKey(key);
-        initSymCiphers(key.getAlgorithm(), key);
-        setSymVersion(version);
-
-        // drain the up queue
-        log.debug("setting queue up to false in setKeys");
-        queue_up=false;
-        drainUpQueue();
-
-        queue_down=false;
-        drainDownQueue();
-    }
-
-    /**
-     * Does the actual work for decrypting - if version does not match current cipher then tries the previous cipher
-     */
-    private Message decryptMessage(Cipher cipher, Message msg) throws Exception {
-        EncryptHeader hdr=(EncryptHeader)msg.getHeader(this.id);
-        if(!Arrays.equals(hdr.getVersion(),getSymVersion())) {
-            log.warn("attempting to use stored cipher as message does not use current encryption version ");
-            cipher=keyMap.get(new AsciiString(hdr.getVersion()));
-            if(cipher == null) {
-                log.warn("unable to find a matching cipher in previous key map");
-                return null;
-            }
-            log.trace("decrypting using previous cipher version");
-            synchronized(cipher) {
-                return _decrypt(cipher, msg, hdr.encryptEntireMessage());
-            }
-        }
-
-        return _decrypt(cipher, msg, hdr.encryptEntireMessage());
-    }
-
-    private Message _decrypt(final Cipher cipher, Message msg, boolean decrypt_entire_msg) throws Exception {
-        byte[] decrypted_msg;
-        if(cipher == null)
-            decrypted_msg=code(msg.getRawBuffer(), msg.getOffset(), msg.getLength(), true);
-        else
-            decrypted_msg=cipher.doFinal(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
-
-        if(!decrypt_entire_msg) {
-            msg.setBuffer(decrypted_msg);
-            return msg;
-        }
-
-        Message ret=Util.streamableFromBuffer(Message.class,decrypted_msg,0,decrypted_msg.length);
-        if(ret.getDest() == null)
-            ret.setDest(msg.getDest());
-        if(ret.getSrc() == null)
-            ret.setSrc(msg.getSrc());
-        return ret;
-    }
-
-    private void sendSecretKey(SecretKey secret, PublicKey pubKey, Address source) throws Exception {
-        // create a cipher with peer's public key
-        Cipher tmp;
-        if (asymProvider != null && !asymProvider.trim().isEmpty())
-            tmp=Cipher.getInstance(asymAlgorithm, asymProvider);
-        else
-            tmp=Cipher.getInstance(asymAlgorithm);
-        tmp.init(Cipher.ENCRYPT_MODE,pubKey);
-
-        //encrypt current secret key
-        byte[] encryptedKey=tmp.doFinal(secret.getEncoded());
-        Message newMsg=new Message(source, local_addr, encryptedKey)
-          .putHeader(this.id, new EncryptHeader(EncryptHeader.SECRETKEY, getSymVersion()));
-
-        log.debug("sending version %s encoded key to client", new String(getSymVersion()));
-        down_prot.down(new Event(Event.MSG,newMsg));
-    }
-
-
-
-    /** send client's public key to server and request server's public key */
-    private void sendKeyRequest() {
-        Message newMsg=new Message(keyServerAddr, local_addr, Kpair.getPublic().getEncoded())
-          .putHeader(this.id,new EncryptHeader(EncryptHeader.KEY_REQUEST,getSymVersion()));
-        down_prot.down(new Event(Event.MSG,newMsg));
-    }
-
-    public Object down(Event evt) {
-        switch(evt.getType()) {
-
-            case Event.MSG:
-                Message msg=(Message)evt.getArg();
-                if(msg.getLength() == 0 && !encrypt_entire_message)
-                    break;
-
-                try {
-                    if(queue_down) {
-                        log.trace("queueing down message as no session key established: %s", msg);
-                        downMessageQueue.put(msg); // queue messages if we are waiting for a new key
-                    }
-                    else {
-                        // make sure the down queue is drained first to keep ordering
-                        if(!suppliedKey)
-                            drainDownQueue();
-                        encryptAndSend(msg);
-                    }
-                }
-                catch(Exception e) {
-                    log.warn("unable to send message down", e);
-                }
-                return null;
-
-            case Event.VIEW_CHANGE:
-                View view=(View)evt.getArg();
-                log.debug("new view: " + view);
-                if(!suppliedKey)
-                    handleViewChange(view, false);
-                break;
-
-            case Event.SET_LOCAL_ADDRESS:
-                local_addr=(Address)evt.getArg();
-                log.debug("set local address to %s", local_addr);
-                break;
-
-            case Event.TMP_VIEW:
-                view=(View)evt.getArg();
-                if(!suppliedKey) {
-                    // if a tmp_view then we are trying to become coordinator so
-                    // make us keyserver
-                    handleViewChange(view, true);
-                }
-                break;
-        }
-        return down_prot.down(evt);
-    }
-
-
-
-
-
-    private void encryptAndSend(Message msg) throws Exception {
-        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, getSymVersion());
-        if(this.encrypt_entire_message)
-            hdr.type|=EncryptHeader.ENCRYPT_ENTIRE_MSG;
-
-        if(encrypt_entire_message) {
-            if(msg.getSrc() == null)
-                msg.setSrc(local_addr);
-
-            Buffer serialized_msg=Util.streamableToBuffer(msg);
-            byte[] encrypted_msg=code(serialized_msg.getBuf(),serialized_msg.getOffset(),serialized_msg.getLength(),false);
-
-            // exclude existing headers, they will be seen again when we decrypt and unmarshal the msg at the receiver
-            Message tmp=msg.copy(false, false).setBuffer(encrypted_msg).putHeader(this.id,hdr);
-            down_prot.down(new Event(Event.MSG, tmp));
-            return;
-        }
-
-        // copy neeeded because same message (object) may be retransmitted -> no double encryption
-        Message msgEncrypted=msg.copy(false).putHeader(this.id, hdr)
-          .setBuffer(code(msg.getRawBuffer(),msg.getOffset(),msg.getLength(),false));
-        down_prot.down(new Event(Event.MSG,msgEncrypted));
-    }
-
-
-    private byte[] code(byte[] buf, int offset, int length, boolean decode) throws Exception {
-        int index=getNextIndex();
-        Lock lock=decode? decoding_locks[index] : encoding_locks[index];
-        Cipher cipher=decode? decoding_ciphers[index] : encoding_ciphers[index];
-
-        lock.lock();
-        try {
-            return cipher.doFinal(buf, offset, length);
-        }
-        finally {
-            lock.unlock();
-        }
-    }
-
-
-    // try and decode secrey key sent from keyserver
-    private SecretKeySpec decodeKey(byte[] encodedKey) throws Exception {
-        byte[] keyBytes;
-
-        synchronized(this) {
-            keyBytes=asymCipher.doFinal(encodedKey);
-        }
-
-        try {
-            SecretKeySpec keySpec=new SecretKeySpec(keyBytes, getAlgorithm(symAlgorithm));
-
-            // test reconstituted key to see if valid
-            Cipher temp;
-            if (symProvider != null && !symProvider.trim().isEmpty())
-                temp=Cipher.getInstance(symAlgorithm, symProvider);
-            else
-                temp=Cipher.getInstance(symAlgorithm);
-            temp.init(Cipher.SECRET_KEY, keySpec);
-            return keySpec;
-        }
-        catch(Exception e) {
-            log.error(Util.getMessage("FailedDecodingKey"), e);
-            return null;
-        }
-    }
-
-    /**
-     * used to reconstitute public key sent in byte form from peer
-     * 
-     * @param encodedKey
-     * @return PublicKey
-     */
-    private PublicKey generatePubKey(byte[] encodedKey) {
-        PublicKey pubKey=null;
-        try {
-            KeyFactory KeyFac=KeyFactory.getInstance(getAlgorithm(asymAlgorithm));
-            X509EncodedKeySpec x509KeySpec=new X509EncodedKeySpec(encodedKey);
-            pubKey=KeyFac.generatePublic(x509KeySpec);
-        }
-        catch(Exception e) {
-            e.printStackTrace();
-        }
-        return pubKey;
-    }
-
-
-
-
-    /** Decrypts all messages in a batch, replacing encrypted messages in-place with their decrypted versions */
-    protected class Decrypter implements BiFunction<Message,MessageBatch,Message> {
-        protected Lock   lock;
-        protected Cipher cipher;
-
-        public Message apply(Message msg, MessageBatch batch) {
-            EncryptHeader hdr;
-
-            if(msg == null || (msg.getLength() == 0 && !encrypt_entire_message) || ((hdr=(EncryptHeader)msg.getHeader(id)) == null))
-                return null;
-
-            if(hdr.getType() == EncryptHeader.ENCRYPT) {
-                // if queueing then pass into queue to be dealt with later
-                if(queue_up) {
-                    queueUpMessage(msg, batch);
-                    return null;
-                }
-
-                // make sure we pass up any queued messages first
-                if(!suppliedKey)
-                    drainUpQueue();
-
-                if(lock == null) {
-                    int index=getNextIndex();
-                    lock=decoding_locks[index];
-                    cipher=decoding_ciphers[index];
-                    lock.lock();
-                }
-
-                try {
-                    Message tmpMsg=decryptMessage(cipher, msg.copy()); // need to copy for possible xmits
-                    if(tmpMsg != null)
-                        batch.replace(msg, tmpMsg);
-                }
-                catch(Exception e) {
-                    log.error("failed decrypting message from %s (offset=%d, length=%d, buf.length=%d): %s, headers are %s",
-                              msg.getSrc(), msg.getOffset(), msg.getLength(), msg.getRawBuffer().length, e, msg.printHeaders());
-                }
-            }
-            else {
-                batch.remove(msg); // a control message will get handled by ENCRYPT and should not be passed up
-                handleUpEvent(msg, hdr);
-            }
-            return null;
-        }
-
-        protected void unlock() {
-            if(lock != null) {
-                lock.unlock();
-                lock=null;
-            }
-        }
-
-        protected void queueUpMessage(Message msg, MessageBatch batch) {
-            log.trace("queueing up message as no session key established: " + msg);
-            try {
-                upMessageQueue.put(msg);
-                batch.remove(msg);
-            }
-            catch(InterruptedException e) {
-            }
-        }
-    }
-
-
-    public static class EncryptHeader extends org.jgroups.Header {
-        public static final byte ENCRYPT            = 1 << 0;
-        public static final byte KEY_REQUEST        = 1 << 1;
-        public static final byte SECRETKEY          = 1 << 2;
-        public static final byte ENCRYPT_ENTIRE_MSG = 1 << 3;
-
-        private   byte   type;
-        protected byte[] version;
-
-
-        public EncryptHeader() {}
-
-
-        public EncryptHeader(byte type, byte[] version) {
-            this.type=type;
-            this.version=version;
-            if(version == null)
-                throw new IllegalArgumentException("version must be defined");
-        }
-
-        public byte getType() {
-            return (byte)(type & ~ENCRYPT_ENTIRE_MSG); // clear the ENCRYPT_ENTIRE_MSG flag
-        }
-
-        /**
-         * @return Returns the version.
-         */
-        protected byte[] getVersion() {
-            return version;
-        }
-
-        public boolean encryptEntireMessage() {
-            return Util.isFlagSet(type, ENCRYPT_ENTIRE_MSG);
-        }
-
-        public void writeTo(DataOutput out) throws Exception {
-            out.writeByte(type);
-            out.writeShort(version.length);
-            out.write(version);
-        }
-
-        public void readFrom(DataInput in) throws Exception {
-            type=in.readByte();
-            short len=in.readShort();
-            version=new byte[len];
-            in.readFully(version);
-        }
-
-        public String toString() {
-            return "[type=" + type + " version=\"" + (version != null? version.length + " bytes" : "n/a") + "\"]";
-        }
-
-        public int size() {
-            int retval=Global.BYTE_SIZE + Global.SHORT_SIZE;
-            retval+=version.length;
-            return retval;
-        }
-
-
-
-
-    }
-}
diff --git a/src/org/jgroups/protocols/Encrypt.java b/src/org/jgroups/protocols/Encrypt.java
new file mode 100644
index 0000000000..4597bab0c5
--- /dev/null
+++ b/src/org/jgroups/protocols/Encrypt.java
@@ -0,0 +1,437 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.Property;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.*;
+
+import javax.crypto.Cipher;
+import javax.crypto.SecretKey;
+import java.security.MessageDigest;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.function.BiConsumer;
+import java.util.zip.Adler32;
+import java.util.zip.CRC32;
+import java.util.zip.Checksum;
+
+/**
+ * Super class of symmetric ({@link SYM_ENCRYPT}) and asymmetric ({@link ASYM_ENCRYPT}) encryption protocols.
+ * @author Bela Ban
+ */
+public abstract class Encrypt extends Protocol {
+    protected static final String DEFAULT_SYM_ALGO="AES";
+
+
+    /* -----------------------------------------    Properties     -------------------------------------------------- */
+    @Property(description="Cryptographic Service Provider")
+    protected String                        provider;
+
+    @Property(description="Cipher engine transformation for asymmetric algorithm. Default is RSA")
+    protected String                        asym_algorithm="RSA";
+
+    @Property(description="Cipher engine transformation for symmetric algorithm. Default is AES")
+    protected String                        sym_algorithm=DEFAULT_SYM_ALGO;
+
+    @Property(description="Initial public/private key length. Default is 512")
+    protected int                           asym_keylength=512;
+
+    @Property(description="Initial key length for matching symmetric algorithm. Default is 128")
+    protected int                           sym_keylength=128;
+
+    @Property(description="Number of ciphers in the pool to parallelize encrypt and decrypt requests",writable=false)
+    protected int                           cipher_pool_size=8;
+
+    @Property(description="If true, the entire message (including payload and headers) is encrypted, else only the payload")
+    protected boolean                       encrypt_entire_message=true;
+
+    @Property(description="If true, all messages are digitally signed by adding an encrypted checksum of the encrypted " +
+      "message to the header. Ignored if encrypt_entire_message is false")
+    protected boolean                       sign_msgs=true;
+
+    @Property(description="When sign_msgs is true, by default CRC32 is used to create the checksum. If use_adler is " +
+      "true, Adler32 will be used")
+    protected boolean                       use_adler;
+
+    protected volatile Address              local_addr;
+
+    protected volatile View                 view;
+
+    // Cipher pools used for encryption and decryption. Size is cipher_pool_size
+    protected BlockingQueue<Cipher>         encoding_ciphers, decoding_ciphers;
+
+    // version filed for secret key
+    protected volatile byte[]               sym_version;
+
+    // shared secret key to encrypt/decrypt messages
+    protected volatile SecretKey            secret_key;
+
+    // map to hold previous keys so we can decrypt some earlier messages if we need to
+    protected final Map<AsciiString,Cipher> key_map=new WeakHashMap<>();
+
+
+
+    public int                      asymKeylength()                 {return asym_keylength;}
+    public <T extends Encrypt> T    asymKeylength(int len)          {this.asym_keylength=len; return (T)this;}
+    public int                      symKeylength()                  {return sym_keylength;}
+    public <T extends Encrypt> T    symKeylength(int len)           {this.sym_keylength=len; return (T)this;}
+    public SecretKey                secretKey()                     {return secret_key;}
+    public <T extends Encrypt> T    secretKey(SecretKey key)        {this.secret_key=key; return (T)this;}
+    public String                   symAlgorithm()                  {return sym_algorithm;}
+    public <T extends Encrypt> T    symAlgorithm(String alg)        {this.sym_algorithm=alg; return (T)this;}
+    public String                   asymAlgorithm()                 {return asym_algorithm;}
+    public <T extends Encrypt> T    asymAlgorithm(String alg)       {this.asym_algorithm=alg; return (T)this;}
+    public byte[]                   symVersion()                    {return sym_version;}
+    public <T extends Encrypt> T    symVersion(byte[] v)            {this.sym_version=Arrays.copyOf(v, v.length); return (T)this;}
+    public <T extends Encrypt> T    localAddress(Address addr)      {this.local_addr=addr; return (T)this;}
+    public boolean                  encryptEntireMessage()          {return encrypt_entire_message;}
+    public <T extends Encrypt> T    encryptEntireMessage(boolean b) {this.encrypt_entire_message=b; return (T)this;}
+    public boolean                  signMessages()                  {return this.sign_msgs;}
+    public <T extends Encrypt> T    signMessages(boolean flag)      {this.sign_msgs=flag; return (T)this;}
+    public boolean                  adler()                         {return use_adler;}
+    public <T extends Encrypt> T    adler(boolean flag)             {this.use_adler=flag; return (T)this;}
+    @ManagedAttribute public String version()                       {return Util.byteArrayToHexString(sym_version);}
+
+    public void init() throws Exception {
+        int tmp=Util.getNextHigherPowerOfTwo(cipher_pool_size);
+        if(tmp != cipher_pool_size) {
+            log.warn("%s: setting cipher_pool_size (%d) to %d (power of 2) for faster modulo operation", local_addr, cipher_pool_size, tmp);
+            cipher_pool_size=tmp;
+        }
+        encoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);
+        decoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);
+        initSymCiphers(sym_algorithm, secret_key);
+    }
+
+
+    public Object down(Event evt) {
+        switch(evt.getType()) {
+            case Event.MSG:
+                Message msg=evt.getArg();
+                try {
+                    if(secret_key == null) {
+                        log.trace("%s: discarded %s message to %s as secret key is null, hdrs: %s",
+                                  local_addr, msg.dest() == null? "mcast" : "unicast", msg.dest(), msg.printHeaders());
+                        return null;
+                    }
+                    encryptAndSend(msg);
+                }
+                catch(Exception e) {
+                    log.warn("%s: unable to send message down", local_addr, e);
+                }
+                return null;
+
+            case Event.VIEW_CHANGE:
+                handleView(evt.getArg());
+                break;
+
+            case Event.SET_LOCAL_ADDRESS:
+                local_addr=evt.getArg();
+                break;
+        }
+        return down_prot.down(evt);
+    }
+
+
+    public Object up(Event evt) {
+        switch(evt.getType()) {
+            case Event.VIEW_CHANGE:
+                handleView(evt.getArg());
+                break;
+            case Event.MSG:
+                Message msg=evt.getArg();
+                try {
+                    return handleUpMessage(msg);
+                }
+                catch(Exception e) {
+                    log.warn("%s: exception occurred decrypting message", local_addr, e);
+                }
+                return null;
+        }
+        return up_prot.up(evt);
+    }
+
+
+    public void up(MessageBatch batch) {
+        Cipher cipher=null;
+        try {
+            if(secret_key == null) {
+                log.trace("%s: discarded %s batch from %s as secret key is null",
+                          local_addr, batch.dest() == null? "mcast" : "unicast", batch.sender());
+                return;
+            }
+            BiConsumer<Message,MessageBatch> decrypter=new Decrypter(cipher=decoding_ciphers.take());
+            batch.forEach(decrypter);
+        }
+        catch(InterruptedException e) {
+            log.error("%s: failed processing batch; discarding batch", local_addr, e);
+            // we need to drop the batch if we for example have a failure fetching a cipher, or else other messages
+            // in the batch might make it up the stack, bypassing decryption! This is not an issue because encryption
+            // is below NAKACK2 or UNICAST3, so messages will get retransmitted
+            return;
+        }
+        finally {
+            if(cipher != null)
+                decoding_ciphers.offer(cipher);
+        }
+        if(!batch.isEmpty())
+            up_prot.up(batch);
+    }
+
+
+
+    /** Initialises the ciphers for both encryption and decryption using the generated or supplied secret key */
+    protected synchronized void initSymCiphers(String algorithm, SecretKey secret) throws Exception {
+        if(secret == null)
+            return;
+        encoding_ciphers.clear();
+        decoding_ciphers.clear();
+        for(int i=0; i < cipher_pool_size; i++ ) {
+            encoding_ciphers.add(createCipher(Cipher.ENCRYPT_MODE, secret, algorithm));
+            decoding_ciphers.add(createCipher(Cipher.DECRYPT_MODE, secret, algorithm));
+        };
+
+        //set the version
+        MessageDigest digest=MessageDigest.getInstance("MD5");
+        digest.reset();
+        digest.update(secret.getEncoded());
+
+        byte[] tmp=digest.digest();
+        sym_version=Arrays.copyOf(tmp, tmp.length);
+        log.debug("%s: created %d symmetric ciphers with secret key (%d bytes)", local_addr, cipher_pool_size, sym_version.length);
+    }
+
+
+    protected Cipher createCipher(int mode, SecretKey secret_key, String algorithm) throws Exception {
+        Cipher cipher=provider != null && !provider.trim().isEmpty()?
+          Cipher.getInstance(algorithm, provider) : Cipher.getInstance(algorithm);
+        cipher.init(mode, secret_key);
+        return cipher;
+    }
+
+
+    protected Object handleUpMessage(Message msg) throws Exception {
+        EncryptHeader hdr=msg.getHeader(this.id);
+        if(hdr == null) {
+            log.error("%s: received message without encrypt header from %s; dropping it", local_addr, msg.src());
+            return null;
+        }
+        switch(hdr.type()) {
+            case EncryptHeader.ENCRYPT:
+                return handleEncryptedMessage(msg);
+            default:
+                return handleUpEvent(msg,hdr);
+        }
+    }
+
+
+    protected Object handleEncryptedMessage(Message msg) throws Exception {
+        if(!process(msg))
+            return null;
+
+        // try and decrypt the message - we need to copy msg as we modify its
+        // buffer (http://jira.jboss.com/jira/browse/JGRP-538)
+        Message tmpMsg=decryptMessage(null, msg.copy()); // need to copy for possible xmits
+        if(tmpMsg != null)
+            return up_prot.up(new Event(Event.MSG, tmpMsg));
+        log.warn("%s: unrecognized cipher; discarding message from %s", local_addr, msg.src());
+        return null;
+    }
+
+    protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+        return null;
+    }
+
+    /** Whether or not to process this received message */
+    protected boolean process(Message msg) {return true;}
+
+    protected void handleView(View view) {
+        this.view=view;
+    }
+
+    protected boolean inView(Address sender, String error_msg) {
+        View curr_view=this.view;
+        if(curr_view == null || curr_view.containsMember(sender))
+            return true;
+        log.error(error_msg, sender, curr_view);
+        return false;
+    }
+
+    protected Checksum createChecksummer() {return use_adler? new Adler32() : new CRC32();}
+
+
+    /** Does the actual work for decrypting - if version does not match current cipher then tries the previous cipher */
+    protected Message decryptMessage(Cipher cipher, Message msg) throws Exception {
+        EncryptHeader hdr=msg.getHeader(this.id);
+        if(!Arrays.equals(hdr.version(), sym_version)) {
+            cipher=key_map.get(new AsciiString(hdr.version()));
+            if(cipher == null) {
+                handleUnknownVersion();
+                return null;
+            }
+            log.trace("%s: decrypting msg from %s using previous cipher version", local_addr, msg.src());
+            return _decrypt(cipher, msg, hdr);
+        }
+        return _decrypt(cipher, msg, hdr);
+    }
+
+    protected Message _decrypt(final Cipher cipher, Message msg, EncryptHeader hdr) throws Exception {
+        byte[] decrypted_msg;
+
+        if(!encrypt_entire_message && msg.getLength() == 0)
+            return msg;
+
+        if(encrypt_entire_message && sign_msgs) {
+            byte[] signature=hdr.signature();
+            if(signature == null) {
+                log.error("%s: dropped message from %s as the header did not have a checksum", local_addr, msg.src());
+                return null;
+            }
+
+            long msg_checksum=decryptChecksum(cipher, signature, 0, signature.length);
+            long actual_checksum=computeChecksum(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+            if(actual_checksum != msg_checksum) {
+                log.error("%s: dropped message from %s as the message's checksum (%d) did not match the computed checksum (%d)",
+                          local_addr, msg.src(), msg_checksum, actual_checksum);
+                return null;
+            }
+        }
+
+        if(cipher == null)
+            decrypted_msg=code(msg.getRawBuffer(), msg.getOffset(), msg.getLength(), true);
+        else
+            decrypted_msg=cipher.doFinal(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+
+        if(!encrypt_entire_message) {
+            msg.setBuffer(decrypted_msg);
+            return msg;
+        }
+
+        Message ret=Util.streamableFromBuffer(Message.class,decrypted_msg,0,decrypted_msg.length);
+        if(ret.getDest() == null)
+            ret.setDest(msg.getDest());
+        if(ret.getSrc() == null)
+            ret.setSrc(msg.getSrc());
+        return ret;
+    }
+
+
+    protected void encryptAndSend(Message msg) throws Exception {
+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, symVersion());
+        if(encrypt_entire_message) {
+            if(msg.getSrc() == null)
+                msg.setSrc(local_addr);
+
+            Buffer serialized_msg=Util.streamableToBuffer(msg);
+            byte[] encrypted_msg=code(serialized_msg.getBuf(),serialized_msg.getOffset(),serialized_msg.getLength(),false);
+
+            if(sign_msgs) {
+                long checksum=computeChecksum(encrypted_msg, 0, encrypted_msg.length);
+                byte[] checksum_array=encryptChecksum(checksum);
+                hdr.signature(checksum_array);
+            }
+
+            // exclude existing headers, they will be seen again when we decrypt and unmarshal the msg at the receiver
+            Message tmp=msg.copy(false, false).setBuffer(encrypted_msg).putHeader(this.id,hdr);
+            down_prot.down(new Event(Event.MSG, tmp));
+            return;
+        }
+
+        // copy neeeded because same message (object) may be retransmitted -> prevent double encryption
+        Message msgEncrypted=msg.copy(false).putHeader(this.id, hdr);
+        if(msg.getLength() > 0)
+            msgEncrypted.setBuffer(code(msg.getRawBuffer(),msg.getOffset(),msg.getLength(),false));
+        down_prot.down(new Event(Event.MSG,msgEncrypted));
+    }
+
+
+    protected byte[] code(byte[] buf, int offset, int length, boolean decode) throws Exception {
+        BlockingQueue<Cipher> queue=decode? decoding_ciphers : encoding_ciphers;
+        Cipher cipher=queue.take();
+        try {
+            return cipher.doFinal(buf, offset, length);
+        }
+        finally {
+            queue.offer(cipher);
+        }
+    }
+
+    protected long computeChecksum(byte[] input, int offset, int length) {
+        Checksum checksummer=createChecksummer();
+        checksummer.update(input, offset, length);
+        return checksummer.getValue();
+    }
+
+    protected byte[] encryptChecksum(long checksum) throws Exception {
+        byte[] checksum_array=new byte[Global.LONG_SIZE];
+        Bits.writeLong(checksum, checksum_array, 0);
+        return code(checksum_array, 0, checksum_array.length, false);
+    }
+
+    protected long decryptChecksum(final Cipher cipher, byte[] input, int offset, int length) throws Exception {
+        byte[] decrypted_checksum;
+        if(cipher == null)
+            decrypted_checksum=code(input, offset, length, true);
+        else
+            decrypted_checksum=cipher.doFinal(input, offset, length);
+        return Bits.readLong(decrypted_checksum, 0);
+    }
+
+
+    /* Get the algorithm name from "algorithm/mode/padding"  taken from original ENCRYPT */
+    protected static String getAlgorithm(String s) {
+        int index=s.indexOf('/');
+        return index == -1? s : s.substring(0, index);
+    }
+
+
+    /** Called when the version shipped in the header can't be found */
+    protected void handleUnknownVersion() {}
+
+
+    /** Decrypts all messages in a batch, replacing encrypted messages in-place with their decrypted versions */
+    protected class Decrypter implements BiConsumer<Message,MessageBatch> {
+        protected final Cipher cipher;
+
+        public Decrypter(Cipher cipher) {
+            this.cipher=cipher;
+        }
+
+        public void accept(Message msg, MessageBatch batch) {
+            EncryptHeader hdr;
+            if((hdr=msg.getHeader(id)) == null) {
+                log.error("%s: received message without encrypt header from %s; dropping it", local_addr, batch.sender());
+                batch.remove(msg); // remove from batch to prevent passing the message further up as part of the batch
+                return;
+            }
+
+            if(hdr.type() == EncryptHeader.ENCRYPT) {
+                try {
+                    if(!process(msg)) {
+                        batch.remove(msg);
+                        return;
+                    }
+                    Message tmpMsg=decryptMessage(cipher, msg.copy()); // need to copy for possible xmits
+                    if(tmpMsg != null)
+                        batch.replace(msg, tmpMsg);
+                    else
+                        batch.remove(msg);
+                }
+                catch(Exception e) {
+                    log.error("%s: failed decrypting message from %s (offset=%d, length=%d, buf.length=%d): %s, headers are %s",
+                              local_addr, msg.getSrc(), msg.getOffset(), msg.getLength(), msg.getRawBuffer().length, e, msg.printHeaders());
+                    batch.remove(msg);
+                }
+            }
+            else {
+                batch.remove(msg); // a control message will get handled by ENCRYPT and should not be passed up
+                handleUpEvent(msg, hdr);
+            }
+        }
+    }
+
+}
diff --git a/src/org/jgroups/protocols/EncryptHeader.java b/src/org/jgroups/protocols/EncryptHeader.java
new file mode 100644
index 0000000000..3cd6448464
--- /dev/null
+++ b/src/org/jgroups/protocols/EncryptHeader.java
@@ -0,0 +1,63 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Global;
+import org.jgroups.Header;
+import org.jgroups.util.Util;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+
+/**
+ * @author Bela Ban
+ * @since  4.0
+ */
+public class EncryptHeader extends Header {
+    public static final byte ENCRYPT        = 1 << 0;
+    public static final byte SECRET_KEY_REQ = 1 << 1;
+    public static final byte SECRET_KEY_RSP = 1 << 2;
+
+    protected byte   type;
+    protected byte[] version;
+    protected byte[] signature; // the encrypted checksum
+
+
+    public EncryptHeader() {}
+
+
+    public EncryptHeader(byte type, byte[] version) {
+        this.type=type;
+        this.version=version;
+    }
+
+    public byte          type()              {return type;}
+    public byte[]        version()           {return version;}
+    public byte[]        signature()         {return signature;}
+    public EncryptHeader signature(byte[] s) {this.signature=s; return this;}
+
+    public void writeTo(DataOutput out) throws Exception {
+        out.writeByte(type);
+        Util.writeByteBuffer(version, 0, version != null? version.length : 0, out);
+        Util.writeByteBuffer(signature, 0, signature != null? signature.length : 0, out);
+    }
+
+    public void readFrom(DataInput in) throws Exception {
+        type=in.readByte();
+        version=Util.readByteBuffer(in);
+        signature=Util.readByteBuffer(in);
+    }
+
+    public String toString() {
+        return String.format("[%s version=%s]", typeToString(type), (version != null? version.length + " bytes" : "n/a"));
+    }
+
+    public int size() {return Global.BYTE_SIZE + Util.size(version) + Util.size(signature) /*+ Util.size(payload) */;}
+
+    protected static String typeToString(byte type) {
+        switch(type) {
+            case ENCRYPT:        return "ENCRYPT";
+            case SECRET_KEY_REQ: return "SECRET_KEY_REQ";
+            case SECRET_KEY_RSP: return "SECRET_KEY_RSP";
+            default:             return "<unrecognized type " + type;
+        }
+    }
+}
diff --git a/src/org/jgroups/protocols/SEQUENCER.java b/src/org/jgroups/protocols/SEQUENCER.java
index c331f93775..b44b542837 100644
--- a/src/org/jgroups/protocols/SEQUENCER.java
+++ b/src/org/jgroups/protocols/SEQUENCER.java
@@ -140,7 +140,7 @@ public void stop() {
     public Object down(Event evt) {
         switch(evt.getType()) {
             case Event.MSG:
-                Message msg=(Message)evt.getArg();
+                Message msg=evt.getArg();
                 if(msg.getDest() != null || msg.isFlagSet(Message.Flag.NO_TOTAL_ORDER) || msg.isFlagSet(Message.Flag.OOB))
                     break;
 
@@ -174,15 +174,15 @@ public Object down(Event evt) {
                 return null; // don't pass down
 
             case Event.VIEW_CHANGE:
-                handleViewChange((View)evt.getArg());
+                handleViewChange(evt.getArg());
                 break;
 
             case Event.TMP_VIEW:
-                handleTmpView((View)evt.getArg());
+                handleTmpView(evt.getArg());
                 break;
 
             case Event.SET_LOCAL_ADDRESS:
-                local_addr=(Address)evt.getArg();
+                local_addr=evt.getArg();
                 break;
         }
         return down_prot.down(evt);
@@ -197,10 +197,10 @@ public Object up(Event evt) {
 
         switch(evt.getType()) {
             case Event.MSG:
-                msg=(Message)evt.getArg();
+                msg=evt.getArg();
                 if(msg.isFlagSet(Message.Flag.NO_TOTAL_ORDER) || msg.isFlagSet(Message.Flag.OOB))
                     break;
-                hdr=(SequencerHeader)msg.getHeader(this.id);
+                hdr=msg.getHeader(this.id);
                 if(hdr == null)
                     break; // pass up
 
@@ -238,11 +238,11 @@ public Object up(Event evt) {
 
             case Event.VIEW_CHANGE:
                 Object retval=up_prot.up(evt);
-                handleViewChange((View)evt.getArg());
+                handleViewChange(evt.getArg());
                 return retval;
 
             case Event.TMP_VIEW:
-                handleTmpView((View)evt.getArg());
+                handleTmpView(evt.getArg());
                 break;
         }
 
@@ -484,7 +484,7 @@ protected void broadcast(final Message msg, boolean copy, Address original_sende
     protected void unwrapAndDeliver(final Message msg, boolean flush_ack) {
         try {
             Message msg_to_deliver=Util.streamableFromBuffer(Message.class, msg.getRawBuffer(), msg.getOffset(), msg.getLength());
-            SequencerHeader hdr=(SequencerHeader)msg_to_deliver.getHeader(this.id);
+            SequencerHeader hdr=msg_to_deliver.getHeader(this.id);
             if(flush_ack)
                 hdr.flush_ack=true;
             deliver(msg_to_deliver, new Event(Event.MSG, msg_to_deliver), hdr);
diff --git a/src/org/jgroups/protocols/SEQUENCER2.java b/src/org/jgroups/protocols/SEQUENCER2.java
index b9b638ed51..7a0c6debac 100644
--- a/src/org/jgroups/protocols/SEQUENCER2.java
+++ b/src/org/jgroups/protocols/SEQUENCER2.java
@@ -135,7 +135,7 @@ public Object down(Event evt) {
         switch(evt.getType()) {
             case Event.MSG:
             	
-                Message msg=(Message)evt.getArg();
+                Message msg=evt.getArg();
                 if(msg.getDest() != null || msg.isFlagSet(Message.Flag.NO_TOTAL_ORDER) || msg.isFlagSet(Message.Flag.OOB))
                     break;
                 
@@ -158,15 +158,15 @@ public Object down(Event evt) {
                 return null; // don't pass down
 
             case Event.VIEW_CHANGE:
-                handleViewChange((View)evt.getArg());
+                handleViewChange(evt.getArg());
                 break;
 
             case Event.TMP_VIEW:
-                handleTmpView((View)evt.getArg());
+                handleTmpView(evt.getArg());
                 break;
 
             case Event.SET_LOCAL_ADDRESS:
-                local_addr=(Address)evt.getArg();
+                local_addr=evt.getArg();
                 break;
         }
         return down_prot.down(evt);
@@ -178,10 +178,10 @@ public Object up(Event evt) {
 
         switch(evt.getType()) {
             case Event.MSG:
-                msg=(Message)evt.getArg();
+                msg=evt.getArg();
                 if(msg.isFlagSet(Message.Flag.NO_TOTAL_ORDER) || msg.isFlagSet(Message.Flag.OOB))
                     break;
-                hdr=(SequencerHeader)msg.getHeader(this.id);
+                hdr=msg.getHeader(this.id);
                 if(hdr == null)
                     break; // pass up
                                 
@@ -236,11 +236,11 @@ public Object up(Event evt) {
 
             case Event.VIEW_CHANGE:
                 Object retval=up_prot.up(evt);
-                handleViewChange((View)evt.getArg());
+                handleViewChange(evt.getArg());
                 return retval;
 
             case Event.TMP_VIEW:
-                handleTmpView((View)evt.getArg());
+                handleTmpView(evt.getArg());
                 break;
         }
 
@@ -433,7 +433,7 @@ protected void deliverBatch(MessageBatch batch) {
                 Message first=batch.first(), last=batch.last();
                 StringBuilder sb=new StringBuilder(local_addr + ": delivering");
                 if(first != null && last != null) {
-                    SequencerHeader hdr1=(SequencerHeader)first.getHeader(id), hdr2=(SequencerHeader)last.getHeader(id);
+                    SequencerHeader hdr1=first.getHeader(id), hdr2=last.getHeader(id);
                     sb.append(" #").append(hdr1.seqno).append(" - #").append(hdr2.seqno);
                 }
                 sb.append(" (" + batch.size()).append(" messages)");
diff --git a/src/org/jgroups/protocols/SNIFF.java b/src/org/jgroups/protocols/SNIFF.java
new file mode 100644
index 0000000000..2e2f71dd53
--- /dev/null
+++ b/src/org/jgroups/protocols/SNIFF.java
@@ -0,0 +1,70 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Event;
+import org.jgroups.Message;
+import org.jgroups.annotations.MBean;
+import org.jgroups.annotations.Property;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.MessageBatch;
+
+/**
+ * Protocol trying to print message payloads as strings
+ * @author Bela Ban
+ * @since  4.0
+ */
+@MBean(description="Protocol trying to print payloads as strings")
+public class SNIFF extends Protocol {
+    @Property(description="Print received messages")
+    protected boolean up=true;
+
+    @Property(description="Print sent messages")
+    protected boolean down;
+
+
+    public Object down(Event evt) {
+        if(down && evt.getType() == Event.MSG) {
+            Message msg=(Message)evt.getArg();
+            dump("down msg", msg);
+        }
+        return down_prot.down(evt);
+    }
+
+    public Object up(Event evt) {
+        if(up && evt.getType() == Event.MSG) {
+            Message msg=(Message)evt.getArg();
+            dump("up msg", msg);
+        }
+        return up_prot.up(evt);
+    }
+
+    public void up(MessageBatch batch) {
+        int count=1;
+        for(Message msg: batch)
+            dump("batch msg#" + count++, msg);
+
+        up_prot.up(batch);
+    }
+
+
+
+    protected static void dump(String type, Message msg) {
+        StringBuilder sb=new StringBuilder();
+        sb.append(String.format("\n%s from %s (%d bytes):\nhdrs: %s\n", type, msg.src(), msg.getLength(), msg.printHeaders()));
+        if(msg.getLength() > 0) {
+            sb.append("payload: ");
+            printPayload(msg, sb);
+            sb.append("\n");
+        }
+        System.out.println(sb.toString());
+    }
+
+    protected static String printPayload(Message msg, final StringBuilder sb) {
+        byte[] payload=msg.getRawBuffer();
+        int print_max=Math.min(msg.getLength(), 50);
+        for(int i=msg.getOffset(); i < print_max; i++) {
+            byte ch=payload[i];
+            sb.append((char)ch);
+        }
+        return null;
+    }
+}
diff --git a/src/org/jgroups/protocols/SYM_ENCRYPT.java b/src/org/jgroups/protocols/SYM_ENCRYPT.java
new file mode 100644
index 0000000000..b3f47ac363
--- /dev/null
+++ b/src/org/jgroups/protocols/SYM_ENCRYPT.java
@@ -0,0 +1,124 @@
+package org.jgroups.protocols;
+
+import org.jgroups.annotations.MBean;
+import org.jgroups.annotations.Property;
+import org.jgroups.util.Util;
+
+import javax.crypto.SecretKey;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.KeyStore;
+import java.security.NoSuchAlgorithmException;
+import java.security.cert.CertificateException;
+
+/**
+ * Encrypts and decrypts communication in JGroups by using a secret key shared by all cluster members.<p>
+ *
+ * The secret key is identical for all cluster members and is injected into this protocol at startup, e.g. by reading
+ * it from a keystore. Messages are sent by encrypting them with the secret key and received by decrypting them with
+ * the secret key. Note that all cluster members must be shipped with the same keystore file<p>
+ *
+ * This protocol is typically placed under {@link org.jgroups.protocols.pbcast.NAKACK2}, so that most important
+ * headers are encrypted as well, to prevent replay attacks.<p>
+ *
+ * A possible configuration looks like this:<br><br>
+ * {@code <SYM_ENCRYPT key_store_name="defaultStore.keystore" store_password="changeit" alias="myKey"/>}
+ * <br>
+ * <br>
+ * In order to use SYM_ENCRYPT layer in this manner, it is necessary to have the secret key already generated in a
+ * keystore file. The directory containing the keystore file must be on the application's classpath. You cannot create a
+ * secret key keystore file using the keytool application shipped with the JDK. A java file called KeyStoreGenerator is
+ * included in the demo package that can be used from the command line (or IDE) to generate a suitable keystore.
+ *
+ * @author Bela Ban
+ * @author Steve Woodcock
+ */
+@MBean(description="Symmetric encryption protocol. The (shared) shared secret key is configured up front, " +
+  "e.g. via a key store, or injection")
+public class SYM_ENCRYPT extends Encrypt {
+
+    /* -----------------------------------------    Properties     -------------------------------------------------- */
+    @Property(description="File on classpath that contains keystore repository")
+    protected String   keystore_name;
+
+    @Property(description="Password used to check the integrity/unlock the keystore. Change the default",
+      exposeAsManagedAttribute=false)
+    protected String   store_password="changeit"; // JDK default
+
+    @Property(description="Password for recovering the key. Change the default", exposeAsManagedAttribute=false)
+    protected String   key_password; // allows to assign keypwd=storepwd if not set (https://issues.jboss.org/browse/JGRP-1375)
+
+
+    @Property(name="alias", description="Alias used for recovering the key. Change the default",exposeAsManagedAttribute=false)
+    protected String   alias="mykey"; // JDK default
+
+
+    public String      keystoreName()                      {return this.keystore_name;}
+    public SYM_ENCRYPT keystoreName(String n)              {this.keystore_name=n; return this;}
+    public String      alias()                             {return alias;}
+    public SYM_ENCRYPT alias(String a)                     {this.alias=a; return this;}
+    public String      storePassword()                     {return store_password;}
+    public SYM_ENCRYPT storePassword(String pwd)           {this.store_password=pwd; return this;}
+
+
+
+
+    public void init() throws Exception {
+        if(key_password == null && store_password != null) {
+            key_password=store_password;
+            log.debug("%s: key_password used is same as store_password", local_addr);
+        }
+        readSecretKeyFromKeystore();
+        super.init();
+    }
+
+    /**
+     * Initialisation if a supplied key is defined in the properties. This supplied key must be in a keystore which
+     * can be generated using the keystoreGenerator file in demos. The keystore must be on the classpath to find it.
+     */
+    protected void readSecretKeyFromKeystore() throws Exception {
+        InputStream inputStream=null;
+        // must not use default keystore type - as it does not support secret keys
+        KeyStore store=KeyStore.getInstance("JCEKS");
+
+        SecretKey tempKey=null;
+        try {
+            if(this.secret_key == null) { // in case the secret key was set before, e.g. via injection in a unit test
+                // load in keystore using this thread's classloader
+                inputStream=Thread.currentThread().getContextClassLoader().getResourceAsStream(keystore_name);
+                if(inputStream == null)
+                    inputStream=new FileInputStream(keystore_name);
+                // we can't find a keystore here -
+                if(inputStream == null)
+                    throw new Exception("Unable to load keystore " + keystore_name + " ensure file is on classpath");
+                // we have located a file lets load the keystore
+                try {
+                    store.load(inputStream, store_password.toCharArray());
+                    // loaded keystore - get the key
+                    tempKey=(SecretKey)store.getKey(alias, key_password.toCharArray());
+                }
+                catch(IOException e) {
+                    throw new Exception("Unable to load keystore " + keystore_name + ": " + e);
+                }
+                catch(NoSuchAlgorithmException e) {
+                    throw new Exception("No Such algorithm " + keystore_name + ": " + e);
+                }
+                catch(CertificateException e) {
+                    throw new Exception("Certificate exception " + keystore_name + ": " + e);
+                }
+
+                if(tempKey == null)
+                    throw new Exception("Unable to retrieve key '" + alias + "' from keystore " + keystore_name);
+                this.secret_key=tempKey;
+                if(sym_algorithm.equals(DEFAULT_SYM_ALGO))
+                    sym_algorithm=tempKey.getAlgorithm();
+            }
+        }
+        finally {
+            Util.close(inputStream);
+        }
+    }
+
+
+}
diff --git a/src/org/jgroups/protocols/TP.java b/src/org/jgroups/protocols/TP.java
index 9e2169fcb9..6a62c1fdca 100644
--- a/src/org/jgroups/protocols/TP.java
+++ b/src/org/jgroups/protocols/TP.java
@@ -1231,7 +1231,7 @@ public Object down(Event evt) {
 
         Message msg=(Message)evt.getArg();
         if(header != null)
-            msg.putHeaderIfAbsent(this.id, header); // added patch by Roland Kurmann (March 20 2003)
+            msg.putHeader(this.id, header); // added patch by Roland Kurmann (March 20 2003)
 
         setSourceAddress(msg); // very important !! listToBuffer() will fail with a null src address !!
 
diff --git a/src/org/jgroups/protocols/TpHeader.java b/src/org/jgroups/protocols/TpHeader.java
index 19a5beb0bc..196186ceb6 100644
--- a/src/org/jgroups/protocols/TpHeader.java
+++ b/src/org/jgroups/protocols/TpHeader.java
@@ -36,7 +36,7 @@ public TpHeader(byte[] n) {
     }
 
     public String toString() {
-        return "[cluster_name=" + new String(cluster_name) + ']';
+        return String.format("[cluster_name=%s]", new String(cluster_name));
     }
 
     public int size() {
diff --git a/src/org/jgroups/protocols/UNICAST3.java b/src/org/jgroups/protocols/UNICAST3.java
index d82a7bb468..8469077b80 100644
--- a/src/org/jgroups/protocols/UNICAST3.java
+++ b/src/org/jgroups/protocols/UNICAST3.java
@@ -398,11 +398,11 @@ public void stop() {
     public Object up(Event evt) {
         switch(evt.getType()) {
             case Event.MSG:
-                Message msg=(Message)evt.getArg();
+                Message msg=evt.getArg();
                 if(msg.getDest() == null || msg.isFlagSet(Message.Flag.NO_RELIABILITY))  // only handle unicast messages
                     break;  // pass up
 
-                Header hdr=(Header)msg.getHeader(this.id);
+                Header hdr=msg.getHeader(this.id);
                 if(hdr == null)
                     break;
                 Address sender=msg.getSrc();
@@ -478,7 +478,7 @@ public void up(MessageBatch batch) {
 
         for(Message msg: batch) {
             Header hdr;
-            if(msg == null || msg.isFlagSet(Message.Flag.NO_RELIABILITY) || (hdr=(Header)msg.getHeader(id)) == null)
+            if(msg == null || msg.isFlagSet(Message.Flag.NO_RELIABILITY) || (hdr=msg.getHeader(id)) == null)
                 continue;
             batch.remove(msg); // remove the message from the batch, so it won't be passed up the stack
 
@@ -518,7 +518,7 @@ protected void handleBatchFromSelf(MessageBatch batch, Entry entry) {
 
         for(Message msg: batch) {
             Header hdr;
-            if(msg == null || msg.isFlagSet(Message.Flag.NO_RELIABILITY) || (hdr=(Header)msg.getHeader(id)) == null)
+            if(msg == null || msg.isFlagSet(Message.Flag.NO_RELIABILITY) || (hdr=msg.getHeader(id)) == null)
                 continue;
             batch.remove(msg); // remove the message from the batch, so it won't be passed up the stack
 
@@ -569,7 +569,7 @@ public Object down(Event evt) {
         switch (evt.getType()) {
 
             case Event.MSG: // Add UnicastHeader, add to AckSenderWindow and pass down
-                Message msg=(Message)evt.getArg();
+                Message msg=evt.getArg();
                 Address dst=msg.getDest();
 
                 /* only handle unicast messages */
@@ -623,7 +623,7 @@ public Object down(Event evt) {
                 return down_prot.down(evt);
 
             case Event.VIEW_CHANGE:  // remove connections to peers that are not members anymore !
-                View view=(View)evt.getArg();
+                View view=evt.getArg();
                 List<Address> new_members=view.getMembers();
                 Set<Address> non_members=new HashSet<>(send_table.keySet());
                 non_members.addAll(recv_table.keySet());
@@ -651,7 +651,7 @@ public Object down(Event evt) {
                 break;
 
             case Event.SET_LOCAL_ADDRESS:
-                local_addr=(Address)evt.getArg();
+                local_addr=evt.getArg();
                 break;
         }
 
@@ -722,7 +722,7 @@ protected void retransmit(SeqnoList missing, Address sender) {
     /** Called by the sender to resend messages for which no ACK has been received yet */
     protected void retransmit(Message msg) {
         if(log.isTraceEnabled()) {
-            Header hdr=(Header)msg.getHeader(id);
+            Header hdr=msg.getHeader(id);
             long seqno=hdr != null? hdr.seqno : -1;
             log.trace("%s --> XMIT(%s: #%d)", local_addr, msg.getDest(), seqno);
         }
@@ -892,12 +892,12 @@ protected String printMessageList(List<Tuple<Long,Message>> list) {
         Message first=size > 0? list.get(0).getVal2() : null, second=size > 1? list.get(size-1).getVal2() : first;
         Header hdr;
         if(first != null) {
-            hdr=(Header)first.getHeader(id);
+            hdr=first.getHeader(id);
             if(hdr != null)
                 sb.append("#" + hdr.seqno);
         }
         if(second != null) {
-            hdr=(Header)second.getHeader(id);
+            hdr=second.getHeader(id);
             if(hdr != null)
                 sb.append(" - #" + hdr.seqno);
         }
@@ -1013,7 +1013,7 @@ protected void handleResendingOfFirstMessage(Address sender, long timestamp) {
             // the headers and therefore we'd modify the original message in the sender retransmission window
             // (https://jira.jboss.org/jira/browse/JGRP-965)
             Message copy=rsp.copy();
-            Header hdr=(Header)copy.getHeader(this.id);
+            Header hdr=copy.getHeader(this.id);
             Header newhdr=hdr.copy();
             newhdr.first=true;
             copy.putHeader(this.id, newhdr);
@@ -1051,7 +1051,7 @@ protected void deliverMessage(final Event evt, final Address sender, final long
             up_prot.up(evt);
         }
         catch(Throwable t) {
-            Message msg=(Message)evt.getArg();
+            Message msg=evt.getArg();
             log.error(Util.getMessage("FailedToDeliverMsg"), local_addr, msg.isFlagSet(Message.Flag.OOB) ?
               "OOB message" : "message", msg, t);
         }
@@ -1065,7 +1065,7 @@ protected void deliverBatch(MessageBatch batch) {
                 Message first=batch.first(), last=batch.last();
                 StringBuilder sb=new StringBuilder(local_addr + ": delivering");
                 if(first != null && last != null) {
-                    Header hdr1=(Header)first.getHeader(id), hdr2=(Header)last.getHeader(id);
+                    Header hdr1=first.getHeader(id), hdr2=last.getHeader(id);
                     sb.append(" #").append(hdr1.seqno).append(" - #").append(hdr2.seqno);
                 }
                 sb.append(" (" + batch.size()).append(" messages)");
diff --git a/src/org/jgroups/protocols/pbcast/GMS.java b/src/org/jgroups/protocols/pbcast/GMS.java
index 869e40cb1e..815ff74751 100644
--- a/src/org/jgroups/protocols/pbcast/GMS.java
+++ b/src/org/jgroups/protocols/pbcast/GMS.java
@@ -620,8 +620,10 @@ public void sendJoinResponses(JoinRsp jr, Collection<Address> newMembers) {
         if(jr != null && newMembers != null && !newMembers.isEmpty()) {
             final ViewId view_id=jr.getView().getViewId();
             ack_collector.reset(new ArrayList<>(newMembers));
-            for(Address joiner: newMembers)
+            for(Address joiner: newMembers) {
+                log.trace("%s: sending join-rsp to %s: view=%s (%d mbrs)\n", local_addr, joiner, jr.getView(), jr.getView().size());
                 sendJoinResponse(jr, joiner);
+            }
             try {
                 ack_collector.waitForAllAcks(view_ack_collection_timeout);
                 log.trace("%s: got all ACKs (%d) from joiners for view %s", local_addr, ack_collector.expectedAcks(), view_id);
@@ -847,8 +849,8 @@ public Object up(Event evt) {
         switch(evt.getType()) {
 
             case Event.MSG:
-                final Message msg=(Message)evt.getArg();
-                GmsHeader hdr=(GmsHeader)msg.getHeader(this.id);
+                final Message msg=evt.getArg();
+                GmsHeader hdr=msg.getHeader(this.id);
                 if(hdr == null)
                     break;
 
@@ -1006,18 +1008,18 @@ public Object up(Event evt) {
 
             case Event.SUSPECT:
                 Object retval=up_prot.up(evt);
-                Address suspected=(Address)evt.getArg();
+                Address suspected=evt.getArg();
                 view_handler.add(new Request(Request.SUSPECT, suspected, true));
                 ack_collector.suspect(suspected);
                 merge_ack_collector.suspect(suspected);
                 return retval;
 
             case Event.UNSUSPECT:
-                impl.unsuspect((Address)evt.getArg());
+                impl.unsuspect(evt.getArg());
                 return null;                              // discard
 
             case Event.MERGE:
-                view_handler.add(new Request(Request.MERGE, null, false, (Map<Address,View>)evt.getArg()));
+                view_handler.add(new Request(Request.MERGE, null, false, evt.getArg()));
                 return null;                              // don't pass up
 
             case Event.IS_MERGE_IN_PROGRESS:
@@ -1069,7 +1071,7 @@ public Object down(Event evt) {
                 return null;  // don't pass down: event has already been passed down
 
             case Event.DISCONNECT:
-                impl.leave((Address)evt.getArg());
+                impl.leave(evt.getArg());
                 if(!(impl instanceof CoordGmsImpl)) {
                     initState(); // in case connect() is called again
                 }
@@ -1077,14 +1079,14 @@ public Object down(Event evt) {
                 return null;
 
             case Event.CONFIG :
-               Map<String,Object> config=(Map<String,Object>)evt.getArg();
+               Map<String,Object> config=evt.getArg();
                if((config != null && config.containsKey("flush_supported"))){
                  flushProtocolInStack=true;
                }
                break;
 
             case Event.SET_LOCAL_ADDRESS:
-                local_addr=(Address)evt.getArg();
+                local_addr=evt.getArg();
                 break;
             case Event.GET_VIEW_FROM_COORD:
                 Address coord=view != null? view.getCreator() : null;
@@ -1397,7 +1399,7 @@ public GmsHeader(byte type, Address mbr) {
         public MergeId   getMergeId()                             {return merge_id;}
         public void      setMergeId(MergeId merge_id)             {this.merge_id=merge_id;}
         public boolean   isMergeRejected()                        {return merge_rejected;}
-        public void      setMergeRejected(boolean merge_rejected) {this.merge_rejected=merge_rejected;}
+        public GmsHeader setMergeRejected(boolean merge_rejected) {this.merge_rejected=merge_rejected; return this;}
 
 
 
diff --git a/src/org/jgroups/protocols/pbcast/Merger.java b/src/org/jgroups/protocols/pbcast/Merger.java
index 5b257f1777..78c57dafa2 100644
--- a/src/org/jgroups/protocols/pbcast/Merger.java
+++ b/src/org/jgroups/protocols/pbcast/Merger.java
@@ -610,8 +610,8 @@ protected boolean getMergeDataFromSubgroupCoordinators(Map<Address,Collection<Ad
             // wait until num_rsps_expected >= num_rsps or timeout elapsed
             merge_rsps.waitForAllResponses(timeout);
             gotAllResponses=merge_rsps.hasAllResponses();
-            long stop=System.currentTimeMillis();
-            log.trace("%s: collected %d merge response(s) in %d ms", gms.local_addr, merge_rsps.numberOfValidResponses(), stop - start);
+            long time=System.currentTimeMillis() - start;
+            log.trace("%s: collected %d merge response(s) in %d ms", gms.local_addr, merge_rsps.numberOfValidResponses(), time);
             return gotAllResponses;
         }
 
diff --git a/src/org/jgroups/protocols/pbcast/NAKACK2.java b/src/org/jgroups/protocols/pbcast/NAKACK2.java
index 2c913ca02c..91ed7e05cb 100644
--- a/src/org/jgroups/protocols/pbcast/NAKACK2.java
+++ b/src/org/jgroups/protocols/pbcast/NAKACK2.java
@@ -484,7 +484,7 @@ public Object down(Event evt) {
         switch(evt.getType()) {
 
             case Event.MSG:
-                Message msg=(Message)evt.getArg();
+                Message msg=evt.getArg();
                 Address dest=msg.getDest();
                 if(dest != null || msg.isFlagSet(Message.Flag.NO_RELIABILITY))
                     break; // unicast address: not null and not mcast, pass down unchanged
@@ -493,31 +493,31 @@ public Object down(Event evt) {
                 return null;    // don't pass down the stack
 
             case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg
-                stable((Digest)evt.getArg());
+                stable(evt.getArg());
                 return null;  // do not pass down further (Bela Aug 7 2001)
 
             case Event.GET_DIGEST:
-                return getDigest((Address)evt.getArg());
+                return getDigest(evt.getArg());
 
             case Event.SET_DIGEST:
-                setDigest((Digest)evt.getArg());
+                setDigest(evt.getArg());
                 return null;
 
             case Event.OVERWRITE_DIGEST:
-                overwriteDigest((Digest)evt.getArg());
+                overwriteDigest(evt.getArg());
                 return null;
 
             case Event.MERGE_DIGEST:
-                mergeDigest((Digest)evt.getArg());
+                mergeDigest(evt.getArg());
                 return null;
 
             case Event.TMP_VIEW:
-                View tmp_view=(View)evt.getArg();
+                View tmp_view=evt.getArg();
                 members=tmp_view.getMembers();
                 break;
 
             case Event.VIEW_CHANGE:
-                tmp_view=(View)evt.getArg();
+                tmp_view=evt.getArg();
                 List<Address> mbrs=tmp_view.getMembers();
                 members=mbrs;
                 view=tmp_view;
@@ -534,7 +534,7 @@ public Object down(Event evt) {
                 break;
 
             case Event.SET_LOCAL_ADDRESS:
-                local_addr=(Address)evt.getArg();
+                local_addr=evt.getArg();
                 break;
 
             case Event.DISCONNECT:
@@ -544,7 +544,7 @@ public Object down(Event evt) {
 
             case Event.REBROADCAST:
                 rebroadcasting=true;
-                rebroadcast_digest=(Digest)evt.getArg();
+                rebroadcast_digest=evt.getArg();
                 try {
                     rebroadcastMessages();
                 }
@@ -575,10 +575,10 @@ public Object up(Event evt) {
         switch(evt.getType()) {
 
             case Event.MSG:
-                Message msg=(Message)evt.getArg();
+                Message msg=evt.getArg();
                 if(msg.isFlagSet(Message.Flag.NO_RELIABILITY))
                     break;
-                NakAckHeader2 hdr=(NakAckHeader2)msg.getHeader(this.id);
+                NakAckHeader2 hdr=msg.getHeader(this.id);
                 if(hdr == null)
                     break;  // pass up (e.g. unicast msg)
 
@@ -618,7 +618,7 @@ public Object up(Event evt) {
                 }
 
             case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg
-                stable((Digest)evt.getArg());
+                stable(evt.getArg());
                 return null;  // do not pass up further (Bela Aug 7 2001)
 
             case Event.SUSPECT:
@@ -640,7 +640,7 @@ public void up(MessageBatch batch) {
         for(Iterator<Message> it=batch.iterator(); it.hasNext();) {
             final Message msg=it.next();
             NakAckHeader2 hdr;
-            if(msg == null || msg.isFlagSet(Message.Flag.NO_RELIABILITY) || (hdr=(NakAckHeader2)msg.getHeader(id)) == null)
+            if(msg == null || msg.isFlagSet(Message.Flag.NO_RELIABILITY) || (hdr=msg.getHeader(id)) == null)
                 continue;
             it.remove(); // remove the message from the batch, so it won't be passed up the stack
 
@@ -959,7 +959,7 @@ protected void deliverBatch(MessageBatch batch) {
                 Message first=batch.first(), last=batch.last();
                 StringBuilder sb=new StringBuilder(local_addr + ": delivering " + batch.sender());
                 if(first != null && last != null) {
-                    NakAckHeader2 hdr1=(NakAckHeader2)first.getHeader(id), hdr2=(NakAckHeader2)last.getHeader(id);
+                    NakAckHeader2 hdr1=first.getHeader(id), hdr2=last.getHeader(id);
                     sb.append("#").append(hdr1.seqno).append("-").append(hdr2.seqno);
                 }
                 sb.append(" (" + batch.size()).append(" messages)");
@@ -1035,7 +1035,7 @@ protected void sendXmitRsp(Address dest, Message msg) {
         }
 
         Message xmit_msg=msg.copy(true, true).dest(dest); // copy payload and headers
-        NakAckHeader2 hdr=(NakAckHeader2)xmit_msg.getHeader(id);
+        NakAckHeader2 hdr=xmit_msg.getHeader(id);
         NakAckHeader2 newhdr=hdr.copy();
         newhdr.type=NakAckHeader2.XMIT_RSP; // change the type in the copy from MSG --> XMIT_RSP
         xmit_msg.putHeader(id, newhdr);
diff --git a/src/org/jgroups/stack/Protocol.java b/src/org/jgroups/stack/Protocol.java
index 2c68284bb1..dd56dc8e5f 100644
--- a/src/org/jgroups/stack/Protocol.java
+++ b/src/org/jgroups/stack/Protocol.java
@@ -73,8 +73,8 @@
 
 
     /**
-     * Sets the level of a logger. This method is used to dynamically change the logging level of a
-     * running system, e.g. via JMX. The appender of a level needs to exist.
+     * Sets the level of a logger. This method is used to dynamically change the logging level of a running system,
+     * e.g. via JMX. The appender of a level needs to exist.
      * @param level The new level. Valid values are "fatal", "error", "warn", "info", "debug", "trace"
      * (capitalization not relevant)
      */
diff --git a/src/org/jgroups/stack/ProtocolStack.java b/src/org/jgroups/stack/ProtocolStack.java
index 51b55475bd..119ce5995b 100644
--- a/src/org/jgroups/stack/ProtocolStack.java
+++ b/src/org/jgroups/stack/ProtocolStack.java
@@ -30,8 +30,7 @@
  * @author Bela Ban
  */
 public class ProtocolStack extends Protocol {
-    public static final int       ABOVE = 1; // used by insertProtocol()
-    public static final int       BELOW = 2; // used by insertProtocol()
+    public enum Position {ABOVE, BELOW};
     protected static final String max_list_print_size="max-list-print-size";
 
     protected Protocol            top_prot;
@@ -133,7 +132,7 @@
                         log.error(Util.getMessage("NeighborProtocol") + neighbor_prot + " not found in stack");
                         break;
                     }
-                    int position=tmp.equalsIgnoreCase("above")? ABOVE : BELOW;
+                    Position position=tmp.equalsIgnoreCase("above")? Position.ABOVE : Position.BELOW;
                     try {
                         insertProtocol(prot, position, neighbor.getClass());
                     }
@@ -288,7 +287,7 @@ public TP getTransport() {
                         it.remove();
                 }
             }
-            retval.put(protocol_name, tmp);
+            retval.put(protocol_name, new TreeMap<>(tmp));
         }
 
         return retval;
@@ -536,25 +535,22 @@ public ProtocolStack addProtocols(List<Protocol> prots) {
      *                      is not found
      * @exception Exception Will be thrown when the new protocol cannot be created, or inserted.
      */
-    public void insertProtocol(Protocol prot, int position, String neighbor_prot) throws Exception {
+    public void insertProtocol(Protocol prot, Position position, String neighbor_prot) throws Exception {
         if(neighbor_prot == null) throw new IllegalArgumentException("neighbor_prot is null");
-        if(position != ProtocolStack.ABOVE && position != ProtocolStack.BELOW)
-            throw new IllegalArgumentException("position has to be ABOVE or BELOW");
-
         Protocol neighbor=findProtocol(neighbor_prot);
         if(neighbor == null)
             throw new IllegalArgumentException("protocol " + neighbor_prot + " not found in " + printProtocolSpec(false));
 
-        if(position == ProtocolStack.BELOW && neighbor instanceof TP)
+        if(position == Position.BELOW && neighbor instanceof TP)
             throw new IllegalArgumentException("Cannot insert protocol " + prot.getName() + " below transport protocol");
 
         insertProtocolInStack(prot, neighbor,  position);
     }
 
 
-    public void insertProtocolInStack(Protocol prot, Protocol neighbor, int position) {
+    public void insertProtocolInStack(Protocol prot, Protocol neighbor, Position position) {
      // connect to the protocol layer below and above
-        if(position == ProtocolStack.BELOW) {
+        if(position == Position.BELOW) {
             prot.setUpProtocol(neighbor);
             Protocol below=neighbor.getDownProtocol();
             prot.setDownProtocol(below);
@@ -580,29 +576,21 @@ private void checkAndSwitchTop(Protocol oldTop, Protocol newTop){
         }
     }
 
-    public void insertProtocol(Protocol prot, int position, Class<? extends Protocol> neighbor_prot) throws Exception {
+    public void insertProtocol(Protocol prot, Position position, Class<? extends Protocol> neighbor_prot) throws Exception {
         if(neighbor_prot == null) throw new IllegalArgumentException("neighbor_prot is null");
-        if(position != ProtocolStack.ABOVE && position != ProtocolStack.BELOW)
-            throw new IllegalArgumentException("position has to be ABOVE or BELOW");
-
         Protocol neighbor=findProtocol(neighbor_prot);
         if(neighbor == null)
             throw new IllegalArgumentException("protocol \"" + neighbor_prot + "\" not found in " + stack.printProtocolSpec(false));
 
-        if(position == ProtocolStack.BELOW && neighbor instanceof TP)
-            throw new IllegalArgumentException("protocol \"" + prot + "\" cannot be inserted below the transport protocol (" +
-                                                 neighbor + ")");
-
+        if(position == Position.BELOW && neighbor instanceof TP)
+            throw new IllegalArgumentException("\"" + prot + "\" cannot be inserted below the transport (" + neighbor + ")");
         insertProtocolInStack(prot, neighbor,  position);
     }
 
 
     @SafeVarargs
-    public final void insertProtocol(Protocol prot, int position, Class<? extends Protocol>... neighbor_prots) throws Exception {
+    public final void insertProtocol(Protocol prot, Position position, Class<? extends Protocol>... neighbor_prots) throws Exception {
         if(neighbor_prots == null) throw new IllegalArgumentException("neighbor_prots is null");
-        if(position != ProtocolStack.ABOVE && position != ProtocolStack.BELOW)
-            throw new IllegalArgumentException("position has to be ABOVE or BELOW");
-
         Protocol neighbor=findProtocol(neighbor_prots);
         if(neighbor == null)
             throw new IllegalArgumentException("protocol \"" + Arrays.toString(neighbor_prots) + "\" not found in " + stack.printProtocolSpec(false));
diff --git a/src/org/jgroups/util/AsciiString.java b/src/org/jgroups/util/AsciiString.java
index 4b98563347..45ccab0c61 100644
--- a/src/org/jgroups/util/AsciiString.java
+++ b/src/org/jgroups/util/AsciiString.java
@@ -69,8 +69,9 @@ public boolean equals(Object obj) {
 
     public int hashCode() {
         int h=0;
-        for(int i=0; i < val.length; i++)
-            h=31 * h + val[i];
+        if(val != null)
+            for(int i=0; i < val.length; i++)
+                h=31 * h + val[i];
         return h;
     }
 
diff --git a/src/org/jgroups/util/Headers.java b/src/org/jgroups/util/Headers.java
index 9dccb7cfe2..2e7fa67dde 100644
--- a/src/org/jgroups/util/Headers.java
+++ b/src/org/jgroups/util/Headers.java
@@ -36,14 +36,14 @@ private Headers() {
      * @param id The ID
      * @return
      */
-    public static Header getHeader(final Header[] hdrs, short id) {
+    public static <T extends Header> T getHeader(final Header[] hdrs, short id) {
         if(hdrs == null)
             return null;
         for(Header hdr: hdrs) {
             if(hdr == null)
                 return null;
             if(hdr.getProtId() == id)
-                return hdr;
+                return (T)hdr;
         }
         return null;
     }
diff --git a/src/org/jgroups/util/MessageBatch.java b/src/org/jgroups/util/MessageBatch.java
index 738f4b0fa7..0e4c1b76f4 100644
--- a/src/org/jgroups/util/MessageBatch.java
+++ b/src/org/jgroups/util/MessageBatch.java
@@ -4,6 +4,7 @@
 import org.jgroups.Message;
 
 import java.util.*;
+import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
@@ -215,6 +216,16 @@ public MessageBatch clear() {
         return retval;
     }
 
+    public <T> void forEach(BiConsumer<Message,MessageBatch> consumer) {
+        for(int i=0; i < index; i++) {
+            try {
+                consumer.accept(messages[i], this);
+            }
+            catch(Throwable t) {
+            }
+        }
+    }
+
 
     /** Returns the number of non-null messages */
     public int size() {
diff --git a/src/org/jgroups/util/MyReceiver.java b/src/org/jgroups/util/MyReceiver.java
index 9b7be342da..db0813f353 100644
--- a/src/org/jgroups/util/MyReceiver.java
+++ b/src/org/jgroups/util/MyReceiver.java
@@ -3,8 +3,8 @@
 import org.jgroups.Message;
 import org.jgroups.ReceiverAdapter;
 
-import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
  * Generic receiver for a JChannel
@@ -12,18 +12,20 @@
  * @since  3.3
  */
 public class MyReceiver<T> extends ReceiverAdapter {
-    protected final List<T> list=new ArrayList<>();
+    protected final List<T> list=new CopyOnWriteArrayList<>();
     protected String        name;
     protected boolean       verbose;
+    protected boolean       raw_msgs;
 
     public void receive(Message msg) {
-        T obj=(T)msg.getObject();
+        T obj=raw_msgs? (T)msg : (T)msg.getObject();
         list.add(obj);
         if(verbose) {
             System.out.println((name() != null? name() + ":" : "") + " received message from " + msg.getSrc() + ": " + obj);
         }
     }
 
+    public MyReceiver    rawMsgs(boolean flag) {this.raw_msgs=flag; return this;}
     public List<T>       list()                {return list;}
     public MyReceiver<T> verbose(boolean flag) {verbose=flag; return this;}
     public String        name()                {return name;}
diff --git a/src/org/jgroups/util/SuppressLog.java b/src/org/jgroups/util/SuppressLog.java
index d63bb5cc26..64be39181b 100644
--- a/src/org/jgroups/util/SuppressLog.java
+++ b/src/org/jgroups/util/SuppressLog.java
@@ -19,7 +19,7 @@ public SuppressLog(Log log, String message_key, String suppress_msg) {
         this.log=log;
         cache=new SuppressCache<>();
         message_format=Util.getMessage(message_key);
-        suppress_format=Util.getMessage(suppress_msg); // "(received {3} identical messages from {2} in the last {4} ms)"
+        suppress_format=Util.getMessage(suppress_msg); // "(received %d identical messages from %s in the last %d ms)"
     }
 
     public SuppressCache<T> getCache()               {return cache;}
diff --git a/src/org/jgroups/util/Util.java b/src/org/jgroups/util/Util.java
index e644295267..33b95ba069 100644
--- a/src/org/jgroups/util/Util.java
+++ b/src/org/jgroups/util/Util.java
@@ -401,7 +401,7 @@ public static void shutdown(JChannel ch) throws Exception {
         discard.setDiscardAll(true);
         ProtocolStack stack=ch.getProtocolStack();
         TP transport=stack.getTransport();
-        stack.insertProtocol(discard,ProtocolStack.ABOVE,transport.getClass());
+        stack.insertProtocol(discard,ProtocolStack.Position.ABOVE,transport.getClass());
 
         //abruptly shutdown FD_SOCK just as in real life when member gets killed non gracefully
         FD_SOCK fd=ch.getProtocolStack().findProtocol(FD_SOCK.class);
@@ -1005,6 +1005,18 @@ public static String bytesToString(byte[] bytes) {
         return bytes != null? new String(bytes) : null;
     }
 
+    public static String byteArrayToHexString(byte[] b) {
+        if(b == null)
+            return "null";
+        StringBuilder sb = new StringBuilder(b.length * 2);
+        for (int i = 0; i < b.length; i++){
+            int v = b[i] & 0xff;
+            if (v < 16) { sb.append('0'); }
+            sb.append(Integer.toHexString(v));
+        }
+        return sb.toString().toUpperCase();
+    }
+
     /** Compares 2 byte arrays, elements are treated as unigned */
     public static int compare(byte[] left,byte[] right) {
         for(int i=0, j=0; i < left.length && j < right.length; i++,j++) {
@@ -1323,10 +1335,7 @@ public static int size(String s) {
     }
 
     public static int size(byte[] buf) {
-        int retval=Global.BYTE_SIZE + Global.INT_SIZE;
-        if(buf != null)
-            retval+=buf.length;
-        return retval;
+        return buf == null? Global.BYTE_SIZE : Global.BYTE_SIZE + Global.INT_SIZE + buf.length;
     }
 
     private static Address readOtherAddress(DataInput in) throws Exception {
@@ -1681,9 +1690,8 @@ public static void writeByteBuffer(byte[] buf,int offset,int length,DataOutput o
             out.writeInt(length);
             out.write(buf,offset,length);
         }
-        else {
+        else
             out.write(0);
-        }
     }
 
     public static byte[] readByteBuffer(DataInput in) throws Exception {
diff --git a/tests/byteman/org/jgroups/tests/byteman/SequencerFailoverTest.java b/tests/byteman/org/jgroups/tests/byteman/SequencerFailoverTest.java
index 0f11faa18f..42e77af90b 100644
--- a/tests/byteman/org/jgroups/tests/byteman/SequencerFailoverTest.java
+++ b/tests/byteman/org/jgroups/tests/byteman/SequencerFailoverTest.java
@@ -145,7 +145,7 @@ public void testFailoverWithMultipleThreadsSendingMessages() throws Exception {
         discard.setDiscardAll(true);
         ProtocolStack stack=a.getProtocolStack();
         TP transport=stack.getTransport();
-        stack.insertProtocol(discard,  ProtocolStack.ABOVE, transport.getClass());
+        stack.insertProtocol(discard,  ProtocolStack.Position.ABOVE, transport.getClass());
         
         MySender[] senders=new MySender[num_senders];
         for(int i=0; i < senders.length; i++) {
diff --git a/tests/junit-functional/org/jgroups/protocols/ASYM_ENCRYPT_Test.java b/tests/junit-functional/org/jgroups/protocols/ASYM_ENCRYPT_Test.java
new file mode 100644
index 0000000000..0c0830d4fe
--- /dev/null
+++ b/tests/junit-functional/org/jgroups/protocols/ASYM_ENCRYPT_Test.java
@@ -0,0 +1,325 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.auth.MD5Token;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.protocols.pbcast.DeltaView;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.JoinRsp;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.stack.ProtocolStack;
+import org.jgroups.util.Buffer;
+import org.jgroups.util.ByteArrayDataOutputStream;
+import org.jgroups.util.Util;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import javax.crypto.SecretKey;
+import java.util.Arrays;
+import java.util.stream.Stream;
+
+/**
+ * Tests use cases for {@link ASYM_ENCRYPT} described in https://issues.jboss.org/browse/JGRP-2021.
+ * @author Bela Ban
+ * @since  4.0
+ */
+@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+public class ASYM_ENCRYPT_Test extends EncryptTest {
+    protected static final short  ASYM_ENCRYPT_ID;
+
+    static {
+        ASYM_ENCRYPT_ID=ClassConfigurator.getProtocolId(ASYM_ENCRYPT.class);
+    }
+
+
+    @BeforeMethod protected void init() throws Exception {
+        super.init(getClass().getSimpleName());
+    }
+
+    @AfterMethod protected void destroy() {
+        super.destroy();
+    }
+
+    /** Calling methods in superclass. Kludge because TestNG doesn't call methods in superclass correctly **/
+    public void testRegularMessageReception() throws Exception {
+        super.testRegularMessageReception();
+    }
+
+    public void testRegularMessageReceptionWithEmptyMessages() throws Exception {
+        super.testRegularMessageReceptionWithEmptyMessages();
+    }
+
+    public void testChecksum() throws Exception {
+        super.testChecksum();
+    }
+
+    public void testRogueMemberJoin() throws Exception {
+        super.testRogueMemberJoin();
+    }
+
+    public void testMessageSendingByRogue() throws Exception {
+        super.testMessageSendingByRogue();
+    }
+
+    public void testMessageSendingByRogueUsingEncryption() throws Exception {
+        super.testMessageSendingByRogueUsingEncryption();
+    }
+
+    public void testMessageReceptionByRogue() throws Exception {
+        super.testMessageReceptionByRogue();
+    }
+
+    public void testCapturingOfMessageByNonMemberAndResending() throws Exception {
+        super.testCapturingOfMessageByNonMemberAndResending();
+    }
+
+    public void testRogueViewInstallation() throws Exception {
+        super.testRogueViewInstallation();
+    }
+
+
+
+    /**
+     * A non-member sends a {@link EncryptHeader#SECRET_KEY_REQ} request to the key server. Asserts that the rogue member
+     * doesn't get the secret key. If it did, it would be able to decrypt all messages from cluster members!
+     */
+    public void nonMemberGetsSecretKeyFromKeyServer() throws Exception {
+        Util.close(rogue);
+
+        rogue=new JChannel(Util.getTestStack()).name("rogue");
+        DISCARD discard=new DISCARD().setDiscardAll(true);
+        rogue.getProtocolStack().insertProtocol(discard, ProtocolStack.Position.ABOVE, TP.class);
+        CustomENCRYPT encrypt=new CustomENCRYPT();
+        encrypt.init();
+
+        rogue.getProtocolStack().insertProtocol(encrypt, ProtocolStack.Position.BELOW, NAKACK2.class);
+        rogue.connect(cluster_name); // creates a singleton cluster
+
+        assert rogue.getView().size() == 1;
+        GMS gms=rogue.getProtocolStack().findProtocol(GMS.class);
+        View rogue_view=new View(a.getAddress(), a.getView().getViewId().getId(),
+                                 Arrays.asList(a.getAddress(),b.getAddress(),c.getAddress(),rogue.getAddress()));
+        gms.installView(rogue_view);
+
+
+        // now fabricate a KEY_REQUEST message and send it to the key server (A)
+        Message newMsg=new Message(a.getAddress(), rogue.getAddress(), encrypt.keyPair().getPublic().getEncoded())
+          .putHeader(encrypt.getId(),new EncryptHeader(EncryptHeader.SECRET_KEY_REQ, encrypt.symVersion()));
+
+        discard.setDiscardAll(false);
+        System.out.printf("-- sending KEY_REQUEST to key server %s\n", a.getAddress());
+        encrypt.getDownProtocol().down(new Event(Event.MSG, newMsg));
+        for(int i=0; i < 10; i++) {
+            SecretKey secret_key=encrypt.key;
+            if(secret_key != null)
+                break;
+            Util.sleep(500);
+        }
+
+        discard.setDiscardAll(true);
+        gms.installView(View.create(rogue.getAddress(), 20, rogue.getAddress()));
+        System.out.printf("-- secret key is %s (should be null)\n", encrypt.key);
+        assert encrypt.key == null : String.format("should not have received secret key %s", encrypt.key);
+    }
+
+
+
+    /** Verifies that a non-member (non-coord) cannot send a JOIN-RSP to a member */
+    public void nonMemberInjectingJoinResponse() throws Exception {
+        Util.close(rogue);
+        rogue=create("rogue");
+        ProtocolStack stack=rogue.getProtocolStack();
+        AUTH auth=stack.findProtocol(AUTH.class);
+        auth.setAuthToken(new MD5Token("unknown_pwd"));
+        GMS gms=stack.findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(1);
+        DISCARD discard=new DISCARD().setDiscardAll(true);
+        stack.insertProtocol(discard, ProtocolStack.Position.ABOVE, TP.class);
+        rogue.connect(cluster_name);
+        assert rogue.getView().size() == 1;
+        discard.setDiscardAll(false);
+        stack.removeProtocol(NAKACK2.class, UNICAST3.class);
+
+        View rogue_view=View.create(a.getAddress(), a.getView().getViewId().getId() +5,
+                                    a.getAddress(),b.getAddress(),c.getAddress(),rogue.getAddress());
+        JoinRsp join_rsp=new JoinRsp(rogue_view, null);
+        GMS.GmsHeader gms_hdr=new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP);
+        Message rogue_join_rsp=new Message(b.getAddress(), rogue.getAddress()).putHeader(GMS_ID, gms_hdr)
+          .setBuffer(GMS.marshal(join_rsp)).setFlag(Message.Flag.NO_RELIABILITY); // bypasses NAKACK2 / UNICAST3
+        rogue.down(new Event(Event.MSG, rogue_join_rsp));
+        for(int i=0; i < 10; i++) {
+            if(b.getView().size() > 3)
+                break;
+            Util.sleep(500);
+        }
+        assert b.getView().size() == 3 : String.format("B's view is %s, but should be {A,B,C}", b.getView());
+    }
+
+
+
+    /** The rogue node has an incorrect {@link AUTH} config (secret) and can thus not join */
+    public void rogueMemberCannotJoinDueToAuthRejection() throws Exception {
+        Util.close(rogue);
+        rogue=create("rogue");
+        AUTH auth=rogue.getProtocolStack().findProtocol(AUTH.class);
+        auth.setAuthToken(new MD5Token("unknown_pwd"));
+        GMS gms=rogue.getProtocolStack().findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(2);
+        rogue.connect(cluster_name);
+        System.out.printf("Rogue's view is %s\n", rogue.getView());
+        assert rogue.getView().size() == 1 : String.format("rogue should have a singleton view of itself, but doesn't: %s", rogue.getView());
+    }
+
+
+    public void mergeViewInjectionByNonMember() throws Exception {
+        Util.close(rogue);
+        rogue=create("rogue");
+        AUTH auth=rogue.getProtocolStack().findProtocol(AUTH.class);
+        auth.setAuthToken(new MD5Token("unknown_pwd"));
+        GMS gms=rogue.getProtocolStack().findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(1);
+        rogue.connect(cluster_name);
+
+        MergeView merge_view=new MergeView(a.getAddress(), a.getView().getViewId().getId()+5,
+                                           Arrays.asList(a.getAddress(), b.getAddress(), c.getAddress(), rogue.getAddress()), null);
+        GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.INSTALL_MERGE_VIEW, a.getAddress());
+        Message merge_view_msg=new Message(null, marshalView(merge_view)).putHeader(GMS_ID, hdr)
+          .setFlag(Message.Flag.NO_RELIABILITY);
+        System.out.printf("** %s: trying to install MergeView %s in all members\n", rogue.getAddress(), merge_view);
+        rogue.down(new Event(Event.MSG, merge_view_msg));
+
+        // check if A, B or C installed the MergeView sent by rogue:
+        for(int i=0; i < 10; i++) {
+            boolean rogue_views_installed=Stream.of(a,b,c).anyMatch(ch -> ch.getView().containsMember(rogue.getAddress()));
+            if(rogue_views_installed)
+                break;
+            Util.sleep(500);
+        }
+        Stream.of(a,b,c).forEach(ch -> System.out.printf("%s: %s\n", ch.getAddress(), ch.getView()));
+        assert !Stream.of(a,b,c).anyMatch(ch -> ch.getView().containsMember(rogue.getAddress()));
+    }
+
+
+    /** Tests that when {ABC} -> {AB}, neither A nor B can receive a message from non-member C */
+    public void testMessagesByLeftMember() throws Exception {
+        View view=View.create(a.getAddress(), a.getView().getViewId().getId()+1, a.getAddress(),b.getAddress());
+        Stream.of(a,b).forEach(ch -> {
+            GMS gms=ch.getProtocolStack().findProtocol(GMS.class);
+            gms.installView(view);
+        });
+        Stream.of(a,b).forEach(ch -> System.out.printf("%s: %s\n", ch.getAddress(), ch.getView()));
+        System.out.printf("%s: %s\n", c.getAddress(), c.getView());
+
+        c.getProtocolStack().removeProtocol(NAKACK2.class); // to prevent A and B from discarding C as non-member
+
+        Util.sleep(1000); // give members time to handle the new view
+        c.send(null, "hello world from left member C!");
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 0 || rb.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert ra.size() == 0 : String.format("A: received msgs from non-member C: %s", print(ra.list()));
+        assert rb.size() == 0 : String.format("B: received msgs from non-member C: %s", print(rb.list()));
+    }
+
+    /** Tests that a left member C cannot decrypt messages from the cluster */
+    public void testEavesdroppingByLeftMember() throws Exception {
+        printSymVersion(a,b,c);
+        View view=View.create(a.getAddress(), a.getView().getViewId().getId()+1, a.getAddress(),b.getAddress());
+        Stream.of(a,b).forEach(ch -> {
+            GMS gms=ch.getProtocolStack().findProtocol(GMS.class);
+            gms.installView(view);
+        });
+        Stream.of(a,b).forEach(ch -> System.out.printf("%s: %s\n", ch.getAddress(), ch.getView()));
+        System.out.printf("%s: %s\n", c.getAddress(), c.getView());
+        c.getProtocolStack().removeProtocol(NAKACK2.class); // to prevent A and B from discarding C as non-member
+
+        Util.sleep(2000); // give members time to handle the new view
+
+
+        printSymVersion(a,b,c);
+        a.send(null, "hello from A");
+        b.send(null, "hello from B");
+
+        for(int i=0; i < 10; i++) {
+            if(rc.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert rc.size() == 0 : String.format("C: received msgs from cluster: %s", print(rc.list()));
+    }
+
+
+    protected JChannel create(String name) throws Exception {
+        JChannel ch=new JChannel(Util.getTestStack()).name(name);
+        ProtocolStack stack=ch.getProtocolStack();
+        Encrypt encrypt=createENCRYPT();
+        stack.insertProtocol(encrypt, ProtocolStack.Position.BELOW, NAKACK2.class);
+        AUTH auth=new AUTH().setAuthCoord(true).setAuthToken(new MD5Token("mysecret")); // .setAuthCoord(false);
+        stack.insertProtocol(auth, ProtocolStack.Position.BELOW, GMS.class);
+        stack.findProtocol(GMS.class).setValue("join_timeout", 2000); // .setValue("view_ack_collection_timeout", 10);
+        return ch;
+    }
+
+    protected void printSymVersion(JChannel ... channels) {
+        for(JChannel ch: channels) {
+            ASYM_ENCRYPT encr=ch.getProtocolStack().findProtocol(ASYM_ENCRYPT.class);
+            byte[] sym_version=encr.symVersion();
+            System.out.printf("sym-version %s: %s\n", ch.getAddress(), Util.byteArrayToHexString(sym_version));
+        }
+    }
+
+
+    // Note that setting encrypt_entire_message to true is critical here, or else some of the tests in this
+    // unit test would fail!
+    protected ASYM_ENCRYPT createENCRYPT() throws Exception {
+        ASYM_ENCRYPT encrypt=new ASYM_ENCRYPT().encryptEntireMessage(true).signMessages(true);
+        encrypt.init();
+        return encrypt;
+    }
+
+
+    protected static Buffer marshalView(final View view) throws Exception {
+        final ByteArrayDataOutputStream out=new ByteArrayDataOutputStream(512);
+        out.writeShort(determineFlags(view));
+        view.writeTo(out);
+        return out.getBuffer();
+    }
+
+    protected static short determineFlags(final View view) {
+        short retval=0;
+        if(view != null) {
+            retval|=GMS.VIEW_PRESENT;
+            if(view instanceof MergeView)
+                retval|=GMS.MERGE_VIEW;
+            else if(view instanceof DeltaView)
+                retval|=GMS.DELTA_VIEW;
+        }
+        return retval;
+    }
+
+
+    protected static class CustomENCRYPT extends ASYM_ENCRYPT {
+        protected SecretKey key;
+
+        public CustomENCRYPT() {
+            this.id=ASYM_ENCRYPT_ID;
+        }
+
+        protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+            if(hdr.type() == EncryptHeader.SECRET_KEY_RSP) {
+                try {
+                    key=decodeKey(msg.getBuffer());
+                    System.out.printf("received secret key %s !\n", key);
+                }
+                catch(Exception e) {
+                    e.printStackTrace();
+                }
+            }
+            return super.handleUpEvent(msg, hdr);
+        }
+    }
+
+}
diff --git a/tests/junit-functional/org/jgroups/protocols/AUTHTest.java b/tests/junit-functional/org/jgroups/protocols/AUTHTest.java
index f07351eeea..a723ad1b91 100644
--- a/tests/junit-functional/org/jgroups/protocols/AUTHTest.java
+++ b/tests/junit-functional/org/jgroups/protocols/AUTHTest.java
@@ -9,7 +9,7 @@
 import org.testng.annotations.Test;
 
 /**
- * A set of JUnit tests for the AUTH protocol
+ * A set of tests for the AUTH protocol
  * @author Chris Mills
  */
 @Test(groups=Global.FUNCTIONAL,sequential=false)
diff --git a/tests/junit-functional/org/jgroups/protocols/ECRYPTTest.java b/tests/junit-functional/org/jgroups/protocols/ECRYPTTest.java
deleted file mode 100644
index 621176ba92..0000000000
--- a/tests/junit-functional/org/jgroups/protocols/ECRYPTTest.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.jgroups.protocols;
-
-import org.jgroups.Global;
-import org.jgroups.JChannel;
-import org.testng.annotations.Test;
-
-/**
- * @author Bela Ban
- * @since  4.0
- */
-@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
-public class ECRYPTTest {
-    protected JChannel a,b,c,rogue;
-
-    protected void init() {
-        a=create("A");
-    }
-
-
-    protected JChannel create(String name) {
-        return null;
-    }
-}
diff --git a/tests/junit-functional/org/jgroups/protocols/ENCRYPTAsymmetricTest.java b/tests/junit-functional/org/jgroups/protocols/ENCRYPTAsymmetricTest.java
deleted file mode 100644
index 954b8dc3a6..0000000000
--- a/tests/junit-functional/org/jgroups/protocols/ENCRYPTAsymmetricTest.java
+++ /dev/null
@@ -1,485 +0,0 @@
-/*
- * Created on 04-Jul-2004
- *
- * To change the template for this generated file go to
- * Window - Preferences - Java - Code Generation - Code and Comments
- */
-package org.jgroups.protocols;
-
-
-import org.jgroups.*;
-import org.jgroups.conf.ClassConfigurator;
-import org.jgroups.protocols.ENCRYPT.EncryptHeader;
-import org.jgroups.stack.Protocol;
-import org.jgroups.util.MessageBatch;
-import org.jgroups.util.Util;
-import org.testng.Assert;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-import javax.crypto.Cipher;
-import javax.crypto.SecretKey;
-import java.security.MessageDigest;
-import java.security.Security;
-import java.util.TreeMap;
-
-/**
- * @author xenephon
- * @author Bela Ban
- */
-@Test(groups=Global.FUNCTIONAL, sequential=false)
-public class ENCRYPTAsymmetricTest {
-
-    protected static final short ENCRYPT_ID=ClassConfigurator.getProtocolId(ENCRYPT.class);
-    protected static final Address encrypt_addr=Util.createRandomAddress("encrypt");
-    protected static final Address server_addr=Util.createRandomAddress("server");
-    protected static final Address peer_addr=Util.createRandomAddress("peer");
-    protected static final Address peer2_addr=Util.createRandomAddress("peer2");
-
-
-    @BeforeClass
-    static void initProvider() {
-        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
-    }
-
-    public static void testInitNoProperties() throws Exception {
-        ENCRYPT encrypt=new ENCRYPT();
-        encrypt.init();
-
-        // test the default asymetric key
-        assert "RSA".equals(encrypt.getAsymAlgorithm());
-        assert encrypt.getAsymInit() == 512;
-        assert "RSA".equals(encrypt.getKpair().getPublic().getAlgorithm());
-        assert "X.509".equals(encrypt.getKpair().getPublic().getFormat());
-
-        assert encrypt.getKpair().getPublic().getEncoded() != null;
-
-        // test the default symetric key
-        assert "AES".equals(encrypt.getSymAlgorithm());
-        assert encrypt.getSymInit() == 128;
-        assert "AES".equals(encrypt.getDesKey().getAlgorithm());
-        assert "RAW".equals(encrypt.getDesKey().getFormat());
-        assert encrypt.getDesKey().getEncoded() != null;
-
-        //test the resulting ciphers
-        System.out.println("Provider:" + encrypt.getAsymCipher().getProvider());
-        assert encrypt.getAsymCipher() != null;
-        assert encrypt.getSymDecodingCipher() != null;
-        assert encrypt.getSymEncodingCipher() != null;
-    }
-
-    public static void testInitBCAsymProperties() throws Exception {
-        ENCRYPT encrypt=new ENCRYPT();
-        encrypt.asymAlgorithm = "RSA";
-        encrypt.init();
-
-        // test the default asymetric key
-        assert "RSA".equals(encrypt.getAsymAlgorithm());
-        assert encrypt.getAsymInit() == 512;
-        assert "RSA".equals(encrypt.getKpair().getPublic().getAlgorithm());
-        //Strangely this returns differently from the default provider for RSA which is also BC!
-        assert "X.509".equals(encrypt.getKpair().getPublic().getFormat());
-        assert encrypt.getKpair().getPublic().getEncoded() != null;
-
-        //test the resulting ciphers
-        assert encrypt.getAsymCipher() != null;
-
-    }
-
-
-
-    @Test(expectedExceptions=Exception.class)
-    public static void testInitIDEAProperties() throws Exception {
-        ENCRYPT encrypt=new ENCRYPT();
-        encrypt.symAlgorithm =  "IDEA";
-        encrypt.symInit = 128;
-        encrypt.init();
-    }
-
-
-    public static void testInitAESProperties() throws Exception {
-        ENCRYPT encrypt=new ENCRYPT();
-        encrypt.symAlgorithm = "AES";
-        encrypt.symInit = 128;
-        encrypt.init();
-
-        // test the default symetric key
-        assert "AES".equals(encrypt.getSymAlgorithm()) : "expected AES but was " + encrypt.getSymAlgorithm();
-        Util.assertEquals(128, encrypt.getSymInit());
-        Util.assertEquals("AES", encrypt.getDesKey().getAlgorithm());
-        Util.assertEquals("RAW", encrypt.getDesKey().getFormat());
-        Util.assertNotNull(encrypt.getDesKey().getEncoded());
-
-        //test the resulting ciphers
-
-        Util.assertNotNull(encrypt.getSymDecodingCipher());
-        Util.assertNotNull(encrypt.getSymEncodingCipher());
-    }
-
-    public static void testViewChangeBecomeKeyserver() throws Exception {
-        // set up the peer
-        ENCRYPT encrypt=new ENCRYPT();
-        encrypt.init();
-
-        // set in the observer
-        encrypt.setLocalAddress(encrypt_addr);
-        MockProtocol observer=new MockProtocol();
-        encrypt.setUpProtocol(observer);
-
-        // produce encrypted message
-        Cipher cipher=encrypt.getSymEncodingCipher();
-
-        MessageDigest digest=MessageDigest.getInstance("MD5");
-        digest.reset();
-        digest.update(encrypt.getDesKey().getEncoded());
-
-        byte[] symVersion=digest.digest();
-        encrypt.keyServer=false;
-        Message msg=new Message().setBuffer(cipher.doFinal("hello".getBytes()))
-          .putHeader(ENCRYPT_ID, new EncryptHeader(EncryptHeader.ENCRYPT, symVersion));
-
-        encrypt.up(new Event(Event.MSG, msg));
-
-        // assert that message is queued as we have no key
-        Util.assertTrue(observer.upMessages.isEmpty());
-
-        // send a view change to trigger the become key server
-        // we use the fact that our address is now the controller one
-        View tempView=View.create(encrypt_addr,1,encrypt_addr);
-        Event event=new Event(Event.VIEW_CHANGE, tempView);
-        // this should have changed us to the key server
-        encrypt.up(event);
-
-        // send another encrypted message
-        Message msg2=new Message().setBuffer(cipher.doFinal("hello2".getBytes()))
-          .putHeader(ENCRYPT_ID,new EncryptHeader(EncryptHeader.ENCRYPT,symVersion));
-
-        // we should have three messages now in our observer that are decrypted
-        encrypt.up(new Event(Event.MSG, msg2));
-        Util.assertEquals(3, observer.upMessages.size());
-
-        Event sent=observer.upMessages.get("message1");
-        Util.assertEquals("hello", new String(((Message)sent.getArg()).getBuffer()));
-
-        sent=observer.upMessages.get("message2");
-        Util.assertEquals("hello2", new String(((Message)sent.getArg()).getBuffer()));
-    }
-
-
-    public static void testViewChangeNewKeyServer() throws Exception {
-        ENCRYPT peer=new ENCRYPT();
-        peer.init();
-
-        ENCRYPT server=new ENCRYPT();
-        server.init();
-
-        // set up server
-        server.keyServer=true;
-        MockProtocol serverObserver=new MockProtocol();
-        server.setUpProtocol(serverObserver);
-        server.setDownProtocol(serverObserver);
-
-        server.setLocalAddress(server_addr);
-        Event viewChange = new Event(Event.VIEW_CHANGE, View.create(server_addr, 1, server_addr));
-        server.up(viewChange);
-
-        // set up peer
-        peer.setLocalAddress(peer_addr);
-        MockProtocol peerObserver=new MockProtocol();
-        peer.setUpProtocol(peerObserver);
-        peer.setDownProtocol(peerObserver);
-        peer.keyServer=false;
-
-
-        MessageDigest digest=MessageDigest.getInstance("MD5");
-        digest.reset();
-        digest.update(server.getDesKey().getEncoded());
-
-        // encrypt and send an initial message to peer
-        Cipher cipher=server.getSymEncodingCipher();
-        byte[] symVersion=digest.digest();
-        Message msg=new Message().setBuffer(cipher.doFinal("hello".getBytes()))
-          .putHeader(ENCRYPT_ID, new EncryptHeader(EncryptHeader.ENCRYPT, symVersion));
-
-        peer.up(new Event(Event.MSG, msg));
-        //assert that message is queued as we have no key from server
-        Util.assertTrue(peerObserver.upMessages.isEmpty());
-
-        // send a view change where we are not the controller
-
-        // send to peer - which should have peer2 as its key server
-        peer.up(viewChange);
-        // assert that peer\ keyserver address is now set
-        Util.assertEquals(server_addr, peer.getKeyServerAddr());
-
-        // get the resulting message from the peer - should be a key request
-
-        Event sent=peerObserver.downMessages.get("message0");
-
-        Util.assertEquals(((EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.KEY_REQUEST);
-        Util.assertEquals(new String(((Message)sent.getArg()).getBuffer()), new String(peer.getKpair().getPublic().getEncoded()));
-
-        // send this event to server
-        server.up(sent);
-
-        Event reply=serverObserver.downMessages.get("message1");
-
-        //assert that reply is the session key encrypted with peer's public key
-        Util.assertEquals(((EncryptHeader)((Message)reply.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.SECRETKEY);
-
-
-        assert !peer.getDesKey().equals(server.getDesKey());
-        // now send back to peer
-        peer.up(reply);
-
-        // assert that both now have same key
-        Util.assertEquals(peer.getDesKey(), server.getDesKey());
-
-        // send another encrypted message to peer to test queue
-        Message msg2=new Message().setBuffer(cipher.doFinal("hello2".getBytes()))
-          .putHeader(ENCRYPT_ID,new EncryptHeader(EncryptHeader.ENCRYPT,symVersion));
-        peer.up(new Event(Event.MSG, msg2));
-
-        // make sure we have the events now in the up layers
-        Util.assertEquals(3,peerObserver.upMessages.size());
-
-        Event tempEvt=peerObserver.upMessages.get("message2");
-        Util.assertEquals("hello", new String(((Message)tempEvt.getArg()).getBuffer()));
-
-        tempEvt=peerObserver.upMessages.get("message3");
-        Util.assertEquals("hello2", new String(((Message)tempEvt.getArg()).getBuffer()));
-    }
-
-
-    public static void testViewChangeNewKeyServerNewKey() throws Exception {
-        // create peer and server
-        ENCRYPT peer=new ENCRYPT();
-        peer.init();
-
-        ENCRYPT server=new ENCRYPT();
-        server.init();
-
-        ENCRYPT peer2=new ENCRYPT();
-        peer2.init();
-
-        // set up server
-        server.keyServer=true;
-        MockProtocol serverObserver=new MockProtocol();
-        server.setUpProtocol(serverObserver);
-        server.setDownProtocol(serverObserver);
-
-        //set the local address and view change to simulate a started instance
-        server.setLocalAddress(server_addr);
-
-        Event serverEvent = new Event(Event.VIEW_CHANGE, View.create(server_addr, 1, server_addr));
-        server.up(serverEvent);
-
-        // set up peer as if it has started but not recieved view change
-        peer.setLocalAddress(peer_addr);
-        MockProtocol peerObserver=new MockProtocol();
-        peer.setUpProtocol(peerObserver);
-        peer.setDownProtocol(peerObserver);
-        peer.keyServer=false;
-
-        // set up peer2 with server as key server
-        peer2.setLocalAddress(peer2_addr);
-        MockProtocol peer2Observer=new MockProtocol();
-        peer2.setUpProtocol(peer2Observer);
-        peer2.setDownProtocol(peer2Observer);
-        peer2.keyServer=false;
-        peer2.setKeyServerAddr(server_addr);
-
-        // send an encrypted message from the server
-        Message msg=new Message().setBuffer("hello".getBytes());
-        server.down(new Event(Event.MSG, msg));
-
-        // message0 is in response to view change
-        Event encEvt=serverObserver.downMessages.get("message1");
-
-        // sent to peer encrypted - should be queued in encyption layer as we do not have a keyserver set
-        peer.up(encEvt);
-
-        //assert that message is queued as we have no key from server
-        Util.assertTrue(peerObserver.upMessages.isEmpty());
-        updateViewFor(peer, server, serverObserver, serverEvent, peerObserver);
-        Util.assertFalse(peerObserver.upMessages.isEmpty());
-
-        Event event = new Event(Event.VIEW_CHANGE, View.create(peer2_addr, 2, peer2_addr));
-
-        // send to peer - should set peer2 as keyserver
-        peer.up(event);
-
-        // assert that peer\ keyserver address is now set
-        Util.assertEquals(peer2_addr, peer.getKeyServerAddr());
-
-        // get the resulting message from the peer - should be a key request to peer2
-        Event sent=peerObserver.downMessages.get("message0");
-
-        // ensure type and that request contains peers pub key
-        Util.assertEquals(((EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.KEY_REQUEST);
-        Util.assertEquals(new String(((Message)sent.getArg()).getBuffer()), new String(peer.getKpair().getPublic().getEncoded()));
-
-
-        // this should have changed us to the key server
-        peer2.up(event);
-
-        peer2.up(sent);
-
-        Event reply=peer2Observer.downMessages.get("message1");
-
-        //assert that reply is the session key encrypted with peer's public key
-        Util.assertEquals(((EncryptHeader)((Message)reply.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.SECRETKEY);
-
-
-        assert !peer.getDesKey().equals(peer2.getDesKey());
-        assert !server.getDesKey().equals(peer2.getDesKey());
-
-        // now send back to peer
-        peer.up(reply);
-
-        // assert that both now have same key
-        Util.assertEquals(peer.getDesKey(), peer2.getDesKey());
-        assert !server.getDesKey().equals(peer.getDesKey());
-
-        // send another encrypted message to peer to test queue
-        Message msg2=new Message();
-        msg2.setBuffer("hello2".getBytes());
-
-
-        Event evt2=new Event(Event.MSG, msg2);
-
-        peer2.down(evt2);
-
-        Event evt3=peer2Observer.downMessages.get("message2");
-
-        peer.up(evt3);
-        // make sure we have the events now in the up layers
-        Util.assertEquals(4, peerObserver.upMessages.size());
-
-        Event tempEvt=peerObserver.getLatestUpMessage();
-        Util.assertEquals("hello2", new String(((Message)tempEvt.getArg()).getBuffer()));
-    }
-
-    public void testKeyChangesDuringKeyServerChange() throws Exception {
-        // create peers and server
-        ENCRYPT peer=new ENCRYPT();
-        peer.init();
-
-        ENCRYPT server=new ENCRYPT();
-        server.init();
-
-        ENCRYPT peer2=new ENCRYPT();
-        peer2.init();
-
-        // set up server
-        server.keyServer=true;
-        MockProtocol serverObserver=new MockProtocol();
-        server.setUpProtocol(serverObserver);
-        server.setDownProtocol(serverObserver);
-
-        //set the local address and view change to simulate a started instance
-        server.setLocalAddress(server_addr);
-
-        //	set the server up as keyserver
-        Event serverEvent = new Event(Event.VIEW_CHANGE, View.create(server_addr, 1, server_addr));
-        server.up(new Event(Event.TMP_VIEW, serverEvent.getArg()));
-        server.up(serverEvent);
-
-        peer.setLocalAddress(peer_addr);
-        MockProtocol peerObserver=new MockProtocol();
-        peer.setUpProtocol(peerObserver);
-        peer.setDownProtocol(peerObserver);
-        peer.keyServer=false;
-
-        updateViewFor(peer, server, serverObserver, serverEvent, peerObserver);
-
-        // set up peer2 with server as key server
-        peer2.setLocalAddress(peer2_addr);
-        MockProtocol peer2Observer=new MockProtocol();
-        peer2.setUpProtocol(peer2Observer);
-        peer2.setDownProtocol(peer2Observer);
-        peer2.keyServer=false;
-        updateViewFor(peer2, server, serverObserver, serverEvent, peer2Observer);
-
-        Assert.assertEquals(server.getDesKey().getEncoded(), peer.getDesKey().getEncoded());
-        Assert.assertEquals(server.getDesKey().getEncoded(), peer2.getDesKey().getEncoded());
-
-        Event viewChange2 = new Event(Event.VIEW_CHANGE, View.create(peer2_addr, 2, peer2_addr));
-        peer2.up(new Event(Event.TMP_VIEW, viewChange2.getArg()));
-        peer2.up(viewChange2);
-
-        updateViewFor(peer, peer2, peer2Observer, viewChange2, peerObserver);
-
-        Assert.assertFalse(server.getDesKey().equals(peer.getDesKey()));
-        Assert.assertEquals(peer.getDesKey().getEncoded(), peer2.getDesKey().getEncoded());
-
-    }
-
-    public static void testSymmetricKeyIsChangedOnViewChange() throws Exception{
-        ENCRYPT server=new ENCRYPT();
-        server.changeKeysOnViewChange=true;
-        MockProtocol serverObserver=new MockProtocol();
-        server.setDownProtocol(serverObserver);
-        server.setUpProtocol(serverObserver);
-        server.setLocalAddress(server_addr);
-        server.init();
-
-        //	set the server up as key server
-        Event initalView = new Event(Event.VIEW_CHANGE, View.create(server_addr, 1, server_addr));
-        server.up(new Event(Event.TMP_VIEW, initalView.getArg()));
-        server.up(initalView);
-
-        SecretKey key = server.getDesKey();
-
-        //	Update the view with new member
-        Event updatedView = new Event(Event.VIEW_CHANGE, View.create(server_addr, 2, peer_addr));
-        server.up(new Event(Event.TMP_VIEW, updatedView.getArg()));
-        server.up(updatedView);
-
-        SecretKey keyAfterViewChange = server.getDesKey();
-        Util.assertFalse(key.equals(keyAfterViewChange));
-    }
-
-	private static void updateViewFor(ENCRYPT peer, ENCRYPT keyServer, MockProtocol serverObserver, Event serverEvent,
-                                      MockProtocol peerObserver) {
-		peer.up(serverEvent);
-        Event peerKeyRequest=peerObserver.getLatestDownMessage();
-        keyServer.up(peerKeyRequest);
-        Event serverKeyToPeer=serverObserver.getLatestDownMessage();
-        peer.up(serverKeyToPeer);
-	}
-
-
-
-    static class MockProtocol extends Protocol {
-        private final TreeMap<String, Event> upMessages=new TreeMap<>();
-        private final TreeMap<String, Event> downMessages=new TreeMap<>();
-        private int counter;
-
-
-        public Object down(Event evt) {
-            downMessages.put("message" + counter++, evt);
-            return null;
-        }
-
-        public Object up(Event evt) {
-            upMessages.put("message" + counter++, evt);
-            return null;
-        }
-
-        public void up(MessageBatch batch) {
-            throw new UnsupportedOperationException();
-        }
-
-        protected Event getLatestUpMessage() {
-            return upMessages.isEmpty()? null : upMessages.lastEntry().getValue();
-        }
-
-        protected Event getLatestDownMessage() {
-            return downMessages.isEmpty()? null : downMessages.lastEntry().getValue();
-        }
-    }
-
-
-
-}
diff --git a/tests/junit-functional/org/jgroups/protocols/ENCRYPTKeystoreTest.java b/tests/junit-functional/org/jgroups/protocols/ENCRYPTKeystoreTest.java
index 8d848f65fd..ee0076755a 100644
--- a/tests/junit-functional/org/jgroups/protocols/ENCRYPTKeystoreTest.java
+++ b/tests/junit-functional/org/jgroups/protocols/ENCRYPTKeystoreTest.java
@@ -12,7 +12,6 @@
 import org.jgroups.util.MessageBatch;
 import org.testng.annotations.Test;
 
-import javax.crypto.Cipher;
 import java.security.MessageDigest;
 import java.util.HashMap;
 import java.util.Map;
@@ -24,11 +23,10 @@
 @Test(groups=Global.FUNCTIONAL, sequential=false)
 public class ENCRYPTKeystoreTest {
 
-    static final short ENCRYPT_ID=ClassConfigurator.getProtocolId(ENCRYPT.class);
+    static final short ENCRYPT_ID=ClassConfigurator.getProtocolId(SYM_ENCRYPT.class);
 
-    public static void testInitWrongKeystoreProperties() {        
-        ENCRYPT encrypt=new ENCRYPT();
-        encrypt.keyStoreName = "unkownKeystore.keystore";
+    public void testInitWrongKeystoreProperties() {
+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT().keystoreName("unkownKeystore.keystore");
         try {
             encrypt.init();
         }
@@ -37,21 +35,16 @@ public static void testInitWrongKeystoreProperties() {
         }
     }
 
-    public static void testInitKeystoreProperties() throws Exception {
-        ENCRYPT encrypt=new ENCRYPT();
-        encrypt.keyStoreName = "defaultStore.keystore";
+    public void testInitKeystoreProperties() throws Exception {
+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT().keystoreName("defaultStore.keystore");
         encrypt.init();
-        assert encrypt.getSymDecodingCipher() != null;
-        assert encrypt.getSymEncodingCipher() != null;
-
     }
 
-    public static void testMessageDownEncode() throws Exception {
-        ENCRYPT encrypt=create("defaultStore.keystore"), encrypt2=create("defaultStore.keystore");
+    public void testMessageDownEncode() throws Exception {
+        SYM_ENCRYPT encrypt=create("defaultStore.keystore");
         MockProtocol observer=new MockProtocol();
         encrypt.setDownProtocol(observer);
 
-        encrypt.keyServer=true;
         String messageText="hello this is a test message";
         Message msg=new Message(null, messageText.getBytes());
 
@@ -59,34 +52,30 @@ public static void testMessageDownEncode() throws Exception {
         Message sentMsg=(Message)observer.getDownMessages().get("message0").getArg();
         String encText=new String(sentMsg.getBuffer());
         assert !encText.equals(messageText);
-        Cipher cipher=encrypt2.getSymDecodingCipher();
-        byte[] decodedBytes=cipher.doFinal(sentMsg.getBuffer());
+        byte[] decodedBytes=encrypt.code(sentMsg.getRawBuffer(), sentMsg.getOffset(), sentMsg.getLength(), true);
         String temp=new String(decodedBytes);
-        System.out.println("decoded text:" + temp);
-        assert temp.equals(messageText);
-
+        System.out.printf("decoded text: '%s'\n", temp);
+        assert temp.equals(messageText) : String.format("sent: '%s', decoded: '%s'", messageText, temp);
     }
 
 
-    public static void testMessageUpDecode() throws Exception {
-        ENCRYPT encrypt=create("defaultStore.keystore"), encrypt2=create("defaultStore.keystore");
+    public void testMessageUpDecode() throws Exception {
+        SYM_ENCRYPT encrypt=create("defaultStore.keystore"), encrypt2=create("defaultStore.keystore");
         
         MockProtocol observer=new MockProtocol();
         encrypt.setUpProtocol(observer);
 
-        encrypt.keyServer=true;
         String messageText="hello this is a test message";
-        Cipher cipher=encrypt2.getSymEncodingCipher();
-        byte[] encodedBytes=cipher.doFinal(messageText.getBytes());
+        byte[] bytes=messageText.getBytes();
+        byte[] encodedBytes=encrypt2.code(bytes, 0, bytes.length, false);
         assert !new String(encodedBytes).equals(messageText);
 
         MessageDigest digest=MessageDigest.getInstance("MD5");
         digest.reset();
-        digest.update(encrypt.getDesKey().getEncoded());
+        digest.update(encrypt.secretKey().getEncoded());
 
         byte[] symVersion=digest.digest();
-        Message msg=new Message(null, encodedBytes)
-          .putHeader(ENCRYPT_ID, new ENCRYPT.EncryptHeader(ENCRYPT.EncryptHeader.ENCRYPT, symVersion));
+        Message msg=new Message(null, encodedBytes).putHeader(ENCRYPT_ID, new EncryptHeader(EncryptHeader.ENCRYPT, symVersion));
         encrypt.up(new Event(Event.MSG, msg));
         Message rcvdMsg=(Message)observer.getUpMessages().get("message0").getArg();
         String decText=new String(rcvdMsg.getBuffer());
@@ -94,70 +83,58 @@ public static void testMessageUpDecode() throws Exception {
 
     }
 
-    public static void testMessageUpWrongKey() throws Exception {
-        ENCRYPT encrypt=create("defaultStore.keystore"), encrypt2=create("defaultStore2.keystore");
+    public void testMessageUpWrongKey() throws Exception {
+        SYM_ENCRYPT encrypt=create("defaultStore.keystore"), encrypt2=create("defaultStore2.keystore");
         MockProtocol observer=new MockProtocol();
         encrypt.setUpProtocol(observer);
 
-        encrypt.keyServer=true;
         String messageText="hello this is a test message";
-        Cipher cipher=encrypt2.getSymEncodingCipher();
-        byte[] encodedBytes=cipher.doFinal(messageText.getBytes());
+        byte[] bytes=messageText.getBytes();
+        byte[] encodedBytes=encrypt2.code(bytes, 0, bytes.length, false);
         assert !new String(encodedBytes).equals(messageText);
 
         MessageDigest digest=MessageDigest.getInstance("MD5");
         digest.reset();
-        digest.update(encrypt2.getDesKey().getEncoded());
+        digest.update(encrypt2.secretKey().getEncoded());
 
         byte[] symVersion=digest.digest();
 
-        Message msg=new Message(null, null, encodedBytes)
-          .putHeader(ENCRYPT_ID, new ENCRYPT.EncryptHeader(ENCRYPT.EncryptHeader.ENCRYPT, symVersion));
+        Message msg=new Message(null, null, encodedBytes).putHeader(ENCRYPT_ID, new EncryptHeader(EncryptHeader.ENCRYPT, symVersion));
         encrypt.up(new Event(Event.MSG, msg));
         assert observer.getUpMessages().isEmpty();
     }
 
-    public static void testMessageUpNoEncryptHeader() throws Exception {
-        ENCRYPT encrypt=create("defaultStore.keystore"), encrypt2=create("defaultStore.keystore");
+    public void testMessageUpNoEncryptHeader() throws Exception {
+        SYM_ENCRYPT encrypt=create("defaultStore.keystore"), encrypt2=create("defaultStore.keystore");
         MockProtocol observer=new MockProtocol();
         encrypt.setUpProtocol(observer);
-
-        encrypt.keyServer=true;
         String messageText="hello this is a test message";
-        Cipher cipher=encrypt2.getSymEncodingCipher();
-        byte[] encodedBytes=cipher.doFinal(messageText.getBytes());
+        byte[] bytes=messageText.getBytes();
+        byte[] encodedBytes=encrypt2.code(bytes, 0, bytes.length, false);
         assert !new String(encodedBytes).equals(messageText);
-
         Message msg=new Message(null, encodedBytes);
         encrypt.up(new Event(Event.MSG, msg));
-        assert observer.getUpMessages().size() == 1;
+        assert observer.getUpMessages().isEmpty();
     }
 
-    public static void testEventUpNoMessage() throws Exception {
-        ENCRYPT encrypt=create("defaultStore.keystore");
+    public void testEventUpNoMessage() throws Exception {
+        SYM_ENCRYPT encrypt=create("defaultStore.keystore");
         MockProtocol observer=new MockProtocol();
         encrypt.setUpProtocol(observer);
-        encrypt.keyServer=true;
-
         encrypt.up(new Event(Event.MSG, null));
-        assert observer.getUpMessages().size() == 1;
-
-
+        assert observer.getUpMessages().isEmpty();
     }
 
-    public static void testMessageUpNoBuffer() throws Exception {
-        ENCRYPT encrypt=create("defaultStore.keystore");
+    public void testMessageUpNoBuffer() throws Exception {
+        SYM_ENCRYPT encrypt=create("defaultStore.keystore");
         MockProtocol observer=new MockProtocol();
         encrypt.setUpProtocol(observer);
-        encrypt.keyServer=true;
-        encrypt.up(new Event(Event.MSG, new Message()));
-        assert observer.getUpMessages().size() == 1;
+        encrypt.up(new Event(Event.MSG, new Message().putHeader(ENCRYPT_ID, new EncryptHeader(EncryptHeader.ENCRYPT, "bla".getBytes()))));
+        assert observer.getUpMessages().isEmpty();
     }
 
     public void testEncryptEntireMessage() throws Exception {
-        ENCRYPT encrypt=create("defaultStore.keystore");
-        encrypt.keyServer=true;
-        encrypt.setValue("encrypt_entire_message",true);
+        SYM_ENCRYPT encrypt=create("defaultStore.keystore").encryptEntireMessage(true);
         Message msg=new Message(null, "hello world".getBytes()).putHeader((short)1, new TpHeader("cluster"));
         MockProtocol mock=new MockProtocol();
         encrypt.setDownProtocol(mock);
@@ -174,9 +151,8 @@ public void testEncryptEntireMessage() throws Exception {
         assert "hello world".equals(temp);
     }
 
-    protected static ENCRYPT create(String keystore) throws Exception {
-        ENCRYPT encrypt=new ENCRYPT();
-        encrypt.keyStoreName = keystore;
+    protected static SYM_ENCRYPT create(String keystore) throws Exception {
+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT().keystoreName(keystore).encryptEntireMessage(false);
         encrypt.init();
         return encrypt;
     }
diff --git a/tests/junit-functional/org/jgroups/protocols/EncryptTest.java b/tests/junit-functional/org/jgroups/protocols/EncryptTest.java
new file mode 100644
index 0000000000..1e887b78c6
--- /dev/null
+++ b/tests/junit-functional/org/jgroups/protocols/EncryptTest.java
@@ -0,0 +1,327 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.demos.KeyStoreGenerator;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.protocols.pbcast.NakAckHeader2;
+import org.jgroups.util.Buffer;
+import org.jgroups.util.ByteArrayDataOutputStream;
+import org.jgroups.util.MyReceiver;
+import org.jgroups.util.Util;
+import org.testng.annotations.Test;
+
+import javax.crypto.SecretKey;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+/**
+ * Base class for tests {@link SYM_ENCRYPT_Test} and {@link ASYM_ENCRYPT_Test}
+ * @author Bela Ban
+ * @since  4.0
+ */
+
+@Test(enabled=false)
+public abstract class EncryptTest {
+    protected JChannel            a,b,c,rogue;
+    protected MyReceiver<Message> ra, rb, rc, r_rogue;
+    protected String              cluster_name;
+    protected static final short  GMS_ID;
+
+    static {
+        GMS_ID=ClassConfigurator.getProtocolId(GMS.class);
+    }
+
+    protected void init(String cluster_name) throws Exception {
+        this.cluster_name=cluster_name;
+        a=create("A").connect(cluster_name).setReceiver(ra=new MyReceiver<>().rawMsgs(true));
+        b=create("B").connect(cluster_name).setReceiver(rb=new MyReceiver<>().rawMsgs(true));
+        c=create("C").connect(cluster_name).setReceiver(rc=new MyReceiver<>().rawMsgs(true));
+        Util.waitUntilAllChannelsHaveSameSize(10000, 500, a,b,c);
+        rogue=createRogue("rogue").connect(cluster_name);
+        Stream.of(a,b,c,rogue).forEach(ch -> System.out.printf("%s: %s\n", ch.getAddress(), ch.getView()));
+        System.out.println("");
+    }
+
+    @Test(enabled=false) protected void destroy() {Util.close(rogue, c, b, a);}
+
+    protected abstract JChannel create(String name) throws Exception;
+
+
+
+    /** Tests A,B or C sending messages and their reception by everyone in cluster {A,B,C} */
+    //@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testRegularMessageReception() throws Exception {
+        a.send(null, "Hello from A");
+        b.send(null, "Hello from B");
+        c.send(null, "Hello from C");
+        for(int i=0; i < 10; i++) {
+            if(ra.size() == 3 && rb.size() == 3 && rc.size() == 3)
+                break;
+            Util.sleep(500);
+        }
+        Stream.of(ra, rb, rc).map(MyReceiver::list).map(l -> l.stream().map(msg -> (String)msg.getObject())
+          .collect(ArrayList::new, ArrayList::add, (x, y) -> {})).forEach(System.out::println);
+        assertForEachReceiver(r -> r.size() == 3);
+    }
+
+    /** Same as above, but all messages are 0-length */
+    //@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testRegularMessageReceptionWithEmptyMessages() throws Exception {
+        a.send(new Message(null));
+        b.send(new Message(null));
+        c.send(new Message(null));
+        for(int i=0; i < 10; i++) {
+            if(ra.size() == 3 && rb.size() == 3 && rc.size() == 3)
+                break;
+            Util.sleep(500);
+        }
+        Stream.of(ra, rb, rc).map(MyReceiver::list).map(l -> l.stream().map(msg -> (String)msg.getObject())
+          .collect(ArrayList::new, ArrayList::add, (x, y) -> {})).forEach(System.out::println);
+        assertForEachReceiver(r -> r.size() == 3);
+    }
+
+    //@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testChecksum() throws Exception {
+        Encrypt encrypt=a.getProtocolStack().findProtocol(Encrypt.class);
+
+        byte[] buffer="Hello world".getBytes();
+        long checksum=encrypt.computeChecksum(buffer, 0, buffer.length);
+        byte[] checksum_array=encrypt.encryptChecksum(checksum);
+
+        long actual_checksum=encrypt.decryptChecksum(null, checksum_array, 0, checksum_array.length);
+        assert checksum == actual_checksum : String.format("checksum: %d, actual: %d", checksum, actual_checksum);
+    }
+
+
+    /** A rogue member should not be able to join a cluster */
+    //@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testRogueMemberJoin() throws Exception {
+        Util.close(rogue);
+        rogue=new JChannel(Util.getTestStack()).name("rogue");
+        rogue.getProtocolStack().removeProtocol(Encrypt.class);
+        GMS gms=rogue.getProtocolStack().findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(1);
+        rogue.connect(cluster_name);
+        for(int i=0; i < 10; i++) {
+            if(a.getView().size() > 3)
+                break;
+            Util.sleep(500);
+        }
+        Arrays.asList(a,b,c).forEach(ch -> System.out.printf("%s: view is %s\n", ch.getAddress(), ch.getView()));
+        Arrays.asList(a,b,c).forEach(ch -> {
+            View view=ch.getView();
+            assert view.size() == 3 : "view should be {A,B,C}: " + view;
+        });
+    }
+
+
+    /** Test that A,B,C do NOT receive any message sent by a rogue node which is not member of {A,B,C} */
+    //@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testMessageSendingByRogue() throws Exception {
+        rogue.send(null, "message from rogue");  // tests single messages
+        Util.sleep(500);
+        for(int i=1; i <= 100; i++)              // tests message batches
+            rogue.send(null, "msg #" + i + " from rogue");
+
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 0 || rb.size() > 0 || rc.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert ra.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(ra.list()));
+        assert rb.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rb.list()));
+        assert rc.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rc.list()));
+    }
+
+
+    /**
+     * R sends a message that has an encryption header and is encrypted with R's secret key (which of course is different
+     * from the cluster members' shared key as R doesn't know it). The cluster members should drop R's message as they
+     * shouldn't be able to decrypt it.
+     */
+    //@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testMessageSendingByRogueUsingEncryption() throws Exception {
+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT().keystoreName("/tmp/ignored.keystore");
+        encrypt.encryptEntireMessage(true).signMessages(true);
+
+        SecretKey secret_key=KeyStoreGenerator.createSecretKey();
+        Field secretKey=Util.getField(SYM_ENCRYPT.class, "secret_key");
+        secretKey.setAccessible(true);
+        Util.setField(secretKey, encrypt, secret_key);
+        encrypt.init();
+
+        short encrypt_id=ClassConfigurator.getProtocolId(SYM_ENCRYPT.class);
+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, encrypt.symVersion());
+        Message msg=new Message(null).putHeader(encrypt_id, hdr);
+
+        byte[] buf="hello from rogue".getBytes();
+        byte[] encrypted_buf=encrypt.code(buf, 0, buf.length, false);
+        msg.setBuffer(encrypted_buf);
+        long checksum=encrypt.computeChecksum(encrypted_buf, 0, encrypted_buf.length);
+        byte[] tmp=encrypt.encryptChecksum(checksum);
+        hdr.signature(tmp);
+
+        rogue.send(msg);
+
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 0 || rb.size() > 0 || rc.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert ra.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(ra.list()));
+        assert rb.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rb.list()));
+        assert rc.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rc.list()));
+    }
+
+
+    /**
+     * Tests that the non-member does NOT receive messages from cluster {A,B,C}. The de-serialization of a message's
+     * payload (encrypted with the secret key of the rogue non-member) will fail, so the message is never passed up
+     * to the application.
+     */
+    //@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testMessageReceptionByRogue() throws Exception {
+        rogue.setReceiver(r_rogue=new MyReceiver().rawMsgs(true));
+        a.setReceiver(null); b.setReceiver(null); c.setReceiver(null);
+        a.send(null, "Hello from A");
+        b.send(null, "Hello from B");
+        c.send(null, "Hello from C");
+        for(int i=0; i < 10; i++) {
+            // retransmissions will add dupes to rogue as it doesn't have dupe elimination, so we could have more than
+            // 3 messages!
+            if(r_rogue.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+
+        // the non-member may have received some cluster messages, if the encrypted messages coincidentally didn't
+        // cause a deserialization exception, but it will not be able to read their contents:
+        if(r_rogue.size() > 0) {
+            System.out.printf("Rogue non-member received %d message(s), but it should not be able to read deserialize " +
+                                "the contents (this should throw exceptions below):\n", r_rogue.size());
+            r_rogue.list().forEach(msg -> {
+                try {
+                    String payload=(String)msg.getObject();
+                    assert !payload.startsWith("Hello from");
+                }
+                catch(Exception t) {
+                    System.out.printf("caught exception trying to de-serialize garbage payload into a string: %s\n", t);
+                }
+            });
+        }
+    }
+
+
+    /**
+     * Tests the scenario where the non-member R captures a message from some cluster member in {A,B,C}, then
+     * increments the NAKACK2 seqno and resends that message. The message must not be received by {A,B,C};
+     * it should be discarded.
+     */
+    //@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testCapturingOfMessageByNonMemberAndResending() throws Exception {
+        rogue.setReceiver(msg -> {
+            System.out.printf("rogue: modifying and resending msg %s, hdrs: %s\n", msg, msg.printHeaders());
+            rogue.setReceiver(null); // to prevent recursive cycle
+            try {
+                short prot_id=ClassConfigurator.getProtocolId(NAKACK2.class);
+                NakAckHeader2 hdr=msg.getHeader(prot_id);
+                if(hdr != null) {
+                    long seqno=hdr.getSeqno();
+                    Util.setField(Util.getField(NakAckHeader2.class, "seqno"), hdr, seqno+1);
+                }
+                else {
+                    System.out.printf("Rogue was not able to get the %s header, fabricating one with seqno=50\n", NAKACK2.class.getSimpleName());
+                    NakAckHeader2 hdr2=NakAckHeader2.createMessageHeader(50);
+                    msg.putHeader(prot_id, hdr2);
+                }
+
+                rogue.send(msg);
+            }
+            catch(Exception e) {
+                e.printStackTrace();
+            }
+        });
+
+        a.send(null, "Hello world from A");
+
+        // everybody in {A,B,C} should receive this message, but NOT the rogue's resent message
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 1 || rb.size() > 1 || rc.size() > 1)
+                break; // this should NOT happen
+            Util.sleep(500);
+        }
+
+        Stream.of(ra, rb, rc).map(MyReceiver::list).map(l -> l.stream().map(msg -> (String)msg.getObject())
+          .collect(ArrayList::new, ArrayList::add, (x, y) -> {})).forEach(System.out::println);
+        assert ra.size() == 1 : String.format("received msgs from non-member: '%s'; this should not be the case", print(ra.list()));
+        assert rb.size() == 1 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rb.list()));
+        assert rc.size() == 1 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rc.list()));
+    }
+
+
+
+    /**
+     * Tests the case where a non-member installs a new view {rogue,A,B,C}, making itself the coordinator and therefore
+     * controlling admission of new members to the cluster etc...
+     */
+    //@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testRogueViewInstallation() throws Exception {
+        final Address rogue_addr=rogue.getAddress();
+        View rogue_view=View.create(rogue_addr, a.getView().getViewId().getId()+1,
+                                    rogue_addr, a.getAddress(), b.getAddress(), c.getAddress());
+
+        Message view_change_msg=new Message().putHeader(GMS_ID, new GMS.GmsHeader(GMS.GmsHeader.VIEW))
+          .setBuffer(marshal(rogue_view));
+        rogue.send(view_change_msg);
+
+        for(int i=0; i < 10; i++) {
+            if(a.getView().size() > 3)
+                break;
+            Util.sleep(500);
+        }
+        Arrays.asList(a,b,c).forEach(ch -> {
+            View view=ch.getView();
+            System.out.printf("%s: view is %s\n", ch.getAddress(), view);
+            assert !view.containsMember(rogue_addr) : "view contains rogue member: " + view;
+        });
+    }
+
+
+    protected static JChannel createRogue(String name) throws Exception {
+        return new JChannel(new SHARED_LOOPBACK()).name(name);
+    }
+
+
+    protected static Buffer marshal(final View view) throws Exception {
+        ByteArrayDataOutputStream out=new ByteArrayDataOutputStream(512);
+        out.writeShort(1);
+        if(view != null)
+            view.writeTo(out);
+        return out.getBuffer();
+    }
+
+    protected void assertForEachReceiver(Predicate<MyReceiver<Message>> predicate) {
+        Stream.of(ra, rb, rc).forEach(receiver -> {assert predicate.test(receiver);});
+    }
+
+    protected static String print(List<Message> msgs) {
+        return msgs.stream().collect(ArrayList::new, (l,msg) -> l.add(msg.getObject()), (x, y) -> {}).toString();
+    }
+
+    protected static String print(byte[] buf, int offset, int length) {
+        StringBuilder sb=new StringBuilder("encrypted string: ");
+        for(int i=0; i < length; i++) {
+            int ch=buf[offset+i];
+            sb.append(ch).append(' ');
+        }
+        return sb.toString();
+    }
+
+
+}
diff --git a/tests/junit-functional/org/jgroups/protocols/GMS_MergeTest.java b/tests/junit-functional/org/jgroups/protocols/GMS_MergeTest.java
index 23bdd130b5..df1e1f13e8 100644
--- a/tests/junit-functional/org/jgroups/protocols/GMS_MergeTest.java
+++ b/tests/junit-functional/org/jgroups/protocols/GMS_MergeTest.java
@@ -326,7 +326,7 @@ static void _testMergeAsymmetricPartitions(boolean use_flush_props, String clust
              discard.addIgnoreMember(c.getAddress());
 
              // A should drop all traffic from B or C
-             a.getProtocolStack().insertProtocol(discard, ProtocolStack.ABOVE, SHARED_LOOPBACK.class);
+             a.getProtocolStack().insertProtocol(discard, ProtocolStack.Position.ABOVE, SHARED_LOOPBACK.class);
 
              System.out.println("B and C exchange " + NUM + " messages, A discards them");
              for(int i=0; i < NUM; i++)
diff --git a/tests/junit-functional/org/jgroups/protocols/NAKACK_RetransmitTest.java b/tests/junit-functional/org/jgroups/protocols/NAKACK_RetransmitTest.java
index d55699390d..a0fe65b31b 100644
--- a/tests/junit-functional/org/jgroups/protocols/NAKACK_RetransmitTest.java
+++ b/tests/junit-functional/org/jgroups/protocols/NAKACK_RetransmitTest.java
@@ -150,7 +150,7 @@ protected void startRetransmission(JChannel ... channels) throws Exception {
     protected static void insertDiscardProtocol(JChannel ... channels) {
         for(JChannel ch: channels) {
             ProtocolStack stack=ch.getProtocolStack();
-            stack.insertProtocolInStack(new DiscardEveryOtherMulticastMessage(), stack.getTransport(), ProtocolStack.ABOVE);
+            stack.insertProtocolInStack(new DiscardEveryOtherMulticastMessage(), stack.getTransport(), ProtocolStack.Position.ABOVE);
         }
     }
 
diff --git a/tests/junit-functional/org/jgroups/protocols/SASLTest.java b/tests/junit-functional/org/jgroups/protocols/SASLTest.java
index d0b50638b4..91f5a71cd8 100644
--- a/tests/junit-functional/org/jgroups/protocols/SASLTest.java
+++ b/tests/junit-functional/org/jgroups/protocols/SASLTest.java
@@ -1,25 +1,6 @@
 package org.jgroups.protocols;
 
-import static org.testng.AssertJUnit.assertTrue;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-import javax.security.auth.callback.Callback;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.callback.NameCallback;
-import javax.security.auth.callback.PasswordCallback;
-import javax.security.auth.callback.UnsupportedCallbackException;
-import javax.security.sasl.AuthorizeCallback;
-import javax.security.sasl.RealmCallback;
-
-import org.jgroups.Address;
-import org.jgroups.Event;
-import org.jgroups.Global;
-import org.jgroups.JChannel;
-import org.jgroups.Membership;
-import org.jgroups.View;
+import org.jgroups.*;
 import org.jgroups.protocols.pbcast.GMS;
 import org.jgroups.protocols.pbcast.NAKACK2;
 import org.jgroups.protocols.pbcast.STABLE;
@@ -29,6 +10,15 @@
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.Test;
 
+import javax.security.auth.callback.*;
+import javax.security.sasl.AuthorizeCallback;
+import javax.security.sasl.RealmCallback;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.testng.AssertJUnit.assertTrue;
+
 @Test(groups = Global.FUNCTIONAL, singleThreaded = true)
 public class SASLTest {
     private static final String REALM = "MyRealm";
@@ -121,7 +111,7 @@ private static void createPartitions(JChannel... channels) throws Exception {
         for (JChannel ch : channels) {
             DISCARD discard = new DISCARD();
             discard.setDiscardAll(true);
-            ch.getProtocolStack().insertProtocol(discard, ProtocolStack.ABOVE, TP.class);
+            ch.getProtocolStack().insertProtocol(discard, ProtocolStack.Position.ABOVE, TP.class);
         }
 
         for (JChannel ch : channels) {
diff --git a/tests/junit-functional/org/jgroups/protocols/SYM_ENCRYPT_Test.java b/tests/junit-functional/org/jgroups/protocols/SYM_ENCRYPT_Test.java
new file mode 100644
index 0000000000..0bdcd0f4b9
--- /dev/null
+++ b/tests/junit-functional/org/jgroups/protocols/SYM_ENCRYPT_Test.java
@@ -0,0 +1,93 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Global;
+import org.jgroups.JChannel;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.stack.ProtocolStack;
+import org.jgroups.util.Util;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+/**
+ * Tests use cases for {@link SYM_ENCRYPT} described in https://issues.jboss.org/browse/JGRP-2021.
+ * Make sure you create the keystore before running this test (ant make-keystore).
+ * @author Bela Ban
+ * @since  4.0
+ */
+@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+public class SYM_ENCRYPT_Test extends EncryptTest {
+    protected static final String DEF_PWD="changeit";
+
+    @BeforeMethod protected void init() throws Exception {
+        super.init(getClass().getSimpleName());
+    }
+
+    @AfterMethod protected void destroy() {
+        super.destroy();
+    }
+
+
+    /** Calling methods in superclass. Kludge because TestNG doesn't call methods in superclass correctly **/
+    public void testRegularMessageReception() throws Exception {
+        super.testRegularMessageReception();
+    }
+
+    public void testRegularMessageReceptionWithEmptyMessages() throws Exception {
+        super.testRegularMessageReceptionWithEmptyMessages();
+    }
+
+    public void testChecksum() throws Exception {
+        super.testChecksum();
+    }
+
+    public void testRogueMemberJoin() throws Exception {
+        super.testRogueMemberJoin();
+    }
+
+    public void testMessageSendingByRogue() throws Exception {
+        super.testMessageSendingByRogue();
+    }
+
+    public void testMessageSendingByRogueUsingEncryption() throws Exception {
+        super.testMessageSendingByRogueUsingEncryption();
+    }
+
+    public void testMessageReceptionByRogue() throws Exception {
+        super.testMessageReceptionByRogue();
+    }
+
+    public void testCapturingOfMessageByNonMemberAndResending() throws Exception {
+        super.testCapturingOfMessageByNonMemberAndResending();
+    }
+
+    public void testRogueViewInstallation() throws Exception {
+        super.testRogueViewInstallation();
+    }
+
+
+
+    protected JChannel create(String name) throws Exception {
+        JChannel ch=new JChannel(Util.getTestStack()).name(name);
+        SYM_ENCRYPT encrypt;
+        try {
+            encrypt=createENCRYPT("keystore/defaultStore.keystore", DEF_PWD);
+        }
+        catch(Throwable t) {
+            encrypt=createENCRYPT("defaultStore.keystore", DEF_PWD);
+        }
+        ch.getProtocolStack().insertProtocol(encrypt, ProtocolStack.Position.BELOW, NAKACK2.class);
+        return ch;
+    }
+
+
+    // Note that setting encrypt_entire_message to true is critical here, or else some of the tests in this
+    // unit test would fail!
+    protected SYM_ENCRYPT createENCRYPT(String keystore_name, String store_pwd) throws Exception {
+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT().keystoreName(keystore_name).alias("myKey")
+          .storePassword(store_pwd).encryptEntireMessage(true).signMessages(true);
+        encrypt.init();
+        return encrypt;
+    }
+
+}
diff --git a/tests/junit-functional/org/jgroups/protocols/UNICAST_ConnectionTests.java b/tests/junit-functional/org/jgroups/protocols/UNICAST_ConnectionTests.java
index 8de19d809e..ec80d02b73 100644
--- a/tests/junit-functional/org/jgroups/protocols/UNICAST_ConnectionTests.java
+++ b/tests/junit-functional/org/jgroups/protocols/UNICAST_ConnectionTests.java
@@ -164,7 +164,7 @@ public void testAClosingUnilaterallyButLosingFirstMessage(Class<? extends Protoc
 
         // add a Drop protocol to drop the first unicast message
         Drop drop=new Drop(true);
-        a.getProtocolStack().insertProtocol(drop, ProtocolStack.BELOW,(Class<? extends Protocol>[])Util.getUnicastProtocols());
+        a.getProtocolStack().insertProtocol(drop, ProtocolStack.Position.BELOW,(Class<? extends Protocol>[])Util.getUnicastProtocols());
 
         // then send messages from A to B
         sendAndCheck(a, b_addr, 10, r2);
diff --git a/tests/junit-functional/org/jgroups/protocols/UNICAST_MessagesToSelfTest.java b/tests/junit-functional/org/jgroups/protocols/UNICAST_MessagesToSelfTest.java
index 95370ecb14..92ba344d46 100644
--- a/tests/junit-functional/org/jgroups/protocols/UNICAST_MessagesToSelfTest.java
+++ b/tests/junit-functional/org/jgroups/protocols/UNICAST_MessagesToSelfTest.java
@@ -76,7 +76,7 @@ protected static JChannel createChannel(Protocol unicast, DISCARD discard) throw
                                  new STABLE().setValue("max_bytes", 50000),
                                  new GMS().setValue("print_local_addr", false));
         if(discard != null)
-            ch.getProtocolStack().insertProtocol(discard, ProtocolStack.ABOVE, SHARED_LOOPBACK.class);
+            ch.getProtocolStack().insertProtocol(discard, ProtocolStack.Position.ABOVE, SHARED_LOOPBACK.class);
         return ch;
     }
 
diff --git a/tests/junit-functional/org/jgroups/protocols/UNICAST_OOB_Test.java b/tests/junit-functional/org/jgroups/protocols/UNICAST_OOB_Test.java
index 610a783fd3..8c25fc84ac 100644
--- a/tests/junit-functional/org/jgroups/protocols/UNICAST_OOB_Test.java
+++ b/tests/junit-functional/org/jgroups/protocols/UNICAST_OOB_Test.java
@@ -66,7 +66,7 @@ private void sendMessages(boolean oob) throws Exception {
         ProtocolStack stack=a.getProtocolStack();
         Protocol neighbor=stack.findProtocol(Util.getUnicastProtocols());
         System.out.println("Found unicast protocol " + neighbor.getClass().getSimpleName());
-        stack.insertProtocolInStack(discard,neighbor,ProtocolStack.BELOW);
+        stack.insertProtocolInStack(discard,neighbor,ProtocolStack.Position.BELOW);
 
         a.connect("UNICAST_OOB_Test");
         b.connect("UNICAST_OOB_Test");
diff --git a/tests/junit-functional/org/jgroups/protocols/UNICAST_RetransmitTest.java b/tests/junit-functional/org/jgroups/protocols/UNICAST_RetransmitTest.java
index 2b85e6b1f8..bc3e4685f7 100644
--- a/tests/junit-functional/org/jgroups/protocols/UNICAST_RetransmitTest.java
+++ b/tests/junit-functional/org/jgroups/protocols/UNICAST_RetransmitTest.java
@@ -78,7 +78,7 @@ protected static void change(JChannel ... channels) {
         for(JChannel ch: channels) {
             TP transport=ch.getProtocolStack().getTransport();
             transport.setMaxBundleSize(MAX_BUNDLE_SIZE);
-            UNICAST3 ucast=(UNICAST3)ch.getProtocolStack().findProtocol(UNICAST3.class);
+            UNICAST3 ucast=ch.getProtocolStack().findProtocol(UNICAST3.class);
             if(ucast == null)
                 throw new IllegalStateException("UNICAST3 not present in the stack");
             ucast.setValue("max_xmit_req_size", 5000);
@@ -101,21 +101,21 @@ public void receive(Message msg) {
 
     protected void stopRetransmission(JChannel ... channels) {
         for(JChannel ch: channels) {
-            UNICAST3 ucast=(UNICAST3)ch.getProtocolStack().findProtocol(UNICAST3.class);
+            UNICAST3 ucast=ch.getProtocolStack().findProtocol(UNICAST3.class);
             ucast.stopRetransmitTask();
         }
     }
 
     protected void startRetransmission(JChannel ... channels) {
         for(JChannel ch: channels) {
-            UNICAST3 ucast=(UNICAST3)ch.getProtocolStack().findProtocol(UNICAST3.class);
+            UNICAST3 ucast=ch.getProtocolStack().findProtocol(UNICAST3.class);
             ucast.startRetransmitTask();
         }
     }
 
     protected static void insertDiscardProtocol(JChannel ch) {
         ProtocolStack stack=ch.getProtocolStack();
-        stack.insertProtocolInStack(new DiscardEveryOtherUnicastMessage(), stack.getTransport(), ProtocolStack.ABOVE);
+        stack.insertProtocolInStack(new DiscardEveryOtherUnicastMessage(), stack.getTransport(), ProtocolStack.Position.ABOVE);
     }
 
     protected static void removeDiscardProtocol(JChannel ch) {
diff --git a/tests/junit-functional/org/jgroups/tests/ConfiguratorTest.java b/tests/junit-functional/org/jgroups/tests/ConfiguratorTest.java
index add2b56f76..04f8eb05f9 100644
--- a/tests/junit-functional/org/jgroups/tests/ConfiguratorTest.java
+++ b/tests/junit-functional/org/jgroups/tests/ConfiguratorTest.java
@@ -58,7 +58,7 @@ public void testRemovalOfBottom() throws Exception {
     
     public void testAddingAboveTop() throws Exception{
         Protocol new_prot=new TRACE();
-        stack.insertProtocol(new_prot, ProtocolStack.ABOVE, MFC.class);
+        stack.insertProtocol(new_prot, ProtocolStack.Position.ABOVE, MFC.class);
         List<Protocol> protocols=stack.getProtocols();
         Assert.assertEquals(7, protocols.size());       
         assert protocols.get(0).getName().endsWith("TRACE");
@@ -71,7 +71,7 @@ public void testAddingAboveTop() throws Exception{
     @Test(expectedExceptions={IllegalArgumentException.class})
     public void testAddingBelowBottom() throws Exception{
         Protocol new_prot=new TRACE();
-        stack.insertProtocol(new_prot, ProtocolStack.BELOW, UDP.class);
+        stack.insertProtocol(new_prot, ProtocolStack.Position.BELOW, UDP.class);
     }
     
     
@@ -89,7 +89,7 @@ public void testInsertion() throws Exception {
 
         // insert below
         Protocol new_prot=(Protocol)Class.forName("org.jgroups.protocols.TRACE").newInstance();
-        stack.insertProtocol(new_prot, ProtocolStack.BELOW, UNICAST3.class);
+        stack.insertProtocol(new_prot, ProtocolStack.Position.BELOW, UNICAST3.class);
         protocols=stack.getProtocols();
         Assert.assertEquals(7, protocols.size());
         for(int i=0; i < below.length; i++) {
@@ -111,7 +111,7 @@ public void testInsertion() throws Exception {
 
         // insert above
         new_prot=(Protocol)Class.forName("org.jgroups.protocols.TRACE").newInstance();
-        stack.insertProtocol(new_prot, ProtocolStack.ABOVE, UNICAST3.class);
+        stack.insertProtocol(new_prot, ProtocolStack.Position.ABOVE, UNICAST3.class);
         protocols=stack.getProtocols();
         Assert.assertEquals(7, protocols.size());
         for(int i=0; i < above.length; i++) {
diff --git a/tests/junit-functional/org/jgroups/tests/DynamicDiscardTest.java b/tests/junit-functional/org/jgroups/tests/DynamicDiscardTest.java
index b33d9deb0c..744860e030 100644
--- a/tests/junit-functional/org/jgroups/tests/DynamicDiscardTest.java
+++ b/tests/junit-functional/org/jgroups/tests/DynamicDiscardTest.java
@@ -55,7 +55,7 @@ public void testLeaveDuringSend() throws Exception {
 
         // discard all messages (except those to self)
         DISCARD discard = new DISCARD();
-        channels[0].getProtocolStack().insertProtocol(discard, ProtocolStack.ABOVE, TP.class);
+        channels[0].getProtocolStack().insertProtocol(discard, ProtocolStack.Position.ABOVE, TP.class);
         discard.setDiscardAll(true);
 
         // send a RSVP message
diff --git a/tests/junit-functional/org/jgroups/tests/ForkChannelTest.java b/tests/junit-functional/org/jgroups/tests/ForkChannelTest.java
index 28b1f80857..8a6a6d48f0 100644
--- a/tests/junit-functional/org/jgroups/tests/ForkChannelTest.java
+++ b/tests/junit-functional/org/jgroups/tests/ForkChannelTest.java
@@ -52,7 +52,7 @@ public void testCreateForkIfAbsent() throws Exception {
                 "hijack-stack",
                 "lead-hijacker",
                 true,
-                ProtocolStack.ABOVE,
+                ProtocolStack.Position.ABOVE,
                 FRAG2.class);
         assert fc.isOpen() && !fc.isConnected() && !fc.isClosed() : "state=" + fc.getState();
 
@@ -261,8 +261,8 @@ public void testNullForkStack() throws Exception {
      * @throws Exception
      */
     public void testCounterService() throws Exception {
-        fc1=new ForkChannel(a, "stack", "fc1", false,ProtocolStack.ABOVE, FORK.class, new COUNTER());
-        fc2=new ForkChannel(a, "stack", "fc2", false,ProtocolStack.ABOVE, FORK.class, new COUNTER());
+        fc1=new ForkChannel(a, "stack", "fc1", false,ProtocolStack.Position.ABOVE, FORK.class, new COUNTER());
+        fc2=new ForkChannel(a, "stack", "fc2", false,ProtocolStack.Position.ABOVE, FORK.class, new COUNTER());
         a.connect(CLUSTER);
         fc1.connect("foo");
         fc2.connect("bar");
diff --git a/tests/junit-functional/org/jgroups/tests/MergeTest4.java b/tests/junit-functional/org/jgroups/tests/MergeTest4.java
index 062028da78..08ce614871 100644
--- a/tests/junit-functional/org/jgroups/tests/MergeTest4.java
+++ b/tests/junit-functional/org/jgroups/tests/MergeTest4.java
@@ -627,7 +627,7 @@ protected void discard(boolean flag, JChannel ... channels) throws Exception {
             ProtocolStack stack=ch.getProtocolStack();
             DISCARD discard=stack.findProtocol(DISCARD.class);
             if(discard == null)
-                stack.insertProtocol(discard=new DISCARD(), ProtocolStack.ABOVE, stack.getTransport().getClass());
+                stack.insertProtocol(discard=new DISCARD(), ProtocolStack.Position.ABOVE, stack.getTransport().getClass());
             discard.setDiscardAll(flag);
         }
     }
diff --git a/tests/junit-functional/org/jgroups/tests/SizeTest.java b/tests/junit-functional/org/jgroups/tests/SizeTest.java
index b5a213bdc7..8f99c7e05d 100644
--- a/tests/junit-functional/org/jgroups/tests/SizeTest.java
+++ b/tests/junit-functional/org/jgroups/tests/SizeTest.java
@@ -619,10 +619,10 @@ public static void testRelay2Header() throws Exception {
     }
 
 
-    public static void testEncryptHeader() throws Exception {
-        ENCRYPT.EncryptHeader hdr=new ENCRYPT.EncryptHeader((byte)1, new byte[]{'b','e', 'l', 'a'});
+    public void testEncryptHeader() throws Exception {
+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, new byte[]{'b','e', 'l', 'a'});
         _testSize(hdr);
-        hdr=new ENCRYPT.EncryptHeader((byte)2, "Hello world".getBytes());
+        hdr=new EncryptHeader(EncryptHeader.ENCRYPT, "Hello".getBytes()).signature("bla".getBytes());
         _testSize(hdr);
     }
 
diff --git a/tests/junit-functional/org/jgroups/tests/ViewTest.java b/tests/junit-functional/org/jgroups/tests/ViewTest.java
index e4254e1566..23f1105360 100644
--- a/tests/junit-functional/org/jgroups/tests/ViewTest.java
+++ b/tests/junit-functional/org/jgroups/tests/ViewTest.java
@@ -81,6 +81,17 @@ public void testContainsMember() {
         assert !view.containsMember(i) : "Member should not be in view";
     }
 
+    public void testContainsMembers() {
+        assert view.containsMembers(b,a,d,c);
+        assert !view.containsMembers(a,b,d,f, Util.createRandomAddress("X"));
+
+        View v=View.create(a,1,a,b,c);
+        assert v.containsMembers(a,b);
+
+        v=View.create(a,2,a,b);
+        assert !v.containsMembers(a,b,c);
+    }
+
     public void testEqualsCreator() {
         assert a.equals(view.getCreator()) : "Creator should be a";
         assert !view.getCreator().equals(d) : "Creator should not be d";
diff --git a/tests/junit/org/jgroups/tests/DiscardTest.java b/tests/junit/org/jgroups/tests/DiscardTest.java
index 2870abb5b8..bd6a9a493b 100644
--- a/tests/junit/org/jgroups/tests/DiscardTest.java
+++ b/tests/junit/org/jgroups/tests/DiscardTest.java
@@ -73,11 +73,11 @@ private void _testLosslessReception(boolean discard) throws Exception {
             Properties properties=new Properties();
             properties.setProperty("down", "0.1");
 
-            a.getProtocolStack().insertProtocol(discard_prot, ProtocolStack.BELOW, MERGE3.class);
+            a.getProtocolStack().insertProtocol(discard_prot, ProtocolStack.Position.BELOW, MERGE3.class);
             discard_prot=new DISCARD();
             properties=new Properties();
             properties.setProperty("down", "0.1");
-            b.getProtocolStack().insertProtocol(discard_prot, ProtocolStack.BELOW, MERGE3.class);
+            b.getProtocolStack().insertProtocol(discard_prot, ProtocolStack.Position.BELOW, MERGE3.class);
         }
 
         System.out.printf("sending %d %d-byte messages to all members (including myself)\n", NUM_MSGS, MSG_SIZE);
diff --git a/tests/junit/org/jgroups/tests/DuplicateTest.java b/tests/junit/org/jgroups/tests/DuplicateTest.java
index 9ec6ca6c1c..28793ae6fd 100644
--- a/tests/junit/org/jgroups/tests/DuplicateTest.java
+++ b/tests/junit/org/jgroups/tests/DuplicateTest.java
@@ -180,7 +180,7 @@ private void createChannels(boolean copy_multicasts, boolean copy_unicasts, int
         a=createChannel(true, 3, "A");
         DUPL dupl=new DUPL(copy_multicasts, copy_unicasts, num_incoming_copies, num_outgoing_copies);
         ProtocolStack stack=a.getProtocolStack();
-        stack.insertProtocol(dupl,ProtocolStack.BELOW,NAKACK2.class);
+        stack.insertProtocol(dupl,ProtocolStack.Position.BELOW,NAKACK2.class);
 
         b=createChannel(a, "B");
         c=createChannel(a, "C");
diff --git a/tests/junit/org/jgroups/tests/JoinTest.java b/tests/junit/org/jgroups/tests/JoinTest.java
index 79f34eedd5..16483bc8c8 100644
--- a/tests/junit/org/jgroups/tests/JoinTest.java
+++ b/tests/junit/org/jgroups/tests/JoinTest.java
@@ -137,14 +137,14 @@ void _testDelayedJoinResponse(long join_timeout, long delay_join_req, long toler
         b.connect("JoinTest");
 
         ProtocolStack stack=b.getProtocolStack();
-        GMS gms=(GMS)stack.findProtocol(GMS.class);
+        GMS gms=stack.findProtocol(GMS.class);
         if(gms != null)
             gms.setJoinTimeout(join_timeout);
 
 
         stack=a.getProtocolStack();
         DELAY_JOIN_REQ delay=new DELAY_JOIN_REQ().delay(delay_join_req);
-        stack.insertProtocol(delay, ProtocolStack.BELOW, GMS.class);
+        stack.insertProtocol(delay, ProtocolStack.Position.BELOW, GMS.class);
 
         System.out.println(new Date() + ": joining c2");
         long start=System.currentTimeMillis(), stop;
@@ -196,7 +196,7 @@ public Object up(final Event evt) {
             switch(evt.getType()) {
                 case Event.MSG:
                     Message msg=(Message)evt.getArg();
-                    final GMS.GmsHeader hdr=(GMS.GmsHeader)msg.getHeader(gms_id);
+                    final GMS.GmsHeader hdr=msg.getHeader(gms_id);
                     if(hdr != null) {
                         switch(hdr.getType()) {
                             case GMS.GmsHeader.JOIN_REQ:
diff --git a/tests/junit/org/jgroups/tests/LastMessageDroppedTest.java b/tests/junit/org/jgroups/tests/LastMessageDroppedTest.java
index dd8f7a9873..d8be5aa9a1 100644
--- a/tests/junit/org/jgroups/tests/LastMessageDroppedTest.java
+++ b/tests/junit/org/jgroups/tests/LastMessageDroppedTest.java
@@ -40,7 +40,7 @@
     public void testLastMessageDropped() throws Exception {
         DISCARD discard=new DISCARD();
         ProtocolStack stack=a.getProtocolStack();
-        stack.insertProtocol(discard,ProtocolStack.BELOW,NAKACK2.class);
+        stack.insertProtocol(discard,ProtocolStack.Position.BELOW,NAKACK2.class);
         a.setDiscardOwnMessages(true);
 
         MyReceiver receiver=new MyReceiver();
diff --git a/tests/junit/org/jgroups/tests/MergeTest.java b/tests/junit/org/jgroups/tests/MergeTest.java
index 08a98e4d81..383891be3a 100644
--- a/tests/junit/org/jgroups/tests/MergeTest.java
+++ b/tests/junit/org/jgroups/tests/MergeTest.java
@@ -123,7 +123,7 @@ private static void createPartitions(JChannel[] channels) throws Exception {
         for(JChannel ch: channels) {
             DISCARD discard=new DISCARD();
             discard.setDiscardAll(true);
-            ch.getProtocolStack().insertProtocol(discard, ProtocolStack.ABOVE,TP.class);
+            ch.getProtocolStack().insertProtocol(discard, ProtocolStack.Position.ABOVE,TP.class);
         }
 
         for(JChannel ch: channels) {
diff --git a/tests/junit/org/jgroups/tests/NAKACK_Test.java b/tests/junit/org/jgroups/tests/NAKACK_Test.java
index 544a5906e6..e3cd997131 100644
--- a/tests/junit/org/jgroups/tests/NAKACK_Test.java
+++ b/tests/junit/org/jgroups/tests/NAKACK_Test.java
@@ -54,7 +54,7 @@ public void testOutOfBandMessages() throws Exception {
         c2.setReceiver(receiver2);
         c3.setReceiver(receiver3);
 
-        c1.getProtocolStack().insertProtocol(new DISCARD_PAYLOAD(), ProtocolStack.BELOW, NAKACK2.class);
+        c1.getProtocolStack().insertProtocol(new DISCARD_PAYLOAD(), ProtocolStack.Position.BELOW, NAKACK2.class);
 
         c1.connect("NAKACK_OOB_Test");
         c2.connect("NAKACK_OOB_Test");
diff --git a/tests/junit/org/jgroups/tests/OOBTest.java b/tests/junit/org/jgroups/tests/OOBTest.java
index cbd1368f3a..45073351b7 100644
--- a/tests/junit/org/jgroups/tests/OOBTest.java
+++ b/tests/junit/org/jgroups/tests/OOBTest.java
@@ -62,7 +62,7 @@ public void testNonBlockingMulticastOOBMessage() throws Exception {
     public void testRegularAndOOBUnicasts() throws Exception {
         DISCARD discard=new DISCARD();
         ProtocolStack stack=a.getProtocolStack();
-        stack.insertProtocol(discard, ProtocolStack.BELOW,(Class<? extends Protocol>[])Util.getUnicastProtocols());
+        stack.insertProtocol(discard, ProtocolStack.Position.BELOW,(Class<? extends Protocol>[])Util.getUnicastProtocols());
 
         Address dest=b.getAddress();
         Message m1=new Message(dest, 1);
@@ -90,7 +90,7 @@ public void testRegularAndOOBUnicasts() throws Exception {
     public void testRegularAndOOBUnicasts2() throws Exception {
         DISCARD discard=new DISCARD();
         ProtocolStack stack=a.getProtocolStack();
-        stack.insertProtocol(discard, ProtocolStack.BELOW,(Class<? extends Protocol>[])Util.getUnicastProtocols());
+        stack.insertProtocol(discard, ProtocolStack.Position.BELOW,(Class<? extends Protocol>[])Util.getUnicastProtocols());
 
         Address dest=b.getAddress();
         Message m1=new Message(dest, 1);
@@ -121,7 +121,7 @@ public void testRegularAndOOBUnicasts2() throws Exception {
     public void testRegularAndOOBMulticasts() throws Exception {
         DISCARD discard=new DISCARD();
         ProtocolStack stack=a.getProtocolStack();
-        stack.insertProtocol(discard, ProtocolStack.BELOW, NAKACK2.class);
+        stack.insertProtocol(discard, ProtocolStack.Position.BELOW, NAKACK2.class);
         a.setDiscardOwnMessages(true);
 
         Address dest=null; // send to all
@@ -157,7 +157,7 @@ public void testRandomRegularAndOOBMulticasts() throws Exception {
         discard.setLocalAddress(a.getAddress());
         discard.setUpDiscardRate(0.5);
         ProtocolStack stack=a.getProtocolStack();
-        stack.insertProtocol(discard, ProtocolStack.ABOVE, TP.class);
+        stack.insertProtocol(discard, ProtocolStack.Position.ABOVE, TP.class);
         MyReceiver r1=new MyReceiver("A"), r2=new MyReceiver("B");
         a.setReceiver(r1);
         b.setReceiver(r2);
@@ -200,7 +200,7 @@ public void testOOBMessageLoss() throws Exception {
         for(int i=1; i <= NUM; i++)
             a.send(new Message(null, i).setFlag(Message.Flag.OOB));
 
-        STABLE stable=(STABLE)a.getProtocolStack().findProtocol(STABLE.class);
+        STABLE stable=a.getProtocolStack().findProtocol(STABLE.class);
         if(stable != null)
             stable.gc();
         Collection<Integer> msgs=receiver.getMsgs();
@@ -364,7 +364,7 @@ private static void setOOBPoolSize(JChannel... channels) {
     private static void setStableGossip(JChannel... channels) {
         for(JChannel channel: channels) {
             ProtocolStack stack=channel.getProtocolStack();
-            STABLE stable=(STABLE)stack.findProtocol(STABLE.class);
+            STABLE stable=stack.findProtocol(STABLE.class);
             stable.setDesiredAverageGossip(2000);
         }
     }
diff --git a/tests/junit/org/jgroups/tests/OverlappingMergeTest.java b/tests/junit/org/jgroups/tests/OverlappingMergeTest.java
index 918e74dabd..3e7fe2985e 100644
--- a/tests/junit/org/jgroups/tests/OverlappingMergeTest.java
+++ b/tests/junit/org/jgroups/tests/OverlappingMergeTest.java
@@ -372,7 +372,7 @@ public void testSameCreatorDifferentIDs() throws Exception {
             MERGE3 merge_prot=ch.getProtocolStack().findProtocol(MERGE3.class);
             if(merge_prot == null) {
                 merge_prot=new MERGE3();
-                ch.getProtocolStack().insertProtocol(merge_prot, ProtocolStack.ABOVE, Discovery.class);
+                ch.getProtocolStack().insertProtocol(merge_prot, ProtocolStack.Position.ABOVE, Discovery.class);
                 merge_prot.init();
                 merge_prot.down(new Event(Event.SET_LOCAL_ADDRESS, ch.getAddress()));
                 merge_prot.setMinInterval(2000).setMaxInterval(3000).setValue("check_interval", 5000);
diff --git a/tests/junit/org/jgroups/tests/PrioTest.java b/tests/junit/org/jgroups/tests/PrioTest.java
index 0f80860deb..360e07bad8 100644
--- a/tests/junit/org/jgroups/tests/PrioTest.java
+++ b/tests/junit/org/jgroups/tests/PrioTest.java
@@ -29,7 +29,7 @@
 
     @BeforeTest void init() throws Exception {
         c1=createChannel("A");
-        c1.getProtocolStack().insertProtocol(new PRIO(), ProtocolStack.ABOVE, NAKACK2.class);
+        c1.getProtocolStack().insertProtocol(new PRIO(), ProtocolStack.Position.ABOVE, NAKACK2.class);
         c2=createChannel("B");
         c1.connect("PrioTest");
         c1.setReceiver(r1=new PrioReceiver());
diff --git a/tests/junit/org/jgroups/tests/ReconciliationTest.java b/tests/junit/org/jgroups/tests/ReconciliationTest.java
index ab89b574a7..362c88d329 100644
--- a/tests/junit/org/jgroups/tests/ReconciliationTest.java
+++ b/tests/junit/org/jgroups/tests/ReconciliationTest.java
@@ -246,7 +246,7 @@ private static void insertDISCARD(JChannel ch, Address exclude) throws Exception
         DISCARD discard=new DISCARD().localAddress(ch.getAddress());
         discard.setExcludeItself(true);
         discard.addIgnoreMember(exclude); // ignore messages from this member
-        ch.getProtocolStack().insertProtocol(discard, ProtocolStack.BELOW, NAKACK2.class);
+        ch.getProtocolStack().insertProtocol(discard, ProtocolStack.Position.BELOW, NAKACK2.class);
     }
 
     private static void removeDISCARD(JChannel...channels) throws Exception {
diff --git a/tests/junit/org/jgroups/tests/SequencerOrderTest.java b/tests/junit/org/jgroups/tests/SequencerOrderTest.java
index a0bbc3586a..3038716fc0 100644
--- a/tests/junit/org/jgroups/tests/SequencerOrderTest.java
+++ b/tests/junit/org/jgroups/tests/SequencerOrderTest.java
@@ -103,14 +103,14 @@ protected static void insertShuffle(JChannel... channels) throws Exception {
             shuffle.setUp(true);
             shuffle.setMaxSize(10);
             shuffle.setMaxTime(1000);
-            ch.getProtocolStack().insertProtocol(shuffle, ProtocolStack.BELOW, NAKACK2.class);
+            ch.getProtocolStack().insertProtocol(shuffle, ProtocolStack.Position.BELOW, NAKACK2.class);
             shuffle.init(); // starts the timer
         }
     }
 
     protected static void removeSHUFFLE(JChannel ... channels) {
         for(JChannel ch: channels) {
-            SHUFFLE shuffle=(SHUFFLE)ch.getProtocolStack().removeProtocol(SHUFFLE.class);
+            SHUFFLE shuffle=ch.getProtocolStack().removeProtocol(SHUFFLE.class);
             if(shuffle != null)
                 shuffle.destroy();
         }
diff --git a/tests/junit/org/jgroups/tests/StateTransferTest.java b/tests/junit/org/jgroups/tests/StateTransferTest.java
index f0d2e30855..3df95c601e 100644
--- a/tests/junit/org/jgroups/tests/StateTransferTest.java
+++ b/tests/junit/org/jgroups/tests/StateTransferTest.java
@@ -218,7 +218,7 @@ protected void replaceStateTransferProtocolWith(JChannel ch, Class<? extends Pro
         else { // no state transfer protocol found in stack
             Protocol flush=stack.findProtocol(FLUSH.class);
             if(flush != null)
-                stack.insertProtocol(new_state_transfer_protcol, ProtocolStack.BELOW, FLUSH.class);
+                stack.insertProtocol(new_state_transfer_protcol, ProtocolStack.Position.BELOW, FLUSH.class);
             else
                 stack.insertProtocolAtTop(new_state_transfer_protcol);
         }
diff --git a/tests/junit/org/jgroups/tests/StateTransferTest2.java b/tests/junit/org/jgroups/tests/StateTransferTest2.java
index 5494cbad74..9123f47d51 100644
--- a/tests/junit/org/jgroups/tests/StateTransferTest2.java
+++ b/tests/junit/org/jgroups/tests/StateTransferTest2.java
@@ -111,7 +111,7 @@ protected void replaceStateTransferProtocolWith(JChannel ch, Class<? extends Pro
         else { // no state transfer protocol found in stack
             Protocol flush=stack.findProtocol(FLUSH.class);
             if(flush != null)
-                stack.insertProtocol(new_state_transfer_protcol, ProtocolStack.BELOW, FLUSH.class);
+                stack.insertProtocol(new_state_transfer_protcol, ProtocolStack.Position.BELOW, FLUSH.class);
             else
                 stack.insertProtocolAtTop(new_state_transfer_protcol);
         }
diff --git a/tests/stress/org/jgroups/tests/RemoteGetStressTest.java b/tests/stress/org/jgroups/tests/RemoteGetStressTest.java
index 7ff340fb1c..3c9a062d50 100644
--- a/tests/stress/org/jgroups/tests/RemoteGetStressTest.java
+++ b/tests/stress/org/jgroups/tests/RemoteGetStressTest.java
@@ -132,7 +132,7 @@ protected static void insertDISCARD(JChannel ch, double discard_rate) throws Exc
         TP transport=ch.getProtocolStack().getTransport();
         DISCARD discard=new DISCARD();
         discard.setUpDiscardRate(discard_rate);
-        ch.getProtocolStack().insertProtocol(discard, ProtocolStack.ABOVE, transport.getClass());
+        ch.getProtocolStack().insertProtocol(discard, ProtocolStack.Position.ABOVE, transport.getClass());
     }
 
     protected class Invoker extends Thread {
