diff --git a/.gitignore b/.gitignore
index a8a43d9f3f..b628883381 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,7 @@
 *.iws
 *.ipr
 *.iml
+.ant-targets-build.xml
 .project
 .classpath
 .factorypath
diff --git a/build.xml b/build.xml
index d93fd1d31d..a8033055ba 100644
--- a/build.xml
+++ b/build.xml
@@ -631,6 +631,43 @@
                  threadcount="5" />
     </target>
 
+    <!--listeners="org.jgroups.util.JUnitXMLReporter"-->
+
+    <target name="encrypt" description="Runs SYM_ENCRYPT_Test only" depends="define-testng-task">
+        <mkdir dir="${tmp.dir}/test-results/xml/functional"/>
+
+        <testng classpathref="jg.classpath"
+                suitename="encrypt-test"
+                groups="encr"
+                parallel="classes"
+                threadcount="5"
+                usedefaultlisteners="false"
+                outputdir="${tmp.dir}/test-results/xml/functional"
+                timeout="${unittest.timeout}"
+                timeOut="${unittest.timeout}"
+                verbose="1"
+                listeners="org.jgroups.util.JUnitXMLReporter"
+                configfailurepolicy="continue">
+
+            <classfileset dir="${compile.dir}"/>
+
+            <jvmarg value="-Djgroups.bind_addr=${jgroups.bind_addr}"/>
+            <jvmarg value="-Djgroups.udp.ip_ttl=0"/>
+            <jvmarg value="-Djgroups.tcpping.initial_hosts=${jgroups.tcpping.initial_hosts}"/>
+            <jvmarg value="-Djgroups.tunnel.gossip_router_hosts=${jgroups.tunnel.gossip_router_hosts}"/>
+            <jvmarg value="-Dtests.tmp.dir=${tmp.dir}"/>
+            <jvmarg value="-Dlog4j.configuration=file:${conf.dir}/log4j.properties"/>
+            <jvmarg value="-Dlog4j.configurationFile=${conf.dir}/log4j2.xml"/>
+            <jvmarg value="-Djava.net.preferIPv4Stack=${java.net.preferIPv4Stack}"/>
+            <jvmarg value="-Djava.net.preferIPv6Addresses=${java.net.preferIPv6Addresses}"/>
+            <jvmarg value="-Xms400M"/>
+            <jvmarg value="-Xmx800M"/>
+            <!--<additional-args/>-->
+        </testng>
+
+
+    </target>
+
 
     <target name="byteman" depends="postcompile,define-testng-task" description="Runs the byteman tests">
         <mkdir dir="${tmp.dir}/test-results/xml/byteman"/>
diff --git a/conf/asym-encrypt.xml b/conf/asym-encrypt.xml
new file mode 100644
index 0000000000..8b9a93d34d
--- /dev/null
+++ b/conf/asym-encrypt.xml
@@ -0,0 +1,29 @@
+
+<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+        xmlns="urn:org:jgroups"
+        xsi:schemaLocation="urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd">
+    <UDP />
+    <PING/>
+    <MERGE3/>
+    <FD_ALL timeout="5000"/>
+    <FD_SOCK/>
+    <VERIFY_SUSPECT/>
+
+    <!-- Asymmetric encryption using public/private encryption to fetch the shared secret key -->
+    <ASYM_ENCRYPT
+            encrypt_entire_message="true"
+            sym_keylength="128"
+            sym_algorithm="AES/ECB/PKCS5Padding"
+            asym_keylength="512"
+            asym_algorithm="RSA"/>
+
+    <pbcast.NAKACK2/>
+    <UNICAST3/>
+    <pbcast.STABLE/>
+    <FRAG2/>
+    <!-- AUTH below is required by ASYM_ENCRYPT -->
+    <AUTH auth_class="org.jgroups.auth.MD5Token"
+          auth_value="chris"
+          token_hash="MD5"/>
+    <pbcast.GMS join_timeout="2000" />
+</config>
diff --git a/conf/jg-magic-map.xml b/conf/jg-magic-map.xml
index da13de37e4..c89f7257bf 100644
--- a/conf/jg-magic-map.xml
+++ b/conf/jg-magic-map.xml
@@ -24,7 +24,7 @@
     <class id="53"  name="org.jgroups.protocols.COMPRESS$CompressHeader"/>
     <class id="54"  name="org.jgroups.protocols.FcHeader"/>
     <class id="56"  name="org.jgroups.protocols.TpHeader"/>
-    <class id="57"  name="org.jgroups.protocols.ENCRYPT$EncryptHeader"/>
+    <class id="57"  name="org.jgroups.protocols.EncryptHeader"/>
     <class id="58"  name="org.jgroups.protocols.SEQUENCER$SequencerHeader"/>
     <class id="61"  name="org.jgroups.protocols.FD_ALL$HeartbeatHeader"/>
     <class id="62"  name="org.jgroups.protocols.FD_ALL2$HeartbeatHeader"/>
diff --git a/conf/jg-protocol-ids.xml b/conf/jg-protocol-ids.xml
index 86d759b25b..50b4f92ec1 100644
--- a/conf/jg-protocol-ids.xml
+++ b/conf/jg-protocol-ids.xml
@@ -69,6 +69,9 @@
     <class id="73" name="org.jgroups.protocols.ABP"/>
     <class id="74" name="org.jgroups.protocols.TCP_NIO2"/>
     <class id="75" name="org.jgroups.protocols.TP"/>
+    <class id="76" name="org.jgroups.protocols.SYM_ENCRYPT"/>
+    <class id="77" name="org.jgroups.protocols.ASYM_ENCRYPT"/>
+
 
     <!-- IDs reserved for building blocks -->
     <class id="200" name="org.jgroups.blocks.RequestCorrelator"/> <!-- ID should be the same as Global.BLOCKS_START_ID -->
diff --git a/conf/sym-encrypt.xml b/conf/sym-encrypt.xml
new file mode 100644
index 0000000000..fb5af81175
--- /dev/null
+++ b/conf/sym-encrypt.xml
@@ -0,0 +1,30 @@
+
+
+
+<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+        xmlns="urn:org:jgroups"
+        xsi:schemaLocation="urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd">
+    <UDP />
+    <PING/>
+    <MERGE3/>
+    <FD_ALL timeout="5000"/>
+    <FD_SOCK/>
+    <VERIFY_SUSPECT/>
+
+    <!-- Symmetric encryption with a keystore -->
+    <SYM_ENCRYPT
+        provider="SunJCE"
+        sym_algorithm="AES"
+        encrypt_entire_message="true"
+        keystore_name="/home/bela/JGroups/keystore/defaultStore.keystore" 
+        store_password="changeit" alias="myKey"/>
+    <pbcast.NAKACK2/>
+    <UNICAST3/>
+    <pbcast.STABLE/>
+    <FRAG2/>
+    <!-- AUTH below is optional -->
+    <AUTH auth_class="org.jgroups.auth.MD5Token"
+          auth_value="chris"
+          token_hash="MD5"/>
+    <pbcast.GMS join_timeout="2000" />
+</config>
diff --git a/doc/design/MaliciousAttacks.txt b/doc/design/MaliciousAttacks.txt
new file mode 100644
index 0000000000..f73f4a961b
--- /dev/null
+++ b/doc/design/MaliciousAttacks.txt
@@ -0,0 +1,91 @@
+
+Use of encryption and authentication protocols to fend off malicious attacks
+============================================================================
+Author: Bela Ban, April 2016
+JIRA:   https://issues.jboss.org/browse/JGRP-2021
+
+The following discussion refers to the changes made in JGroups 4.0. These have been backported to the 3.6 branch, but
+the syntax looks different. However, the concepts are the same.
+
+
+
+Types of attacks handled
+------------------------
+Malicious attacks essentially include (1) non-authorized nodes being able to join a cluster and (2) non-members being
+able to communicate with cluster members.
+
+(1) is handled by AUTH which allows only authenticated nodes to join a cluster.
+
+(2) is handled by the encryption protocol (SYM_ENCRYPT or ASYM_ENCRYPT) which encrypts messages between cluster
+members such that a non-member cannot understand them.
+
+
+
+Authentication
+--------------
+Authentication is performed by AUTH. Its main use is to make sure only authenticated members can join a cluster.
+Other scenarios where a check is performed are:
+* Merging: make sure only authenticated members can merge into a new cluster
+* View installation (if enabled): views and merge views can only be installed by authenticated members
+
+So authentication makes sure that rogue nodes will never be able to be members of a cluster, be it via joining or
+merging. Note that while AUTH is optional with SYM_ENCRYPT, it is required by ASYM_ENCRYPT: there's a sanity check that
+will prevent a member to start if ASYM_ENCRYPT is present but AUTH is absent.
+
+
+
+Authorization
+-------------
+There is currently no authorization in JGroups. Once a member is admitted to the cluster (via authentication),
+it can send and receive messages to anyone.
+
+
+
+Encryption
+----------
+This is based on a shared secret key that all members of a cluster have. The key is either acquired from a shared
+keystore (symmetric encryption, below) or a new joiner fetches it from the coordinator via public/private key exchange
+(asymmetric encryption, below).
+
+A sent message is encrypted with the shared secret key by the sender and decrypted with the same secret key by the
+receiver(s).
+
+By default, the entire message (including the headers) is encrypted, but it is also possible to only encrypt the payload
+(this is configurable). If the headers are not encrypted, it is possible to use replay attacks, because the
+sequence numbers (seqnos) of a message are seen. For example, if a seqno is 50, then an attacker might copy the message,
+and increment the seqno. This is prevented by copying and _signing_ the message.
+
+A message can be signed, which is a hash over the encrypted message, encrypted with the secret key. If the hash shipped
+with a message doesn't match the hash computed over the received message, the message will be discarded by a receiver,
+and no attempt is made to decrypt it.
+
+The cost of encrypting the entire message includes serializing the entire message (including headers, flags, destination
+address etc) and encrypting it into the buffer of a new message (to the same destination). If message signing is enabled,
+the cost of computing a hashcode and encrypting it is added to the above cost.
+
+Attributes present in both symmetric and asymmetric encryption include sign_msgs and encrypt_entire_message.
+
+
+Symmetric encryption
+--------------------
+This is done by SYM_ENCRYPT. The configuration includes mainly attributes that define the keystore, e.g. keystore_name
+(name of the keystore, needs to be found on the classpath), store_password, key_password and alias.
+
+
+Asymmetric encryption
+---------------------
+Contrary to SYM_ENCRYPT, the secret key is not fetched from a shared keystore, but from the current coordinator C. After
+new member P joined the cluster (passing the join check done by AUTH), P sends a request to get the secret key
+(including P's public key) to C.
+
+C then sends the secret key back to P, encrypted with P's public key, and P decrypts it with its private key
+and installs it. From then on, P encrypts and decrypts messages using the secret key.
+
+When a member leaves, C can optionally (based on change_key_on_leave) create a new secret key, and every cluster member
+needs to fetch it again, using the public/private key exchange described above.
+
+
+
+
+
+
diff --git a/doc/manual/protocols.adoc b/doc/manual/protocols.adoc
index 15e4d86ce6..851f10f252 100644
--- a/doc/manual/protocols.adoc
+++ b/doc/manual/protocols.adoc
@@ -1507,10 +1507,15 @@ ${STATS}
 
 
 ==== Security
+Security is used to prevent (1) non-authorized nodes being able to join a cluster and (2) non-members being
+able to communicate with cluster members.
 
-JGroups provides protocols to encrypt cluster traffic (ENCRYPT), and to make sure that only
-                authorized members can join a cluster (AUTH and SASL).
-            
+(1) is handled by AUTH or SASL which allows only authenticated nodes to join a cluster.
+
+(2) is handled by the encryption protocol (ENCRYPT, SYM_ENCRYPT or ASYM_ENCRYPT) which encrypts messages between cluster
+members such that a non-member cannot understand them.
+
+NOTE: ENCRYPT is deprecated, and SYM_ENCRYPT or ASYM_ENCRYPT are recommended for encryption.
 
 [[ENCRYPT]]
 
@@ -1597,6 +1602,85 @@ NOTE: If asymmetric encryption is used (no shared key via keystore), ENCRYPT has
 
 ${ENCRYPT}
 
+[[SYM_ENCRYPT]]
+===== SYM_ENCRYPT
+
+This is done by SYM_ENCRYPT. The configuration includes mainly attributes that define the keystore, e.g. `keystore_name`
+(name of the keystore, needs to be found on the classpath), `store_password`, `key_password` and `alias`.
+
+SYM_ENCRYPT uses store type JCEKS (for details between JKS and JCEKS see here), however `keytool` uses JKS, therefore
+a keystore generated with keytool will not be accessible.
+
+To generate a keystore compatible with JCEKS, use the following command line options to keytool:
+
+----
+keytool -genseckey -alias myKey -keypass changeit -storepass changeit  -keyalg Blowfish -keysize 56 -keystore defaultStore.keystore -storetype  JCEKS
+----
+
+SYM_ENCRYPT could then be configured as follows:
+
+
+
+[source,xml]
+----
+<SYM_ENCRYPT sym_algorithm="AES"
+             encrypt_entire_message="true"
+             key_store_name="defaultStore.keystore"
+             store_password="changeit"
+             alias="myKey"/>
+----
+
+Note that defaultStore.keystore will have to be found in the claspath.
+
+NOTE: Both SYM_ENCRYPT and ASYM_ENCRYPT should be placed directly under NAKACK2
+(see link:https://github.com/belaban/JGroups/tree/master/conf[sample configurations]).
+
+
+${SYM_ENCRYPT}
+
+
+
+[[ASYM_ENCRYPT]]
+===== ASYM_ENCRYPT
+Contrary to SYM_ENCRYPT, the secret key is not fetched from a shared keystore, but from the current coordinator C. After
+new member P joined the cluster (passing the join check done by AUTH), P sends a request to get the secret key
+(including P's public key) to C.
+
+C then sends the secret key back to P, encrypted with P's public key, and P decrypts it with its private key
+and installs it. From then on, P encrypts and decrypts messages using the secret key.
+
+When a member leaves, C can optionally (based on `change_key_on_leave`) create a new secret key, and every cluster member
+needs to fetch it again, using the public/private key exchange described above.
+
+A stack configured to use asymmetric encryption could look like this:
+[source,xml]
+----
+    ...
+    <VERIFY_SUSPECT/>
+    <ASYM_ENCRYPT encrypt_entire_message="true"
+             sym_keylength="128"
+             sym_algorithm="AES/ECB/PKCS5Padding"
+             asym_keylength="512"
+             asym_algorithm="RSA"/>
+
+    <pbcast.NAKACK2/>
+    <UNICAST3/>
+    <pbcast.STABLE/>
+    <FRAG2/>
+    <AUTH auth_class="org.jgroups.auth.MD5Token"
+          auth_value="chris"
+          token_hash="MD5"/>
+    <pbcast.GMS join_timeout="2000" />
+----
+
+The configuration snippet shows ASYM_ENCRYPT positioned just below NAKACK2, so that headers of the important
+retransmission protocols NAKACK2 and UNICAST3 are encrypted, too. Note that AUTH should be part of the configuration, or
+else unauthenticated nodes would be able to acquire the secret key from the coordinator.
+
+${ASYM_ENCRYPT}
+
+
+
 [[AUTH]]
 
 
diff --git a/src/org/jgroups/Channel.java b/src/org/jgroups/Channel.java
index d87d0d54f0..ab48c58537 100644
--- a/src/org/jgroups/Channel.java
+++ b/src/org/jgroups/Channel.java
@@ -396,7 +396,7 @@ public synchronized void clearChannelListeners() {
     * */
     public void setReceiver(Receiver r) {
         if(receiver != null && r != null)
-            log.warn("%s: receiver already set");
+            log.warn("%s: receiver already set", getAddress());
         receiver=r;
     }
 
diff --git a/src/org/jgroups/Event.java b/src/org/jgroups/Event.java
index 020cbca3da..998534fec3 100644
--- a/src/org/jgroups/Event.java
+++ b/src/org/jgroups/Event.java
@@ -88,14 +88,12 @@ public Event(int type, Object arg) {
         this.arg=arg;
     }
 
-    public final int getType() {
+    public final int             getType() {
         return type;
     }
-
-
-    public Object getArg() {
-        return arg;
-    }
+    public int                   type()    {return type;}
+    public Object                getArg()  {return arg;}
+    public <T extends Object> T  arg()     {return (T)arg;}
 
 
 
diff --git a/src/org/jgroups/View.java b/src/org/jgroups/View.java
index 9a1a9fcd60..152472caf4 100644
--- a/src/org/jgroups/View.java
+++ b/src/org/jgroups/View.java
@@ -109,6 +109,8 @@ public Address getCreator() {
         return view_id.getCreator();
     }
 
+    public Address getCoord() {return members.length > 0? members[0] : null;}
+
     /**
      * Returns the member list
      * @return an unmodifiable list
@@ -138,6 +140,17 @@ public boolean containsMember(Address mbr) {
         return false;
     }
 
+    /** Returns true if all mbrs are elements of this view, false otherwise */
+    public boolean containsMembers(Address ... mbrs) {
+        if(mbrs == null || members == null)
+            return false;
+        for(Address mbr: mbrs) {
+            if(!containsMember(mbr))
+                return false;
+        }
+        return true;
+    }
+
 
     public int compareTo(View o) {
         return view_id.compareTo(o.view_id);
diff --git a/src/org/jgroups/demos/KeyStoreGenerator.java b/src/org/jgroups/demos/KeyStoreGenerator.java
index 99312276a0..6e4748a50c 100644
--- a/src/org/jgroups/demos/KeyStoreGenerator.java
+++ b/src/org/jgroups/demos/KeyStoreGenerator.java
@@ -3,12 +3,12 @@
 
 import org.jgroups.util.Util;
 
+import javax.crypto.KeyGenerator;
+import javax.crypto.SecretKey;
 import java.io.FileOutputStream;
 import java.io.OutputStream;
 import java.security.KeyStore;
-
-import javax.crypto.KeyGenerator;
-import javax.crypto.SecretKey;
+import java.security.NoSuchAlgorithmException;
 
 /**
  * Generates a keystore file that has a SecretKey in it. It is not possible to
@@ -130,6 +130,17 @@ public static SecretKey initSymKey() throws Exception {
 
     }
 
+    public static SecretKey createSecretKey() throws Exception {
+        return createSecretKey(symAlg, keySize);
+    }
+
+    public static SecretKey createSecretKey(String sym_alg, int key_size) throws NoSuchAlgorithmException {
+        // KeyGenerator keyGen=KeyGenerator.getInstance(getAlgorithm(sym_alg));
+        KeyGenerator keyGen=KeyGenerator.getInstance(sym_alg);
+        keyGen.init(key_size);
+        return keyGen.generateKey();
+    }
+
     private static String getAlgorithm(String s) {
         int index=s.indexOf("/");
         if(index == -1)
diff --git a/src/org/jgroups/protocols/ASYM_ENCRYPT.java b/src/org/jgroups/protocols/ASYM_ENCRYPT.java
new file mode 100644
index 0000000000..a34769d777
--- /dev/null
+++ b/src/org/jgroups/protocols/ASYM_ENCRYPT.java
@@ -0,0 +1,413 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.annotations.MBean;
+import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.ManagedOperation;
+import org.jgroups.annotations.Property;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.util.AsciiString;
+import org.jgroups.util.MessageBatch;
+import org.jgroups.util.Util;
+
+import javax.crypto.Cipher;
+import javax.crypto.KeyGenerator;
+import javax.crypto.SecretKey;
+import javax.crypto.spec.SecretKeySpec;
+import java.security.*;
+import java.security.spec.X509EncodedKeySpec;
+import java.util.Arrays;
+import java.util.Objects;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+
+/**
+ * Encrypts and decrypts communication in JGroups by using a secret key distributed to all cluster members by the
+ * key server (coordinator) using asymmetric (public/private key) encryption.<br>
+ *
+ * The secret key is identical for all cluster members and is used to encrypt messages when sending and decrypt them
+ * when receiving messages.
+ *
+ * This protocol is typically placed under {@link org.jgroups.protocols.pbcast.NAKACK2}, so that most important
+ * headers are encrypted as well, to prevent replay attacks.<br>
+ *
+ * The current keyserver (always the coordinator) generates a secret key. When a new member joins, it asks the keyserver
+ * for the secret key. The keyserver encrypts the secret key with the joiner's public key and the joiner decrypts it with
+ * its private key and then installs it and starts encrypting and decrypting messages with the secret key.<br>
+ *
+ * View changes that identify a new keyserver will result in a new secret key being generated and then distributed to
+ * all cluster members. This overhead can be substantial in an application with a reasonable member churn.<br>
+ *
+ * This protocol is suited to an application that does not ship with a known key but instead it is generated and
+ * distributed by the keyserver.
+ *
+ * Since messages can only get encrypted and decrypted when the secret key was received from the keyserver, messages
+ * other then join and merge requests/responses are dropped when the secret key isn't yet available. Join and merge
+ * requests / responses are handled by {@link AUTH}.
+ *
+ * @author Bela Ban
+ * @author Steve Woodcock
+ */
+@MBean(description="Asymmetric encryption protocol. The secret key for encryption and decryption of messages is fetched " +
+  "from a key server (the coordinator) via asymmetric encryption")
+public class ASYM_ENCRYPT extends EncryptBase {
+    protected static final short                   GMS_ID=ClassConfigurator.getProtocolId(GMS.class);
+
+    @Property(description="When a member leaves the view, change the secret key, preventing old members from eavesdropping",
+      writable=false)
+    protected boolean                              change_key_on_leave=true;
+    protected volatile Address                     key_server_addr;
+    @ManagedAttribute(description="True if this member is the current key server, false otherwise")
+    protected volatile boolean                     is_key_server;
+    protected KeyPair                              key_pair; // to store own's public/private Key
+    protected Cipher                               asym_cipher;  // decrypting cypher for secret key requests
+    // queue all up msgs until the secret key has been received/created
+    @ManagedAttribute(description="whether or not to queue received messages (until the secret key was received)")
+    protected volatile boolean                     queue_up_msgs=true;
+    // queues a bounded number of messages received during a null secret key (or fetching the key from a new coord)
+    protected final BlockingQueue<Message>         up_queue=new ArrayBlockingQueue<>(100);
+
+    protected volatile long                        last_key_request;
+
+
+    public KeyPair      keyPair()                         {return key_pair;}
+    public Cipher       asymCipher()                      {return asym_cipher;}
+    public Address      keyServerAddr()                   {return key_server_addr;}
+    public ASYM_ENCRYPT keyServerAddr(Address key_srv)    {this.key_server_addr=key_srv; return this;}
+
+    @ManagedAttribute(description="Number of received messages currently queued")
+    public int numQueuedMessages() {return up_queue.size();}
+
+    @ManagedOperation(description="Triggers a request for the secret key to the current keyserver")
+    public void sendKeyRequest() {
+        if(key_server_addr == null) {
+            log.error("%s: key server is currently not set", key_server_addr);
+            return;
+        }
+        sendKeyRequest(key_server_addr);
+    }
+
+    public void init() throws Exception {
+        initKeyPair();
+        super.init();
+    }
+
+    public void stop() {
+        drainUpQueue();
+        super.stop();
+    }
+
+    public Object down(Event evt) {
+        if(evt.type() == Event.MSG) {
+            Message msg=evt.arg();
+            if(skip(msg))
+                return down_prot.down(evt);
+        }
+        return super.down(evt);
+    }
+
+    public Object up(Event evt) {
+        if(evt.type() == Event.MSG) {
+            Message msg=evt.arg();
+            if(skip(msg))
+                return up_prot.up(evt);
+        }
+        return super.up(evt);
+    }
+
+    public void up(MessageBatch batch) {
+        for(Message msg: batch) {
+            if(skip(msg)) {
+                try {
+                    up_prot.up(new Event(Event.MSG, msg));
+                    batch.remove(msg);
+                }
+                catch(Throwable t) {
+                    log.error("failed passing up message from %s: %s, ex=%s", msg.src(), msg.printHeaders(), t);
+                }
+            }
+        }
+        if(!batch.isEmpty())
+            super.up(batch); // decrypt the rest of the messages in the batch (if any)
+    }
+
+
+
+    /** Checks if a message needs to be encrypted/decrypted. Join and merge requests/responses don't need to be
+     * encrypted as they're authenticated by {@link AUTH} */
+    protected static boolean skip(Message msg) {
+        GMS.GmsHeader hdr=(GMS.GmsHeader)msg.getHeader(GMS_ID);
+        if(hdr == null) return false;
+        switch(hdr.getType()) {
+            case GMS.GmsHeader.JOIN_REQ:
+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
+            case GMS.GmsHeader.JOIN_RSP:
+            case GMS.GmsHeader.MERGE_REQ:
+            case GMS.GmsHeader.MERGE_RSP:
+            case GMS.GmsHeader.VIEW_ACK:
+            case GMS.GmsHeader.INSTALL_MERGE_VIEW:
+                return true;
+        }
+        return false;
+    }
+
+
+    @Override protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+        switch(hdr.type()) {
+            case EncryptHeader.SECRET_KEY_REQ:
+                handleSecretKeyRequest(msg);
+                break;
+            case EncryptHeader.SECRET_KEY_RSP:
+                handleSecretKeyResponse(msg, hdr.version());
+                break;
+            default:
+                log.warn("%s: received unknown encrypt header of type %d", local_addr, hdr.type());
+                break;
+        }
+        return null;
+    }
+
+    @Override protected boolean process(Message msg) {
+        if(queue_up_msgs || secret_key == null) {
+            up_queue.offer(msg);
+            log.trace("%s: queuing %s message from %s as secret key hasn't been retrieved from keyserver %s yet, hdrs: %s",
+                      local_addr, msg.dest() == null? "mcast" : "unicast", msg.src(), key_server_addr, msg.printHeaders());
+            if(last_key_request == 0 || System.currentTimeMillis() - last_key_request > 2000) {
+                last_key_request=System.currentTimeMillis();
+                sendKeyRequest();
+            }
+            return false;
+        }
+        return true;
+    }
+
+    protected void handleSecretKeyRequest(final Message msg) {
+        if(!inView(msg.src(), "key requester %s is not in current view %s; ignoring key request"))
+            return;
+        log.debug("%s: received key request from %s", local_addr, msg.getSrc());
+        try {
+            PublicKey tmpKey=generatePubKey(msg.getBuffer());
+            sendSecretKey(secret_key, tmpKey, msg.getSrc());
+        }
+        catch(Exception e) {
+            log.warn("%s: unable to reconstitute peer's public key", local_addr);
+        }
+    }
+
+
+    protected void handleSecretKeyResponse(final Message msg, final byte[] key_version) {
+        if(!inView(msg.src(), "ignoring secret key sent by %s which is not in current view %s"))
+            return;
+        try {
+            SecretKey tmp=decodeKey(msg.getBuffer());
+            if(tmp == null)
+                sendKeyRequest(key_server_addr); // unable to understand response, let's try again
+            else {
+                // otherwise set the returned key as the shared key
+                log.debug("%s: received secret key from keyserver %s", local_addr, msg.getSrc());
+                setKeys(tmp, key_version);
+            }
+        }
+        catch(Exception e) {
+            log.warn("%s: unable to process received public key", local_addr, e);
+        }
+    }
+
+
+    /** Initialise the symmetric key if none is supplied in a keystore */
+    protected SecretKey createSecretKey() throws Exception {
+        KeyGenerator keyGen=null;
+        // see if we have a provider specified
+        if(provider != null && !provider.trim().isEmpty())
+            keyGen=KeyGenerator.getInstance(getAlgorithm(sym_algorithm), provider);
+        else
+            keyGen=KeyGenerator.getInstance(getAlgorithm(sym_algorithm));
+        // generate the key using the defined init properties
+        keyGen.init(sym_keylength);
+        return keyGen.generateKey();
+    }
+
+
+
+    /** Generates the public/private key pair from the init params */
+    protected void initKeyPair() throws Exception {
+        // generate keys according to the specified algorithms
+        // generate publicKey and Private Key
+        KeyPairGenerator KpairGen=null;
+        if(provider != null && !provider.trim().isEmpty())
+            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asym_algorithm), provider);
+        else
+            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asym_algorithm));
+        KpairGen.initialize(asym_keylength,new SecureRandom());
+        key_pair=KpairGen.generateKeyPair();
+
+        // set up the Cipher to decrypt secret key responses encrypted with our key
+        if(provider != null && !provider.trim().isEmpty())
+            asym_cipher=Cipher.getInstance(asym_algorithm, provider);
+        else
+            asym_cipher=Cipher.getInstance(asym_algorithm);
+        asym_cipher.init(Cipher.DECRYPT_MODE, key_pair.getPrivate());
+    }
+
+
+    @Override protected synchronized void handleView(View v) {
+        boolean left_mbrs=change_key_on_leave && this.view != null && !v.containsMembers(this.view.getMembersRaw());
+        super.handleView(v);
+        Address tmpKeyServer=v.getCoord(); // the coordinator is the keyserver
+        if(tmpKeyServer.equals(local_addr)) {
+            if(!is_key_server || left_mbrs)
+                becomeKeyServer(tmpKeyServer, left_mbrs);
+        }
+        else
+            handleNewKeyServer(tmpKeyServer, v instanceof MergeView, left_mbrs);
+    }
+
+
+    protected void becomeKeyServer(Address tmpKeyServer, boolean left_mbrs) {
+        if(log.isDebugEnabled()) {
+            if(!is_key_server)
+                log.debug("%s: I'm the new key server", local_addr);
+            else if(left_mbrs)
+                log.debug("%s: creating new secret key because members left", local_addr);
+        }
+        key_server_addr=tmpKeyServer;
+        is_key_server=true;
+        try {
+            this.secret_key=createSecretKey();
+            initSymCiphers(sym_algorithm, secret_key);
+            drainUpQueue();
+        }
+        catch(Exception ex) {
+            log.error("%s: failed creating secret key and initializing ciphers", local_addr, ex);
+        }
+    }
+
+    /** If the keyserver changed, send a request for the secret key to the keyserver */
+    protected void handleNewKeyServer(Address newKeyServer, boolean merge_view, boolean left_mbrs) {
+        if(keyServerChanged(newKeyServer) || merge_view || left_mbrs) {
+            secret_key=null;
+            sym_version=null;
+            queue_up_msgs=true;
+            key_server_addr=newKeyServer;
+            is_key_server=false;
+            log.debug("%s: sending request for secret key to the new keyserver %s", local_addr, key_server_addr);
+            sendKeyRequest(key_server_addr);
+        }
+    }
+
+	protected boolean keyServerChanged(Address newKeyServer) {
+		return !Objects.equals(key_server_addr, newKeyServer);
+	}
+
+
+
+    protected void setKeys(SecretKey key, byte[] version) throws Exception {
+        if(Arrays.equals(this.sym_version, version))
+            return;
+
+        // System.out.printf("%s: ******** setting sym_version (%s) to %s\n", local_addr,
+           //               Util.byteArrayToHexString(this.sym_version), Util.byteArrayToHexString(version));
+
+        Cipher decoding_cipher=secret_key != null? decoding_ciphers.take() : null;
+        // put the previous key into the map, keep the cipher: no leak, as we'll clear decoding_ciphers in initSymCiphers()
+        if(decoding_cipher != null)
+            key_map.put(new AsciiString(version), decoding_cipher);
+        secret_key=key;
+        initSymCiphers(key.getAlgorithm(), key);
+        sym_version=version;
+        drainUpQueue();
+    }
+
+
+    protected void sendSecretKey(SecretKey secret_key, PublicKey public_key, Address source) throws Exception {
+        byte[] encryptedKey=encryptSecretKey(secret_key, public_key);
+        Message newMsg=new Message(source, local_addr, encryptedKey)
+          .putHeader(this.id, new EncryptHeader(EncryptHeader.SECRET_KEY_RSP, symVersion()));
+        log.debug("%s: sending secret key to %s", local_addr, source);
+        down_prot.down(new Event(Event.MSG,newMsg));
+    }
+
+    /** Encrypts the current secret key with the requester's public key (the requester will decrypt it with its private key) */
+    protected byte[] encryptSecretKey(SecretKey secret_key, PublicKey public_key) throws Exception {
+        Cipher tmp;
+        if (provider != null && !provider.trim().isEmpty())
+            tmp=Cipher.getInstance(asym_algorithm, provider);
+        else
+            tmp=Cipher.getInstance(asym_algorithm);
+        tmp.init(Cipher.ENCRYPT_MODE, public_key);
+
+        // encrypt current secret key
+        return tmp.doFinal(secret_key.getEncoded());
+    }
+
+
+    /** send client's public key to server and request server's public key */
+    protected void sendKeyRequest(Address key_server) {
+        Message newMsg=new Message(key_server, local_addr, key_pair.getPublic().getEncoded())
+          .putHeader(this.id,new EncryptHeader(EncryptHeader.SECRET_KEY_REQ, sym_version));
+        down_prot.down(new Event(Event.MSG,newMsg));
+    }
+
+
+    protected SecretKeySpec decodeKey(byte[] encodedKey) throws Exception {
+        byte[] keyBytes;
+
+        synchronized(this) {
+            keyBytes=asym_cipher.doFinal(encodedKey);
+        }
+
+        try {
+            SecretKeySpec keySpec=new SecretKeySpec(keyBytes, getAlgorithm(sym_algorithm));
+            Cipher temp;
+            if (provider != null && !provider.trim().isEmpty())
+                temp=Cipher.getInstance(sym_algorithm, provider);
+            else
+                temp=Cipher.getInstance(sym_algorithm);
+            temp.init(Cipher.SECRET_KEY, keySpec);
+            return keySpec;
+        }
+        catch(Exception e) {
+            log.error(Util.getMessage("FailedDecodingKey"), e);
+            return null;
+        }
+    }
+
+    // doesn't have to be 100% correct: leftover messages wll be delivered later and will be discarded as dupes, as
+    // retransmission is likely to have kicked in before anyway
+    protected void drainUpQueue() {
+        queue_up_msgs=false;
+        Message queued_msg;
+        while((queued_msg=up_queue.poll()) != null) {
+            try {
+                Message decrypted_msg=decryptMessage(null, queued_msg.copy());
+                if(decrypted_msg != null)
+                    up_prot.up(new Event(Event.MSG, decrypted_msg));
+            }
+            catch(Exception ex) {
+                log.error("failed decrypting message from %s: %s", queued_msg.src(), ex);
+            }
+        }
+    }
+
+
+    @Override protected void handleUnknownVersion() {
+        if(!is_key_server)
+            sendKeyRequest(key_server_addr);
+    }
+
+    /** Used to reconstitute public key sent in byte form from peer */
+    protected PublicKey generatePubKey(byte[] encodedKey) {
+        PublicKey pubKey=null;
+        try {
+            KeyFactory KeyFac=KeyFactory.getInstance(getAlgorithm(asym_algorithm));
+            X509EncodedKeySpec x509KeySpec=new X509EncodedKeySpec(encodedKey);
+            pubKey=KeyFac.generatePublic(x509KeySpec);
+        }
+        catch(Exception e) {
+            e.printStackTrace();
+        }
+        return pubKey;
+    }
+
+}
diff --git a/src/org/jgroups/protocols/AUTH.java b/src/org/jgroups/protocols/AUTH.java
index b1e2528e93..01bd848a50 100644
--- a/src/org/jgroups/protocols/AUTH.java
+++ b/src/org/jgroups/protocols/AUTH.java
@@ -19,7 +19,9 @@
 
 
 /**
- * The AUTH protocol adds a layer of authentication to JGroups
+ * The AUTH protocol adds a layer of authentication to JGroups. It intercepts join and merge requests and rejects them
+ * if the joiner or merger is not permitted to join a or merge into a cluster. AUTH should be placed right below
+ * {@link GMS} in the configuration.
  * @author Chris Mills
  * @author Bela Ban
  */
@@ -41,16 +43,16 @@
         /**
          * Called when an up event has been received
          * @param evt the event
-         * @return true if the event should be pass up, else false
+         * @return true if the event should be passed up, else false
          */
         boolean handleUpEvent(Event evt);
     }
 
 
     /** Used on the coordinator to authentication joining member requests against */
-    protected AuthToken             auth_token=null;
+    protected AuthToken             auth_token;
 
-    protected static final short    gms_id=ClassConfigurator.getProtocolId(GMS.class);
+    protected static final short    GMS_ID=ClassConfigurator.getProtocolId(GMS.class);
 
     /** List of UpHandler which are called when an up event has been received. Usually used by AuthToken impls */
     protected final List<UpHandler> up_handlers=new ArrayList<>();
@@ -60,14 +62,14 @@
 
     public AUTH() {name="AUTH";}
 
-    private volatile boolean authenticateCoord = false;
+    protected volatile boolean      authenticate_coord=true;
     
-   @Property(name="authenticate_coord")
-   public void setAuthCoord( boolean authenticateCoord) {
-	   this.authenticateCoord = authenticateCoord;
-   }
+    @Property(description="Do join or merge responses from the coordinator also need to be authenticated")
+    public AUTH setAuthCoord( boolean authenticateCoord) {
+        this.authenticate_coord= authenticateCoord; return this;
+    }
 
-    @Property(name="auth_class")
+    @Property(name="auth_class",description="The fully qualified name of the class implementing the AuthToken interface")
     public void setAuthClass(String class_name) throws Exception {
         Object obj=Class.forName(class_name).newInstance();
         auth_token=(AuthToken)obj;
@@ -76,9 +78,9 @@ public void setAuthClass(String class_name) throws Exception {
 
     public String    getAuthClass()                {return auth_token != null? auth_token.getClass().getName() : null;}
     public AuthToken getAuthToken()                {return auth_token;}
-    public void      setAuthToken(AuthToken token) {this.auth_token=token;}
-    public void      register(UpHandler handler)   {up_handlers.add(handler);}
-    public void      unregister(UpHandler handler) {up_handlers.remove(handler);}
+    public AUTH      setAuthToken(AuthToken token) {this.auth_token=token; return this;}
+    public AUTH      register(UpHandler handler)   {up_handlers.add(handler); return this;}
+    public AUTH      unregister(UpHandler handler) {up_handlers.remove(handler);return this;}
     public Address   getAddress()                  {return local_addr;}
     public PhysicalAddress getPhysicalAddress()    {return getTransport().getPhysicalAddress();}
 
@@ -92,6 +94,8 @@ public void setAuthClass(String class_name) throws Exception {
 
     public void init() throws Exception {
         super.init();
+        if(auth_token == null)
+            throw new IllegalStateException("no authentication mechanism configured");
         if(auth_token instanceof X509Token) {
             X509Token tmp=(X509Token)auth_token;
             tmp.setCertificate();
@@ -118,13 +122,11 @@ public void destroy() {
     }
 
     /**
-     * An event was received from the layer below. Usually the current layer will want to examine
-     * the event type and - depending on its type - perform some computation
-     * (e.g. removing headers from a MSG event type, or updating the internal membership list
-     * when receiving a VIEW_CHANGE event).
-     * Finally the event is either a) discarded, or b) an event is sent down
-     * the stack using <code>down_prot.down()</code> or c) the event (or another event) is sent up
-     * the stack using <code>up_prot.up()</code>.
+     * An event was received from the layer below. Usually the current layer will want to examine the event type and
+     * - depending on its type - perform some computation (e.g. removing headers from a MSG event type, or updating
+     * the internal membership list when receiving a VIEW_CHANGE event).
+     * Finally the event is either a) discarded, or b) an event is sent down the stack using {@code down_prot.down()}
+     * or c) the event (or another event) is sent up the stack using {@code up_prot.up()}.
      */
     public Object up(Event evt) {
         switch(evt.getType()) {
@@ -136,7 +138,7 @@ public Object up(Event evt) {
                 if(gms_hdr != null && needsAuthentication(gms_hdr)) {
                     AuthHeader auth_hdr=(AuthHeader)msg.getHeader(id);
                     if(auth_hdr == null)
-                        throw new IllegalStateException("found GMS join or merge request but no AUTH header");
+                        throw new IllegalStateException(String.format("found %s from %s but no AUTH header", gms_hdr, msg.src()));
                     if(!handleAuthHeader(gms_hdr, auth_hdr, msg)) // authentication failed
                         return null;    // don't pass up
                 }
@@ -155,7 +157,7 @@ public void up(MessageBatch batch) {
             if(gms_hdr != null && needsAuthentication(gms_hdr)) {
                 AuthHeader auth_hdr=(AuthHeader)msg.getHeader(id);
                 if(auth_hdr == null) {
-                    log.warn("found GMS join or merge request but no AUTH header");
+                    log.warn("%s: found GMS join or merge request from %s but no AUTH header", local_addr, batch.sender());
                     sendRejectionMessage(gms_hdr.getType(), batch.sender(), "join or merge without an AUTH header");
                     batch.remove(msg);
                 }
@@ -172,17 +174,16 @@ else if(!handleAuthHeader(gms_hdr, auth_hdr, msg)) // authentication failed
      * An event is to be sent down the stack. The layer may want to examine its type and perform
      * some action on it, depending on the event's type. If the event is a message MSG, then
      * the layer may need to add a header to it (or do nothing at all) before sending it down
-     * the stack using <code>down_prot.down()</code>. In case of a GET_ADDRESS event (which tries to
+     * the stack using {@code down_prot.down()}. In case of a GET_ADDRESS event (which tries to
      * retrieve the stack's address from one of the bottom layers), the layer may need to send
-     * a new response event back up the stack using <code>up_prot.up()</code>.
+     * a new response event back up the stack using {@code up_prot.up()}.
      */
     public Object down(Event evt) {
         GMS.GmsHeader hdr = getGMSHeader(evt);
         if(hdr != null && needsAuthentication(hdr)) {
             // we found a join request message - now add an AUTH Header
-            Message msg = (Message)evt.getArg();
-            AuthHeader authHeader = new AuthHeader(this.auth_token);
-            msg.putHeader(this.id, authHeader);
+            Message msg=(Message)evt.getArg();
+            msg.putHeader(this.id, new AuthHeader(this.auth_token));
         }
 
         if(evt.getType() == Event.SET_LOCAL_ADDRESS)
@@ -194,17 +195,18 @@ public Object down(Event evt) {
 
 
     protected boolean needsAuthentication(GMS.GmsHeader hdr) {
-    	switch(hdr.getType()) {
-        case GMS.GmsHeader.JOIN_REQ:
-        case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
-        case GMS.GmsHeader.MERGE_REQ:
-            return true;
-        case GMS.GmsHeader.JOIN_RSP:
-        case GMS.GmsHeader.MERGE_RSP:
-        	return this.authenticateCoord;
-        default:
-            return false;
-            }
+        switch(hdr.getType()) {
+            case GMS.GmsHeader.JOIN_REQ:
+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:
+            case GMS.GmsHeader.MERGE_REQ:
+                return true;
+            case GMS.GmsHeader.JOIN_RSP:
+            case GMS.GmsHeader.MERGE_RSP:
+            case GMS.GmsHeader.INSTALL_MERGE_VIEW:
+                return this.authenticate_coord;
+            default:
+                return false;
+        }
     }
 
 
@@ -215,17 +217,17 @@ protected boolean needsAuthentication(GMS.GmsHeader hdr) {
      * @return true if the message should be passed up, or else false
      */
     protected boolean handleAuthHeader(GMS.GmsHeader gms_hdr, AuthHeader auth_hdr, Message msg) {
-    	if ( needsAuthentication(gms_hdr)) {
-            if(this.auth_token.authenticate(auth_hdr.getToken(), msg)) {
+        if(needsAuthentication(gms_hdr)) {
+            if(this.auth_token.authenticate(auth_hdr.getToken(), msg))
                 return true; //  authentication passed, send message up the stack
-            } else {
-                log.warn("failed to validate AuthHeader token from " + msg.getSrc() + ", token: " + auth_token);
+            else {
+                log.warn("%s: failed to validate AuthHeader (token: %s) from %s; dropping message",
+                         local_addr, auth_token.getClass().getSimpleName(), msg.src());
                 sendRejectionMessage(gms_hdr.getType(), msg.getSrc(), "authentication failed");
                 return false;
             }
-    	} else {
-    		return true;
-    	}
+        }
+        return true;
     }
 
 
@@ -238,9 +240,6 @@ protected void sendRejectionMessage(byte type, Address dest, String error_msg) {
             case GMS.GmsHeader.MERGE_REQ:
                 sendMergeRejectionMessage(dest);
                 break;
-            default:
-                log.error("type " + type + " unknown");
-                break;
         }
     }
 
@@ -249,24 +248,27 @@ protected void sendJoinRejectionMessage(Address dest, String error_msg) {
             return;
 
         JoinRsp joinRes=new JoinRsp(error_msg); // specify the error message on the JoinRsp
-        Message msg = new Message(dest).putHeader(gms_id, new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP))
+        Message msg = new Message(dest).putHeader(GMS_ID, new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP))
           .setBuffer(GMS.marshal(joinRes));
+        if(this.authenticate_coord)
+            msg.putHeader(this.id, new AuthHeader(this.auth_token));
         down_prot.down(new Event(Event.MSG, msg));
     }
 
     protected void sendMergeRejectionMessage(Address dest) {
-        Message msg=new Message(dest).setFlag(Message.Flag.OOB);
         GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.MERGE_RSP);
         hdr.setMergeRejected(true);
-        msg.putHeader(gms_id, hdr);
-        if(log.isDebugEnabled()) log.debug("merge response=" + hdr);
+        Message msg=new Message(dest).setFlag(Message.Flag.OOB).putHeader(GMS_ID, hdr);
+        if(this.authenticate_coord)
+            msg.putHeader(this.id, new AuthHeader(this.auth_token));
+        log.debug("merge response=%s", hdr);
         down_prot.down(new Event(Event.MSG, msg));
     }
 
     protected boolean callUpHandlers(Event evt) {
         boolean pass_up=true;
         for(UpHandler handler: up_handlers) {
-            if(handler.handleUpEvent(evt) == false)
+            if(!handler.handleUpEvent(evt))
                 pass_up=false;
         }
         return pass_up;
@@ -282,7 +284,7 @@ protected boolean callUpHandlers(Event evt) {
     }
 
     protected static GMS.GmsHeader getGMSHeader(Message msg){
-        Header hdr = msg.getHeader(gms_id);
+        Header hdr = msg.getHeader(GMS_ID);
         if(hdr instanceof GMS.GmsHeader)
             return (GMS.GmsHeader)hdr;
         return null;
diff --git a/src/org/jgroups/protocols/EncryptBase.java b/src/org/jgroups/protocols/EncryptBase.java
new file mode 100644
index 0000000000..fffad51993
--- /dev/null
+++ b/src/org/jgroups/protocols/EncryptBase.java
@@ -0,0 +1,437 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.annotations.ManagedAttribute;
+import org.jgroups.annotations.Property;
+import org.jgroups.stack.Protocol;
+import org.jgroups.util.*;
+
+import javax.crypto.Cipher;
+import javax.crypto.SecretKey;
+import java.security.MessageDigest;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.zip.Adler32;
+import java.util.zip.CRC32;
+import java.util.zip.Checksum;
+
+/**
+ * Super class of symmetric ({@link SYM_ENCRYPT}) and asymmetric ({@link ASYM_ENCRYPT}) encryption protocols.
+ * @author Bela Ban
+ */
+public abstract class EncryptBase extends Protocol {
+    protected static final String DEFAULT_SYM_ALGO="AES";
+
+
+    /* -----------------------------------------    Properties     -------------------------------------------------- */
+    @Property(description="Cryptographic Service Provider")
+    protected String                        provider;
+
+    @Property(description="Cipher engine transformation for asymmetric algorithm. Default is RSA")
+    protected String                        asym_algorithm="RSA";
+
+    @Property(description="Cipher engine transformation for symmetric algorithm. Default is AES")
+    protected String                        sym_algorithm=DEFAULT_SYM_ALGO;
+
+    @Property(description="Initial public/private key length. Default is 512")
+    protected int                           asym_keylength=512;
+
+    @Property(description="Initial key length for matching symmetric algorithm. Default is 128")
+    protected int                           sym_keylength=128;
+
+    @Property(description="Number of ciphers in the pool to parallelize encrypt and decrypt requests",writable=false)
+    protected int                           cipher_pool_size=8;
+
+    @Property(description="If true, the entire message (including payload and headers) is encrypted, else only the payload")
+    protected boolean                       encrypt_entire_message=true;
+
+    @Property(description="If true, all messages are digitally signed by adding an encrypted checksum of the encrypted " +
+      "message to the header. Ignored if encrypt_entire_message is false")
+    protected boolean                       sign_msgs=true;
+
+    @Property(description="When sign_msgs is true, by default CRC32 is used to create the checksum. If use_adler is " +
+      "true, Adler32 will be used")
+    protected boolean                       use_adler;
+
+    protected volatile Address              local_addr;
+
+    protected volatile View                 view;
+
+    // Cipher pools used for encryption and decryption. Size is cipher_pool_size
+    protected BlockingQueue<Cipher>         encoding_ciphers, decoding_ciphers;
+
+    // version filed for secret key
+    protected volatile byte[]               sym_version;
+
+    // shared secret key to encrypt/decrypt messages
+    protected volatile SecretKey            secret_key;
+
+    // map to hold previous keys so we can decrypt some earlier messages if we need to
+    protected final Map<AsciiString,Cipher> key_map=new WeakHashMap<>();
+
+
+
+    public int                      asymKeylength()                 {return asym_keylength;}
+    public <T extends EncryptBase> T    asymKeylength(int len)          {this.asym_keylength=len; return (T)this;}
+    public int                      symKeylength()                  {return sym_keylength;}
+    public <T extends EncryptBase> T    symKeylength(int len)           {this.sym_keylength=len; return (T)this;}
+    public SecretKey                secretKey()                     {return secret_key;}
+    public <T extends EncryptBase> T    secretKey(SecretKey key)        {this.secret_key=key; return (T)this;}
+    public String                   symAlgorithm()                  {return sym_algorithm;}
+    public <T extends EncryptBase> T    symAlgorithm(String alg)        {this.sym_algorithm=alg; return (T)this;}
+    public String                   asymAlgorithm()                 {return asym_algorithm;}
+    public <T extends EncryptBase> T    asymAlgorithm(String alg)       {this.asym_algorithm=alg; return (T)this;}
+    public byte[]                   symVersion()                    {return sym_version;}
+    public <T extends EncryptBase> T    symVersion(byte[] v)            {this.sym_version=Arrays.copyOf(v, v.length); return (T)this;}
+    public <T extends EncryptBase> T    localAddress(Address addr)      {this.local_addr=addr; return (T)this;}
+    public boolean                  encryptEntireMessage()          {return encrypt_entire_message;}
+    public <T extends EncryptBase> T    encryptEntireMessage(boolean b) {this.encrypt_entire_message=b; return (T)this;}
+    public boolean                  signMessages()                  {return this.sign_msgs;}
+    public <T extends EncryptBase> T    signMessages(boolean flag)      {this.sign_msgs=flag; return (T)this;}
+    public boolean                  adler()                         {return use_adler;}
+    public <T extends EncryptBase> T    adler(boolean flag)             {this.use_adler=flag; return (T)this;}
+    @ManagedAttribute public String version()                       {return Util.byteArrayToHexString(sym_version);}
+
+    public void init() throws Exception {
+        int tmp=Util.getNextHigherPowerOfTwo(cipher_pool_size);
+        if(tmp != cipher_pool_size) {
+            log.warn("%s: setting cipher_pool_size (%d) to %d (power of 2) for faster modulo operation", local_addr, cipher_pool_size, tmp);
+            cipher_pool_size=tmp;
+        }
+        encoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);
+        decoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);
+        initSymCiphers(sym_algorithm, secret_key);
+    }
+
+
+    public Object down(Event evt) {
+        switch(evt.getType()) {
+            case Event.MSG:
+                Message msg=evt.arg();
+                try {
+                    if(secret_key == null) {
+                        log.trace("%s: discarded %s message to %s as secret key is null, hdrs: %s",
+                                  local_addr, msg.dest() == null? "mcast" : "unicast", msg.dest(), msg.printHeaders());
+                        return null;
+                    }
+                    encryptAndSend(msg);
+                }
+                catch(Exception e) {
+                    log.warn("%s: unable to send message down", local_addr, e);
+                }
+                return null;
+
+            case Event.VIEW_CHANGE:
+                handleView((View)evt.getArg());
+                break;
+
+            case Event.SET_LOCAL_ADDRESS:
+                local_addr=evt.arg();
+                break;
+        }
+        return down_prot.down(evt);
+    }
+
+
+    public Object up(Event evt) {
+        switch(evt.getType()) {
+            case Event.VIEW_CHANGE:
+                handleView((View)evt.getArg());
+                break;
+            case Event.MSG:
+                Message msg=evt.arg();
+                try {
+                    return handleUpMessage(msg);
+                }
+                catch(Exception e) {
+                    log.warn("%s: exception occurred decrypting message", local_addr, e);
+                }
+                return null;
+        }
+        return up_prot.up(evt);
+    }
+
+
+    public void up(MessageBatch batch) {
+        Cipher cipher=null;
+        try {
+            if(secret_key == null) {
+                log.trace("%s: discarded %s batch from %s as secret key is null",
+                          local_addr, batch.dest() == null? "mcast" : "unicast", batch.sender());
+                return;
+            }
+            MessageBatch.Visitor<Message> decrypter=new Decrypter(cipher=decoding_ciphers.take());
+            batch.map(decrypter);
+        }
+        catch(InterruptedException e) {
+            log.error("%s: failed processing batch; discarding batch", local_addr, e);
+            // we need to drop the batch if we for example have a failure fetching a cipher, or else other messages
+            // in the batch might make it up the stack, bypassing decryption! This is not an issue because encryption
+            // is below NAKACK2 or UNICAST3, so messages will get retransmitted
+            return;
+        }
+        finally {
+            if(cipher != null)
+                decoding_ciphers.offer(cipher);
+        }
+        if(!batch.isEmpty())
+            up_prot.up(batch);
+    }
+
+
+
+    /** Initialises the ciphers for both encryption and decryption using the generated or supplied secret key */
+    protected synchronized void initSymCiphers(String algorithm, SecretKey secret) throws Exception {
+        if(secret == null)
+            return;
+        encoding_ciphers.clear();
+        decoding_ciphers.clear();
+        for(int i=0; i < cipher_pool_size; i++ ) {
+            encoding_ciphers.add(createCipher(Cipher.ENCRYPT_MODE, secret, algorithm));
+            decoding_ciphers.add(createCipher(Cipher.DECRYPT_MODE, secret, algorithm));
+        };
+
+        //set the version
+        MessageDigest digest=MessageDigest.getInstance("MD5");
+        digest.reset();
+        digest.update(secret.getEncoded());
+
+        byte[] tmp=digest.digest();
+        sym_version=Arrays.copyOf(tmp, tmp.length);
+        log.debug("%s: created %d symmetric ciphers with secret key (%d bytes)", local_addr, cipher_pool_size, sym_version.length);
+    }
+
+
+    protected Cipher createCipher(int mode, SecretKey secret_key, String algorithm) throws Exception {
+        Cipher cipher=provider != null && !provider.trim().isEmpty()?
+          Cipher.getInstance(algorithm, provider) : Cipher.getInstance(algorithm);
+        cipher.init(mode, secret_key);
+        return cipher;
+    }
+
+
+    protected Object handleUpMessage(Message msg) throws Exception {
+        EncryptHeader hdr=(EncryptHeader)msg.getHeader(this.id);
+        if(hdr == null) {
+            log.error("%s: received message without encrypt header from %s; dropping it", local_addr, msg.src());
+            return null;
+        }
+        switch(hdr.type()) {
+            case EncryptHeader.ENCRYPT:
+                return handleEncryptedMessage(msg);
+            default:
+                return handleUpEvent(msg,hdr);
+        }
+    }
+
+
+    protected Object handleEncryptedMessage(Message msg) throws Exception {
+        if(!process(msg))
+            return null;
+
+        // try and decrypt the message - we need to copy msg as we modify its
+        // buffer (http://jira.jboss.com/jira/browse/JGRP-538)
+        Message tmpMsg=decryptMessage(null, msg.copy()); // need to copy for possible xmits
+        if(tmpMsg != null)
+            return up_prot.up(new Event(Event.MSG, tmpMsg));
+        log.warn("%s: unrecognized cipher; discarding message from %s", local_addr, msg.src());
+        return null;
+    }
+
+    protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+        return null;
+    }
+
+    /** Whether or not to process this received message */
+    protected boolean process(Message msg) {return true;}
+
+    protected void handleView(View view) {
+        this.view=view;
+    }
+
+    protected boolean inView(Address sender, String error_msg) {
+        View curr_view=this.view;
+        if(curr_view == null || curr_view.containsMember(sender))
+            return true;
+        log.error(error_msg, sender, curr_view);
+        return false;
+    }
+
+    protected Checksum createChecksummer() {return use_adler? new Adler32() : new CRC32();}
+
+
+    /** Does the actual work for decrypting - if version does not match current cipher then tries the previous cipher */
+    protected Message decryptMessage(Cipher cipher, Message msg) throws Exception {
+        EncryptHeader hdr=(EncryptHeader)msg.getHeader(this.id);
+        if(!Arrays.equals(hdr.version(), sym_version)) {
+            cipher=key_map.get(new AsciiString(hdr.version()));
+            if(cipher == null) {
+                handleUnknownVersion();
+                return null;
+            }
+            log.trace("%s: decrypting msg from %s using previous cipher version", local_addr, msg.src());
+            return _decrypt(cipher, msg, hdr);
+        }
+        return _decrypt(cipher, msg, hdr);
+    }
+
+    protected Message _decrypt(final Cipher cipher, Message msg, EncryptHeader hdr) throws Exception {
+        byte[] decrypted_msg;
+
+        if(!encrypt_entire_message && msg.getLength() == 0)
+            return msg;
+
+        if(encrypt_entire_message && sign_msgs) {
+            byte[] signature=hdr.signature();
+            if(signature == null) {
+                log.error("%s: dropped message from %s as the header did not have a checksum", local_addr, msg.src());
+                return null;
+            }
+
+            long msg_checksum=decryptChecksum(cipher, signature, 0, signature.length);
+            long actual_checksum=computeChecksum(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+            if(actual_checksum != msg_checksum) {
+                log.error("%s: dropped message from %s as the message's checksum (%d) did not match the computed checksum (%d)",
+                          local_addr, msg.src(), msg_checksum, actual_checksum);
+                return null;
+            }
+        }
+
+        if(cipher == null)
+            decrypted_msg=code(msg.getRawBuffer(), msg.getOffset(), msg.getLength(), true);
+        else
+            decrypted_msg=cipher.doFinal(msg.getRawBuffer(), msg.getOffset(), msg.getLength());
+
+        if(!encrypt_entire_message) {
+            msg.setBuffer(decrypted_msg);
+            return msg;
+        }
+
+        Message ret=Util.streamableFromBuffer(Message.class,decrypted_msg,0,decrypted_msg.length);
+        if(ret.getDest() == null)
+            ret.setDest(msg.getDest());
+        if(ret.getSrc() == null)
+            ret.setSrc(msg.getSrc());
+        return ret;
+    }
+
+
+    protected void encryptAndSend(Message msg) throws Exception {
+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, symVersion());
+        if(encrypt_entire_message) {
+            if(msg.getSrc() == null)
+                msg.setSrc(local_addr);
+
+            Buffer serialized_msg=Util.streamableToBuffer(msg);
+            byte[] encrypted_msg=code(serialized_msg.getBuf(),serialized_msg.getOffset(),serialized_msg.getLength(),false);
+
+            if(sign_msgs) {
+                long checksum=computeChecksum(encrypted_msg, 0, encrypted_msg.length);
+                byte[] checksum_array=encryptChecksum(checksum);
+                hdr.signature(checksum_array);
+            }
+
+            // exclude existing headers, they will be seen again when we decrypt and unmarshal the msg at the receiver
+            Message tmp=msg.copy(false, false).setBuffer(encrypted_msg).putHeader(this.id,hdr);
+            down_prot.down(new Event(Event.MSG, tmp));
+            return;
+        }
+
+        // copy neeeded because same message (object) may be retransmitted -> prevent double encryption
+        Message msgEncrypted=msg.copy(false).putHeader(this.id, hdr);
+        if(msg.getLength() > 0)
+            msgEncrypted.setBuffer(code(msg.getRawBuffer(),msg.getOffset(),msg.getLength(),false));
+        down_prot.down(new Event(Event.MSG,msgEncrypted));
+    }
+
+
+    protected byte[] code(byte[] buf, int offset, int length, boolean decode) throws Exception {
+        BlockingQueue<Cipher> queue=decode? decoding_ciphers : encoding_ciphers;
+        Cipher cipher=queue.take();
+        try {
+            return cipher.doFinal(buf, offset, length);
+        }
+        finally {
+            queue.offer(cipher);
+        }
+    }
+
+    protected long computeChecksum(byte[] input, int offset, int length) {
+        Checksum checksummer=createChecksummer();
+        checksummer.update(input, offset, length);
+        return checksummer.getValue();
+    }
+
+    protected byte[] encryptChecksum(long checksum) throws Exception {
+        byte[] checksum_array=new byte[Global.LONG_SIZE];
+        Bits.writeLong(checksum, checksum_array, 0);
+        return code(checksum_array, 0, checksum_array.length, false);
+    }
+
+    protected long decryptChecksum(final Cipher cipher, byte[] input, int offset, int length) throws Exception {
+        byte[] decrypted_checksum;
+        if(cipher == null)
+            decrypted_checksum=code(input, offset, length, true);
+        else
+            decrypted_checksum=cipher.doFinal(input, offset, length);
+        return Bits.readLong(decrypted_checksum, 0);
+    }
+
+
+    /* Get the algorithm name from "algorithm/mode/padding"  taken from original ENCRYPT */
+    protected static String getAlgorithm(String s) {
+        int index=s.indexOf('/');
+        return index == -1? s : s.substring(0, index);
+    }
+
+
+    /** Called when the version shipped in the header can't be found */
+    protected void handleUnknownVersion() {}
+
+
+    /** Decrypts all messages in a batch, replacing encrypted messages in-place with their decrypted versions */
+    protected class Decrypter implements MessageBatch.Visitor<Message> {
+        protected final Cipher cipher;
+
+        public Decrypter(Cipher cipher) {
+            this.cipher=cipher;
+        }
+
+        public Message visit(Message msg, MessageBatch batch) {
+            EncryptHeader hdr;
+            if((hdr=(EncryptHeader)msg.getHeader(id)) == null) {
+                log.error("%s: received message without encrypt header from %s; dropping it", local_addr, batch.sender());
+                batch.remove(msg); // remove from batch to prevent passing the message further up as part of the batch
+                return null;
+            }
+
+            if(hdr.type() == EncryptHeader.ENCRYPT) {
+                try {
+                    if(!process(msg)) {
+                        batch.remove(msg);
+                        return null;
+                    }
+                    Message tmpMsg=decryptMessage(cipher, msg.copy()); // need to copy for possible xmits
+                    if(tmpMsg != null)
+                        batch.replace(msg, tmpMsg);
+                    else
+                        batch.remove(msg);
+                }
+                catch(Exception e) {
+                    log.error("%s: failed decrypting message from %s (offset=%d, length=%d, buf.length=%d): %s, headers are %s",
+                              local_addr, msg.getSrc(), msg.getOffset(), msg.getLength(), msg.getRawBuffer().length, e, msg.printHeaders());
+                    batch.remove(msg);
+                }
+            }
+            else {
+                batch.remove(msg); // a control message will get handled by ENCRYPT and should not be passed up
+                handleUpEvent(msg, hdr);
+            }
+            return null;
+        }
+    }
+
+}
diff --git a/src/org/jgroups/protocols/EncryptHeader.java b/src/org/jgroups/protocols/EncryptHeader.java
new file mode 100644
index 0000000000..3142bbe881
--- /dev/null
+++ b/src/org/jgroups/protocols/EncryptHeader.java
@@ -0,0 +1,65 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Global;
+import org.jgroups.Header;
+import org.jgroups.util.Util;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+
+/**
+ * @author Bela Ban
+ * @since  3.6.10
+ */
+public class EncryptHeader extends Header {
+    public static final byte ENCRYPT        = 1 << 0;
+    public static final byte SECRET_KEY_REQ = 1 << 1;
+    public static final byte SECRET_KEY_RSP = 1 << 2;
+
+    protected byte   type;
+    protected byte[] version;
+    protected byte[] signature; // the encrypted checksum
+
+
+    public EncryptHeader() {}
+
+
+    public EncryptHeader(byte type, byte[] version) {
+        this.type=type;
+        this.version=version;
+    }
+
+    public byte          type()              {return type;}
+    public byte          getType()           {return type;}
+    public byte[]        version()           {return version;}
+    public byte[]        getVersion()        {return version;}
+    public byte[]        signature()         {return signature;}
+    public EncryptHeader signature(byte[] s) {this.signature=s; return this;}
+
+    public void writeTo(DataOutput out) throws Exception {
+        out.writeByte(type);
+        Util.writeByteBuffer(version, 0, version != null? version.length : 0, out);
+        Util.writeByteBuffer(signature, 0, signature != null? signature.length : 0, out);
+    }
+
+    public void readFrom(DataInput in) throws Exception {
+        type=in.readByte();
+        version=Util.readByteBuffer(in);
+        signature=Util.readByteBuffer(in);
+    }
+
+    public String toString() {
+        return String.format("[%s version=%s]", typeToString(type), (version != null? version.length + " bytes" : "n/a"));
+    }
+
+    public int size() {return Global.BYTE_SIZE + Util.size(version) + Util.size(signature) /*+ Util.size(payload) */;}
+
+    protected static String typeToString(byte type) {
+        switch(type) {
+            case ENCRYPT:        return "ENCRYPT";
+            case SECRET_KEY_REQ: return "SECRET_KEY_REQ";
+            case SECRET_KEY_RSP: return "SECRET_KEY_RSP";
+            default:             return "<unrecognized type " + type;
+        }
+    }
+}
diff --git a/src/org/jgroups/protocols/SYM_ENCRYPT.java b/src/org/jgroups/protocols/SYM_ENCRYPT.java
new file mode 100644
index 0000000000..9ce628951c
--- /dev/null
+++ b/src/org/jgroups/protocols/SYM_ENCRYPT.java
@@ -0,0 +1,124 @@
+package org.jgroups.protocols;
+
+import org.jgroups.annotations.MBean;
+import org.jgroups.annotations.Property;
+import org.jgroups.util.Util;
+
+import javax.crypto.SecretKey;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.KeyStore;
+import java.security.NoSuchAlgorithmException;
+import java.security.cert.CertificateException;
+
+/**
+ * Encrypts and decrypts communication in JGroups by using a secret key shared by all cluster members.<p>
+ *
+ * The secret key is identical for all cluster members and is injected into this protocol at startup, e.g. by reading
+ * it from a keystore. Messages are sent by encrypting them with the secret key and received by decrypting them with
+ * the secret key. Note that all cluster members must be shipped with the same keystore file<p>
+ *
+ * This protocol is typically placed under {@link org.jgroups.protocols.pbcast.NAKACK2}, so that most important
+ * headers are encrypted as well, to prevent replay attacks.<p>
+ *
+ * A possible configuration looks like this:<br><br>
+ * {@code <SYM_ENCRYPT key_store_name="defaultStore.keystore" store_password="changeit" alias="myKey"/>}
+ * <br>
+ * <br>
+ * In order to use SYM_ENCRYPT layer in this manner, it is necessary to have the secret key already generated in a
+ * keystore file. The directory containing the keystore file must be on the application's classpath. You cannot create a
+ * secret key keystore file using the keytool application shipped with the JDK. A java file called KeyStoreGenerator is
+ * included in the demo package that can be used from the command line (or IDE) to generate a suitable keystore.
+ *
+ * @author Bela Ban
+ * @author Steve Woodcock
+ */
+@MBean(description="Symmetric encryption protocol. The (shared) shared secret key is configured up front, " +
+  "e.g. via a key store, or injection")
+public class SYM_ENCRYPT extends EncryptBase {
+
+    /* -----------------------------------------    Properties     -------------------------------------------------- */
+    @Property(description="File on classpath that contains keystore repository")
+    protected String   keystore_name;
+
+    @Property(description="Password used to check the integrity/unlock the keystore. Change the default",
+      exposeAsManagedAttribute=false)
+    protected String   store_password="changeit"; // JDK default
+
+    @Property(description="Password for recovering the key. Change the default", exposeAsManagedAttribute=false)
+    protected String   key_password; // allows to assign keypwd=storepwd if not set (https://issues.jboss.org/browse/JGRP-1375)
+
+
+    @Property(name="alias", description="Alias used for recovering the key. Change the default",exposeAsManagedAttribute=false)
+    protected String   alias="mykey"; // JDK default
+
+
+    public String      keystoreName()                      {return this.keystore_name;}
+    public SYM_ENCRYPT keystoreName(String n)              {this.keystore_name=n; return this;}
+    public String      alias()                             {return alias;}
+    public SYM_ENCRYPT alias(String a)                     {this.alias=a; return this;}
+    public String      storePassword()                     {return store_password;}
+    public SYM_ENCRYPT storePassword(String pwd)           {this.store_password=pwd; return this;}
+
+
+
+
+    public void init() throws Exception {
+        if(key_password == null && store_password != null) {
+            key_password=store_password;
+            log.debug("%s: key_password used is same as store_password", local_addr);
+        }
+        readSecretKeyFromKeystore();
+        super.init();
+    }
+
+    /**
+     * Initialisation if a supplied key is defined in the properties. This supplied key must be in a keystore which
+     * can be generated using the keystoreGenerator file in demos. The keystore must be on the classpath to find it.
+     */
+    protected void readSecretKeyFromKeystore() throws Exception {
+        InputStream inputStream=null;
+        // must not use default keystore type - as it does not support secret keys
+        KeyStore store=KeyStore.getInstance("JCEKS");
+
+        SecretKey tempKey=null;
+        try {
+            if(this.secret_key == null) { // in case the secret key was set before, e.g. via injection in a unit test
+                // load in keystore using this thread's classloader
+                inputStream=Thread.currentThread().getContextClassLoader().getResourceAsStream(keystore_name);
+                if(inputStream == null)
+                    inputStream=new FileInputStream(keystore_name);
+                // we can't find a keystore here -
+                if(inputStream == null)
+                    throw new Exception("Unable to load keystore " + keystore_name + " ensure file is on classpath");
+                // we have located a file lets load the keystore
+                try {
+                    store.load(inputStream, store_password.toCharArray());
+                    // loaded keystore - get the key
+                    tempKey=(SecretKey)store.getKey(alias, key_password.toCharArray());
+                }
+                catch(IOException e) {
+                    throw new Exception("Unable to load keystore " + keystore_name + ": " + e);
+                }
+                catch(NoSuchAlgorithmException e) {
+                    throw new Exception("No Such algorithm " + keystore_name + ": " + e);
+                }
+                catch(CertificateException e) {
+                    throw new Exception("Certificate exception " + keystore_name + ": " + e);
+                }
+
+                if(tempKey == null)
+                    throw new Exception("Unable to retrieve key '" + alias + "' from keystore " + keystore_name);
+                this.secret_key=tempKey;
+                if(sym_algorithm.equals(DEFAULT_SYM_ALGO))
+                    sym_algorithm=tempKey.getAlgorithm();
+            }
+        }
+        finally {
+            Util.close(inputStream);
+        }
+    }
+
+
+}
diff --git a/src/org/jgroups/util/MyReceiver.java b/src/org/jgroups/util/MyReceiver.java
index 9b7be342da..db0813f353 100644
--- a/src/org/jgroups/util/MyReceiver.java
+++ b/src/org/jgroups/util/MyReceiver.java
@@ -3,8 +3,8 @@
 import org.jgroups.Message;
 import org.jgroups.ReceiverAdapter;
 
-import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
  * Generic receiver for a JChannel
@@ -12,18 +12,20 @@
  * @since  3.3
  */
 public class MyReceiver<T> extends ReceiverAdapter {
-    protected final List<T> list=new ArrayList<>();
+    protected final List<T> list=new CopyOnWriteArrayList<>();
     protected String        name;
     protected boolean       verbose;
+    protected boolean       raw_msgs;
 
     public void receive(Message msg) {
-        T obj=(T)msg.getObject();
+        T obj=raw_msgs? (T)msg : (T)msg.getObject();
         list.add(obj);
         if(verbose) {
             System.out.println((name() != null? name() + ":" : "") + " received message from " + msg.getSrc() + ": " + obj);
         }
     }
 
+    public MyReceiver    rawMsgs(boolean flag) {this.raw_msgs=flag; return this;}
     public List<T>       list()                {return list;}
     public MyReceiver<T> verbose(boolean flag) {verbose=flag; return this;}
     public String        name()                {return name;}
diff --git a/src/org/jgroups/util/Util.java b/src/org/jgroups/util/Util.java
index 1ae2b2591c..4c25e3d635 100644
--- a/src/org/jgroups/util/Util.java
+++ b/src/org/jgroups/util/Util.java
@@ -861,6 +861,18 @@ public static String bytesToString(byte[] bytes) {
         return bytes != null? new String(bytes) : null;
     }
 
+    public static String byteArrayToHexString(byte[] b) {
+        if(b == null)
+            return "null";
+        StringBuilder sb = new StringBuilder(b.length * 2);
+        for (int i = 0; i < b.length; i++){
+            int v = b[i] & 0xff;
+            if (v < 16) { sb.append('0'); }
+            sb.append(Integer.toHexString(v));
+        }
+        return sb.toString().toUpperCase();
+    }
+
     /** Compares 2 byte arrays, elements are treated as unigned */
     public static int compare(byte[] left,byte[] right) {
         for(int i=0, j=0; i < left.length && j < right.length; i++,j++) {
@@ -1016,10 +1028,11 @@ public static int size(String s) {
     }
 
     public static int size(byte[] buf) {
-        int retval=Global.BYTE_SIZE + Global.INT_SIZE;
+       /* int retval=Global.BYTE_SIZE + Global.INT_SIZE;
         if(buf != null)
             retval+=buf.length;
-        return retval;
+        return retval;*/
+        return buf == null? Global.BYTE_SIZE : Global.BYTE_SIZE + Global.INT_SIZE + buf.length;
     }
 
     private static Address readOtherAddress(DataInput in) throws Exception {
diff --git a/tests/junit-functional/org/jgroups/protocols/ASYM_ENCRYPT_Test.java b/tests/junit-functional/org/jgroups/protocols/ASYM_ENCRYPT_Test.java
new file mode 100644
index 0000000000..e6e36e8700
--- /dev/null
+++ b/tests/junit-functional/org/jgroups/protocols/ASYM_ENCRYPT_Test.java
@@ -0,0 +1,334 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.auth.MD5Token;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.protocols.pbcast.DeltaView;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.JoinRsp;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.stack.ProtocolStack;
+import org.jgroups.util.Buffer;
+import org.jgroups.util.ByteArrayDataOutputStream;
+import org.jgroups.util.Util;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import javax.crypto.SecretKey;
+import java.util.Arrays;
+
+/**
+ * Tests use cases for {@link ASYM_ENCRYPT} described in https://issues.jboss.org/browse/JGRP-2021.
+ * @author Bela Ban
+ * @since  4.0
+ */
+@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+public class ASYM_ENCRYPT_Test extends EncryptTest {
+    protected static final short  ASYM_ENCRYPT_ID;
+
+    static {
+        ASYM_ENCRYPT_ID=ClassConfigurator.getProtocolId(ASYM_ENCRYPT.class);
+    }
+
+
+    @BeforeMethod protected void init() throws Exception {
+        super.init(getClass().getSimpleName());
+    }
+
+    @AfterMethod protected void destroy() {
+        super.destroy();
+    }
+
+  /** Calling methods in superclass. Kludge because TestNG doesn't call methods in superclass correctly **/
+    public void testRegularMessageReception() throws Exception {
+        super.testRegularMessageReception();
+    }
+
+    public void testRegularMessageReceptionWithEmptyMessages() throws Exception {
+        super.testRegularMessageReceptionWithEmptyMessages();
+    }
+
+    public void testChecksum() throws Exception {
+        super.testChecksum();
+    }
+
+    public void testRogueMemberJoin() throws Exception {
+        super.testRogueMemberJoin();
+    }
+
+    public void testMessageSendingByRogue() throws Exception {
+        super.testMessageSendingByRogue();
+    }
+
+    public void testMessageSendingByRogueUsingEncryption() throws Exception {
+        super.testMessageSendingByRogueUsingEncryption();
+    }
+
+    public void testMessageReceptionByRogue() throws Exception {
+        super.testMessageReceptionByRogue();
+    }
+
+    public void testCapturingOfMessageByNonMemberAndResending() throws Exception {
+        super.testCapturingOfMessageByNonMemberAndResending();
+    }
+
+    public void testRogueViewInstallation() throws Exception {
+        super.testRogueViewInstallation();
+    }
+
+
+
+    /**
+     * A non-member sends a {@link EncryptHeader#SECRET_KEY_REQ} request to the key server. Asserts that the rogue member
+     * doesn't get the secret key. If it did, it would be able to decrypt all messages from cluster members!
+     */
+    public void nonMemberGetsSecretKeyFromKeyServer() throws Exception {
+        Util.close(rogue);
+
+        rogue=new JChannel(Util.getTestStack()).name("rogue");
+        DISCARD discard=new DISCARD().setDiscardAll(true);
+        rogue.getProtocolStack().insertProtocol(discard, ProtocolStack.ABOVE, TP.class);
+        CustomENCRYPT encrypt=new CustomENCRYPT();
+        encrypt.init();
+
+        rogue.getProtocolStack().insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK2.class);
+        rogue.connect(cluster_name); // creates a singleton cluster
+
+        assert rogue.getView().size() == 1;
+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);
+        View rogue_view=new View(a.getAddress(), a.getView().getViewId().getId(),
+                                 Arrays.asList(a.getAddress(),b.getAddress(),c.getAddress(),rogue.getAddress()));
+        gms.installView(rogue_view);
+
+
+        // now fabricate a KEY_REQUEST message and send it to the key server (A)
+        Message newMsg=new Message(a.getAddress(), rogue.getAddress(), encrypt.keyPair().getPublic().getEncoded())
+          .putHeader(encrypt.getId(),new EncryptHeader(EncryptHeader.SECRET_KEY_REQ, encrypt.symVersion()));
+
+        discard.setDiscardAll(false);
+        System.out.printf("-- sending KEY_REQUEST to key server %s\n", a.getAddress());
+        encrypt.getDownProtocol().down(new Event(Event.MSG, newMsg));
+        for(int i=0; i < 10; i++) {
+            SecretKey secret_key=encrypt.key;
+            if(secret_key != null)
+                break;
+            Util.sleep(500);
+        }
+
+        discard.setDiscardAll(true);
+        gms.installView(View.create(rogue.getAddress(), 20, rogue.getAddress()));
+        System.out.printf("-- secret key is %s (should be null)\n", encrypt.key);
+        assert encrypt.key == null : String.format("should not have received secret key %s", encrypt.key);
+    }
+
+
+
+    /** Verifies that a non-member (non-coord) cannot send a JOIN-RSP to a member */
+    public void nonMemberInjectingJoinResponse() throws Exception {
+        Util.close(rogue);
+        rogue=create("rogue");
+        ProtocolStack stack=rogue.getProtocolStack();
+        AUTH auth=(AUTH)stack.findProtocol(AUTH.class);
+        auth.setAuthToken(new MD5Token("unknown_pwd"));
+        GMS gms=(GMS)stack.findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(1);
+        DISCARD discard=new DISCARD().setDiscardAll(true);
+        stack.insertProtocol(discard, ProtocolStack.ABOVE, TP.class);
+        rogue.connect(cluster_name);
+        assert rogue.getView().size() == 1;
+        discard.setDiscardAll(false);
+        stack.removeProtocol(NAKACK2.class, UNICAST3.class);
+
+        View rogue_view=View.create(a.getAddress(), a.getView().getViewId().getId() +5,
+                                    a.getAddress(),b.getAddress(),c.getAddress(),rogue.getAddress());
+        JoinRsp join_rsp=new JoinRsp(rogue_view, null);
+        GMS.GmsHeader gms_hdr=new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP);
+        Message rogue_join_rsp=new Message(b.getAddress(), rogue.getAddress()).putHeader(GMS_ID, gms_hdr)
+          .setBuffer(GMS.marshal(join_rsp)).setFlag(Message.Flag.NO_RELIABILITY); // bypasses NAKACK2 / UNICAST3
+        rogue.down(new Event(Event.MSG, rogue_join_rsp));
+        for(int i=0; i < 10; i++) {
+            if(b.getView().size() > 3)
+                break;
+            Util.sleep(500);
+        }
+        assert b.getView().size() == 3 : String.format("B's view is %s, but should be {A,B,C}", b.getView());
+    }
+
+
+
+    /** The rogue node has an incorrect {@link AUTH} config (secret) and can thus not join */
+    public void rogueMemberCannotJoinDueToAuthRejection() throws Exception {
+        Util.close(rogue);
+        rogue=create("rogue");
+        AUTH auth=(AUTH)rogue.getProtocolStack().findProtocol(AUTH.class);
+        auth.setAuthToken(new MD5Token("unknown_pwd"));
+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(2);
+        rogue.connect(cluster_name);
+        System.out.printf("Rogue's view is %s\n", rogue.getView());
+        assert rogue.getView().size() == 1 : String.format("rogue should have a singleton view of itself, but doesn't: %s", rogue.getView());
+    }
+
+
+    public void mergeViewInjectionByNonMember() throws Exception {
+        Util.close(rogue);
+        rogue=create("rogue");
+        AUTH auth=(AUTH)rogue.getProtocolStack().findProtocol(AUTH.class);
+        auth.setAuthToken(new MD5Token("unknown_pwd"));
+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(1);
+        rogue.connect(cluster_name);
+
+        MergeView merge_view=new MergeView(a.getAddress(), a.getView().getViewId().getId()+5,
+                                           Arrays.asList(a.getAddress(), b.getAddress(), c.getAddress(), rogue.getAddress()), null);
+        GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.INSTALL_MERGE_VIEW, a.getAddress());
+        Message merge_view_msg=new Message(null, marshalView(merge_view)).putHeader(GMS_ID, hdr)
+          .setFlag(Message.Flag.NO_RELIABILITY);
+        System.out.printf("** %s: trying to install MergeView %s in all members\n", rogue.getAddress(), merge_view);
+        rogue.down(new Event(Event.MSG, merge_view_msg));
+
+        // check if A, B or C installed the MergeView sent by rogue:
+        for(int i=0; i < 10; i++) {
+            boolean rogue_views_installed=false;
+
+            for(JChannel ch: Arrays.asList(a,b,c))
+                if(ch.getView().containsMember(rogue.getAddress()))
+                    rogue_views_installed=true;
+            if(rogue_views_installed)
+                break;
+            Util.sleep(500);
+        }
+        for(JChannel ch: Arrays.asList(a,b,c))
+            System.out.printf("%s: %s\n", ch.getAddress(), ch.getView());
+        for(JChannel ch: Arrays.asList(a,b,c))
+            assert !ch.getView().containsMember(rogue.getAddress());
+    }
+
+
+    /** Tests that when {ABC} -> {AB}, neither A nor B can receive a message from non-member C */
+    public void testMessagesByLeftMember() throws Exception {
+        View view=View.create(a.getAddress(), a.getView().getViewId().getId()+1, a.getAddress(),b.getAddress());
+        for(JChannel ch: Arrays.asList(a,b)) {
+            GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);
+            gms.installView(view);
+        };
+        for(JChannel ch: Arrays.asList(a,b))
+            System.out.printf("%s: %s\n", ch.getAddress(), ch.getView());
+        System.out.printf("%s: %s\n", c.getAddress(), c.getView());
+
+        c.getProtocolStack().removeProtocol(NAKACK2.class); // to prevent A and B from discarding C as non-member
+
+        Util.sleep(1000); // give members time to handle the new view
+        c.send(null, "hello world from left member C!");
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 0 || rb.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert ra.size() == 0 : String.format("A: received msgs from non-member C: %s", print(ra.list()));
+        assert rb.size() == 0 : String.format("B: received msgs from non-member C: %s", print(rb.list()));
+    }
+
+    /** Tests that a left member C cannot decrypt messages from the cluster */
+    public void testEavesdroppingByLeftMember() throws Exception {
+        printSymVersion(a,b,c);
+        View view=View.create(a.getAddress(), a.getView().getViewId().getId()+1, a.getAddress(),b.getAddress());
+         for(JChannel ch: Arrays.asList(a,b)) {
+            GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);
+            gms.installView(view);
+        };
+        for(JChannel ch: Arrays.asList(a,b))
+            System.out.printf("%s: %s\n", ch.getAddress(), ch.getView());
+        System.out.printf("%s: %s\n", c.getAddress(), c.getView());
+        c.getProtocolStack().removeProtocol(NAKACK2.class); // to prevent A and B from discarding C as non-member
+
+        Util.sleep(2000); // give members time to handle the new view
+
+
+        printSymVersion(a,b,c);
+        a.send(null, "hello from A");
+        b.send(null, "hello from B");
+
+        for(int i=0; i < 10; i++) {
+            if(rc.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert rc.size() == 0 : String.format("C: received msgs from cluster: %s", print(rc.list()));
+    }
+
+
+    protected JChannel create(String name) throws Exception {
+        JChannel ch=new JChannel(Util.getTestStack()).name(name);
+        ProtocolStack stack=ch.getProtocolStack();
+        EncryptBase encrypt=createENCRYPT();
+        stack.insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK2.class);
+        AUTH auth=new AUTH();
+        auth.setAuthCoord(true);
+        auth.setAuthToken(new MD5Token("mysecret")); // .setAuthCoord(false);
+        stack.insertProtocol(auth, ProtocolStack.BELOW, GMS.class);
+        stack.findProtocol(GMS.class).setValue("join_timeout", 2000); // .setValue("view_ack_collection_timeout", 10);
+        return ch;
+    }
+
+    protected void printSymVersion(JChannel ... channels) {
+        for(JChannel ch: channels) {
+            ASYM_ENCRYPT encr=(ASYM_ENCRYPT)ch.getProtocolStack().findProtocol(ASYM_ENCRYPT.class);
+            byte[] sym_version=encr.symVersion();
+            System.out.printf("sym-version %s: %s\n", ch.getAddress(), Util.byteArrayToHexString(sym_version));
+        }
+    }
+
+
+    // Note that setting encrypt_entire_message to true is critical here, or else some of the tests in this
+    // unit test would fail!
+    protected ASYM_ENCRYPT createENCRYPT() throws Exception {
+        ASYM_ENCRYPT encrypt=new ASYM_ENCRYPT().encryptEntireMessage(true).signMessages(true);
+        encrypt.init();
+        return encrypt;
+    }
+
+
+    protected static Buffer marshalView(final View view) throws Exception {
+        final ByteArrayDataOutputStream out=new ByteArrayDataOutputStream(512);
+        out.writeShort(determineFlags(view));
+        view.writeTo(out);
+        return out.getBuffer();
+    }
+
+    protected static short determineFlags(final View view) {
+        short retval=0;
+        if(view != null) {
+            retval|=GMS.VIEW_PRESENT;
+            if(view instanceof MergeView)
+                retval|=GMS.MERGE_VIEW;
+            else if(view instanceof DeltaView)
+                retval|=GMS.DELTA_VIEW;
+        }
+        return retval;
+    }
+
+
+    protected static class CustomENCRYPT extends ASYM_ENCRYPT {
+        protected SecretKey key;
+
+        public CustomENCRYPT() {
+            this.id=ASYM_ENCRYPT_ID;
+        }
+
+        protected Object handleUpEvent(Message msg, EncryptHeader hdr) {
+            if(hdr.type() == EncryptHeader.SECRET_KEY_RSP) {
+                try {
+                    key=decodeKey(msg.getBuffer());
+                    System.out.printf("received secret key %s !\n", key);
+                }
+                catch(Exception e) {
+                    e.printStackTrace();
+                }
+            }
+            return super.handleUpEvent(msg, hdr);
+        }
+    }
+
+}
diff --git a/tests/junit-functional/org/jgroups/protocols/ENCRYPTAsymmetricTest.java b/tests/junit-functional/org/jgroups/protocols/ENCRYPTAsymmetricTest.java
index 954b8dc3a6..0f66d1b29d 100644
--- a/tests/junit-functional/org/jgroups/protocols/ENCRYPTAsymmetricTest.java
+++ b/tests/junit-functional/org/jgroups/protocols/ENCRYPTAsymmetricTest.java
@@ -9,7 +9,6 @@
 
 import org.jgroups.*;
 import org.jgroups.conf.ClassConfigurator;
-import org.jgroups.protocols.ENCRYPT.EncryptHeader;
 import org.jgroups.stack.Protocol;
 import org.jgroups.util.MessageBatch;
 import org.jgroups.util.Util;
@@ -27,7 +26,7 @@
  * @author xenephon
  * @author Bela Ban
  */
-@Test(groups=Global.FUNCTIONAL, sequential=false)
+@Test(groups=Global.FUNCTIONAL)
 public class ENCRYPTAsymmetricTest {
 
     protected static final short ENCRYPT_ID=ClassConfigurator.getProtocolId(ENCRYPT.class);
@@ -136,7 +135,7 @@ public static void testViewChangeBecomeKeyserver() throws Exception {
         byte[] symVersion=digest.digest();
         encrypt.keyServer=false;
         Message msg=new Message().setBuffer(cipher.doFinal("hello".getBytes()))
-          .putHeader(ENCRYPT_ID, new EncryptHeader(EncryptHeader.ENCRYPT, symVersion));
+          .putHeader(ENCRYPT_ID, new ENCRYPT.EncryptHeader(ENCRYPT.EncryptHeader.ENCRYPT, symVersion));
 
         encrypt.up(new Event(Event.MSG, msg));
 
@@ -152,7 +151,7 @@ public static void testViewChangeBecomeKeyserver() throws Exception {
 
         // send another encrypted message
         Message msg2=new Message().setBuffer(cipher.doFinal("hello2".getBytes()))
-          .putHeader(ENCRYPT_ID,new EncryptHeader(EncryptHeader.ENCRYPT,symVersion));
+          .putHeader(ENCRYPT_ID,new ENCRYPT.EncryptHeader(ENCRYPT.EncryptHeader.ENCRYPT,symVersion));
 
         // we should have three messages now in our observer that are decrypted
         encrypt.up(new Event(Event.MSG, msg2));
@@ -199,7 +198,7 @@ public static void testViewChangeNewKeyServer() throws Exception {
         Cipher cipher=server.getSymEncodingCipher();
         byte[] symVersion=digest.digest();
         Message msg=new Message().setBuffer(cipher.doFinal("hello".getBytes()))
-          .putHeader(ENCRYPT_ID, new EncryptHeader(EncryptHeader.ENCRYPT, symVersion));
+          .putHeader(ENCRYPT_ID, new ENCRYPT.EncryptHeader(ENCRYPT.EncryptHeader.ENCRYPT, symVersion));
 
         peer.up(new Event(Event.MSG, msg));
         //assert that message is queued as we have no key from server
@@ -216,7 +215,7 @@ public static void testViewChangeNewKeyServer() throws Exception {
 
         Event sent=peerObserver.downMessages.get("message0");
 
-        Util.assertEquals(((EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.KEY_REQUEST);
+        Util.assertEquals(((ENCRYPT.EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), ENCRYPT.EncryptHeader.KEY_REQUEST);
         Util.assertEquals(new String(((Message)sent.getArg()).getBuffer()), new String(peer.getKpair().getPublic().getEncoded()));
 
         // send this event to server
@@ -225,7 +224,7 @@ public static void testViewChangeNewKeyServer() throws Exception {
         Event reply=serverObserver.downMessages.get("message1");
 
         //assert that reply is the session key encrypted with peer's public key
-        Util.assertEquals(((EncryptHeader)((Message)reply.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.SECRETKEY);
+        Util.assertEquals(((ENCRYPT.EncryptHeader)((Message)reply.getArg()).getHeader(ENCRYPT_ID)).getType(), ENCRYPT.EncryptHeader.SECRETKEY);
 
 
         assert !peer.getDesKey().equals(server.getDesKey());
@@ -237,7 +236,7 @@ public static void testViewChangeNewKeyServer() throws Exception {
 
         // send another encrypted message to peer to test queue
         Message msg2=new Message().setBuffer(cipher.doFinal("hello2".getBytes()))
-          .putHeader(ENCRYPT_ID,new EncryptHeader(EncryptHeader.ENCRYPT,symVersion));
+          .putHeader(ENCRYPT_ID,new ENCRYPT.EncryptHeader(ENCRYPT.EncryptHeader.ENCRYPT,symVersion));
         peer.up(new Event(Event.MSG, msg2));
 
         // make sure we have the events now in the up layers
@@ -316,7 +315,7 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
         Event sent=peerObserver.downMessages.get("message0");
 
         // ensure type and that request contains peers pub key
-        Util.assertEquals(((EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.KEY_REQUEST);
+        Util.assertEquals(((ENCRYPT.EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), ENCRYPT.EncryptHeader.KEY_REQUEST);
         Util.assertEquals(new String(((Message)sent.getArg()).getBuffer()), new String(peer.getKpair().getPublic().getEncoded()));
 
 
@@ -328,7 +327,7 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {
         Event reply=peer2Observer.downMessages.get("message1");
 
         //assert that reply is the session key encrypted with peer's public key
-        Util.assertEquals(((EncryptHeader)((Message)reply.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.SECRETKEY);
+        Util.assertEquals(((ENCRYPT.EncryptHeader)((Message)reply.getArg()).getHeader(ENCRYPT_ID)).getType(), ENCRYPT.EncryptHeader.SECRETKEY);
 
 
         assert !peer.getDesKey().equals(peer2.getDesKey());
diff --git a/tests/junit-functional/org/jgroups/protocols/ENCRYPTKeystoreTest.java b/tests/junit-functional/org/jgroups/protocols/ENCRYPTKeystoreTest.java
index 8d848f65fd..91bb3afa51 100644
--- a/tests/junit-functional/org/jgroups/protocols/ENCRYPTKeystoreTest.java
+++ b/tests/junit-functional/org/jgroups/protocols/ENCRYPTKeystoreTest.java
@@ -21,7 +21,7 @@
  * @author xenephon
  * @author Bela Ban
  */
-@Test(groups=Global.FUNCTIONAL, sequential=false)
+@Test(groups=Global.FUNCTIONAL)
 public class ENCRYPTKeystoreTest {
 
     static final short ENCRYPT_ID=ClassConfigurator.getProtocolId(ENCRYPT.class);
@@ -68,7 +68,7 @@ public static void testMessageDownEncode() throws Exception {
     }
 
 
-    public static void testMessageUpDecode() throws Exception {
+    public void testMessageUpDecode() throws Exception {
         ENCRYPT encrypt=create("defaultStore.keystore"), encrypt2=create("defaultStore.keystore");
         
         MockProtocol observer=new MockProtocol();
diff --git a/tests/junit-functional/org/jgroups/protocols/EncryptTest.java b/tests/junit-functional/org/jgroups/protocols/EncryptTest.java
new file mode 100644
index 0000000000..b1d45640b7
--- /dev/null
+++ b/tests/junit-functional/org/jgroups/protocols/EncryptTest.java
@@ -0,0 +1,346 @@
+package org.jgroups.protocols;
+
+import org.jgroups.*;
+import org.jgroups.conf.ClassConfigurator;
+import org.jgroups.demos.KeyStoreGenerator;
+import org.jgroups.protocols.pbcast.GMS;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.protocols.pbcast.NakAckHeader2;
+import org.jgroups.util.Buffer;
+import org.jgroups.util.ByteArrayDataOutputStream;
+import org.jgroups.util.MyReceiver;
+import org.jgroups.util.Util;
+import org.testng.annotations.Test;
+
+import javax.crypto.SecretKey;
+import java.lang.reflect.Field;
+import java.util.List;
+
+import static java.util.Arrays.asList;
+
+
+/**
+ * Base class for tests {@link SYM_ENCRYPT_Test} and {@link ASYM_ENCRYPT_Test}
+ * @author Bela Ban
+ * @since  4.0
+ */
+
+@Test(enabled=false)
+public abstract class EncryptTest {
+    protected JChannel            a,b,c,rogue;
+    protected MyReceiver<Message> ra, rb, rc, r_rogue;
+    protected String              cluster_name;
+    protected static final short  GMS_ID;
+
+    static {
+        GMS_ID=ClassConfigurator.getProtocolId(GMS.class);
+    }
+
+    protected void init(String cluster_name) throws Exception {
+        this.cluster_name=cluster_name;
+        a=create("A");
+        a.connect(cluster_name);
+        a.setReceiver(ra=new MyReceiver<>().rawMsgs(true));
+
+        b=create("B");
+        b.connect(cluster_name);
+        b.setReceiver(rb=new MyReceiver<>().rawMsgs(true));
+
+        c=create("C");
+        c.connect(cluster_name);
+        c.setReceiver(rc=new MyReceiver<>().rawMsgs(true));
+
+        Util.waitUntilAllChannelsHaveSameSize(10000, 500, a,b,c);
+        rogue=createRogue("rogue");
+        rogue.connect(cluster_name);
+        for(JChannel ch: asList(a,b,c))
+            System.out.printf("%s: %s\n", ch.getAddress(), ch.getView());
+        System.out.println("");
+    }
+
+    @Test(enabled=false) protected void destroy() {
+        Util.close(c, b, a, rogue);
+    }
+
+    protected abstract JChannel create(String name) throws Exception;
+
+
+
+    /** Tests A,B or C sending messages and their reception by everyone in cluster {A,B,C} */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    protected void testRegularMessageReception() throws Exception {
+        a.send(null, "Hello from A");
+        b.send(null, "Hello from B");
+        c.send(null, "Hello from C");
+        for(int i=0; i < 10; i++) {
+            if(ra.size() == 3 && rb.size() == 3 && rc.size() == 3)
+                break;
+            Util.sleep(500);
+        }
+        for(MyReceiver r: asList(ra,rb,rc))
+            System.out.printf("%s: %s\n", r.name(), print(r.list()));
+        assertSize(3);
+    }
+
+    /** Same as above, but all messages are 0-length */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testRegularMessageReceptionWithEmptyMessages() throws Exception {
+        a.send(new Message(null));
+        b.send(new Message(null));
+        c.send(new Message(null));
+        for(int i=0; i < 10; i++) {
+            if(ra.size() == 3 && rb.size() == 3 && rc.size() == 3)
+                break;
+            Util.sleep(500);
+        }
+        for(MyReceiver r: asList(ra,rb,rc))
+            System.out.printf("%s: %s\n", r.name(), print(r.list()));
+        assertSize(3);
+    }
+
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testChecksum() throws Exception {
+        EncryptBase encrypt=(EncryptBase)a.getProtocolStack().findProtocol(EncryptBase.class);
+
+        byte[] buffer="Hello world".getBytes();
+        long checksum=encrypt.computeChecksum(buffer, 0, buffer.length);
+        byte[] checksum_array=encrypt.encryptChecksum(checksum);
+
+        long actual_checksum=encrypt.decryptChecksum(null, checksum_array, 0, checksum_array.length);
+        assert checksum == actual_checksum : String.format("checksum: %d, actual: %d", checksum, actual_checksum);
+    }
+
+
+    /** A rogue member should not be able to join a cluster */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testRogueMemberJoin() throws Exception {
+        Util.close(rogue);
+        rogue=new JChannel(Util.getTestStack()).name("rogue");
+        rogue.getProtocolStack().removeProtocol(EncryptBase.class);
+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);
+        gms.setMaxJoinAttempts(1);
+        rogue.connect(cluster_name);
+        for(int i=0; i < 10; i++) {
+            if(a.getView().size() > 3)
+                break;
+            Util.sleep(500);
+        }
+        for(JChannel ch: asList(a,b,c))
+            System.out.printf("%s: view is %s\n", ch.getAddress(), ch.getView());
+        for(JChannel ch: asList(a,b,c)) {
+            View view=ch.getView();
+            assert view.size() == 3 : "view should be {A,B,C}: " + view;
+        }
+    }
+
+
+    /** Test that A,B,C do NOT receive any message sent by a rogue node which is not member of {A,B,C} */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testMessageSendingByRogue() throws Exception {
+        rogue.send(null, "message from rogue");  // tests single messages
+        Util.sleep(500);
+        for(int i=1; i <= 100; i++)              // tests message batches
+            rogue.send(null, "msg #" + i + " from rogue");
+
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 0 || rb.size() > 0 || rc.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert ra.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(ra.list()));
+        assert rb.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rb.list()));
+        assert rc.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rc.list()));
+    }
+
+
+    /**
+     * R sends a message that has an encryption header and is encrypted with R's secret key (which of course is different
+     * from the cluster members' shared key as R doesn't know it). The cluster members should drop R's message as they
+     * shouldn't be able to decrypt it.
+     */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testMessageSendingByRogueUsingEncryption() throws Exception {
+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT().keystoreName("/tmp/ignored.keystore");
+        encrypt.encryptEntireMessage(true).signMessages(true);
+
+        SecretKey secret_key=KeyStoreGenerator.createSecretKey();
+        Field secretKey=Util.getField(SYM_ENCRYPT.class, "secret_key");
+        secretKey.setAccessible(true);
+        Util.setField(secretKey, encrypt, secret_key);
+        encrypt.init();
+
+        short encrypt_id=ClassConfigurator.getProtocolId(SYM_ENCRYPT.class);
+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, encrypt.symVersion());
+        Message msg=new Message(null).putHeader(encrypt_id, hdr);
+
+        byte[] buf="hello from rogue".getBytes();
+        byte[] encrypted_buf=encrypt.code(buf, 0, buf.length, false);
+        msg.setBuffer(encrypted_buf);
+        long checksum=encrypt.computeChecksum(encrypted_buf, 0, encrypted_buf.length);
+        byte[] tmp=encrypt.encryptChecksum(checksum);
+        hdr.signature(tmp);
+
+        rogue.send(msg);
+
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 0 || rb.size() > 0 || rc.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+        assert ra.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(ra.list()));
+        assert rb.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rb.list()));
+        assert rc.size() == 0 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rc.list()));
+    }
+
+
+    /**
+     * Tests that the non-member does NOT receive messages from cluster {A,B,C}. The de-serialization of a message's
+     * payload (encrypted with the secret key of the rogue non-member) will fail, so the message is never passed up
+     * to the application.
+     */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testMessageReceptionByRogue() throws Exception {
+        rogue.setReceiver(r_rogue=new MyReceiver().rawMsgs(true));
+        a.setReceiver(null); b.setReceiver(null); c.setReceiver(null);
+        a.send(null, "Hello from A");
+        b.send(null, "Hello from B");
+        c.send(null, "Hello from C");
+        for(int i=0; i < 10; i++) {
+            // retransmissions will add dupes to rogue as it doesn't have dupe elimination, so we could have more than
+            // 3 messages!
+            if(r_rogue.size() > 0)
+                break;
+            Util.sleep(500);
+        }
+
+        // the non-member may have received some cluster messages, if the encrypted messages coincidentally didn't
+        // cause a deserialization exception, but it will not be able to read their contents:
+        if(r_rogue.size() > 0) {
+            System.out.printf("Rogue non-member received %d message(s), but it should not be able to read deserialize " +
+                                "the contents (this should throw exceptions below):\n", r_rogue.size());
+            for(Message msg: r_rogue.list()) {
+                try {
+                    String payload=(String)msg.getObject();
+                    assert !payload.startsWith("Hello from");
+                }
+                catch(Exception t) {
+                    System.out.printf("caught exception trying to de-serialize garbage payload into a string: %s\n", t);
+                }
+            };
+        }
+    }
+
+
+    /**
+     * Tests the scenario where the non-member R captures a message from some cluster member in {A,B,C}, then
+     * increments the NAKACK2 seqno and resends that message. The message must not be received by {A,B,C};
+     * it should be discarded.
+     */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testCapturingOfMessageByNonMemberAndResending() throws Exception {
+        rogue.setReceiver(new ReceiverAdapter() {
+            public void receive(Message msg) {
+                System.out.printf("rogue: modifying and resending msg %s, hdrs: %s\n", msg, msg.printHeaders());
+                rogue.setReceiver(null); // to prevent recursive cycle
+                try {
+                    short prot_id=ClassConfigurator.getProtocolId(NAKACK2.class);
+                    NakAckHeader2 hdr=(NakAckHeader2)msg.getHeader(prot_id);
+                    if(hdr != null) {
+                        long seqno=hdr.getSeqno();
+                        Util.setField(Util.getField(NakAckHeader2.class, "seqno"), hdr, seqno+1);
+                    }
+                    else {
+                        System.out.printf("Rogue was not able to get the %s header, fabricating one with seqno=50\n", NAKACK2.class.getSimpleName());
+                        NakAckHeader2 hdr2=NakAckHeader2.createMessageHeader(50);
+                        msg.putHeader(prot_id, hdr2);
+                    }
+
+                    rogue.send(msg);
+                }
+                catch(Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        });
+
+        a.send(null, "Hello world from A");
+
+        // everybody in {A,B,C} should receive this message, but NOT the rogue's resent message
+        for(int i=0; i < 10; i++) {
+            if(ra.size() > 1 || rb.size() > 1 || rc.size() > 1)
+                break; // this should NOT happen
+            Util.sleep(500);
+        }
+
+        for(MyReceiver r: asList(ra,rb,rc))
+            System.out.printf("%s: %s\n", r.name(), print(r.list()));
+        assert ra.size() == 1 : String.format("received msgs from non-member: '%s'; this should not be the case", print(ra.list()));
+        assert rb.size() == 1 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rb.list()));
+        assert rc.size() == 1 : String.format("received msgs from non-member: '%s'; this should not be the case", print(rc.list()));
+    }
+
+
+
+    /**
+     * Tests the case where a non-member installs a new view {rogue,A,B,C}, making itself the coordinator and therefore
+     * controlling admission of new members to the cluster etc...
+     */
+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+    public void testRogueViewInstallation() throws Exception {
+        final Address rogue_addr=rogue.getAddress();
+        View rogue_view=View.create(rogue_addr, a.getView().getViewId().getId()+1,
+                                    rogue_addr, a.getAddress(), b.getAddress(), c.getAddress());
+
+        Message view_change_msg=new Message().putHeader(GMS_ID, new GMS.GmsHeader(GMS.GmsHeader.VIEW))
+          .setBuffer(marshal(rogue_view));
+        rogue.send(view_change_msg);
+
+        for(int i=0; i < 10; i++) {
+            if(a.getView().size() > 3)
+                break;
+            Util.sleep(500);
+        }
+        for(JChannel ch: asList(a,b,c)) {
+            View view=ch.getView();
+            System.out.printf("%s: view is %s\n", ch.getAddress(), view);
+            assert !view.containsMember(rogue_addr) : "view contains rogue member: " + view;
+        };
+    }
+
+
+    protected static JChannel createRogue(String name) throws Exception {
+        return new JChannel(new SHARED_LOOPBACK()).name(name);
+    }
+
+
+    protected static Buffer marshal(final View view) throws Exception {
+        ByteArrayDataOutputStream out=new ByteArrayDataOutputStream(512);
+        out.writeShort(1);
+        if(view != null)
+            view.writeTo(out);
+        return out.getBuffer();
+    }
+
+    protected void assertSize(int expected_size) {
+        for(MyReceiver r: asList(ra,rb,rc))
+        assert r.size() == expected_size : String.format("expected size: %d, actual size of %s: %d", expected_size, r.name(), r.size());
+    }
+
+    protected static String print(List<Message> msgs) {
+        StringBuilder sb=new StringBuilder();
+        for(Message msg: msgs)
+            sb.append(msg.getObject()).append(" ");
+        return sb.toString();
+    }
+
+    protected static String print(byte[] buf, int offset, int length) {
+        StringBuilder sb=new StringBuilder("encrypted string: ");
+        for(int i=0; i < length; i++) {
+            int ch=buf[offset+i];
+            sb.append(ch).append(' ');
+        }
+        return sb.toString();
+    }
+
+
+}
diff --git a/tests/junit-functional/org/jgroups/protocols/SYM_ENCRYPT_Test.java b/tests/junit-functional/org/jgroups/protocols/SYM_ENCRYPT_Test.java
new file mode 100644
index 0000000000..e9f5967ac8
--- /dev/null
+++ b/tests/junit-functional/org/jgroups/protocols/SYM_ENCRYPT_Test.java
@@ -0,0 +1,94 @@
+package org.jgroups.protocols;
+
+import org.jgroups.Global;
+import org.jgroups.JChannel;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import org.jgroups.stack.ProtocolStack;
+import org.jgroups.util.Util;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+/**
+ * Tests use cases for {@link SYM_ENCRYPT} described in https://issues.jboss.org/browse/JGRP-2021.
+ * Make sure you create the keystore before running this test (ant make-keystore).
+ * @author Bela Ban
+ * @since  4.0
+ */
+@Test(groups=Global.FUNCTIONAL,singleThreaded=true)
+public class SYM_ENCRYPT_Test extends EncryptTest {
+    protected static final String DEF_PWD="changeit";
+
+    @BeforeMethod protected void init() throws Exception {
+        super.init(getClass().getSimpleName());
+    }
+
+    @AfterMethod protected void destroy() {
+        super.destroy();
+    }
+
+
+    /** Calling methods in superclass. Kludge because TestNG doesn't call methods in superclass correctly **/
+    public void testRegularMessageReception() throws Exception {
+        super.testRegularMessageReception();
+    }
+
+    public void testRegularMessageReceptionWithEmptyMessages() throws Exception {
+        super.testRegularMessageReceptionWithEmptyMessages();
+    }
+
+    public void testChecksum() throws Exception {
+        super.testChecksum();
+    }
+
+    public void testRogueMemberJoin() throws Exception {
+        super.testRogueMemberJoin();
+    }
+
+    public void testMessageSendingByRogue() throws Exception {
+        super.testMessageSendingByRogue();
+    }
+
+    public void testMessageSendingByRogueUsingEncryption() throws Exception {
+        super.testMessageSendingByRogueUsingEncryption();
+    }
+
+    public void testMessageReceptionByRogue() throws Exception {
+        super.testMessageReceptionByRogue();
+    }
+
+    public void testCapturingOfMessageByNonMemberAndResending() throws Exception {
+        super.testCapturingOfMessageByNonMemberAndResending();
+    }
+
+    public void testRogueViewInstallation() throws Exception {
+        super.testRogueViewInstallation();
+    }
+
+
+
+
+    protected JChannel create(String name) throws Exception {
+        JChannel ch=new JChannel(Util.getTestStack()).name(name);
+        SYM_ENCRYPT encrypt;
+        try {
+            encrypt=createENCRYPT("keystore/defaultStore.keystore", DEF_PWD);
+        }
+        catch(Throwable t) {
+            encrypt=createENCRYPT("defaultStore.keystore", DEF_PWD);
+        }
+        ch.getProtocolStack().insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK2.class);
+        return ch;
+    }
+
+
+    // Note that setting encrypt_entire_message to true is critical here, or else some of the tests in this
+    // unit test would fail!
+    protected SYM_ENCRYPT createENCRYPT(String keystore_name, String store_pwd) throws Exception {
+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT().keystoreName(keystore_name).alias("myKey")
+          .storePassword(store_pwd).encryptEntireMessage(true).signMessages(true);
+        encrypt.init();
+        return encrypt;
+    }
+
+}
diff --git a/tests/junit-functional/org/jgroups/tests/SizeTest.java b/tests/junit-functional/org/jgroups/tests/SizeTest.java
index 39223a6efb..2bbefe6223 100644
--- a/tests/junit-functional/org/jgroups/tests/SizeTest.java
+++ b/tests/junit-functional/org/jgroups/tests/SizeTest.java
@@ -688,10 +688,10 @@ public static void testRelay2Header() throws Exception {
     }
 
 
-    public static void testEncryptHeader() throws Exception {
-        ENCRYPT.EncryptHeader hdr=new ENCRYPT.EncryptHeader((byte)1, new byte[]{'b','e', 'l', 'a'});
+    public void testEncryptHeader() throws Exception {
+        EncryptHeader hdr=new EncryptHeader((byte)1, new byte[]{'b','e', 'l', 'a'});
         _testSize(hdr);
-        hdr=new ENCRYPT.EncryptHeader((byte)2, "Hello world".getBytes());
+        hdr=new EncryptHeader((byte)2, "Hello world".getBytes());
         _testSize(hdr);
     }
 
diff --git a/tests/junit/org/jgroups/protocols/S3_PINGTest.java b/tests/junit/org/jgroups/protocols/S3_PINGTest.java
index 983fab579b..9f1b20b286 100644
--- a/tests/junit/org/jgroups/protocols/S3_PINGTest.java
+++ b/tests/junit/org/jgroups/protocols/S3_PINGTest.java
@@ -1,9 +1,5 @@
 package org.jgroups.protocols;
 
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
-
 import org.jgroups.Global;
 import org.jgroups.protocols.S3_PING.PreSignedUrlParser;
 import org.jgroups.protocols.S3_PING.Utils;
@@ -11,6 +7,10 @@
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
 @Test(groups={Global.STACK_INDEPENDENT})
 public class S3_PINGTest {
     private S3_PING ping;
@@ -80,7 +80,7 @@ public void testUsingPreSignedUrlWhenSet() {
     
     @Test
     public void testGenerateQueryStringAuthenticationWithBasicGet() {
-        String expectedUrl = "http://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=Khyk4bU1A3vaed9woyp%2B5qepazQ%3D";
+        String expectedUrl = "https://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=Khyk4bU1A3vaed9woyp%2B5qepazQ%3D";
         String encodedUrl =
             Utils.generateQueryStringAuthentication("abcd", "efgh", "get",
                                                     "test-bucket", "node1",
@@ -91,7 +91,7 @@ public void testGenerateQueryStringAuthenticationWithBasicGet() {
     
     @Test
     public void testGenerateQueryStringAuthenticationWithBasicPost() {
-        String expectedUrl = "http://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=%2BsCW1Fc20UUvIqPjeGXkyN960sk%3D";
+        String expectedUrl = "https://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=%2BsCW1Fc20UUvIqPjeGXkyN960sk%3D";
         String encodedUrl =
             Utils.generateQueryStringAuthentication("abcd", "efgh", "POST",
                                                     "test-bucket", "node1",
@@ -104,7 +104,7 @@ public void testGenerateQueryStringAuthenticationWithBasicPost() {
     public void testGenerateQueryStringAuthenticationWithBasicPutAndHeaders() {
         Map headers = new HashMap();
         headers.put("x-amz-acl", Arrays.asList("public-read"));
-        String expectedUrl = "http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D";
+        String expectedUrl = "https://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D";
         String encodedUrl =
             Utils.generateQueryStringAuthentication("abcd", "efgh", "put",
                                                     "test-bucket", "subdir/node1",
@@ -115,7 +115,7 @@ public void testGenerateQueryStringAuthenticationWithBasicPutAndHeaders() {
     
     @Test
     public void testGeneratePreSignedUrlForPut() {
-        String expectedUrl = "http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D";
+        String expectedUrl = "https://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D";
         String preSignedUrl = S3_PING.generatePreSignedUrl("abcd", "efgh", "put",
                                                            "test-bucket", "subdir/node1",
                                                            1234567890);
@@ -124,7 +124,7 @@ public void testGeneratePreSignedUrlForPut() {
     
     @Test
     public void testGeneratePreSignedUrlForDelete() {
-        String expectedUrl = "http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=qbEMukqq0KIpZVjXaDi0VxepSVo%3D";
+        String expectedUrl = "https://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=qbEMukqq0KIpZVjXaDi0VxepSVo%3D";
         String preSignedUrl = S3_PING.generatePreSignedUrl("abcd", "efgh", "delete",
                                                            "test-bucket", "subdir/node1",
                                                            1234567890);
