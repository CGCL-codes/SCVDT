commit 5b00e397a14822fae1664d5e8748194ac02f1712
Author:     Jacques Le Roux <jleroux@apache.org>
AuthorDate: Sat Feb 16 09:46:08 2019 +0000
Commit:     Jacques Le Roux <jleroux@apache.org>
CommitDate: Sat Feb 16 09:46:08 2019 +0000

    "Applied fix from trunk framework for revision: 1853691  "
    ------------------------------------------------------------------------
    r1853691 | jleroux | 2019-02-16 10:42:03 +0100 (sam. 16 f√©vr. 2019) | 9 lignes
    
    Improved: Improve ObjectInputStream class
    (OFBIZ-10837)
    
    Fixes CVE-2019-0189
    
    As reported by FindBugs and Sonar, it's troubling (a Bad practice in Sonar[1],
    a code smell in Findbugs[2]) when extending to use the same name than the
    extended Object
    
    [1] https://sbforge.org/sonar/rules/show/findbugs:NM_SAME_SIMPLE_NAME_AS_SUPERCLASS?layout=false
    [2] https://logging.apache.org/log4j/log4j-2.2/log4j-jul/findbugs.html
    ------------------------------------------------------------------------
    
    
    git-svn-id: https://svn.apache.org/repos/asf/ofbiz/branches/release16.11@1853695 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/framework/base/src/main/java/org/apache/ofbiz/base/util/ObjectInputStream.java b/framework/base/src/main/java/org/apache/ofbiz/base/util/SafeObjectInputStream.java
similarity index 64%
rename from framework/base/src/main/java/org/apache/ofbiz/base/util/ObjectInputStream.java
rename to framework/base/src/main/java/org/apache/ofbiz/base/util/SafeObjectInputStream.java
index 85b265efbf..1d232286a6 100644
--- a/framework/base/src/main/java/org/apache/ofbiz/base/util/ObjectInputStream.java
+++ b/framework/base/src/main/java/org/apache/ofbiz/base/util/SafeObjectInputStream.java
@@ -18,29 +18,51 @@
  *******************************************************************************/
 package org.apache.ofbiz.base.util;
 
-import java.io.InputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.ObjectStreamClass;
 import java.lang.reflect.Proxy;
+import java.util.List;
+import java.util.regex.Pattern;
 
 /**
  * ObjectInputStream
  *
  */
-public class ObjectInputStream extends java.io.ObjectInputStream {
+public class SafeObjectInputStream extends java.io.ObjectInputStream implements AutoCloseable {
 
     private ClassLoader classloader;
+    private Pattern WHITELIST_PATTERN = null;
+
+    public SafeObjectInputStream(InputStream in, ClassLoader loader) throws IOException {
+        super(in);
+        this.classloader = loader;
+    }
 
-    public ObjectInputStream(InputStream in, ClassLoader loader) throws IOException {
+    public SafeObjectInputStream(InputStream in, ClassLoader loader, List<String> whitelist) throws IOException {
         super(in);
         this.classloader = loader;
+        StringBuilder bld = new StringBuilder("(");
+        for (int i = 0; i < whitelist.size(); i++) {
+            bld.append(whitelist.get(i));
+            if (i != whitelist.size() - 1) {
+                bld.append("|");
+            }
+        }
+        bld.append(")");
+        WHITELIST_PATTERN = Pattern.compile(bld.toString());
     }
 
+
     /**
      * @see java.io.ObjectInputStream#resolveClass(java.io.ObjectStreamClass)
      */
     @Override
     protected Class<?> resolveClass(ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {
+        if (!WHITELIST_PATTERN.matcher(classDesc.getName()).find()) {
+            throw new ClassCastException("Incompatible class: " + classDesc.getName());
+        }
+        
         return ObjectType.loadClass(classDesc.getName(), classloader);
     }
 
@@ -49,9 +71,10 @@ public class ObjectInputStream extends java.io.ObjectInputStream {
      */
     @Override
     protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {
-        Class<?>[] cinterfaces = new Class[interfaces.length];
-        for (int i = 0; i < interfaces.length; i++)
+        Class<?>[] cinterfaces = new Class<?>[interfaces.length];
+        for (int i = 0; i < interfaces.length; i++) {
             cinterfaces[i] = classloader.loadClass(interfaces[i]);
+        }
 
         try {
             return Proxy.getProxyClass(classloader, cinterfaces);
diff --git a/framework/base/src/main/java/org/apache/ofbiz/base/util/UtilObject.java b/framework/base/src/main/java/org/apache/ofbiz/base/util/UtilObject.java
index 7fabb7a290..704e73d9c3 100644
--- a/framework/base/src/main/java/org/apache/ofbiz/base/util/UtilObject.java
+++ b/framework/base/src/main/java/org/apache/ofbiz/base/util/UtilObject.java
@@ -142,16 +142,12 @@ public final class UtilObject {
 
     /** Deserialize a byte array back to an object */
     public static Object getObjectException(byte[] bytes) throws ClassNotFoundException, IOException {
-        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
-        try {
-            ObjectInputStream ois = new ObjectInputStream(bis, Thread.currentThread().getContextClassLoader());
-            try {
-                return ois.readObject();
-            } finally {
-                ois.close();
-            }
-        } finally {
-            bis.close();
+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
+                SafeObjectInputStream wois = new SafeObjectInputStream(bis,
+                        Thread.currentThread().getContextClassLoader(),
+                        java.util.Arrays.asList("byte\\[\\]", "Number", "Long", "foo", "SerializationInjector"));
+                ) { // byte[] used in EntityCrypto::doDecrypt, all others used in UtilObjectTests::testGetObject
+            return wois.readObject();
         }
     }
 
