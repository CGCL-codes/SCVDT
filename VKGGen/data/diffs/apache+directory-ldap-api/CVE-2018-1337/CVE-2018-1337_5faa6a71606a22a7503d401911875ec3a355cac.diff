diff --git a/ldap/client/api/pom.xml b/ldap/client/api/pom.xml
index ed8b08c10..baa8ffc23 100644
--- a/ldap/client/api/pom.xml
+++ b/ldap/client/api/pom.xml
@@ -100,6 +100,10 @@
       <artifactId>slf4j-log4j12</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+    	<groupId>org.apache.directory.api</groupId>
+    	<artifactId>api-ldap-codec-standalone</artifactId>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/ldap/client/api/src/main/java/org/apache/directory/ldap/client/api/LdapNetworkConnection.java b/ldap/client/api/src/main/java/org/apache/directory/ldap/client/api/LdapNetworkConnection.java
index c63158fd5..948b8ae43 100644
--- a/ldap/client/api/src/main/java/org/apache/directory/ldap/client/api/LdapNetworkConnection.java
+++ b/ldap/client/api/src/main/java/org/apache/directory/ldap/client/api/LdapNetworkConnection.java
@@ -165,8 +165,10 @@
 import org.apache.mina.core.future.WriteFuture;
 import org.apache.mina.core.service.IoConnector;
 import org.apache.mina.core.session.IoSession;
+import org.apache.mina.filter.FilterEvent;
 import org.apache.mina.filter.codec.ProtocolCodecFilter;
 import org.apache.mina.filter.codec.ProtocolEncoderException;
+import org.apache.mina.filter.ssl.SslEvent;
 import org.apache.mina.filter.ssl.SslFilter;
 import org.apache.mina.transport.socket.SocketSessionConfig;
 import org.apache.mina.transport.socket.nio.NioSocketConnector;
@@ -238,6 +240,9 @@
 
     /** The exception stored in the session if we've got one */
     private static final String EXCEPTION_KEY = "sessionException";
+    
+    /** A future used to block any action until the handhake is completed */
+    private HandshakeFuture handshakeFuture;
 
     // ~~~~~~~~~~~~~~~~~ common error messages ~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -664,6 +669,25 @@ public boolean connect() throws LdapException
         {
             connectionFuture = connector.connect( address );
 
+            if ( config.isUseSsl() )
+            {
+                try
+                {
+                    boolean isSecured = handshakeFuture.get( timeout, TimeUnit.MILLISECONDS );
+                
+                    if ( !isSecured )
+                    {
+                        throw new LdapOperationException( ResultCodeEnum.OTHER, I18n.err( I18n.ERR_4100_TLS_HANDSHAKE_ERROR ) );
+                    }
+                }
+                catch ( Exception e )
+                {
+                    String msg = "Failed to initialize the SSL context";
+                    LOG.error( msg, e );
+                    throw new LdapException( msg, e );
+                }
+            }
+
             boolean result = false;
 
             // Wait until it's established
@@ -835,7 +859,6 @@ else if ( responseFuture instanceof SearchFuture )
 
         // Get back the session
         ldapSession = connectionFuture.getSession();
-        connected.set( true );
 
         // Store the container into the session if we don't have one
         @SuppressWarnings("unchecked")
@@ -2024,27 +2047,6 @@ private boolean isNoticeOfDisconnect( Message message )
     public void messageReceived( IoSession session, Object message ) throws Exception
     {
         // Feed the response and store it into the session
-        if ( message instanceof SslFilter.SslFilterMessage )
-        {
-            // This is a SSL message telling if the session has been secured or not
-            HandshakeFuture handshakeFuture = ( HandshakeFuture ) session.getAttribute( "HANDSHAKE_FUTURE" );
-
-            if ( message == SslFilter.SESSION_SECURED )
-            {
-                // SECURED
-                handshakeFuture.secured();
-            }
-            else
-            {
-                // UNSECURED
-                handshakeFuture.cancel();
-            }
-
-            session.removeAttribute( "HANDSHAKE_FUTURE" );
-            
-            return;
-        }
-
         Message response = ( Message ) message;
         LOG.debug( "-------> {} Message received <-------", response );
         int messageId = response.getMessageId();
@@ -3918,6 +3920,21 @@ public void sessionCreated( IoSession session ) throws Exception
             new LdapMessageContainer<>( codec, config.getBinaryAttributeDetector() );
 
         session.setAttribute( LdapDecoder.MESSAGE_CONTAINER_ATTR, ldapMessageContainer );
+        connected.set( true );
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void event( IoSession session, FilterEvent event ) throws Exception 
+    {
+        // Check if it's a SSLevent 
+        if ( ( event instanceof SslEvent ) && ( ( SslEvent ) event == SslEvent.SECURED ) )
+        {
+            handshakeFuture.secured();
+        }
     }
 
 
@@ -4062,7 +4079,9 @@ private void addSslFilter() throws LdapException
                     { "TLSv1", "TLSv1.1", "TLSv1.2" } );
             }
 
-            // for LDAPS
+            // for LDAPS/startTLS
+            handshakeFuture = new HandshakeFuture();
+
             if ( ( ldapSession == null ) || !connected.get() )
             {
                 connector.getFilterChain().addFirst( SSL_FILTER_KEY, sslFilter );
@@ -4070,11 +4089,8 @@ private void addSslFilter() throws LdapException
             else
             // for StartTLS
             {
-                HandshakeFuture handshakeFuture = new HandshakeFuture();
-
-                ldapSession.setAttribute( SslFilter.USE_NOTIFICATION, Boolean.TRUE );
-                ldapSession.setAttribute( "HANDSHAKE_FUTURE", handshakeFuture );
                 ldapSession.getFilterChain().addFirst( SSL_FILTER_KEY, sslFilter );
+
                 boolean isSecured = handshakeFuture.get( timeout, TimeUnit.MILLISECONDS );
                 
                 if ( !isSecured )
@@ -4276,10 +4292,10 @@ private void writeRequest( Request request ) throws LdapException
     {
         // If we are meant to be using a secure connection but the ssl filter isn' in the filter chain then
         // throw immediately
-        if ( config.isUseSsl() && !ldapSession.getFilterChain().contains( "sslFilter" ) )
+        /*if ( config.isUseSsl() && !ldapSession.isSecured() )
         {
             throw new InvalidConnectionException( "Attempting to send over an insecure connection" );
-        }
+        }*/
         
         // Send the request to the server
         WriteFuture writeFuture = ldapSession.write( request );
diff --git a/ldap/client/api/src/test/java/org/apache/directory/ldap/client/api/LdapTest.java b/ldap/client/api/src/test/java/org/apache/directory/ldap/client/api/LdapTest.java
new file mode 100644
index 000000000..1c2b5db3f
--- /dev/null
+++ b/ldap/client/api/src/test/java/org/apache/directory/ldap/client/api/LdapTest.java
@@ -0,0 +1,126 @@
+package org.apache.directory.ldap.client.api;
+
+import org.apache.directory.api.ldap.codec.api.LdapApiServiceFactory;
+import org.apache.directory.api.ldap.model.cursor.EntryCursor;
+import org.apache.directory.api.ldap.model.message.SearchScope;
+import org.apache.directory.api.ldap.model.name.Dn;
+import org.junit.Ignore;
+import org.junit.Test;
+
+public class LdapTest
+{
+    @Test
+    @Ignore
+    public void test2() throws Exception
+    {
+        LdapConnectionConfig config = new LdapConnectionConfig();
+        //config.setLdapHost("10.107.183.18");
+        config.setLdapHost("10.71.6.75");
+        config.setLdapPort(636);
+        config.setUseSsl(true);
+        config.setUseTls(false);
+        //char[] password = "cassandra".toCharArray();
+        //FileInputStream fis = new FileInputStream("/Users/elecharny/ldap_ssl_truststore");
+        //KeyStore ks = KeyStore.getInstance("jks");
+        //ks.load(fis, password);
+        //TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+        //tmf.init(ks);
+        config.setTrustManagers(new NoVerificationTrustManager() );
+        //config.setName("cn=test");
+        config.setName("cn=Manager,dc=example,dc=com");
+        //config.setCredentials("pass");
+        config.setCredentials("secret");
+        config.setLdapApiService( LdapApiServiceFactory.getSingleton());
+
+        ValidatingPoolableLdapConnectionFactory factory = new ValidatingPoolableLdapConnectionFactory(config);
+        LdapConnectionPool connectionPool = new LdapConnectionPool(factory);
+        connectionPool.setMaxActive(2);
+        connectionPool.setMaxIdle(1);
+        connectionPool.setMaxWait(0L);
+        connectionPool.setTestOnBorrow(false);
+        connectionPool.setTestOnReturn(true);
+        connectionPool.setTestWhileIdle(false);
+
+        LdapConnection connection = getConnection(connectionPool);
+        LdapNetworkConnection cnx = (LdapNetworkConnection)((MonitoringLdapConnection)(connection)).wrapped();
+
+        System.out.println( "Conection connected : " + connection.isConnected() + ", secured : " + cnx.isSecured() );
+
+        EntryCursor cursor = connection.search("ou=users,dc=example,dc=com", "(cn=titi)", SearchScope.SUBTREE);
+
+        cursor.next();
+
+        Dn userDn = cursor.get().getDn();
+
+        connection.setTimeOut(0L);
+        connectionPool.releaseConnection(connection);
+
+        connection = connectionPool.getConnection();
+        connection.setTimeOut(0L);
+
+        connection.bind(userDn, "titi");
+
+        connection.setTimeOut(0L);
+        connectionPool.releaseConnection(connection);
+        
+        
+        System.out.println( "Sleeping for 30 seconds" );
+
+        for ( int i = 1; i <= 30; i++ )
+        {
+            Thread.sleep(  1000L );
+            System.out.print( '.' );
+        }
+
+        System.out.println( "\nDone sleeping" );
+
+        connection = connectionPool.getConnection();
+        cnx = (LdapNetworkConnection)((MonitoringLdapConnection)(connection)).wrapped();
+        
+        System.out.println( "Conection connected : " + connection.isConnected() + ", secured : " + cnx.isSecured() );
+
+        cursor = connection.search("ou=users,dc=example,dc=com", "(cn=titi)", SearchScope.SUBTREE);
+
+        cursor.next();
+
+        userDn = cursor.get().getDn();
+
+        connection.setTimeOut(0L);
+        connectionPool.releaseConnection(connection);
+
+        connection = connectionPool.getConnection();
+        connection.setTimeOut(LdapConnectionConfig.DEFAULT_TIMEOUT);
+
+        connection.bind(userDn, "titi");
+
+        connection.setTimeOut(LdapConnectionConfig.DEFAULT_TIMEOUT);
+        connectionPool.releaseConnection(connection);
+    }
+
+    private LdapConnection getConnection(LdapConnectionPool pool) throws Exception
+    {
+        LdapConnection connection = null;
+
+        for (int retry = 0; retry < 2; retry++)
+        {
+            try
+            {
+                connection = pool.getConnection();
+                connection.setTimeOut(0L);
+
+                connection.bind();
+
+                return connection;
+            }
+            catch (Throwable ex)
+            {
+                ex.printStackTrace();
+                if (connection != null)
+                {
+                    pool.invalidateObject(connection);
+                }
+            }
+        }
+        return null;
+    }
+}
diff --git a/ldap/model/src/test/java/org/apache/directory/api/ldap/model/schema/parsers/OpenLdapSchemaParserTest.java b/ldap/model/src/test/java/org/apache/directory/api/ldap/model/schema/parsers/OpenLdapSchemaParserTest.java
index 0dcfbfb19..0e53e7c29 100644
--- a/ldap/model/src/test/java/org/apache/directory/api/ldap/model/schema/parsers/OpenLdapSchemaParserTest.java
+++ b/ldap/model/src/test/java/org/apache/directory/api/ldap/model/schema/parsers/OpenLdapSchemaParserTest.java
@@ -456,4 +456,25 @@ public void testDescWithSpaces() throws Exception
         assertEquals( "1.3.6.1.4.1.1466.115.121.1.15", attributeType.getSyntaxOid() );
         assertTrue( attributeType.isSingleValued() );
     }
+
+
+    @Test
+    public void testFastLdifParsePerf() throws Exception
+    {
+        OpenLdapSchemaParser parser = new OpenLdapSchemaParser();
+        parser.setQuirksMode( true );
+        long t0 = System.currentTimeMillis();
+
+        for ( int i = 0; i < 10_000; i++ )
+        {
+            try ( InputStream input = getClass().getResourceAsStream( "core.schema" ) )
+            {
+                parser.parse( input );
+                parser.clear();
+            }
+        }
+        long t1 = System.currentTimeMillis();
+        
+        System.out.println( t1 - t0 );
+    }
 }
diff --git a/pom.xml b/pom.xml
index 251533d0b..421382ba1 100644
--- a/pom.xml
+++ b/pom.xml
@@ -56,7 +56,7 @@
     <junit.version>4.12</junit.version>
     <log4j.version>1.2.17</log4j.version>
     <logback.version>1.2.3</logback.version>
-    <mina.core.version>2.0.17</mina.core.version>
+    <mina.core.version>2.0.18</mina.core.version>
     <org.osgi.core.version>6.0.0</org.osgi.core.version>
     <org.apache.felix.version>5.6.4</org.apache.felix.version>
     <pax-exam.version>4.11.0</pax-exam.version>
