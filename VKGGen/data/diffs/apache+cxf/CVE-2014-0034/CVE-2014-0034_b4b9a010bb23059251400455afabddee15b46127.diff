diff --git a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/token/validator/SAMLTokenValidator.java b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/token/validator/SAMLTokenValidator.java
index 5e78f3b1831..3bff17a0b32 100644
--- a/services/sts/sts-core/src/main/java/org/apache/cxf/sts/token/validator/SAMLTokenValidator.java
+++ b/services/sts/sts-core/src/main/java/org/apache/cxf/sts/token/validator/SAMLTokenValidator.java
@@ -153,6 +153,29 @@ public TokenValidatorResponse validateToken(TokenValidatorParameters tokenParame
             SAMLTokenPrincipal samlPrincipal = new SAMLTokenPrincipalImpl(assertion);
             response.setPrincipal(samlPrincipal);
             
+            if (!assertion.isSigned()) {
+                LOG.log(Level.WARNING, "The received assertion is not signed, and therefore not trusted");
+                return response;
+            }
+
+            RequestData requestData = new RequestData();
+            requestData.setSigVerCrypto(sigCrypto);
+            WSSConfig wssConfig = WSSConfig.getNewInstance();
+            requestData.setWssConfig(wssConfig);
+            requestData.setCallbackHandler(callbackHandler);
+            requestData.setMsgContext(tokenParameters.getWebServiceContext().getMessageContext());
+
+            WSDocInfo docInfo = new WSDocInfo(validateTargetElement.getOwnerDocument());
+
+            // Verify the signature
+            Signature sig = assertion.getSignature();
+            KeyInfo keyInfo = sig.getKeyInfo();
+            SAMLKeyInfo samlKeyInfo = 
+                SAMLUtil.getCredentialFromKeyInfo(
+                    keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(requestData, docInfo), sigCrypto
+                );
+            assertion.verifySignature(samlKeyInfo);
+                
             SecurityToken secToken = null;
             byte[] signatureValue = assertion.getSignatureValue();
             if (tokenParameters.getTokenStore() != null && signatureValue != null
@@ -169,29 +192,6 @@ public TokenValidatorResponse validateToken(TokenValidatorParameters tokenParame
             }
             
             if (secToken == null) {
-                if (!assertion.isSigned()) {
-                    LOG.log(Level.WARNING, "The received assertion is not signed, and therefore not trusted");
-                    return response;
-                }
-                
-                RequestData requestData = new RequestData();
-                requestData.setSigVerCrypto(sigCrypto);
-                WSSConfig wssConfig = WSSConfig.getNewInstance();
-                requestData.setWssConfig(wssConfig);
-                requestData.setCallbackHandler(callbackHandler);
-                requestData.setMsgContext(tokenParameters.getWebServiceContext().getMessageContext());
-
-                WSDocInfo docInfo = new WSDocInfo(validateTargetElement.getOwnerDocument());
-                
-                // Verify the signature
-                Signature sig = assertion.getSignature();
-                KeyInfo keyInfo = sig.getKeyInfo();
-                SAMLKeyInfo samlKeyInfo = 
-                    SAMLUtil.getCredentialFromKeyInfo(
-                        keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(requestData, docInfo), sigCrypto
-                    );
-                assertion.verifySignature(samlKeyInfo);
-                
                 // Validate the assertion against schemas/profiles
                 validateAssertion(assertion);
 
@@ -211,7 +211,6 @@ public TokenValidatorResponse validateToken(TokenValidatorParameters tokenParame
                 if (!certConstraints.matches(cert)) {
                     return response;
                 }
-                
             }
             
             // Parse roles from the validated token
diff --git a/services/sts/sts-core/src/test/java/org/apache/cxf/sts/token/validator/SAMLTokenValidatorTest.java b/services/sts/sts-core/src/test/java/org/apache/cxf/sts/token/validator/SAMLTokenValidatorTest.java
index 31f1ec125b5..0e8ab23fde9 100644
--- a/services/sts/sts-core/src/test/java/org/apache/cxf/sts/token/validator/SAMLTokenValidatorTest.java
+++ b/services/sts/sts-core/src/test/java/org/apache/cxf/sts/token/validator/SAMLTokenValidatorTest.java
@@ -34,6 +34,7 @@
 
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
+
 import org.apache.cxf.jaxws.context.WebServiceContextImpl;
 import org.apache.cxf.jaxws.context.WrappedMessageContext;
 import org.apache.cxf.message.MessageImpl;
@@ -425,6 +426,53 @@ public void testSAML2AssertionWithRolesCaching() throws Exception {
         assertTrue(roles.iterator().next().getName().equals("employee"));
     }
     
+    /**
+     * Test an invalid SAML 2 Assertion
+     */
+    @org.junit.Test
+    public void testInvalidSAML2Assertion() throws Exception {
+        TokenValidator samlTokenValidator = new SAMLTokenValidator();
+        TokenValidatorParameters validatorParameters = createValidatorParameters();
+        TokenRequirements tokenRequirements = validatorParameters.getTokenRequirements();
+        
+        // Create a ValidateTarget consisting of a SAML Assertion
+        Crypto crypto = CryptoFactory.getInstance(getEncryptionProperties());
+        CallbackHandler callbackHandler = new PasswordCallbackHandler();
+        Element samlToken = 
+            createSAMLAssertion(WSConstants.WSS_SAML2_TOKEN_TYPE, crypto, "mystskey", callbackHandler);
+        Document doc = samlToken.getOwnerDocument();
+        samlToken = (Element)doc.appendChild(samlToken);
+        
+        ReceivedToken validateTarget = new ReceivedToken(samlToken);
+        tokenRequirements.setValidateTarget(validateTarget);
+        validatorParameters.setToken(validateTarget);
+        
+        assertTrue(samlTokenValidator.canHandleToken(validateTarget));
+        
+        TokenValidatorResponse validatorResponse = 
+            samlTokenValidator.validateToken(validatorParameters);
+        assertTrue(validatorResponse != null);
+        assertTrue(validatorResponse.getToken() != null);
+        assertTrue(validatorResponse.getToken().getState() == STATE.VALID);
+        
+        // Replace "alice" with "bob".
+        Element nameID = 
+            (Element)samlToken.getElementsByTagNameNS(WSConstants.SAML2_NS, "NameID").item(0);
+        nameID.setTextContent("bob");
+        
+        // Now validate again
+        validateTarget = new ReceivedToken(samlToken);
+        tokenRequirements.setValidateTarget(validateTarget);
+        validatorParameters.setToken(validateTarget);
+        
+        assertTrue(samlTokenValidator.canHandleToken(validateTarget));
+        
+        validatorResponse = samlTokenValidator.validateToken(validatorParameters);
+        assertTrue(validatorResponse != null);
+        assertTrue(validatorResponse.getToken() != null);
+        assertTrue(validatorResponse.getToken().getState() != STATE.VALID);
+    }
+    
     private TokenValidatorParameters createValidatorParameters() throws WSSecurityException {
         TokenValidatorParameters parameters = new TokenValidatorParameters();
         
@@ -627,5 +675,5 @@ public void handle(Callback[] callbacks) throws IOException,
         }
     }
     
-    
+
 }
