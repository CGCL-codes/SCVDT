commit 775d5fa422c231f9de36d6cc0aabd9a0e5d5feab
Author:     Mark Emlyn David Thomas <markt@apache.org>
AuthorDate: Wed Aug 29 20:21:01 2012 +0000
Commit:     Mark Emlyn David Thomas <markt@apache.org>
CommitDate: Wed Aug 29 20:21:01 2012 +0000

    Resolve a FIXME and expand unit tests to cover CRLF vs LF checking.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1378699 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java b/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
index 05d3d7ef22..dc94f8a5ef 100644
--- a/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
@@ -144,7 +144,7 @@ public class ChunkedInputFilter implements InputFilter {
 
         if(needCRLFParse) {
             needCRLFParse = false;
-            parseCRLF();
+            parseCRLF(false);
         }
 
         if (remaining <= 0) {
@@ -179,7 +179,7 @@ public class ChunkedInputFilter implements InputFilter {
                 //so we defer it to the next call BZ 11117
                 needCRLFParse = true;
             } else {
-                parseCRLF(); //parse the CRLF immediately
+                parseCRLF(false); //parse the CRLF immediately
             }
         }
 
@@ -305,9 +305,8 @@ public class ChunkedInputFilter implements InputFilter {
                     return false;
             }
 
-            if (buf[pos] == Constants.CR) {
-                // FIXME: Improve parsing to check for CRLF
-            } else if (buf[pos] == Constants.LF) {
+            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {
+                parseCRLF(false);
                 eol = true;
             } else if (buf[pos] == Constants.SEMI_COLON) {
                 trailer = true;
@@ -325,7 +324,10 @@ public class ChunkedInputFilter implements InputFilter {
                 }
             }
 
-            pos++;
+            // Parsing the CRLF increments pos
+            if (!eol) {
+                pos++;
+            }
 
         }
 
@@ -346,9 +348,21 @@ public class ChunkedInputFilter implements InputFilter {
 
     /**
      * Parse CRLF at end of chunk.
+     * @deprecated  Use {@link #parseCRLF(boolean)}
      */
-    protected boolean parseCRLF()
-        throws IOException {
+    @Deprecated
+    protected boolean parseCRLF() throws IOException {
+        return parseCRLF(false);
+    }
+
+    /**
+     * Parse CRLF at end of chunk.
+     *
+     * @param   tolerant    Should tolerant parsing (LF and CRLF) be used? This
+     *                      is recommended (RFC2616, section 19.3) for message
+     *                      headers.
+     */
+    protected boolean parseCRLF(boolean tolerant) throws IOException {
 
         boolean eol = false;
         boolean crfound = false;
@@ -364,7 +378,9 @@ public class ChunkedInputFilter implements InputFilter {
                 if (crfound) throw new IOException("Invalid CRLF, two CR characters encountered.");
                 crfound = true;
             } else if (buf[pos] == Constants.LF) {
-                if (!crfound) throw new IOException("Invalid CRLF, no CR character encountered.");
+                if (!tolerant && !crfound) {
+                    throw new IOException("Invalid CRLF, no CR character encountered.");
+                }
                 eol = true;
             } else {
                 throw new IOException("Invalid CRLF");
@@ -396,26 +412,19 @@ public class ChunkedInputFilter implements InputFilter {
         MimeHeaders headers = request.getMimeHeaders();
 
         byte chr = 0;
-        while (true) {
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (readBytes() <0)
-                    throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
-            }
 
-            chr = buf[pos];
-
-            if ((chr == Constants.CR) || (chr == Constants.LF)) {
-                if (chr == Constants.LF) {
-                    pos++;
-                    return false;
-                }
-            } else {
-                break;
-            }
+        // Read new bytes if needed
+        if (pos >= lastValid) {
+            if (readBytes() <0)
+                throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
+        }
 
-            pos++;
+        chr = buf[pos];
 
+        // CRLF terminates the request
+        if (chr == Constants.CR || chr == Constants.LF) {
+            parseCRLF(true);
+            return false;
         }
 
         // Mark the current buffer position
@@ -495,9 +504,8 @@ public class ChunkedInputFilter implements InputFilter {
                 }
 
                 chr = buf[pos];
-                if (chr == Constants.CR) {
-                    // Skip
-                } else if (chr == Constants.LF) {
+                if (chr == Constants.CR || chr == Constants.LF) {
+                    parseCRLF(true);
                     eol = true;
                 } else if (chr == Constants.SP) {
                     trailingHeaders.append(chr);
diff --git a/test/org/apache/catalina/startup/SimpleHttpClient.java b/test/org/apache/catalina/startup/SimpleHttpClient.java
index 0c96f0889b..b3190ebfe9 100644
--- a/test/org/apache/catalina/startup/SimpleHttpClient.java
+++ b/test/org/apache/catalina/startup/SimpleHttpClient.java
@@ -201,7 +201,13 @@ public abstract class SimpleHttpClient {
                 line = readLine();
                 while (line != null) {
                     builder.append(line);
-                    line = readLine();
+                    try {
+                        line = readLine();
+                    } catch (IOException ioe) {
+                        // The server probably closed the connection due to an
+                        // error
+                        line = null;
+                    }
                 }
             }
         }
diff --git a/test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java b/test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java
index a57182ed30..7bf978d2ed 100644
--- a/test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java
+++ b/test/org/apache/coyote/http11/filters/TestChunkedInputFilter.java
@@ -38,8 +38,52 @@ import org.apache.catalina.startup.TomcatBaseTest;
 
 public class TestChunkedInputFilter extends TomcatBaseTest {
 
+    private static final String LF = "\n";
+
+    @Test
+    public void testChunkHeaderCRLF() throws Exception {
+        doTestChunkingCRLF(true, true, true, true, true);
+    }
+
+    @Test
+    public void testChunkHeaderLF() throws Exception {
+        doTestChunkingCRLF(false, true, true, true, false);
+    }
+
+    @Test
+    public void testChunkCRLF() throws Exception {
+        doTestChunkingCRLF(true, true, true, true, true);
+    }
+
+    @Test
+    public void testChunkLF() throws Exception {
+        doTestChunkingCRLF(true, false, true, true, false);
+    }
+
+    @Test
+    public void testTrailingHeadersCRLF() throws Exception {
+        doTestChunkingCRLF(true, true, true, true, true);
+    }
+
+    @Test
+    public void testTrailingHeadersLF() throws Exception {
+        doTestChunkingCRLF(true, true, false, true, true);
+    }
+
     @Test
-    public void testTrailingHeaders() throws Exception {
+    public void testEndCRLF() throws Exception {
+        doTestChunkingCRLF(true, true, true, true, true);
+    }
+
+    @Test
+    public void testEndLF() throws Exception {
+        doTestChunkingCRLF(true, true, true, false, false);
+    }
+
+    private void doTestChunkingCRLF(boolean chunkHeaderUsesCRLF,
+            boolean chunkUsesCRLF, boolean headerUsesCRLF,
+            boolean endUsesCRLF, boolean expectPass) throws Exception {
+
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
 
@@ -60,13 +104,14 @@ public class TestChunkedInputFilter extends TomcatBaseTest {
                     SimpleHttpClient.CRLF +
             "Connection: close" + SimpleHttpClient.CRLF +
             SimpleHttpClient.CRLF +
-            "3" + SimpleHttpClient.CRLF +
-            "a=0" + SimpleHttpClient.CRLF +
+            "3" + (chunkHeaderUsesCRLF ? SimpleHttpClient.CRLF : LF) +
+            "a=0" + (chunkUsesCRLF ? SimpleHttpClient.CRLF : LF) +
             "4" + SimpleHttpClient.CRLF +
             "&b=1" + SimpleHttpClient.CRLF +
             "0" + SimpleHttpClient.CRLF +
-            "x-trailer: Test", "TestTest0123456789abcdefghijABCDEFGHIJopqrstuvwxyz" + SimpleHttpClient.CRLF +
-            SimpleHttpClient.CRLF };
+            "x-trailer: Test", "TestTest0123456789abcdefghijABCDEFGHIJopqrstuvwxyz" +
+            (headerUsesCRLF ? SimpleHttpClient.CRLF : LF)+
+            (endUsesCRLF ? SimpleHttpClient.CRLF : LF) };
 
         TrailerClient client =
                 new TrailerClient(tomcat.getConnector().getLocalPort());
@@ -74,7 +119,13 @@ public class TestChunkedInputFilter extends TomcatBaseTest {
 
         client.connect();
         client.processRequest();
-        assertEquals("null7TestTestTest0123456789abcdefghijABCDEFGHIJopqrstuvwxyz", client.getResponseBody());
+
+        if (expectPass) {
+            assertTrue(client.isResponse200());
+            assertEquals("null7TestTestTest0123456789abcdefghijABCDEFGHIJopqrstuvwxyz", client.getResponseBody());
+        } else {
+            assertTrue(client.getResponseLine(), client.isResponse500());
+        }
     }
 
     @Test
