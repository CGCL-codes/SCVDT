commit 593a2447e6ebe465585cfa07e93b5635dffa1c70
Author:     Mark Emlyn David Thomas <markt@apache.org>
AuthorDate: Fri Jun 6 19:14:07 2014 +0000
Commit:     Mark Emlyn David Thomas <markt@apache.org>
CommitDate: Fri Jun 6 19:14:07 2014 +0000

    i18n for ChunkedInputFilter error message
    Add error flag to allow subsequent attempts at reading after an error to fail fast
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1600984 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java b/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
index 25bae597e1..82ef3452ca 100644
--- a/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
@@ -28,6 +28,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.HexUtils;
 import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.http.MimeHeaders;
+import org.apache.tomcat.util.res.StringManager;
 
 /**
  * Chunked input filter. Parses chunked data according to
@@ -37,6 +38,9 @@ import org.apache.tomcat.util.http.MimeHeaders;
  */
 public class ChunkedInputFilter implements InputFilter {
 
+    private static final StringManager sm = StringManager.getManager(
+            ChunkedInputFilter.class.getPackage().getName());
+
 
     // -------------------------------------------------------------- Constants
 
@@ -133,6 +137,12 @@ public class ChunkedInputFilter implements InputFilter {
     private long extensionSize;
 
 
+    /**
+     * Flag that indicates if an error has occurred.
+     */
+    private boolean error;
+
+
     // ----------------------------------------------------------- Constructors
 
     public ChunkedInputFilter(int maxTrailerSize, int maxExtensionSize) {
@@ -155,6 +165,7 @@ public class ChunkedInputFilter implements InputFilter {
      */
     @Override
     public int doRead(ByteChunk chunk, Request req) throws IOException {
+        checkError();
 
         if (endChunk) {
             return -1;
@@ -167,7 +178,7 @@ public class ChunkedInputFilter implements InputFilter {
 
         if (remaining <= 0) {
             if (!parseChunkHeader()) {
-                throw new IOException("Invalid chunk header");
+                throwIOException(sm.getString("chunkedInputFilter.invalidHeader"));
             }
             if (endChunk) {
                 parseEndChunk();
@@ -179,8 +190,7 @@ public class ChunkedInputFilter implements InputFilter {
 
         if (pos >= lastValid) {
             if (readBytes() < 0) {
-                throw new IOException(
-                        "Unexpected end of stream whilst reading request body");
+                throwIOException(sm.getString("chunkedInputFilter.eos"));
             }
         }
 
@@ -224,6 +234,7 @@ public class ChunkedInputFilter implements InputFilter {
      */
     @Override
     public long end() throws IOException {
+        checkError();
 
         // Consume extra bytes : parse the stream until the end chunk is found
         while (doRead(readChunk, null) >= 0) {
@@ -266,6 +277,7 @@ public class ChunkedInputFilter implements InputFilter {
         trailingHeaders.recycle();
         trailingHeaders.setLimit(maxTrailerSize);
         extensionSize = 0;
+        error = false;
     }
 
 
@@ -279,6 +291,12 @@ public class ChunkedInputFilter implements InputFilter {
     }
 
 
+    @Override
+    public boolean isFinished() {
+        return endChunk;
+    }
+
+
     // ------------------------------------------------------ Protected Methods
 
     /**
@@ -346,7 +364,7 @@ public class ChunkedInputFilter implements InputFilter {
                 // validated. Currently it is simply ignored.
                 extensionSize++;
                 if (maxExtensionSize > -1 && extensionSize > maxExtensionSize) {
-                    throw new IOException("maxExtensionSize exceeded");
+                    throwIOException(sm.getString("chunkedInputFilter.maxExtension"));
                 }
             }
 
@@ -387,20 +405,23 @@ public class ChunkedInputFilter implements InputFilter {
 
         while (!eol) {
             if (pos >= lastValid) {
-                if (readBytes() <= 0)
-                    throw new IOException("Invalid CRLF");
+                if (readBytes() <= 0) {
+                    throwIOException(sm.getString("chunkedInputFilter.invalidCrlfNoData"));
+                }
             }
 
             if (buf[pos] == Constants.CR) {
-                if (crfound) throw new IOException("Invalid CRLF, two CR characters encountered.");
+                if (crfound) {
+                    throwIOException(sm.getString("chunkedInputFilter.invalidCrlfCRCR"));
+                }
                 crfound = true;
             } else if (buf[pos] == Constants.LF) {
                 if (!tolerant && !crfound) {
-                    throw new IOException("Invalid CRLF, no CR character encountered.");
+                    throwIOException(sm.getString("chunkedInputFilter.invalidCrlfNoCR"));
                 }
                 eol = true;
             } else {
-                throw new IOException("Invalid CRLF");
+                throwIOException(sm.getString("chunkedInputFilter.invalidCrlf"));
             }
 
             pos++;
@@ -412,7 +433,6 @@ public class ChunkedInputFilter implements InputFilter {
      * Parse end chunk data.
      */
     protected void parseEndChunk() throws IOException {
-
         // Handle optional trailer headers
         while (parseHeader()) {
             // Loop until we run out of headers
@@ -428,8 +448,9 @@ public class ChunkedInputFilter implements InputFilter {
 
         // Read new bytes if needed
         if (pos >= lastValid) {
-            if (readBytes() <0)
-                throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
+            if (readBytes() <0) {
+               throwEOFException(sm.getString("chunkedInputFilter.eosTrailer"));
+            }
         }
 
         chr = buf[pos];
@@ -453,8 +474,9 @@ public class ChunkedInputFilter implements InputFilter {
 
             // Read new bytes if needed
             if (pos >= lastValid) {
-                if (readBytes() <0)
-                    throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
+                if (readBytes() <0) {
+                    throwEOFException(sm.getString("chunkedInputFilter.eosTrailer"));
+                }
             }
 
             chr = buf[pos];
@@ -494,8 +516,9 @@ public class ChunkedInputFilter implements InputFilter {
 
                 // Read new bytes if needed
                 if (pos >= lastValid) {
-                    if (readBytes() <0)
-                        throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
+                    if (readBytes() <0) {
+                        throwEOFException(sm.getString("chunkedInputFilter.eosTrailer"));
+                    }
                 }
 
                 chr = buf[pos];
@@ -505,7 +528,7 @@ public class ChunkedInputFilter implements InputFilter {
                     // limit placed on trailing header size
                     int newlimit = trailingHeaders.getLimit() -1;
                     if (trailingHeaders.getEnd() > newlimit) {
-                        throw new IOException("Exceeded maxTrailerSize");
+                        throw new IOException(sm.getString("chunkedInputFilter.maxTrailer"));
                     }
                     trailingHeaders.setLimit(newlimit);
                 } else {
@@ -519,8 +542,9 @@ public class ChunkedInputFilter implements InputFilter {
 
                 // Read new bytes if needed
                 if (pos >= lastValid) {
-                    if (readBytes() <0)
-                        throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
+                    if (readBytes() <0) {
+                        throwEOFException(sm.getString("chunkedInputFilter.eosTrailer"));
+                    }
                 }
 
                 chr = buf[pos];
@@ -544,8 +568,9 @@ public class ChunkedInputFilter implements InputFilter {
 
             // Read new bytes if needed
             if (pos >= lastValid) {
-                if (readBytes() <0)
-                    throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
+                if (readBytes() <0) {
+                    throwEOFException(sm.getString("chunkedInputFilter.eosTrailer"));
+                }
             }
 
             chr = buf[pos];
@@ -568,8 +593,21 @@ public class ChunkedInputFilter implements InputFilter {
     }
 
 
-    @Override
-    public boolean isFinished() {
-        return endChunk;
+    private void throwIOException(String msg) throws IOException {
+        error = true;
+        throw new IOException(msg);
+    }
+
+
+    private void throwEOFException(String msg) throws IOException {
+        error = true;
+        throw new EOFException(msg);
+    }
+
+
+    private void checkError() throws IOException {
+        if (error) {
+            throw new IOException(sm.getString("chunkedInputFilter.error"));
+        }
     }
 }
diff --git a/java/org/apache/coyote/http11/filters/LocalStrings.properties b/java/org/apache/coyote/http11/filters/LocalStrings.properties
new file mode 100644
index 0000000000..b4723657f5
--- /dev/null
+++ b/java/org/apache/coyote/http11/filters/LocalStrings.properties
@@ -0,0 +1,25 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+chunkedInputFilter.error=No data available due to previous error
+chunkedInputFilter.eos=Unexpected end of stream while reading request body
+chunkedInputFilter.eosTrailer=Unexpected end of stream while reading trailer headers
+chunkedInputFilter.invalidCrlf=Invalid end of line sequence (character other than CR or LF found)
+chunkedInputFilter.invalidCrlfCRCR=Invalid end of line sequence (CRCR)
+chunkedInputFilter.invalidCrlfNoCR=Invalid end of line sequence (No CR before LF)
+chunkedInputFilter.invalidCrlfNoData=Invalid end of line sequence (no data available to read)
+chunkedInputFilter.invalidHeader=Invalid chunk header
+chunkedInputFilter.maxExtension=maxExtensionSize exceeded
+chunkedInputFilter.maxTrailer=maxTrailerSize exceeded
\ No newline at end of file
