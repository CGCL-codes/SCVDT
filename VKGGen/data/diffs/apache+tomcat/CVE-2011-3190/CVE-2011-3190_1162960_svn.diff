Index: tc5.5.x/trunk/container/webapps/docs/changelog.xml
===================================================================
--- tc5.5.x/trunk/container/webapps/docs/changelog.xml	(revision 1162959)
+++ tc5.5.x/trunk/container/webapps/docs/changelog.xml	(revision 1162960)
@@ -125,6 +125,10 @@
         if it is configured for SSL and an invalid value is provided for
         SSLProtocol. (markt)
       </fix>
+      <fix>
+        <bug>51698</bug>: Fix CVE-2011-3190. Prevent AJP message injection.
+        (markt)
+      </fix>
     </changelog>
   </subsection>
   <subsection name="Jasper">
Index: tc5.5.x/trunk/connectors/jk/java/org/apache/coyote/ajp/AjpAprProcessor.java
===================================================================
--- tc5.5.x/trunk/connectors/jk/java/org/apache/coyote/ajp/AjpAprProcessor.java	(revision 1162959)
+++ tc5.5.x/trunk/connectors/jk/java/org/apache/coyote/ajp/AjpAprProcessor.java	(revision 1162960)
@@ -404,11 +404,13 @@
                     }
                     continue;
                 } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {
-                    // Usually the servlet didn't read the previous request body
-                    if(log.isDebugEnabled()) {
-                        log.debug("Unexpected message: "+type);
+                    // Unexpected packet type. Unread body packets should have
+                    // been swallowed in finish().
+                    if (log.isDebugEnabled()) {
+                        log.debug("Unexpected message: " + type);
                     }
-                    continue;
+                    error = true;
+                    break;
                 }
 
                 keptAlive = true;
@@ -1033,6 +1035,11 @@
 
         finished = true;
 
+        // Swallow the unread body packet if present
+        if (first && request.getContentLengthLong() > 0) {
+            receive();
+        }
+        
         // Add the end message
         if (outputBuffer.position() + endMessageArray.length > outputBuffer.capacity()) {
             flush();
