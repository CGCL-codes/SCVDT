Index: trunk/java/org/apache/coyote/AbstractProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/AbstractProcessor.java	(revision 1833824)
+++ trunk/java/org/apache/coyote/AbstractProcessor.java	(revision 1833825)
@@ -51,6 +51,7 @@
     protected final Adapter adapter;
     protected final AsyncStateMachine asyncStateMachine;
     private volatile long asyncTimeout = -1;
+    private volatile long asyncTimeoutGeneration = 0;
     protected final Request request;
     protected final Response response;
     protected volatile SocketWrapperBase<?> socketWrapper = null;
@@ -620,10 +621,17 @@
     private void doTimeoutAsync() {
         // Avoid multiple timeouts
         setAsyncTimeout(-1);
+        asyncTimeoutGeneration = asyncStateMachine.getCurrentGeneration();
         processSocketEvent(SocketEvent.TIMEOUT, true);
     }
 
 
+    @Override
+    public boolean checkAsyncTimeoutGeneration() {
+        return asyncTimeoutGeneration == asyncStateMachine.getCurrentGeneration();
+    }
+
+
     public void setAsyncTimeout(long timeout) {
         asyncTimeout = timeout;
     }
Index: trunk/java/org/apache/coyote/AbstractProtocol.java
===================================================================
--- trunk/java/org/apache/coyote/AbstractProtocol.java	(revision 1833824)
+++ trunk/java/org/apache/coyote/AbstractProtocol.java	(revision 1833825)
@@ -683,6 +683,16 @@
                         processor, socket));
             }
 
+            // Async timeouts are calculated on a dedicated thread and then
+            // dispatched. Because of delays in the dispatch process, the
+            // timeout may no longer be required. Check here and avoid
+            // unnecessary processing.
+            if (SocketEvent.TIMEOUT == status && (processor == null ||
+                    !processor.isAsync() || !processor.checkAsyncTimeoutGeneration())) {
+                // This is effectively a NO-OP
+                return SocketState.OPEN;
+            }
+
             if (processor != null) {
                 // Make sure an async timeout doesn't fire
                 getProtocol().removeWaitingProcessor(processor);
Index: trunk/java/org/apache/coyote/AsyncStateMachine.java
===================================================================
--- trunk/java/org/apache/coyote/AsyncStateMachine.java	(revision 1833824)
+++ trunk/java/org/apache/coyote/AsyncStateMachine.java	(revision 1833825)
@@ -18,6 +18,7 @@
 
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.res.StringManager;
@@ -189,6 +190,7 @@
 
     private volatile AsyncState state = AsyncState.DISPATCHED;
     private volatile long lastAsyncStart = 0;
+    private AtomicLong generation = new AtomicLong(0);
     // Need this to fire listener on complete
     private AsyncContextCallback asyncCtxt = null;
     private final AbstractProcessor processor;
@@ -234,8 +236,13 @@
         return lastAsyncStart;
     }
 
+    long getCurrentGeneration() {
+        return generation.get();
+    }
+
     synchronized void asyncStart(AsyncContextCallback asyncCtxt) {
         if (state == AsyncState.DISPATCHED) {
+            generation.incrementAndGet();
             state = AsyncState.STARTING;
             this.asyncCtxt = asyncCtxt;
             lastAsyncStart = System.currentTimeMillis();
Index: trunk/java/org/apache/coyote/Processor.java
===================================================================
--- trunk/java/org/apache/coyote/Processor.java	(revision 1833824)
+++ trunk/java/org/apache/coyote/Processor.java	(revision 1833825)
@@ -110,4 +110,15 @@
      * an existing multiplexed connection.
      */
     void pause();
+
+    /**
+     * Check to see if the async generation (each cycle of async increments the
+     * generation of the AsyncStateMachine) is the same as the generation when
+     * the most recent async timeout was triggered. This is intended to be used
+     * to avoid unnecessary processing.
+     *
+     * @return {@code true} If the async generation has not changed since the
+     *         async timeout was triggered
+     */
+    boolean checkAsyncTimeoutGeneration();
 }
Index: trunk/java/org/apache/coyote/http11/upgrade/UpgradeProcessorBase.java
===================================================================
--- trunk/java/org/apache/coyote/http11/upgrade/UpgradeProcessorBase.java	(revision 1833824)
+++ trunk/java/org/apache/coyote/http11/upgrade/UpgradeProcessorBase.java	(revision 1833825)
@@ -94,4 +94,10 @@
     public void timeoutAsync(long now) {
         // NO-OP
     }
+
+
+    @Override
+    public boolean checkAsyncTimeoutGeneration() {
+        return false;
+    }
 }
Index: trunk/webapps/docs/changelog.xml
===================================================================
--- trunk/webapps/docs/changelog.xml	(revision 1833824)
+++ trunk/webapps/docs/changelog.xml	(revision 1833825)
@@ -211,6 +211,9 @@
         Fix <code>NullPointerException</code> thrown from <code>
         replaceSystemProperties()</code> when trying to log messages. (csutherl)
       </fix>
+      <fix>
+        Avoid unnecessary processing of async timeouts. (markt)
+      </fix>
     </changelog>
   </subsection>
   <subsection name="Jasper">
