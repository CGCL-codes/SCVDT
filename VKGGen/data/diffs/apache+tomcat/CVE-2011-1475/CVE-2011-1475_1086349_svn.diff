Index: trunk/java/org/apache/coyote/http11/Http11Protocol.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11Protocol.java	(revision 1086348)
+++ trunk/java/org/apache/coyote/http11/Http11Protocol.java	(revision 1086349)
@@ -194,6 +194,7 @@
                     return processor.asyncPostProcess();
                 } else {
                     socket.setAsync(false);
+                    processor.recycle();
                     recycledProcessors.offer(processor);
                 }
                 return state;
@@ -216,6 +217,7 @@
                 // less-than-verbose logs.
                 log.error(sm.getString("http11protocol.proto.error"), e);
             }
+            processor.recycle();
             recycledProcessors.offer(processor);
             return SocketState.CLOSED;
         }
Index: trunk/java/org/apache/coyote/http11/Http11AprProtocol.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11AprProtocol.java	(revision 1086348)
+++ trunk/java/org/apache/coyote/http11/Http11AprProtocol.java	(revision 1086349)
@@ -296,6 +296,7 @@
                         if (state != SocketState.LONG) {
                             connections.remove(socket.getSocket());
                             socket.setAsync(false);
+                            processor.recycle();
                             recycledProcessors.offer(processor);
                             if (state == SocketState.OPEN) {
                                 ((AprEndpoint)proto.endpoint).getPoller().add(socket.getSocket().longValue());
@@ -337,6 +338,7 @@
                                 socket.getSocket().longValue());
                     }
                 } else {
+                    processor.recycle();
                     recycledProcessors.offer(processor);
                 }
                 return state;
@@ -361,6 +363,7 @@
                 Http11AprProtocol.log.error(
                         sm.getString("http11protocol.proto.error"), e);
             }
+            processor.recycle();
             recycledProcessors.offer(processor);
             return SocketState.CLOSED;
         }
@@ -391,6 +394,7 @@
                     if (state != SocketState.LONG && state != SocketState.ASYNC_END) {
                         connections.remove(socket.getSocket());
                         socket.setAsync(false);
+                        processor.recycle();
                         recycledProcessors.offer(processor);
                         if (state == SocketState.OPEN) {
                             ((AprEndpoint)proto.endpoint).getPoller().add(socket.getSocket().longValue());
Index: trunk/java/org/apache/coyote/http11/Http11Processor.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11Processor.java	(revision 1086348)
+++ trunk/java/org/apache/coyote/http11/Http11Processor.java	(revision 1086349)
@@ -356,12 +356,10 @@
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
 
         if (error) {
-            recycle();
             return SocketState.CLOSED;
         } else if (isAsync()) {
             return SocketState.LONG;
         } else {
-            recycle();
             if (!keepAlive) {
                 return SocketState.CLOSED;
             } else {
Index: trunk/java/org/apache/coyote/http11/Http11AprProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11AprProcessor.java	(revision 1086348)
+++ trunk/java/org/apache/coyote/http11/Http11AprProcessor.java	(revision 1086349)
@@ -187,12 +187,10 @@
         if (error) {
             inputBuffer.nextRequest();
             outputBuffer.nextRequest();
-            recycle();
             return SocketState.CLOSED;
         } else if (!comet) {
             inputBuffer.nextRequest();
             outputBuffer.nextRequest();
-            recycle();
             return SocketState.OPEN;
         } else {
             return SocketState.LONG;
@@ -367,12 +365,10 @@
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
 
         if (error || endpoint.isPaused()) {
-            recycle();
             return SocketState.CLOSED;
         } else if (comet  || isAsync()) {
             return SocketState.LONG;
         } else {
-            recycle();
             return (openSocket) ? SocketState.OPEN : SocketState.CLOSED;
         }
         
@@ -406,12 +402,10 @@
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
 
         if (error) {
-            recycle();
             return SocketState.CLOSED;
         } else if (isAsync()) {
             return SocketState.LONG;
         } else {
-            recycle();
             if (!keepAlive) {
                 return SocketState.CLOSED;
             } else {
Index: trunk/java/org/apache/coyote/http11/Http11NioProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11NioProcessor.java	(revision 1086348)
+++ trunk/java/org/apache/coyote/http11/Http11NioProcessor.java	(revision 1086349)
@@ -206,10 +206,8 @@
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
 
         if (error) {
-            recycle();
             return SocketState.CLOSED;
         } else if (!comet) {
-            recycle();
             return (keepAlive)?SocketState.OPEN:SocketState.CLOSED;
         } else {
             return SocketState.LONG;
@@ -267,10 +265,8 @@
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
 
         if (error) {
-            recycle();
             return SocketState.CLOSED;
         } else if (!comet && !isAsync()) {
-            recycle();
             return (keepAlive)?SocketState.OPEN:SocketState.CLOSED;
         } else {
             return SocketState.LONG;
@@ -305,7 +301,7 @@
 
         boolean keptAlive = false;
         boolean openSocket = false;
-        boolean recycle = true;
+        boolean readComplete = true;
         final KeyAttachment ka = (KeyAttachment)socket.getAttachment(false);
         
         while (!error && keepAlive && !comet && !isAsync() && !endpoint.isPaused()) {
@@ -328,7 +324,7 @@
                     } else {
                         // Started to read request line. Need to keep processor
                         // associated with socket
-                        recycle = false;
+                        readComplete = false;
                     }
                     if (endpoint.isPaused()) {
                         // 503 - Service unavailable
@@ -345,7 +341,7 @@
                         //we've read part of the request, don't recycle it
                         //instead associate it with the socket
                         openSocket = true;
-                        recycle = false;
+                        readComplete = false;
                         break;
                     }
                     request.setStartTime(System.currentTimeMillis());
@@ -471,16 +467,11 @@
 
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
         if (error || endpoint.isPaused()) {
-            recycle();
             return SocketState.CLOSED;
         } else if (comet || isAsync()) {
             return SocketState.LONG;
         } else {
-            if (recycle) {
-                recycle();
-            }
-            //return (openSocket) ? (SocketState.OPEN) : SocketState.CLOSED;
-            return (openSocket) ? (recycle?SocketState.OPEN:SocketState.LONG) : SocketState.CLOSED;
+            return (openSocket) ? (readComplete?SocketState.OPEN:SocketState.LONG) : SocketState.CLOSED;
         }
 
     }
Index: trunk/java/org/apache/coyote/ajp/AjpAprProtocol.java
===================================================================
--- trunk/java/org/apache/coyote/ajp/AjpAprProtocol.java	(revision 1086348)
+++ trunk/java/org/apache/coyote/ajp/AjpAprProtocol.java	(revision 1086349)
@@ -197,6 +197,7 @@
                     connections.put(socket, processor);
                     socket.setAsync(true);
                 } else {
+                    processor.recycle();
                     recycledProcessors.offer(processor);
                 }
                 return state;
@@ -220,6 +221,7 @@
                 // less-than-verbose logs.
                 log.error(sm.getString("ajpprotocol.proto.error"), e);
             }
+            processor.recycle();
             recycledProcessors.offer(processor);
             return SocketState.CLOSED;
         }
@@ -251,6 +253,7 @@
                     }
                     if (state != SocketState.LONG && state != SocketState.ASYNC_END) {
                         connections.remove(socket);
+                        processor.recycle();
                         recycledProcessors.offer(processor);
                         if (state == SocketState.OPEN) {
                             ((AprEndpoint)proto.endpoint).getPoller().add(socket.getSocket().longValue());
Index: trunk/java/org/apache/coyote/ajp/AjpProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/ajp/AjpProcessor.java	(revision 1086348)
+++ trunk/java/org/apache/coyote/ajp/AjpProcessor.java	(revision 1086349)
@@ -334,7 +334,6 @@
 
             rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
             recycle();
-
         }
         
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
@@ -342,7 +341,6 @@
         if (isAsync() && !error && !endpoint.isPaused()) {
             return SocketState.LONG;
         } else {
-            recycle();
             input = null;
             output = null;
             return SocketState.CLOSED;
@@ -373,7 +371,6 @@
             if (error) {
                 response.setStatus(500);
                 request.updateCounters();
-                recycle();
                 input = null;
                 output = null;
                 return SocketState.CLOSED;
@@ -385,7 +382,6 @@
                 response.setStatus(500);
             }
             request.updateCounters();
-            recycle();
             input = null;
             output = null;
             return SocketState.CLOSED;
Index: trunk/java/org/apache/coyote/ajp/AjpProtocol.java
===================================================================
--- trunk/java/org/apache/coyote/ajp/AjpProtocol.java	(revision 1086348)
+++ trunk/java/org/apache/coyote/ajp/AjpProtocol.java	(revision 1086349)
@@ -189,6 +189,7 @@
                     return processor.asyncPostProcess();
                 } else {
                     socket.setAsync(false);
+                    processor.recycle();
                     recycledProcessors.offer(processor);
                 }
                 return state;
@@ -211,6 +212,7 @@
                 // less-than-verbose logs.
                 log.error(sm.getString("ajpprotocol.proto.error"), e);
             }
+            processor.recycle();
             recycledProcessors.offer(processor);
             return SocketState.CLOSED;
         }
Index: trunk/java/org/apache/coyote/ajp/AjpAprProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/ajp/AjpAprProcessor.java	(revision 1086348)
+++ trunk/java/org/apache/coyote/ajp/AjpAprProcessor.java	(revision 1086349)
@@ -316,7 +316,6 @@
 
             rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
             recycle();
-
         }
 
         // Add the socket to the poller
@@ -329,12 +328,10 @@
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
         
         if (error || endpoint.isPaused()) {
-            recycle();
             return SocketState.CLOSED;
         } else if (isAsync()) {
             return SocketState.LONG;
         } else {
-            recycle();
             return SocketState.OPEN;
         }
     }
@@ -369,7 +366,6 @@
         if (isAsync()) {
             if (error) {
                 request.updateCounters();
-                recycle();
                 return SocketState.CLOSED;
             } else {
                 return SocketState.LONG;
@@ -376,7 +372,6 @@
             }
         } else {
             request.updateCounters();
-            recycle();
             if (error) {
                 return SocketState.CLOSED;
             } else {
