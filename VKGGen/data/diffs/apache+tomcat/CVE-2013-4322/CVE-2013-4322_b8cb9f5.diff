commit b8cb9f5f91e9210ca107fd80f3e6acd47531daa7
Author:     Mark Emlyn David Thomas <markt@apache.org>
AuthorDate: Mon Dec 9 09:45:16 2013 +0000
Commit:     Mark Emlyn David Thomas <markt@apache.org>
CommitDate: Mon Dec 9 09:45:16 2013 +0000

    Improve parsing of trailing headers
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1549522 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java b/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
index b47e45eba9..485e3689b6 100644
--- a/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
@@ -125,6 +125,11 @@ public class ChunkedInputFilter implements InputFilter {
     private final long maxExtensionSize;
 
 
+    /**
+     * Limit for trailer size.
+     */
+    private int maxTrailerSize;
+
     /**
      * Size of extensions processed for this request.
      */
@@ -135,6 +140,7 @@ public class ChunkedInputFilter implements InputFilter {
     public ChunkedInputFilter(int maxTrailerSize, int maxExtensionSize) {
         this.trailingHeaders.setLimit(maxTrailerSize);
         this.maxExtensionSize = maxExtensionSize;
+        this.maxTrailerSize = maxTrailerSize;
     }
 
     // ---------------------------------------------------- InputBuffer Methods
@@ -264,6 +270,7 @@ public class ChunkedInputFilter implements InputFilter {
         endChunk = false;
         needCRLFParse = false;
         trailingHeaders.recycle();
+        trailingHeaders.setLimit(maxTrailerSize);
         extensionSize = 0;
     }
 
@@ -326,7 +333,10 @@ public class ChunkedInputFilter implements InputFilter {
             if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {
                 parseCRLF(false);
                 eol = true;
-            } else if (buf[pos] == Constants.SEMI_COLON) {
+            } else if (buf[pos] == Constants.SEMI_COLON && !extension) {
+                // First semi-colon marks the start of the extension. Further
+                // semi-colons may appear to separate multiple chunk-extensions.
+                // These need to be processed as part of parsing the extensions.
                 extension = true;
                 extensionSize++;
             } else if (!extension) {
@@ -342,7 +352,9 @@ public class ChunkedInputFilter implements InputFilter {
                     return false;
                 }
             } else {
-                // extension
+                // Extension 'parsing'
+                // Note that the chunk-extension is neither parsed nor
+                // validated. Currently it is simply ignored.
                 extensionSize++;
                 if (maxExtensionSize > -1 && extensionSize > maxExtensionSize) {
                     throw new IOException("maxExtensionSize exceeded");
@@ -501,6 +513,13 @@ public class ChunkedInputFilter implements InputFilter {
                 chr = buf[pos];
                 if ((chr == Constants.SP) || (chr == Constants.HT)) {
                     pos++;
+                    // If we swallow whitespace, make sure it counts towards the
+                    // limit placed on trailing header size
+                    int newlimit = trailingHeaders.getLimit() -1;
+                    if (trailingHeaders.getEnd() > newlimit) {
+                        throw new IOException("Exceeded maxTrailerSize");
+                    }
+                    trailingHeaders.setLimit(newlimit);
                 } else {
                     space = false;
                 }
