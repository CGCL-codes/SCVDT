Index: trunk/java/org/apache/coyote/http11/AbstractHttp11Processor.java
===================================================================
--- trunk/java/org/apache/coyote/http11/AbstractHttp11Processor.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/AbstractHttp11Processor.java	(revision 1603770)
@@ -647,14 +647,15 @@
     /**
      * Initialize standard input and output filters.
      */
-    protected void initializeFilters(int maxTrailerSize, int maxExtensionSize) {
+    protected void initializeFilters(int maxTrailerSize, int maxExtensionSize,
+            int maxSwallowSize) {
         // Create and add the identity filters.
-        getInputBuffer().addFilter(new IdentityInputFilter());
+        getInputBuffer().addFilter(new IdentityInputFilter(maxSwallowSize));
         getOutputBuffer().addFilter(new IdentityOutputFilter());
 
         // Create and add the chunked filters.
         getInputBuffer().addFilter(
-                new ChunkedInputFilter(maxTrailerSize, maxExtensionSize));
+                new ChunkedInputFilter(maxTrailerSize, maxExtensionSize, maxSwallowSize));
         getOutputBuffer().addFilter(new ChunkedOutputFilter());
 
         // Create and add the void filters.
Index: trunk/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
===================================================================
--- trunk/java/org/apache/coyote/http11/AbstractHttp11Protocol.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/AbstractHttp11Protocol.java	(revision 1603770)
@@ -155,6 +155,16 @@
 
 
     /**
+     * Maximum amount of request body to swallow.
+     */
+    private int maxSwallowSize = 2 * 1024 * 1024;
+    public int getMaxSwallowSize() { return maxSwallowSize; }
+    public void setMaxSwallowSize(int maxSwallowSize) {
+        this.maxSwallowSize = maxSwallowSize;
+    }
+
+
+    /**
      * This field indicates if the protocol is treated as if it is secure. This
      * normally means https is being used but can be used to fake https e.g
      * behind a reverse proxy.
Index: trunk/java/org/apache/coyote/http11/Http11AprProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11AprProcessor.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/Http11AprProcessor.java	(revision 1603770)
@@ -59,7 +59,7 @@
 
 
     public Http11AprProcessor(int headerBufferSize, AprEndpoint endpoint,
-            int maxTrailerSize, int maxExtensionSize) {
+            int maxTrailerSize, int maxExtensionSize, int maxSwallowSize) {
 
         super(endpoint);
 
@@ -69,7 +69,7 @@
         outputBuffer = new InternalAprOutputBuffer(response, headerBufferSize);
         response.setOutputBuffer(outputBuffer);
 
-        initializeFilters(maxTrailerSize, maxExtensionSize);
+        initializeFilters(maxTrailerSize, maxExtensionSize, maxSwallowSize);
     }
 
 
Index: trunk/java/org/apache/coyote/http11/Http11AprProtocol.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11AprProtocol.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/Http11AprProtocol.java	(revision 1603770)
@@ -319,7 +319,8 @@
         protected Http11AprProcessor createProcessor() {
             Http11AprProcessor processor = new Http11AprProcessor(
                     proto.getMaxHttpHeaderSize(), (AprEndpoint)proto.endpoint,
-                    proto.getMaxTrailerSize(), proto.getMaxExtensionSize());
+                    proto.getMaxTrailerSize(), proto.getMaxExtensionSize(),
+                    proto.getMaxSwallowSize());
             processor.setAdapter(proto.getAdapter());
             processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());
             processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());
Index: trunk/java/org/apache/coyote/http11/Http11Nio2Processor.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11Nio2Processor.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/Http11Nio2Processor.java	(revision 1603770)
@@ -60,7 +60,7 @@
 
 
     public Http11Nio2Processor(int maxHttpHeaderSize, Nio2Endpoint endpoint,
-            int maxTrailerSize, int maxExtensionSize) {
+            int maxTrailerSize, int maxExtensionSize, int maxSwallowSize) {
 
         super(endpoint);
 
@@ -70,7 +70,7 @@
         outputBuffer = new InternalNio2OutputBuffer(response, maxHttpHeaderSize);
         response.setOutputBuffer(outputBuffer);
 
-        initializeFilters(maxTrailerSize, maxExtensionSize);
+        initializeFilters(maxTrailerSize, maxExtensionSize, maxSwallowSize);
     }
 
 
Index: trunk/java/org/apache/coyote/http11/Http11Nio2Protocol.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11Nio2Protocol.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/Http11Nio2Protocol.java	(revision 1603770)
@@ -248,7 +248,8 @@
         public Http11Nio2Processor createProcessor() {
             Http11Nio2Processor processor = new Http11Nio2Processor(
                     proto.getMaxHttpHeaderSize(), (Nio2Endpoint) proto.endpoint,
-                    proto.getMaxTrailerSize(), proto.getMaxExtensionSize());
+                    proto.getMaxTrailerSize(), proto.getMaxExtensionSize(),
+                    proto.getMaxSwallowSize());
             processor.setAdapter(proto.getAdapter());
             processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());
             processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());
Index: trunk/java/org/apache/coyote/http11/Http11NioProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11NioProcessor.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/Http11NioProcessor.java	(revision 1603770)
@@ -63,7 +63,7 @@
 
 
     public Http11NioProcessor(int maxHttpHeaderSize, NioEndpoint endpoint,
-            int maxTrailerSize, int maxExtensionSize) {
+            int maxTrailerSize, int maxExtensionSize, int maxSwallowSize) {
 
         super(endpoint);
 
@@ -73,7 +73,7 @@
         outputBuffer = new InternalNioOutputBuffer(response, maxHttpHeaderSize);
         response.setOutputBuffer(outputBuffer);
 
-        initializeFilters(maxTrailerSize, maxExtensionSize);
+        initializeFilters(maxTrailerSize, maxExtensionSize, maxSwallowSize);
     }
 
 
Index: trunk/java/org/apache/coyote/http11/Http11NioProtocol.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11NioProtocol.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/Http11NioProtocol.java	(revision 1603770)
@@ -280,7 +280,8 @@
         public Http11NioProcessor createProcessor() {
             Http11NioProcessor processor = new Http11NioProcessor(
                     proto.getMaxHttpHeaderSize(), (NioEndpoint)proto.endpoint,
-                    proto.getMaxTrailerSize(), proto.getMaxExtensionSize());
+                    proto.getMaxTrailerSize(), proto.getMaxExtensionSize(),
+                    proto.getMaxSwallowSize());
             processor.setAdapter(proto.getAdapter());
             processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());
             processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());
Index: trunk/java/org/apache/coyote/http11/Http11Processor.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11Processor.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/Http11Processor.java	(revision 1603770)
@@ -49,7 +49,7 @@
 
 
     public Http11Processor(int headerBufferSize, JIoEndpoint endpoint,
-            int maxTrailerSize, int maxExtensionSize) {
+            int maxTrailerSize, int maxExtensionSize, int maxSwallowSize) {
 
         super(endpoint);
 
@@ -59,7 +59,7 @@
         outputBuffer = new InternalOutputBuffer(response, headerBufferSize);
         response.setOutputBuffer(outputBuffer);
 
-        initializeFilters(maxTrailerSize, maxExtensionSize);
+        initializeFilters(maxTrailerSize, maxExtensionSize, maxSwallowSize);
     }
 
 
Index: trunk/java/org/apache/coyote/http11/Http11Protocol.java
===================================================================
--- trunk/java/org/apache/coyote/http11/Http11Protocol.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/Http11Protocol.java	(revision 1603770)
@@ -186,7 +186,8 @@
         protected Http11Processor createProcessor() {
             Http11Processor processor = new Http11Processor(
                     proto.getMaxHttpHeaderSize(), (JIoEndpoint)proto.endpoint,
-                    proto.getMaxTrailerSize(),proto.getMaxExtensionSize());
+                    proto.getMaxTrailerSize(),proto.getMaxExtensionSize(),
+                    proto.getMaxSwallowSize());
             processor.setAdapter(proto.getAdapter());
             processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());
             processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());
Index: trunk/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
===================================================================
--- trunk/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java	(revision 1603770)
@@ -137,6 +137,9 @@
     private long extensionSize;
 
 
+    private final int maxSwallowSize;
+
+
     /**
      * Flag that indicates if an error has occurred.
      */
@@ -145,10 +148,11 @@
 
     // ----------------------------------------------------------- Constructors
 
-    public ChunkedInputFilter(int maxTrailerSize, int maxExtensionSize) {
+    public ChunkedInputFilter(int maxTrailerSize, int maxExtensionSize, int maxSwallowSize) {
         this.trailingHeaders.setLimit(maxTrailerSize);
         this.maxExtensionSize = maxExtensionSize;
         this.maxTrailerSize = maxTrailerSize;
+        this.maxSwallowSize = maxSwallowSize;
     }
 
 
@@ -234,9 +238,14 @@
      */
     @Override
     public long end() throws IOException {
+        long swallowed = 0;
+        int read = 0;
         // Consume extra bytes : parse the stream until the end chunk is found
-        while (doRead(readChunk, null) >= 0) {
-            // NOOP: Just consume the input
+        while ((read = doRead(readChunk, null)) >= 0) {
+            swallowed += read;
+            if (maxSwallowSize > -1 && swallowed > maxSwallowSize) {
+                throwIOException(sm.getString("inputFilter.maxSwallow"));
+            }
         }
 
         // Return the number of extra bytes which were consumed
Index: trunk/java/org/apache/coyote/http11/filters/IdentityInputFilter.java
===================================================================
--- trunk/java/org/apache/coyote/http11/filters/IdentityInputFilter.java	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/filters/IdentityInputFilter.java	(revision 1603770)
@@ -24,6 +24,7 @@
 import org.apache.coyote.Request;
 import org.apache.coyote.http11.InputFilter;
 import org.apache.tomcat.util.buf.ByteChunk;
+import org.apache.tomcat.util.res.StringManager;
 
 /**
  * Identity input filter.
@@ -32,7 +33,10 @@
  */
 public class IdentityInputFilter implements InputFilter {
 
+    private static final StringManager sm = StringManager.getManager(
+            IdentityInputFilter.class.getPackage().getName());
 
+
     // -------------------------------------------------------------- Constants
 
 
@@ -76,6 +80,14 @@
     protected final ByteChunk endChunk = new ByteChunk();
 
 
+    private final int maxSwallowSize;
+
+
+    public IdentityInputFilter(int maxSwallowSize) {
+        this.maxSwallowSize = maxSwallowSize;
+    }
+
+
     // ---------------------------------------------------- InputBuffer Methods
 
     /**
@@ -137,9 +149,12 @@
      * End the current request.
      */
     @Override
-    public long end()
-        throws IOException {
+    public long end()  throws IOException {
 
+        if (maxSwallowSize > -1 && remaining > maxSwallowSize) {
+            throw new IOException(sm.getString("inputFilter.maxSwallow"));
+        }
+
         // Consume extra bytes.
         while (remaining > 0) {
             int nread = buffer.doRead(endChunk, null);
Index: trunk/java/org/apache/coyote/http11/filters/LocalStrings.properties
===================================================================
--- trunk/java/org/apache/coyote/http11/filters/LocalStrings.properties	(revision 1603769)
+++ trunk/java/org/apache/coyote/http11/filters/LocalStrings.properties	(revision 1603770)
@@ -22,4 +22,6 @@
 chunkedInputFilter.invalidCrlfNoData=Invalid end of line sequence (no data available to read)
 chunkedInputFilter.invalidHeader=Invalid chunk header
 chunkedInputFilter.maxExtension=maxExtensionSize exceeded
-chunkedInputFilter.maxTrailer=maxTrailerSize exceeded
\ No newline at end of file
+chunkedInputFilter.maxTrailer=maxTrailerSize exceeded
+
+inputFilter.maxSwallow=maxSwallowSize exceeded
\ No newline at end of file
Index: trunk/test/org/apache/catalina/core/TestSwallowAbortedUploads.java
===================================================================
--- trunk/test/org/apache/catalina/core/TestSwallowAbortedUploads.java	(revision 1603769)
+++ trunk/test/org/apache/catalina/core/TestSwallowAbortedUploads.java	(revision 1603770)
@@ -16,8 +16,14 @@
  */
 package org.apache.catalina.core;
 
+import java.io.BufferedReader;
 import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
+import java.io.Writer;
+import java.net.Socket;
+import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -32,6 +38,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
+import org.junit.Assert;
 import org.junit.Test;
 
 import org.apache.catalina.Context;
@@ -113,7 +120,7 @@
         Exception ex = doAbortedUploadTest(client, true, true);
         assertNull("Limited upload with swallow enabled generates client exception",
                    ex);
-        assertTrue("Limited upload with swallow enabled returns error status code",
+        assertTrue("Limited upload with swallow enabled returns non-500 status code",
                    client.isResponse500());
         client.reset();
     }
@@ -400,4 +407,72 @@
         }
     }
 
+
+    @Test
+    public void testChunkedPUTLimit() throws Exception {
+        doTestChunkedPUT(true);
+    }
+
+
+    @Test
+    public void testChunkedPUTNoLimit() throws Exception {
+        doTestChunkedPUT(false);
+    }
+
+
+    public void doTestChunkedPUT(boolean limit) throws Exception {
+
+        Tomcat tomcat = getTomcatInstance();
+        tomcat.addContext("", TEMP_DIR);
+        // No need for target to exist.
+
+        if (!limit) {
+            tomcat.getConnector().setAttribute("maxSwallowSize", "-1");
+        }
+
+        tomcat.start();
+
+        Exception writeEx = null;
+        Exception readEx = null;
+        String responseLine = null;
+
+        try (Socket conn = new Socket("localhost", getPort())) {
+            Writer writer = new OutputStreamWriter(
+                    conn.getOutputStream(), StandardCharsets.US_ASCII);
+            writer.write("PUT /does-not-exist HTTP/1.1\r\n");
+            writer.write("Host: any\r\n");
+            writer.write("Transfer-encoding: chunked\r\n");
+            writer.write("\r\n");
+
+            // Smarter than the typical client. Attempts to read the response
+            // even if the request is not fully written.
+            try {
+                // Write (or try to write) 16MB
+                for (int i = 0; i < 1024 * 1024; i++) {
+                    writer.write("10\r\n");
+                    writer.write("0123456789ABCDEF\r\n");
+                }
+            } catch (Exception e) {
+                writeEx = e;
+            }
+
+            try {
+                BufferedReader reader = new BufferedReader(new InputStreamReader(
+                        conn.getInputStream(), StandardCharsets.US_ASCII));
+
+                responseLine = reader.readLine();
+            } catch (IOException e) {
+                readEx = e;
+            }
+        }
+
+        if (limit) {
+            Assert.assertNotNull(writeEx);
+        } else {
+            Assert.assertNull(writeEx);
+        }
+        Assert.assertNull(readEx);
+        Assert.assertNotNull(responseLine);
+        Assert.assertTrue(responseLine.contains("404"));
+    }
 }
Index: trunk/webapps/docs/changelog.xml
===================================================================
--- trunk/webapps/docs/changelog.xml	(revision 1603769)
+++ trunk/webapps/docs/changelog.xml	(revision 1603770)
@@ -205,6 +205,10 @@
       <fix>
         Improve configuration of cache sizes in the endpoint. (markt)
       </fix>
+      <add>
+        Add a new limit, defaulting to 2MB, for the amount of data Tomcat will
+        swallow for an aborted upload. (markt)
+      </add>
     </changelog>
   </subsection>
   <subsection name="Jasper">
Index: trunk/webapps/docs/config/http.xml
===================================================================
--- trunk/webapps/docs/config/http.xml	(revision 1603769)
+++ trunk/webapps/docs/config/http.xml	(revision 1603770)
@@ -436,6 +436,16 @@
       If not specified, this attribute is set to 100.</p>
     </attribute>
 
+    <attribute name="maxSwallowSize" required="false">
+      <p>The maximum number of request body bytes (excluding transfer encoding
+      overhead) that will be swallowed by Tomcat for an aborted upload. An
+      aborted upload is when Tomcat knows that the request body is going to be
+      ignored but the client still sends it. If Tomcat does not swallow the body
+      the client is unlikely to see the response. If not specified the default
+      of 2097152 (2 megabytes) will be used. A value of less than zero indicates
+      that no limit should be enforced.</p>
+    </attribute>
+
     <attribute name="maxThreads" required="false">
       <p>The maximum number of request processing threads to be created
       by this <strong>Connector</strong>, which therefore determines the
