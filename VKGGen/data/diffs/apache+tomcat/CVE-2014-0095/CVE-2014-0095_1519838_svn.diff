Index: trunk/java/org/apache/coyote/AbstractProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/AbstractProcessor.java	(revision 1519837)
+++ trunk/java/org/apache/coyote/AbstractProcessor.java	(revision 1519838)
@@ -173,4 +173,13 @@
 
     @Override
     public abstract HttpUpgradeHandler getHttpUpgradeHandler();
+
+
+    /**
+     * Register the socket for the specified events.
+     *
+     * @param read  Register the socket for read events
+     * @param write Register the socket for write events
+     */
+    protected abstract void registerForEvent(boolean read, boolean write);
 }
Index: trunk/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/ajp/AbstractAjpProcessor.java	(revision 1519837)
+++ trunk/java/org/apache/coyote/ajp/AbstractAjpProcessor.java	(revision 1519838)
@@ -212,6 +212,13 @@
 
 
     /**
+     * Indicates that a 'get body chunk' message has been sent but the body
+     * chunk has not yet been received.
+     */
+    private boolean waitingForBodyMessage = false;
+
+
+    /**
      * Replay read.
      */
     protected boolean replay = false;
@@ -542,23 +549,34 @@
                     sm.getString("ajpprocessor.comet.notsupported"));
 
         } else if (actionCode == ActionCode.AVAILABLE) {
-            // Web Server only sends data when asked so unless end of stream has
-            // been reached, there should be data available.
-            // TODO Figure out if a 'true' non-blocking approach is possible
-            //      for AJP and what changes would be required to support it.
             if (!endOfStream) {
-                request.setAvailable(1);
+                if (empty) {
+                    try {
+                        refillReadBuffer(false);
+                    } catch (IOException e) {
+                        error = true;
+                        return;
+                    }
+                }
+                if (empty) {
+                    request.setAvailable(0);
+                } else {
+                    request.setAvailable(1);
+                }
             }
 
+        } else if (actionCode == ActionCode.NB_READ_INTEREST) {
+            if (!endOfStream) {
+                registerForEvent(true, false);
+            }
+
         } else if (actionCode == ActionCode.NB_WRITE_INTEREST) {
+            // TODO
             // Until 'true' non-blocking IO is implemented, assume it is always
             // possible write data.
             AtomicBoolean isReady = (AtomicBoolean)param;
             isReady.set(true);
 
-        } else if (actionCode == ActionCode.NB_READ_INTEREST) {
-            // NO-OP. Not required until 'true' non-blocking IO is implemented.
-
         } else if (actionCode == ActionCode.REQUEST_BODY_FULLY_READ) {
             AtomicBoolean result = (AtomicBoolean) param;
             result.set(endOfStream);
@@ -814,6 +832,7 @@
         // Recycle Request object
         first = true;
         endOfStream = false;
+        waitingForBodyMessage = false;
         empty = true;
         replay = false;
         finished = false;
@@ -866,17 +885,27 @@
             throws IOException;
 
     // Methods used by SocketInputBuffer
-    /** Receive a chunk of data. Called to implement the
-     *  'special' packet in ajp13 and to receive the data
-     *  after we send a GET_BODY packet
+    /**
+     * Read an AJP body message. Used to read both the 'special' packet in ajp13
+     * and to receive the data after we send a GET_BODY packet.
+     *
+     * @param block If there is no data available to read when this method is
+     *              called, should this call block until data becomes available?
+     *
+     * @return <code>true</code> if at least one body byte was read, otherwise
+     *         <code>false</code>
      */
-    protected boolean receive() throws IOException {
+    protected boolean receive(boolean block) throws IOException {
 
-        first = false;
         bodyMessage.reset();
 
-        readMessage(bodyMessage, true);
+        if (!readMessage(bodyMessage, block)) {
+            return false;
+        }
 
+        waitingForBodyMessage = false;
+        first = false;
+
         // No data received.
         if (bodyMessage.getLen() == 0) {
             // just the header
@@ -960,7 +989,7 @@
      *
      * @return true if there is more data, false if not.
      */
-    protected boolean refillReadBuffer() throws IOException {
+    protected boolean refillReadBuffer(boolean block) throws IOException {
         // If the server returns an empty packet, assume that that end of
         // the stream has been reached (yuck -- fix protocol??).
         // FORM support
@@ -972,10 +1001,13 @@
         }
 
         // Request more data immediately
-        output(getBodyMessageArray, 0, getBodyMessageArray.length);
+        if (!first && !waitingForBodyMessage) {
+            output(getBodyMessageArray, 0, getBodyMessageArray.length);
+            waitingForBodyMessage = true;
+        }
 
-        boolean moreData = receive();
-        if( !moreData ) {
+        boolean moreData = receive(block);
+        if (!first && !waitingForBodyMessage && !moreData) {
             endOfStream = true;
         }
         return moreData;
@@ -1402,8 +1434,8 @@
         finished = true;
 
         // Swallow the unread body packet if present
-        if (first && request.getContentLengthLong() > 0) {
-            receive();
+        if (first && request.getContentLengthLong() > 0 || waitingForBodyMessage) {
+            receive(true);
         }
 
         // Add the end message
@@ -1424,13 +1456,11 @@
      */
     protected class SocketInputBuffer implements InputBuffer {
 
-
         /**
          * Read bytes into the specified chunk.
          */
         @Override
-        public int doRead(ByteChunk chunk, Request req)
-        throws IOException {
+        public int doRead(ByteChunk chunk, Request req) throws IOException {
 
             if (endOfStream) {
                 return -1;
@@ -1437,11 +1467,11 @@
             }
             if (first && req.getContentLengthLong() > 0) {
                 // Handle special first-body-chunk
-                if (!receive()) {
+                if (!receive(true)) {
                     return 0;
                 }
             } else if (empty) {
-                if (!refillReadBuffer()) {
+                if (!refillReadBuffer(true)) {
                     return -1;
                 }
             }
@@ -1449,9 +1479,7 @@
             chunk.setBytes(bc.getBuffer(), bc.getStart(), bc.getLength());
             empty = true;
             return chunk.getLength();
-
         }
-
     }
 
 
Index: trunk/java/org/apache/coyote/ajp/AjpAprProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/ajp/AjpAprProcessor.java	(revision 1519837)
+++ trunk/java/org/apache/coyote/ajp/AjpAprProcessor.java	(revision 1519838)
@@ -73,6 +73,12 @@
 
 
     @Override
+    protected void registerForEvent(boolean read, boolean write) {
+        ((AprEndpoint) endpoint).getPoller().add(
+                socketWrapper.getSocket().longValue(), -1, read, write);
+    }
+
+    @Override
     protected void resetTimeouts() {
         // NO-OP. The AJP APR/native connector only uses the timeout value on
         //        time SocketWrapper for async timeouts.
Index: trunk/java/org/apache/coyote/ajp/AjpNioProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/ajp/AjpNioProcessor.java	(revision 1519837)
+++ trunk/java/org/apache/coyote/ajp/AjpNioProcessor.java	(revision 1519838)
@@ -19,6 +19,7 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
 
 import org.apache.juli.logging.Log;
@@ -57,6 +58,23 @@
 
 
     @Override
+    protected void registerForEvent(boolean read, boolean write) {
+        final NioEndpoint.KeyAttachment attach =
+                (NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment(
+                        false);
+        if (attach == null) {
+            return;
+        }
+        if (read) {
+            attach.interestOps(attach.interestOps() | SelectionKey.OP_READ);
+        }
+        if (write) {
+            attach.interestOps(attach.interestOps() | SelectionKey.OP_WRITE);
+        }
+    }
+
+
+    @Override
     protected void resetTimeouts() {
         // The NIO connector uses the timeout configured on the wrapper in the
         // poller. Therefore, it needs to be reset once asycn processing has
Index: trunk/java/org/apache/coyote/ajp/AjpProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/ajp/AjpProcessor.java	(revision 1519837)
+++ trunk/java/org/apache/coyote/ajp/AjpProcessor.java	(revision 1519838)
@@ -70,6 +70,11 @@
 
 
     @Override
+    protected void registerForEvent(boolean read, boolean write) {
+        // NO-OP for BIO
+    }
+
+    @Override
     protected void resetTimeouts() {
         // NO-OP. The AJP BIO connector only uses the timeout value on the
         //        SocketWrapper for async timeouts.
Index: trunk/java/org/apache/coyote/http11/AbstractHttp11Processor.java
===================================================================
--- trunk/java/org/apache/coyote/http11/AbstractHttp11Processor.java	(revision 1519837)
+++ trunk/java/org/apache/coyote/http11/AbstractHttp11Processor.java	(revision 1519838)
@@ -1109,15 +1109,6 @@
 
 
     /**
-     * Register the socket for the specified events.
-     *
-     * @param read  Register the socket for read events
-     * @param write Register the socket for write events
-     */
-    protected abstract void registerForEvent(boolean read, boolean write);
-
-
-    /**
      * After reading the request headers, we have to setup the request filters.
      */
     protected void prepareRequest() {
Index: trunk/java/org/apache/coyote/spdy/SpdyProcessor.java
===================================================================
--- trunk/java/org/apache/coyote/spdy/SpdyProcessor.java	(revision 1519837)
+++ trunk/java/org/apache/coyote/spdy/SpdyProcessor.java	(revision 1519838)
@@ -496,6 +496,11 @@
         return null;
     }
 
+    @Override
+    protected void registerForEvent(boolean read, boolean write) {
+        // NO-OP
+    }
+
     public void onSynStream(SpdyStream str) throws IOException {
         this.spdyStream = str;
         SpdyFrame frame = str.reqFrame;
Index: trunk/test/org/apache/catalina/nonblocking/TesterAjpNonBlockingClient.java
===================================================================
--- trunk/test/org/apache/catalina/nonblocking/TesterAjpNonBlockingClient.java	(nonexistent)
+++ trunk/test/org/apache/catalina/nonblocking/TesterAjpNonBlockingClient.java	(revision 1519838)
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.nonblocking;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.servlet.http.HttpServletResponse;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import org.apache.catalina.nonblocking.TestNonBlockingAPI.DataWriter;
+import org.apache.catalina.startup.TomcatBaseTest;
+import org.apache.tomcat.util.buf.ByteChunk;
+
+public class TesterAjpNonBlockingClient extends TomcatBaseTest {
+
+    /**
+     * This is not a standard unit test. This is a test client for AJP
+     * non-blocking reads. It assumes that there is an httpd instance listening
+     * on localhost:80 that is redirecting all traffic to a default Tomcat 8
+     * instance that includes the examples web application.
+     */
+    @Test
+    public void doTestAJPNonBlockingRead() throws Exception {
+
+        Map<String, List<String>> resHeaders = new HashMap<>();
+        ByteChunk out = new ByteChunk();
+        int rc = postUrl(true, new DataWriter(2000), "http://localhost" +
+                "/examples/servlets/nonblocking/bytecounter",
+                out, resHeaders, null);
+
+        System.out.println(out.toString());
+
+        Assert.assertEquals(HttpServletResponse.SC_OK, rc);
+    }
+}

Property changes on: trunk/test/org/apache/catalina/nonblocking/TesterAjpNonBlockingClient.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
