Index: tc8.0.x/trunk/java/org/apache/coyote/http11/AbstractInputBuffer.java
===================================================================
--- tc8.0.x/trunk/java/org/apache/coyote/http11/AbstractInputBuffer.java	(revision 1767652)
+++ tc8.0.x/trunk/java/org/apache/coyote/http11/AbstractInputBuffer.java	(revision 1767653)
@@ -30,64 +30,12 @@
 
 public abstract class AbstractInputBuffer<S> implements InputBuffer{
 
-    protected static final boolean[] HTTP_TOKEN_CHAR = new boolean[128];
-
     /**
      * The string manager for this package.
      */
-    protected static final StringManager sm =
-        StringManager.getManager(Constants.Package);
+    protected static final StringManager sm = StringManager.getManager(Constants.Package);
 
 
-    static {
-        for (int i = 0; i < 128; i++) {
-            if (i < 32) {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == 127) {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '(') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == ')') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '<') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '>') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '@') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == ',') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == ';') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == ':') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '\\') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '\"') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '/') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '[') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == ']') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '?') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '=') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '{') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == '}') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else if (i == ' ') {
-                HTTP_TOKEN_CHAR[i] = false;
-            } else {
-                HTTP_TOKEN_CHAR[i] = true;
-            }
-        }
-    }
-
-
     /**
      * Associated Coyote request.
      */
Index: tc8.0.x/trunk/java/org/apache/coyote/http11/AbstractNioInputBuffer.java
===================================================================
--- tc8.0.x/trunk/java/org/apache/coyote/http11/AbstractNioInputBuffer.java	(revision 1767652)
+++ tc8.0.x/trunk/java/org/apache/coyote/http11/AbstractNioInputBuffer.java	(revision 1767653)
@@ -21,6 +21,7 @@
 
 import org.apache.coyote.Request;
 import org.apache.tomcat.util.buf.MessageBytes;
+import org.apache.tomcat.util.http.parser.HttpParser;
 
 public abstract class AbstractNioInputBuffer<S> extends AbstractInputBuffer<S> {
 
@@ -228,7 +229,7 @@
                 if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                     space = true;
                     request.method().setBytes(buf, parsingRequestLineStart, pos - parsingRequestLineStart);
-                } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
+                } else if (!HttpParser.isToken(buf[pos])) {
                     throw new IllegalArgumentException(sm.getString("iib.invalidmethod"));
                 }
                 pos++;
@@ -276,9 +277,10 @@
                     parsingRequestLineEol = true;
                     space = true;
                     end = pos;
-                } else if ((buf[pos] == Constants.QUESTION)
-                           && (parsingRequestLineQPos == -1)) {
+                } else if ((buf[pos] == Constants.QUESTION) && (parsingRequestLineQPos == -1)) {
                     parsingRequestLineQPos = pos;
+                } else if (HttpParser.isNotRequestTarget(buf[pos])) {
+                    throw new IllegalArgumentException(sm.getString("iib.invalidRequestTarget"));
                 }
                 pos++;
             }
@@ -315,7 +317,7 @@
         if (parsingRequestLinePhase == 6) {
             //
             // Reading the protocol
-            // Protocol is always US-ASCII
+            // Protocol is always "HTTP/" DIGIT "." DIGIT
             //
             while (!parsingRequestLineEol) {
                 // Read new bytes if needed
@@ -330,6 +332,8 @@
                     if (end == 0)
                         end = pos;
                     parsingRequestLineEol = true;
+                } else if (!HttpParser.isHttpProtocol(buf[pos])) {
+                    throw new IllegalArgumentException(sm.getString("iib.invalidHttpProtocol"));
                 }
                 pos++;
             }
@@ -470,7 +474,7 @@
                 headerData.realPos = pos;
                 headerData.lastSignificantChar = pos;
                 break;
-            } else if (chr < 0 || !HTTP_TOKEN_CHAR[chr]) {
+            } else if (!HttpParser.isToken(chr)) {
                 // If a non-token header is detected, skip the line and
                 // ignore the header
                 headerData.lastSignificantChar = pos;
Index: tc8.0.x/trunk/java/org/apache/coyote/http11/InternalAprInputBuffer.java
===================================================================
--- tc8.0.x/trunk/java/org/apache/coyote/http11/InternalAprInputBuffer.java	(revision 1767652)
+++ tc8.0.x/trunk/java/org/apache/coyote/http11/InternalAprInputBuffer.java	(revision 1767653)
@@ -32,6 +32,7 @@
 import org.apache.tomcat.jni.Status;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
+import org.apache.tomcat.util.http.parser.HttpParser;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.SocketWrapper;
 
@@ -181,7 +182,7 @@
             if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                 space = true;
                 request.method().setBytes(buf, start, pos - start);
-            } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
+            } else if (!HttpParser.isToken(buf[pos])) {
                 throw new IllegalArgumentException(sm.getString("iib.invalidmethod"));
             }
 
@@ -232,9 +233,10 @@
                 eol = true;
                 space = true;
                 end = pos;
-            } else if ((buf[pos] == Constants.QUESTION)
-                       && (questionPos == -1)) {
+            } else if ((buf[pos] == Constants.QUESTION) && (questionPos == -1)) {
                 questionPos = pos;
+            } else if (HttpParser.isNotRequestTarget(buf[pos])) {
+                throw new IllegalArgumentException(sm.getString("iib.invalidRequestTarget"));
             }
 
             pos++;
@@ -270,7 +272,7 @@
 
         //
         // Reading the protocol
-        // Protocol is always US-ASCII
+        // Protocol is always "HTTP/" DIGIT "." DIGIT
         //
 
         while (!eol) {
@@ -287,6 +289,8 @@
                 if (end == 0)
                     end = pos;
                 eol = true;
+            } else if (!HttpParser.isHttpProtocol(buf[pos])) {
+                throw new IllegalArgumentException(sm.getString("iib.invalidHttpProtocol"));
             }
 
             pos++;
@@ -385,7 +389,7 @@
             if (buf[pos] == Constants.COLON) {
                 colon = true;
                 headerValue = headers.addValue(buf, start, pos - start);
-            } else if (buf[pos] < 0 || !HTTP_TOKEN_CHAR[buf[pos]]) {
+            } else if (!HttpParser.isToken(buf[pos])) {
                 // If a non-token header is detected, skip the line and
                 // ignore the header
                 skipLine(start);
Index: tc8.0.x/trunk/java/org/apache/coyote/http11/InternalInputBuffer.java
===================================================================
--- tc8.0.x/trunk/java/org/apache/coyote/http11/InternalInputBuffer.java	(revision 1767652)
+++ tc8.0.x/trunk/java/org/apache/coyote/http11/InternalInputBuffer.java	(revision 1767653)
@@ -28,6 +28,7 @@
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
+import org.apache.tomcat.util.http.parser.HttpParser;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.SocketWrapper;
 
@@ -142,7 +143,7 @@
             if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
                 space = true;
                 request.method().setBytes(buf, start, pos - start);
-            } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
+            } else if (!HttpParser.isToken(buf[pos])) {
                 throw new IllegalArgumentException(sm.getString("iib.invalidmethod"));
             }
 
@@ -193,9 +194,10 @@
                 eol = true;
                 space = true;
                 end = pos;
-            } else if ((buf[pos] == Constants.QUESTION)
-                       && (questionPos == -1)) {
+            } else if ((buf[pos] == Constants.QUESTION) && (questionPos == -1)) {
                 questionPos = pos;
+            } else if (HttpParser.isNotRequestTarget(buf[pos])) {
+                throw new IllegalArgumentException(sm.getString("iib.invalidRequestTarget"));
             }
 
             pos++;
@@ -230,9 +232,8 @@
 
         //
         // Reading the protocol
-        // Protocol is always US-ASCII
+        // Protocol is always "HTTP/" DIGIT "." DIGIT
         //
-
         while (!eol) {
 
             // Read new bytes if needed
@@ -247,6 +248,8 @@
                 if (end == 0)
                     end = pos;
                 eol = true;
+            } else if (!HttpParser.isHttpProtocol(buf[pos])) {
+                throw new IllegalArgumentException(sm.getString("iib.invalidHttpProtocol"));
             }
 
             pos++;
@@ -345,7 +348,7 @@
             if (buf[pos] == Constants.COLON) {
                 colon = true;
                 headerValue = headers.addValue(buf, start, pos - start);
-            } else if (buf[pos] < 0 || !HTTP_TOKEN_CHAR[buf[pos]]) {
+            } else if (!HttpParser.isToken(buf[pos])) {
                 // If a non-token header is detected, skip the line and
                 // ignore the header
                 skipLine(start);
Index: tc8.0.x/trunk/java/org/apache/coyote/http11/LocalStrings.properties
===================================================================
--- tc8.0.x/trunk/java/org/apache/coyote/http11/LocalStrings.properties	(revision 1767652)
+++ tc8.0.x/trunk/java/org/apache/coyote/http11/LocalStrings.properties	(revision 1767653)
@@ -33,8 +33,10 @@
 iib.eof.error=Unexpected EOF read on the socket
 iib.failedread.apr=Read failed with APR/native error code [{0}]
 iib.filter.npe=You may not add a null filter
-iib.invalidheader=The HTTP header line [{0}] does not conform to RFC 2616 and has been ignored.
+iib.invalidheader=The HTTP header line [{0}] does not conform to RFC 7230 and has been ignored.
 iib.invalidmethod=Invalid character found in method name. HTTP method names must be tokens
+iib.invalidRequestTarget=Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986
+iib.invalidHttpProtocol=Invalid character found in the HTTP protocol
 iib.parseheaders.ise.error=Unexpected state: headers already parsed. Buffer not recycled?
 iib.readtimeout=Timeout attempting to read data from the socket
 iib.requestheadertoolarge.error=Request header is too large
Index: tc8.0.x/trunk/java/org/apache/tomcat/util/http/parser/HttpParser.java
===================================================================
--- tc8.0.x/trunk/java/org/apache/tomcat/util/http/parser/HttpParser.java	(revision 1767652)
+++ tc8.0.x/trunk/java/org/apache/tomcat/util/http/parser/HttpParser.java	(revision 1767653)
@@ -40,6 +40,8 @@
     private static final boolean[] IS_SEPARATOR = new boolean[ARRAY_SIZE];
     private static final boolean[] IS_TOKEN = new boolean[ARRAY_SIZE];
     private static final boolean[] IS_HEX = new boolean[ARRAY_SIZE];
+    private static final boolean[] IS_NOT_REQUEST_TARGET = new boolean[ARRAY_SIZE];
+    private static final boolean[] IS_HTTP_PROTOCOL = new boolean[ARRAY_SIZE];
 
     static {
         for (int i = 0; i < ARRAY_SIZE; i++) {
@@ -65,6 +67,21 @@
             if ((i >= '0' && i <='9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F')) {
                 IS_HEX[i] = true;
             }
+
+            // Not valid for request target.
+            // Combination of multiple rules from RFC7230 and RFC 3986. Must be
+            // ASCII, no controls plus a few additional characters excluded
+            if (IS_CONTROL[i] || i > 127 ||
+                    i == ' ' || i == '\"' || i == '#' || i == '<' || i == '>' || i == '\\' ||
+                    i == '^' || i == '`'  || i == '{' || i == '|' || i == '}') {
+                IS_NOT_REQUEST_TARGET[i] = true;
+            }
+
+            // Not valid for HTTP protocol
+            // "HTTP/" DIGIT "." DIGIT
+            if (i == 'H' || i == 'T' || i == 'P' || i == '/' || i == '.' || (i >= '0' && i <= '9')) {
+                IS_HTTP_PROTOCOL[i] = true;
+            }
         }
     }
 
@@ -99,6 +116,7 @@
         return result.toString();
     }
 
+
     public static boolean isToken(int c) {
         // Fast for correct values, slower for incorrect ones
         try {
@@ -108,8 +126,9 @@
         }
     }
 
+
     public static boolean isHex(int c) {
-        // Fast for correct values, slower for incorrect ones
+        // Fast for correct values, slower for some incorrect ones
         try {
             return IS_HEX[c];
         } catch (ArrayIndexOutOfBoundsException ex) {
@@ -117,6 +136,29 @@
         }
     }
 
+
+    public static boolean isNotRequestTarget(int c) {
+        // Fast for valid request target characters, slower for some incorrect
+        // ones
+        try {
+            return IS_NOT_REQUEST_TARGET[c];
+        } catch (ArrayIndexOutOfBoundsException ex) {
+            return true;
+        }
+    }
+
+
+    public static boolean isHttpProtocol(int c) {
+        // Fast for valid HTTP protocol characters, slower for some incorrect
+        // ones
+        try {
+            return IS_HTTP_PROTOCOL[c];
+        } catch (ArrayIndexOutOfBoundsException ex) {
+            return false;
+        }
+    }
+
+
     // Skip any LWS and return the next char
     static int skipLws(StringReader input, boolean withReset) throws IOException {
 
Index: tc8.0.x/trunk/test/org/apache/catalina/valves/rewrite/TestRewriteValve.java
===================================================================
--- tc8.0.x/trunk/test/org/apache/catalina/valves/rewrite/TestRewriteValve.java	(revision 1767652)
+++ tc8.0.x/trunk/test/org/apache/catalina/valves/rewrite/TestRewriteValve.java	(revision 1767653)
@@ -232,7 +232,7 @@
         // Failing to escape the redirect means UTF-8 bytes in the Location
         // header which will be treated as if they are ISO-8859-1
         doTestRewrite("RewriteRule ^/b/(.*)/(.*) /c/\u00A1$1?$2 [R,NE]",
-                "/b/%C2%A1/id=%C2%A1?di=%C2%AE", "/c/\u00C2\u00A1\u00C2\u00A1", "id=\u00C2\u00A1");
+                "/b/%C2%A1/id=%C2%A1?di=%C2%AE", null);
     }
 
 
@@ -242,7 +242,7 @@
         // Failing to escape the redirect means UTF-8 bytes in the Location
         // header which will be treated as if they are ISO-8859-1
         doTestRewrite("RewriteRule ^/b/(.*)/(.*) /c/\u00A1$1?$2 [R,B,NE]",
-                "/b/%C2%A1/id=%C2%A1?di=%C2%AE", "/c/\u00C2\u00A1%C2%A1", "id=%C2%A1");
+                "/b/%C2%A1/id=%C2%A1?di=%C2%AE", null);
     }
 
 
@@ -279,8 +279,7 @@
         // Failing to escape the redirect means UTF-8 bytes in the Location
         // header which will be treated as if they are ISO-8859-1
         doTestRewrite("RewriteRule ^/b/(.*)/(.*) /c/\u00A1$1?$2 [R,NE,QSA]",
-                "/b/%C2%A1/id=%C2%A1?di=%C2%AE", "/c/\u00C2\u00A1\u00C2\u00A1",
-                "id=\u00C2\u00A1&di=\u00C2\u00AE");
+                "/b/%C2%A1/id=%C2%A1?di=%C2%AE", null);
     }
 
 
@@ -290,8 +289,7 @@
         // Failing to escape the redirect means UTF-8 bytes in the Location
         // header which will be treated as if they are ISO-8859-1
         doTestRewrite("RewriteRule ^/b/(.*)/(.*) /c/\u00A1$1?$2 [R,B,NE,QSA]",
-                "/b/%C2%A1/id=%C2%A1?di=%C2%AE", "/c/\u00C2\u00A1%C2%A1",
-                "id=%C2%A1&di=\u00C2\u00AE");
+                "/b/%C2%A1/id=%C2%A1?di=%C2%AE", null);
     }
 
 
@@ -333,7 +331,7 @@
         // Failing to escape the redirect means UTF-8 bytes in the Location
         // header which will be treated as if they are ISO-8859-1
         doTestRewrite("RewriteRule ^/b/(.*) /c/\u00A1$1 [R,NE]",
-                "/b/%C2%A1?id=%C2%A1", "/c/\u00C2\u00A1\u00C2\u00A1", "id=\u00C2\u00A1");
+                "/b/%C2%A1?id=%C2%A1", null);
     }
 
 
@@ -343,7 +341,7 @@
         // Failing to escape the redirect means UTF-8 bytes in the Location
         // header which will be treated as if they are ISO-8859-1
         doTestRewrite("RewriteRule ^/b/(.*) /c/\u00A1$1 [R,B,NE]",
-                "/b/%C2%A1?id=%C2%A1", "/c/\u00C2\u00A1%C2%A1", "id=\u00C2\u00A1");
+                "/b/%C2%A1?id=%C2%A1", null);
     }
 
 
@@ -394,7 +392,7 @@
         // Failing to escape the redirect means UTF-8 bytes in the Location
         // header which will be treated as if they are ISO-8859-1
         doTestRewrite("RewriteRule ^/b/(.*)/(.*) /c/\u00A1$1?$2 [R,NE]",
-                "/b/%C2%A1/id=%C2%A1", "/c/\u00C2\u00A1\u00C2\u00A1", "id=\u00C2\u00A1");
+                "/b/%C2%A1/id=%C2%A1", null);
     }
 
 
@@ -404,7 +402,7 @@
         // Failing to escape the redirect means UTF-8 bytes in the Location
         // header which will be treated as if they are ISO-8859-1
         doTestRewrite("RewriteRule ^/b/(.*)/(.*) /c/\u00A1$1?$2 [R,B,NE]",
-                "/b/%C2%A1/id=%C2%A1", "/c/\u00C2\u00A1%C2%A1", "id=%C2%A1");
+                "/b/%C2%A1/id=%C2%A1", null);
     }
 
 
@@ -450,8 +448,7 @@
         // Note %C2%A1 == \u00A1
         // Failing to escape the redirect means UTF-8 bytes in the Location
         // header which will be treated as if they are ISO-8859-1
-        doTestRewrite("RewriteRule ^/b/(.*) /c/\u00A1$1 [R,NE]",
-                "/b/%C2%A1", "/c/\u00C2\u00A1\u00C2\u00A1");
+        doTestRewrite("RewriteRule ^/b/(.*) /c/\u00A1$1 [R,NE]", "/b/%C2%A1", null);
     }
 
 
@@ -460,8 +457,7 @@
         // Note %C2%A1 == \u00A1
         // Failing to escape the redirect means UTF-8 bytes in the Location
         // header which will be treated as if they are ISO-8859-1
-        doTestRewrite("RewriteRule ^/b/(.*) /c/\u00A1$1 [R,B,NE]",
-                "/b/%C2%A1", "/c/\u00C2\u00A1%C2%A1");
+        doTestRewrite("RewriteRule ^/b/(.*) /c/\u00A1$1 [R,B,NE]", "/b/%C2%A1", null);
     }
 
 
@@ -515,22 +511,29 @@
 
         tomcat.start();
 
-        ByteChunk res = getUrl("http://localhost:" + getPort() + request);
+        ByteChunk res = new ByteChunk();
+        int rc = getUrl("http://localhost:" + getPort() + request, res, null);
         res.setCharset(StandardCharsets.UTF_8);
 
-        String body = res.toString();
-        RequestDescriptor requestDesc = SnoopResult.parse(body);
-        String requestURI = requestDesc.getRequestInfo("REQUEST-URI");
-        Assert.assertEquals(expectedURI, requestURI);
+        if (expectedURI == null) {
+            // Rewrite is expected to fail. Probably because invalid characters
+            // were written into the request target
+            Assert.assertEquals(400, rc);
+        } else {
+            String body = res.toString();
+            RequestDescriptor requestDesc = SnoopResult.parse(body);
+            String requestURI = requestDesc.getRequestInfo("REQUEST-URI");
+            Assert.assertEquals(expectedURI, requestURI);
 
-        if (expectedQueryString != null) {
-            String queryString = requestDesc.getRequestInfo("REQUEST-QUERY-STRING");
-            Assert.assertEquals(expectedQueryString, queryString);
-        }
+            if (expectedQueryString != null) {
+                String queryString = requestDesc.getRequestInfo("REQUEST-QUERY-STRING");
+                Assert.assertEquals(expectedQueryString, queryString);
+            }
 
-        if (expectedAttributeValue != null) {
-            String attributeValue = requestDesc.getAttribute("X-Test");
-            Assert.assertEquals(expectedAttributeValue, attributeValue);
+            if (expectedAttributeValue != null) {
+                String attributeValue = requestDesc.getAttribute("X-Test");
+                Assert.assertEquals(expectedAttributeValue, attributeValue);
+            }
         }
     }
 }
Index: tc8.0.x/trunk/webapps/docs/changelog.xml
===================================================================
--- tc8.0.x/trunk/webapps/docs/changelog.xml	(revision 1767652)
+++ tc8.0.x/trunk/webapps/docs/changelog.xml	(revision 1767653)
@@ -97,6 +97,10 @@
         Improve detection of I/O errors during async processing on non-container
         threads and trigger async error handling when they are detected. (markt)
       </fix>
+      <add>
+        Add additional checks for valid characters to the HTTP request line
+        parsing so invalid request lines are rejected sooner. (markt)
+      </add>
     </changelog>
   </subsection>
   <subsection name="Web applications">
Index: tc8.0.x/trunk
===================================================================
--- tc8.0.x/trunk	(revision 1767652)
+++ tc8.0.x/trunk	(revision 1767653)

Property changes on: tc8.0.x/trunk
___________________________________________________________________
Modified: svn:mergeinfo
## -0,0 +0,1 ##
   Merged /tomcat/trunk:r1767641-1767643
