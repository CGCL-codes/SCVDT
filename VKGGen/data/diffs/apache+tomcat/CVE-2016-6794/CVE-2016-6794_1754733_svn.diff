Index: tc6.0.x/trunk/java/org/apache/catalina/loader/WebappClassLoader.java
===================================================================
--- tc6.0.x/trunk/java/org/apache/catalina/loader/WebappClassLoader.java	(revision 1754732)
+++ tc6.0.x/trunk/java/org/apache/catalina/loader/WebappClassLoader.java	(revision 1754733)
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -76,26 +76,27 @@
 import org.apache.naming.resources.ResourceAttributes;
 import org.apache.tomcat.util.IntrospectionUtils;
 import org.apache.tomcat.util.compat.JreCompat;
+import org.apache.tomcat.util.security.PermissionCheck;
 
 /**
  * Specialized web application class loader.
  * <p>
- * This class loader is a full reimplementation of the 
+ * This class loader is a full reimplementation of the
  * <code>URLClassLoader</code> from the JDK. It is designed to be fully
  * compatible with a normal <code>URLClassLoader</code>, although its internal
  * behavior may be completely different.
  * <p>
- * <strong>IMPLEMENTATION NOTE</strong> - This class loader faithfully follows 
- * the delegation model recommended in the specification. The system class 
- * loader will be queried first, then the local repositories, and only then 
- * delegation to the parent class loader will occur. This allows the web 
+ * <strong>IMPLEMENTATION NOTE</strong> - This class loader faithfully follows
+ * the delegation model recommended in the specification. The system class
+ * loader will be queried first, then the local repositories, and only then
+ * delegation to the parent class loader will occur. This allows the web
  * application to override any shared class except the classes from J2SE.
  * Special handling is provided from the JAXP XML parser interfaces, the JNDI
- * interfaces, and the classes from the servlet API, which are never loaded 
+ * interfaces, and the classes from the servlet API, which are never loaded
  * from the webapp repository.
  * <p>
- * <strong>IMPLEMENTATION NOTE</strong> - Due to limitations in Jasper 
- * compilation technology, any repository which contains classes from 
+ * <strong>IMPLEMENTATION NOTE</strong> - Due to limitations in Jasper
+ * compilation technology, any repository which contains classes from
  * the servlet API will be ignored by the class loader.
  * <p>
  * <strong>IMPLEMENTATION NOTE</strong> - The class loader generates source
@@ -114,10 +115,8 @@
  * @author Craig R. McClanahan
  *
  */
-public class WebappClassLoader
-    extends URLClassLoader
-    implements Reloader, Lifecycle
- {
+public class WebappClassLoader extends URLClassLoader
+        implements Reloader, Lifecycle, PermissionCheck {
 
     protected static org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog( WebappClassLoader.class );
@@ -129,7 +128,7 @@
     private static final List<String> JVM_THREAD_GROUP_NAMES =
         new ArrayList<String>();
 
-    public static final boolean ENABLE_CLEAR_REFERENCES = 
+    public static final boolean ENABLE_CLEAR_REFERENCES =
         Boolean.valueOf(System.getProperty("org.apache.catalina.loader.WebappClassLoader.ENABLE_CLEAR_REFERENCES", "true")).booleanValue();
 
     /**
@@ -153,7 +152,7 @@
     }
 
     private static final String JVN_THREAD_GROUP_SYSTEM = "system";
-    
+
     static {
         JVM_THREAD_GROUP_NAMES.add(JVN_THREAD_GROUP_SYSTEM);
         JVM_THREAD_GROUP_NAMES.add("RMI Runtime");
@@ -176,7 +175,7 @@
 
     }
 
-    
+
     protected final class PrivilegedGetClassLoader
         implements PrivilegedAction<ClassLoader> {
 
@@ -186,14 +185,14 @@
             this.clazz = clazz;
         }
 
-        public ClassLoader run() {       
+        public ClassLoader run() {
             return clazz.getClassLoader();
-        }           
+        }
     }
 
-    
 
 
+
     // ------------------------------------------------------- Static Variables
 
 
@@ -224,14 +223,14 @@
     protected static final StringManager sm =
         StringManager.getManager(Constants.Package);
 
-    
+
     /**
      * Use anti JAR locking code, which does URL rerouting when accessing
      * resources.
      */
-    boolean antiJARLocking = false; 
-    
+    boolean antiJARLocking = false;
 
+
     // ----------------------------------------------------------- Constructors
 
 
@@ -262,9 +261,9 @@
     public WebappClassLoader(ClassLoader parent) {
 
         super(new URL[0], parent);
-                
+
         this.parent = getParent();
-        
+
         system = getSystemClassLoader();
         securityManager = System.getSecurityManager();
 
@@ -482,7 +481,7 @@
      * objects is not performed in a thread-safe manner.
      */
     private boolean clearReferencesThreadLocals = false;
-    
+
     /**
      * Should Tomcat call {@link org.apache.juli.logging.LogFactory#release()}
      * when the class loader is stopped? If not specified, the default value
@@ -500,7 +499,7 @@
      * expire however, on a busy system that might not happen for some time.
      */
     private boolean clearReferencesHttpClientKeepAliveThread = true;
-    
+
     /**
      * Name of associated context used with logging and JMX to associate with
      * the right web application. Particularly useful for the clear references
@@ -574,8 +573,8 @@
     public boolean getAntiJARLocking() {
         return antiJARLocking;
     }
-    
-    
+
+
     /**
      * @param antiJARLocking The antiJARLocking to set.
      */
@@ -692,7 +691,7 @@
         this.loaderDir = new File(workDir, "loader");
         if (loaderDir == null) {
             canonicalLoaderDir = null;
-        } else { 
+        } else {
             try {
                 canonicalLoaderDir = loaderDir.getCanonicalPath();
                 if (!canonicalLoaderDir.endsWith(File.separator)) {
@@ -719,7 +718,7 @@
          return (this.clearReferencesStopThreads);
      }
 
-     
+
      /**
       * Set the clearReferencesStopThreads feature for this Context.
       *
@@ -810,7 +809,7 @@
              clearReferencesHttpClientKeepAliveThread;
      }
 
-     
+
     // ------------------------------------------------------- Reloader Methods
 
 
@@ -840,7 +839,7 @@
             repositoryURLs = null;
         } catch (MalformedURLException e) {
             IllegalArgumentException iae = new IllegalArgumentException
-                ("Invalid repository: " + repository); 
+                ("Invalid repository: " + repository);
             iae.initCause(e);
             throw iae;
         }
@@ -971,7 +970,7 @@
     /**
      * Return a String array of the current repositories for this class
      * loader.  If there are no repositories, a zero-length array is
-     * returned.For security reason, returns a clone of the Array (since 
+     * returned.For security reason, returns a clone of the Array (since
      * String are immutable).
      */
     public String[] findRepositories() {
@@ -1006,7 +1005,7 @@
                     ((ResourceAttributes) resources.getAttributes(paths[i]))
                     .getLastModified();
                 if (lastModified != lastModifiedDates[i]) {
-                    if( log.isDebugEnabled() ) 
+                    if( log.isDebugEnabled() )
                         log.debug("  Resource '" + paths[i]
                                   + "' was modified; Date is now: "
                                   + new java.util.Date(lastModified) + " Was: "
@@ -1035,7 +1034,7 @@
                         continue;
                     if (!name.equals(jarNames[i])) {
                         // Missing JAR
-                        log.info("    Additional JARs have been added : '" 
+                        log.info("    Additional JARs have been added : '"
                                  + name + "'");
                         return (true);
                     }
@@ -1043,7 +1042,7 @@
                 }
                 if (enumeration.hasMoreElements()) {
                     while (enumeration.hasMoreElements()) {
-                        NameClassPair ncPair = 
+                        NameClassPair ncPair =
                             (NameClassPair) enumeration.nextElement();
                         String name = ncPair.getName();
                         // Additional non-JAR files are allowed
@@ -1217,7 +1216,7 @@
         // Return the class we have located
         if (log.isTraceEnabled())
             log.debug("      Returning class " + clazz);
-        
+
         if ((log.isTraceEnabled()) && (clazz != null)) {
             ClassLoader cl;
             if (Globals.IS_SECURITY_ENABLED){
@@ -1407,13 +1406,13 @@
         // (2) Search local repositories
         url = findResource(name);
         if (url != null) {
-            // Locating the repository for special handling in the case 
+            // Locating the repository for special handling in the case
             // of a JAR
             if (antiJARLocking) {
                 ResourceEntry entry = (ResourceEntry) resourceEntries.get(name);
                 try {
                     String repository = entry.codeBase.toString();
-                    if ((repository.endsWith(".jar")) 
+                    if ((repository.endsWith(".jar"))
                             && (!(name.endsWith(".class")))) {
                         // Copy binary content to the work directory if not present
                         File resourceFile = new File(loaderDir, name);
@@ -1731,6 +1730,26 @@
     }
 
 
+    public boolean check(Permission permission) {
+        if (!Globals.IS_SECURITY_ENABLED) {
+            return true;
+        }
+        Policy currentPolicy = Policy.getPolicy();
+        if (currentPolicy != null) {
+            ResourceEntry entry = findResourceInternal("/", "/");
+            if (entry != null) {
+                CodeSource cs = new CodeSource(
+                        entry.codeBase, (java.security.cert.Certificate[]) null);
+                PermissionCollection pc = currentPolicy.getPermissions(cs);
+                if (pc.implies(permission)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+
     /**
      * Returns the search path of URLs for loading classes and resources.
      * This includes the original list of URLs specified to the constructor,
@@ -1798,7 +1817,7 @@
 
 
     /**
-     * Get the lifecycle listeners associated with this lifecycle. If this 
+     * Get the lifecycle listeners associated with this lifecycle. If this
      * Lifecycle has no listeners registered, a zero-length array is returned.
      */
     public LifecycleListener[] findLifecycleListeners() {
@@ -1850,9 +1869,9 @@
         // Clearing references should be done before setting started to
         // false, due to possible side effects
         clearReferences();
-        
+
         started = false;
-        
+
         int length = files.length;
         for (int i = 0; i < length; i++) {
             files[i] = null;
@@ -1896,13 +1915,13 @@
 
 
     /**
-     * Used to periodically signal to the classloader to release 
+     * Used to periodically signal to the classloader to release
      * JAR resources.
      */
     public void closeJARs(boolean force) {
         if (jarFiles.length > 0) {
                 synchronized (jarFiles) {
-                    if (force || (System.currentTimeMillis() 
+                    if (force || (System.currentTimeMillis()
                                   > (lastJarAccessed + 90000))) {
                         for (int i = 0; i < jarFiles.length; i++) {
                             try {
@@ -1924,7 +1943,7 @@
 
     // ------------------------------------------------------ Protected Methods
 
-    
+
     /**
      * Clear references.
      */
@@ -1935,10 +1954,10 @@
 
         // Stop any threads the web application started
         clearReferencesThreads();
-        
+
         // Clear any ThreadLocals loaded by this class loader
         clearReferencesThreadLocals();
-        
+
         // Clear RMI Targets loaded by this class loader
         if (clearReferencesRmiTargets) {
             clearReferencesRmiTargets();
@@ -1949,15 +1968,15 @@
         if (ENABLE_CLEAR_REFERENCES) {
             clearReferencesStaticFinal();
         }
-        
+
          // Clear the IntrospectionUtils cache.
         IntrospectionUtils.clear();
-        
+
         // Clear the classloader reference in common-logging
         if (clearReferencesLogFactoryRelease) {
             org.apache.juli.logging.LogFactory.release(this);
         }
-        
+
         // Clear the resource bundle cache
         // This shouldn't be necessary, the cache uses weak references but
         // it has caused leaks. Oddly, using the leak detection code in
@@ -1978,7 +1997,7 @@
      * if it checked the context class loader) b) using reflection would
      * create a dependency on the DriverManager implementation which can,
      * and has, changed.
-     * 
+     *
      * We can't just create an instance of JdbcLeakPrevention as it will be
      * loaded by the common class loader (since it's .class file is in the
      * $CATALINA_HOME/lib directory). This would fail DriverManager's check
@@ -1986,7 +2005,7 @@
      * our parent class loader but define the class with this class loader
      * so the JdbcLeakPrevention looks like a webapp class to the
      * DriverManager.
-     * 
+     *
      * If only apps cleaned up after themselves...
      */
     private final void clearReferencesJdbc() {
@@ -2038,7 +2057,7 @@
 
 
     private final void clearReferencesStaticFinal() {
-        
+
         @SuppressWarnings("unchecked")
         Collection<ResourceEntry> values =
             ((HashMap<String,ResourceEntry>) resourceEntries.clone()).values();
@@ -2074,7 +2093,7 @@
                     for (int i = 0; i < fields.length; i++) {
                         Field field = fields[i];
                         int mods = field.getModifiers();
-                        if (field.getType().isPrimitive() 
+                        if (field.getType().isPrimitive()
                                 || (field.getName().indexOf("$") != -1)) {
                             continue;
                         }
@@ -2089,13 +2108,13 @@
                                 } else {
                                     field.set(null, null);
                                     if (log.isDebugEnabled()) {
-                                        log.debug("Set field " + field.getName() 
+                                        log.debug("Set field " + field.getName()
                                                 + " to null in class " + clazz.getName());
                                     }
                                 }
                             } catch (Throwable t) {
                                 if (log.isDebugEnabled()) {
-                                    log.debug("Could not set field " + field.getName() 
+                                    log.debug("Could not set field " + field.getName()
                                             + " to null in class " + clazz.getName(), t);
                                 }
                             }
@@ -2108,7 +2127,7 @@
                 }
             }
         }
-        
+
     }
 
 
@@ -2120,7 +2139,7 @@
         for (int i = 0; i < fields.length; i++) {
             Field field = fields[i];
             int mods = field.getModifiers();
-            if (field.getType().isPrimitive() 
+            if (field.getType().isPrimitive()
                     || (field.getName().indexOf("$") != -1)) {
                 continue;
             }
@@ -2136,16 +2155,16 @@
                     if (!loadedByThisOrChild(valueClass)) {
                         if (log.isDebugEnabled()) {
                             log.debug("Not setting field " + field.getName() +
-                                    " to null in object of class " + 
+                                    " to null in object of class " +
                                     instance.getClass().getName() +
                                     " because the referenced object was of type " +
-                                    valueClass.getName() + 
+                                    valueClass.getName() +
                                     " which was not loaded by this WebappClassLoader.");
                         }
                     } else {
                         field.set(instance, null);
                         if (log.isDebugEnabled()) {
-                            log.debug("Set field " + field.getName() 
+                            log.debug("Set field " + field.getName()
                                     + " to null in class " + instance.getClass().getName());
                         }
                     }
@@ -2152,8 +2171,8 @@
                 }
             } catch (Throwable t) {
                 if (log.isDebugEnabled()) {
-                    log.debug("Could not set field " + field.getName() 
-                            + " to null in object instance of class " 
+                    log.debug("Could not set field " + field.getName()
+                            + " to null in object instance of class "
                             + instance.getClass().getName(), t);
                 }
             }
@@ -2164,7 +2183,7 @@
     @SuppressWarnings("deprecation")
     private void clearReferencesThreads() {
         Thread[] threads = getThreads();
-        
+
         // Iterate over the set of threads
         for (Thread thread : threads) {
             if (thread != null) {
@@ -2174,7 +2193,7 @@
                     if (thread == Thread.currentThread()) {
                         continue;
                     }
-                    
+
                     // JVM controlled threads
                     ThreadGroup tg = thread.getThreadGroup();
                     if (tg != null &&
@@ -2187,11 +2206,11 @@
                             log.debug(sm.getString(
                                     "webappClassLoader.checkThreadsHttpClient"));
                         }
-                    
+
                         // Don't warn about remaining JVM controlled threads
                         continue;
                     }
-                   
+
                     // Skip threads that have already died
                     if (!thread.isAlive()) {
                         continue;
@@ -2213,13 +2232,13 @@
                         log.error(sm.getString("webappClassLoader.warnThread",
                                 contextName, thread.getName()));
                     }
-                    
+
                     // Don't try an stop the threads unless explicitly
                     // configured to do so
                     if (!clearReferencesStopThreads) {
                         continue;
                     }
-                    
+
                     // If the thread has been started via an executor, try
                     // shutting down the executor
                     try {
@@ -2283,21 +2302,21 @@
         }
     }
 
-    
+
     /*
      * Look at a threads stack trace to see if it is a request thread or not. It
      * isn't perfect, but it should be good-enough for most cases.
      */
     private boolean isRequestThread(Thread thread) {
-        
+
         StackTraceElement[] elements = thread.getStackTrace();
-        
+
         if (elements == null || elements.length == 0) {
             // Must have stopped already. Too late to ignore it. Assume not a
             // request processing thread.
             return false;
         }
-        
+
         // Step through the methods in reverse order looking for calls to any
         // CoyoteAdapter method. All request threads will have this unless
         // Tomcat has been heavily modified - in which case there isn't much we
@@ -2311,8 +2330,8 @@
         }
         return false;
     }
-    
-    
+
+
     private void clearReferencesStopTimerThread(Thread thread) {
 
         // Need to get references to:
@@ -2431,7 +2450,7 @@
         } catch (InvocationTargetException e) {
             log.warn(sm.getString("webappClassLoader.clearThreadLocalFail",
                     contextName), e);
-        }       
+        }
     }
 
 
@@ -2597,13 +2616,13 @@
      * Get the set of current threads as an array.
      */
     private Thread[] getThreads() {
-        // Get the current thread group 
+        // Get the current thread group
         ThreadGroup tg = Thread.currentThread( ).getThreadGroup( );
         // Find the root thread group
         while (tg.getParent() != null) {
             tg = tg.getParent();
         }
-        
+
         int threadCountGuess = tg.activeCount() + 50;
         Thread[] threads = new Thread[threadCountGuess];
         int threadCountActual = tg.enumerate(threads);
@@ -2612,10 +2631,10 @@
             threadCountGuess *=2;
             threads = new Thread[threadCountGuess];
             // Note tg.enumerate(Thread[]) silently ignores any threads that
-            // can't fit into the array 
+            // can't fit into the array
             threadCountActual = tg.enumerate(threads);
         }
-        
+
         return threads;
     }
 
@@ -2645,7 +2664,7 @@
             if (objTable == null) {
                 return;
             }
-            
+
             // Iterate over the values in the table
             if (objTable instanceof Map<?,?>) {
                 Iterator<?> iter = ((Map<?,?>) objTable).values().iterator();
@@ -2668,7 +2687,7 @@
             if (implTable == null) {
                 return;
             }
-            
+
             // Iterate over the values in the table
             if (implTable instanceof Map<?,?>) {
                 Iterator<?> iter = ((Map<?,?>) implTable).values().iterator();
@@ -2708,8 +2727,8 @@
             }
         }
     }
-    
-    
+
+
     /**
      * Clear the {@link ResourceBundle} cache of any bundles loaded by this
      * class loader or any class loader where this loader is a parent class
@@ -2716,7 +2735,7 @@
      * loader. Whilst {@link ResourceBundle#clearCache()} could be used there
      * are complications around the {@link JasperLoader} that mean a reflection
      * based approach is more likely to be complete.
-     * 
+     *
      * The ResourceBundle is using WeakReferences so it shouldn't be pinning the
      * class loader in memory. However, it is. Therefore clear ou the
      * references.
@@ -2732,20 +2751,20 @@
             // Java 5 uses SoftCache extends Abstract Map
             // So use Map and it *should* work with both
             Map<?,?> cacheList = (Map<?,?>) cacheListField.get(null);
-            
+
             // Get the keys (loader references are in the key)
             Set<?> keys = cacheList.keySet();
-            
+
             Field loaderRefField = null;
-            
+
             // Iterate over the keys looking at the loader instances
             Iterator<?> keysIter = keys.iterator();
-            
+
             int countRemoved = 0;
-            
+
             while (keysIter.hasNext()) {
                 Object key = keysIter.next();
-                
+
                 if (loaderRefField == null) {
                     loaderRefField =
                         key.getClass().getDeclaredField("loaderRef");
@@ -2753,19 +2772,19 @@
                 }
                 WeakReference<?> loaderRef =
                     (WeakReference<?>) loaderRefField.get(key);
-                
+
                 ClassLoader loader = (ClassLoader) loaderRef.get();
-                
+
                 while (loader != null && loader != this) {
                     loader = loader.getParent();
                 }
-                
+
                 if (loader != null) {
                     keysIter.remove();
                     countRemoved++;
                 }
             }
-            
+
             if (countRemoved > 0 && log.isDebugEnabled()) {
                 log.debug(sm.getString(
                         "webappClassLoader.clearReferencesResourceBundlesCount",
@@ -2812,7 +2831,7 @@
             }
         }
         return result;
-    }    
+    }
 
 
     /**
@@ -2882,9 +2901,9 @@
             int pos = name.lastIndexOf('.');
             if (pos != -1)
                 packageName = name.substring(0, pos);
-        
+
             Package pkg = null;
-        
+
             if (packageName != null) {
                 pkg = getPackage(packageName);
                 // Define the package (if null)
@@ -2903,7 +2922,7 @@
                     pkg = getPackage(packageName);
                 }
             }
-    
+
             if (securityManager != null) {
 
                 // Checking sealing
@@ -2920,12 +2939,12 @@
                             ("Sealing violation loading " + name + " : Package "
                              + packageName + " is sealed.");
                 }
-    
+
             }
 
             try {
                 clazz = defineClass(name, entry.binaryContent, 0,
-                        entry.binaryContent.length, 
+                        entry.binaryContent.length,
                         new CodeSource(entry.codeBase, entry.certificates));
             } catch (UnsupportedClassVersionError ucve) {
                 throw new UnsupportedClassVersionError(
@@ -2940,7 +2959,7 @@
             entry.manifest = null;
             entry.certificates = null;
         }
-        
+
         return clazz;
 
     }
@@ -2957,11 +2976,11 @@
             entry.codeBase = getURL(new File(file, path), false);
         } catch (MalformedURLException e) {
             return null;
-        }   
+        }
         return entry;
     }
-    
 
+
     /**
      * Find specified resource in local repositories.
      *
@@ -3033,7 +3052,7 @@
 
                         int j;
 
-                        long[] result2 = 
+                        long[] result2 =
                             new long[lastModifiedDates.length + 1];
                         for (j = 0; j < lastModifiedDates.length; j++) {
                             result2[j] = lastModifiedDates[j];
@@ -3068,11 +3087,11 @@
                     return null;
                 }
                 for (i = 0; (entry == null) && (i < jarFilesLength); i++) {
-    
+
                     jarEntry = jarFiles[i].getJarEntry(path);
-    
+
                     if (jarEntry != null) {
-    
+
                         entry = new ResourceEntry();
                         try {
                             entry.codeBase = getURL(jarRealFiles[i], false);
@@ -3090,7 +3109,7 @@
                         } catch (IOException e) {
                             return null;
                         }
-    
+
                         // Extract resources contained in JAR to the workdir
                         if (antiJARLocking && !(path.endsWith(".class"))) {
                             byte[] buf = new byte[1024];
@@ -3101,7 +3120,7 @@
                                     jarFiles[i].entries();
                                 while (entries.hasMoreElements()) {
                                     JarEntry jarEntry2 =  entries.nextElement();
-                                    if (!(jarEntry2.isDirectory()) 
+                                    if (!(jarEntry2.isDirectory())
                                         && (!jarEntry2.getName().endsWith
                                             (".class"))) {
                                         resourceFile = new File
@@ -3117,7 +3136,7 @@
                                             throw new IllegalArgumentException(
                                                     sm.getString("webappClassLoader.validationErrorJarPath",
                                                             jarEntry2.getName()), ioe);
-                                        }                                 
+                                        }
                                         resourceFile.getParentFile().mkdirs();
                                         FileOutputStream os = null;
                                         InputStream is = null;
@@ -3153,11 +3172,11 @@
                                 }
                             }
                         }
-    
+
                     }
-    
+
                 }
-    
+
                 if (entry == null) {
                     synchronized (notFoundResources) {
                         notFoundResources.put(name, name);
@@ -3164,14 +3183,14 @@
                     }
                     return null;
                 }
-    
+
                 if (binaryStream != null) {
-    
+
                     byte[] binaryContent = new byte[contentLength];
-    
+
                     int pos = 0;
                     try {
-    
+
                         while (true) {
                             int n = binaryStream.read(binaryContent, pos,
                                                       binaryContent.length - pos);
@@ -3196,13 +3215,13 @@
                         }
                     }
                     entry.binaryContent = binaryContent;
-    
-                    // The certificates are only available after the JarEntry 
+
+                    // The certificates are only available after the JarEntry
                     // associated input stream has been fully read
                     if (jarEntry != null) {
                         entry.certificates = jarEntry.getCertificates();
                     }
-    
+
                 }
             } finally {
                 if (binaryStream != null) {
@@ -3238,7 +3257,7 @@
     protected boolean isPackageSealed(String name, Manifest man) {
 
         String path = name.replace('.', '/') + '/';
-        Attributes attr = man.getAttributes(path); 
+        Attributes attr = man.getAttributes(path);
         String sealed = null;
         if (attr != null) {
             sealed = attr.getValue(Name.SEALED);
@@ -3297,8 +3316,8 @@
     protected void refreshPolicy() {
 
         try {
-            // The policy file may have been modified to adjust 
-            // permissions, so we're reloading it when loading or 
+            // The policy file may have been modified to adjust
+            // permissions, so we're reloading it when loading or
             // reloading a Context
             Policy policy = Policy.getPolicy();
             policy.refresh();
@@ -3312,7 +3331,7 @@
 
     /**
      * Filter classes.
-     * 
+     *
      * @param name class name
      * @return true if the class should be filtered
      */
@@ -3340,12 +3359,12 @@
 
 
     /**
-     * Validate a classname. As per SRV.9.7.2, we must restict loading of 
-     * classes from J2SE (java.*) and classes of the servlet API 
+     * Validate a classname. As per SRV.9.7.2, we must restict loading of
+     * classes from J2SE (java.*) and classes of the servlet API
      * (javax.servlet.*). That should enhance robustness and prevent a number
      * of user error (where an older version of servlet.jar would be present
      * in /WEB-INF/lib).
-     * 
+     *
      * @param name class name
      * @return true if the name is valid
      */
Index: tc6.0.x/trunk/java/org/apache/tomcat/util/digester/Digester.java
===================================================================
--- tc6.0.x/trunk/java/org/apache/tomcat/util/digester/Digester.java	(revision 1754732)
+++ tc6.0.x/trunk/java/org/apache/tomcat/util/digester/Digester.java	(revision 1754733)
@@ -26,6 +26,7 @@
 import java.lang.reflect.InvocationTargetException;
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.security.Permission;
 import java.util.EmptyStackException;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -32,6 +33,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
+import java.util.PropertyPermission;
 
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParser;
@@ -40,6 +42,7 @@
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.IntrospectionUtils;
+import org.apache.tomcat.util.security.PermissionCheck;
 import org.xml.sax.Attributes;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.ErrorHandler;
@@ -80,6 +83,13 @@
     private static class SystemPropertySource
         implements IntrospectionUtils.PropertySource {
         public String getProperty( String key ) {
+            ClassLoader cl = Thread.currentThread().getContextClassLoader();
+            if (cl instanceof PermissionCheck) {
+                Permission p = new PropertyPermission(key, "read");
+                if (!((PermissionCheck) cl).check(p)) {
+                    return null;
+                }
+            }
             return System.getProperty(key);
         }
     }
Index: tc6.0.x/trunk/java/org/apache/tomcat/util/security/PermissionCheck.java
===================================================================
--- tc6.0.x/trunk/java/org/apache/tomcat/util/security/PermissionCheck.java	(nonexistent)
+++ tc6.0.x/trunk/java/org/apache/tomcat/util/security/PermissionCheck.java	(revision 1754733)
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.security;
+
+import java.security.Permission;
+
+/**
+ * This interface is implemented by components to enable privileged code to
+ * check whether the component has a given permission.
+ * This is typically used when a privileged component (e.g. the container) is
+ * performing an action on behalf of an untrusted component (e.g. a web
+ * application) without the current thread having passed through a code source
+ * provided by the untrusted component. Because the current thread has not
+ * passed through a code source provided by the untrusted component the
+ * SecurityManager assumes the code is trusted so the standard checking
+ * mechanisms can't be used.
+ */
+public interface PermissionCheck {
+
+    /**
+     * Does this component have the given permission?
+     *
+     * @param permission The permission to test
+     *
+     * @return {@code false} if a SecurityManager is enabled and the component
+     *         does not have the given permission, otherwise {@code false}
+     */
+    boolean check(Permission permission);
+}

Property changes on: tc6.0.x/trunk/java/org/apache/tomcat/util/security/PermissionCheck.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: tc6.0.x/trunk/webapps/docs/changelog.xml
===================================================================
--- tc6.0.x/trunk/webapps/docs/changelog.xml	(revision 1754732)
+++ tc6.0.x/trunk/webapps/docs/changelog.xml	(revision 1754733)
@@ -109,6 +109,14 @@
         <code>dispatchersUseEncodedPaths</code> attribute of the Context.
         (markt)
       </fix>
+      <add>
+        Provide a mechanism that enables the container to check if a component
+        (typically a web application) has been granted a given permission when
+        running under a SecurityManager without the current execution stack
+        having to have passed through the component. Use this new mechanism to
+        extend SecurityManager protection to the system property replacement
+        feature of the digester. (markt)
+      </add>
     </changelog>
   </subsection>
   <subsection name="Coyote">
Index: tc6.0.x/trunk
===================================================================
--- tc6.0.x/trunk	(revision 1754732)
+++ tc6.0.x/trunk	(revision 1754733)

Property changes on: tc6.0.x/trunk
___________________________________________________________________
Modified: svn:mergeinfo
## -0,0 +0,3 ##
   Merged /tomcat/tc7.0.x/trunk:r1754728
   Merged /tomcat/trunk:r1754445
   Merged /tomcat/tc8.5.x/trunk:r1754726
