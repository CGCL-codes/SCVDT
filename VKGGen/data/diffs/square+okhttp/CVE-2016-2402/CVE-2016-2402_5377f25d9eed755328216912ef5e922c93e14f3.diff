diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/CertificateAuthorityCouncilTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/CertificateChainCleanerTest.java
similarity index 74%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/CertificateAuthorityCouncilTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/CertificateChainCleanerTest.java
index ed5180f79d..68c0946b1a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/CertificateAuthorityCouncilTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/CertificateChainCleanerTest.java
@@ -15,33 +15,34 @@
  */
 package com.squareup.okhttp.internal.tls;
 
+import com.squareup.okhttp.internal.HeldCertificate;
 import java.security.cert.Certificate;
 import java.util.ArrayList;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import com.squareup.okhttp.internal.HeldCertificate;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-public final class CertificateAuthorityCouncilTest {
+public final class CertificateChainCleanerTest {
   @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
         .serialNumber("1")
         .build();
-    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
-    assertEquals(list(root), council.normalizeCertificateChain(list(root)));
+    CertificateChainCleaner council = new CertificateChainCleaner(
+        new RealTrustRootIndex(root.certificate));
+    assertEquals(list(root), council.clean(list(root)));
   }
 
   @Test public void normalizeUnknownSelfSignedCertificate() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
         .serialNumber("1")
         .build();
-    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil();
+    CertificateChainCleaner council = new CertificateChainCleaner(new RealTrustRootIndex());
 
     try {
-      council.normalizeCertificateChain(list(root));
+      council.clean(list(root));
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
@@ -60,9 +61,9 @@
         .issuedBy(certA)
         .build();
 
-    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
-    assertEquals(list(certB, certA, root),
-        council.normalizeCertificateChain(list(certB, certA, root)));
+    CertificateChainCleaner council = new CertificateChainCleaner(
+        new RealTrustRootIndex(root.certificate));
+    assertEquals(list(certB, certA, root), council.clean(list(certB, certA, root)));
   }
 
   @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
@@ -78,9 +79,9 @@
         .issuedBy(certA)
         .build();
 
-    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
-    assertEquals(list(certB, certA, root),
-        council.normalizeCertificateChain(list(certB, certA))); // Root is added!
+    CertificateChainCleaner council = new CertificateChainCleaner(
+        new RealTrustRootIndex(root.certificate));
+    assertEquals(list(certB, certA, root), council.clean(list(certB, certA))); // Root is added!
   }
 
   @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
@@ -100,9 +101,9 @@
         .issuedBy(certB)
         .build();
 
-    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
-    assertEquals(list(certC, certB, certA, root),
-        council.normalizeCertificateChain(list(certC, certA, root, certB)));
+    CertificateChainCleaner council = new CertificateChainCleaner(
+        new RealTrustRootIndex(root.certificate));
+    assertEquals(list(certC, certB, certA, root), council.clean(list(certC, certA, root, certB)));
   }
 
   @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
@@ -122,9 +123,9 @@
         .issuedBy(certB)
         .build();
 
-    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
-    assertEquals(list(certC, certB, certA, root),
-        council.normalizeCertificateChain(list(certC, certA, certB)));
+    CertificateChainCleaner council = new CertificateChainCleaner(
+        new RealTrustRootIndex(root.certificate));
+    assertEquals(list(certC, certB, certA, root), council.clean(list(certC, certA, certB)));
   }
 
   @Test public void unrelatedCertificatesAreOmitted() throws Exception {
@@ -143,9 +144,10 @@
         .serialNumber("4")
         .build();
 
-    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(root.certificate);
+    CertificateChainCleaner council = new CertificateChainCleaner(
+        new RealTrustRootIndex(root.certificate));
     assertEquals(list(certB, certA, root),
-        council.normalizeCertificateChain(list(certB, certUnnecessary, certA, root)));
+        council.clean(list(certB, certUnnecessary, certA, root)));
   }
 
   @Test public void unnecessaryTrustedCertificatesAreOmitted() throws Exception {
@@ -165,10 +167,9 @@
         .issuedBy(certA)
         .build();
 
-    CertificateAuthorityCouncil council = new CertificateAuthorityCouncil(
-        superRoot.certificate, root.certificate);
-    assertEquals(list(certB, certA, root),
-        council.normalizeCertificateChain(list(certB, certA, root, superRoot)));
+    CertificateChainCleaner council = new CertificateChainCleaner(
+        new RealTrustRootIndex(superRoot.certificate, root.certificate));
+    assertEquals(list(certB, certA, root), council.clean(list(certB, certA, root, superRoot)));
   }
 
   private List<Certificate> list(HeldCertificate... heldCertificates) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java b/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
index 1b7bbb0ca7..bd3df19ca2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
@@ -135,7 +135,7 @@
   private final Map<String, Set<ByteString>> hostnameToPins;
 
   private CertificatePinner(Builder builder) {
-    hostnameToPins = Util.immutableMap(builder.hostnameToPins);
+    this.hostnameToPins = Util.immutableMap(builder.hostnameToPins);
   }
 
   /**
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index 044ed08423..a2df181fc6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -18,6 +18,9 @@
 
 import android.util.Log;
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.tls.AndroidTrustRootIndex;
+import com.squareup.okhttp.internal.tls.RealTrustRootIndex;
+import com.squareup.okhttp.internal.tls.TrustRootIndex;
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationHandler;
@@ -86,6 +89,10 @@ public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
     return null;
   }
 
+  public TrustRootIndex trustRootIndex(X509TrustManager trustManager) {
+    return new RealTrustRootIndex(trustManager.getAcceptedIssuers());
+  }
+
   /**
    * Configure TLS extensions on {@code sslSocket} for {@code route}.
    *
@@ -235,7 +242,18 @@ public Android(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSession
 
     @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
       Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
-      if (context == null) return null;
+      if (context == null) {
+        // If that didn't work, try the Google Play Services SSL provider before giving up. This
+        // must be loaded by the SSLSocketFactory's class loader.
+        try {
+          Class<?> gmsSslParametersClass = Class.forName(
+              "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
+              sslSocketFactory.getClass().getClassLoader());
+          context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass, "sslParameters");
+        } catch (ClassNotFoundException e) {
+          return null;
+        }
+      }
 
       X509TrustManager x509TrustManager = readFieldOrNull(
           context, X509TrustManager.class, "x509TrustManager");
@@ -244,6 +262,12 @@ public Android(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSession
       return readFieldOrNull(context, X509TrustManager.class, "trustManager");
     }
 
+    @Override public TrustRootIndex trustRootIndex(X509TrustManager trustManager) {
+      TrustRootIndex result = AndroidTrustRootIndex.get(trustManager);
+      if (result != null) return result;
+      return super.trustRootIndex(trustManager);
+    }
+
     @Override public void configureTlsExtensions(
         SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
       // Enable SNI and session tickets.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java
index c9c6059556..9ff53c1c10 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java
@@ -35,8 +35,9 @@
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.StreamAllocation;
-import com.squareup.okhttp.internal.tls.CertificateAuthorityCouncil;
+import com.squareup.okhttp.internal.tls.CertificateChainCleaner;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
+import com.squareup.okhttp.internal.tls.TrustRootIndex;
 import java.io.IOException;
 import java.lang.ref.Reference;
 import java.net.ConnectException;
@@ -202,8 +203,9 @@ private void connectTls(int readTimeout, int writeTimeout,
 
       // Check that the certificate pinner is satisfied by the certificates presented.
       if (address.getCertificatePinner() != CertificatePinner.DEFAULT) {
-        List<Certificate> certificates = certificateAuthorityCouncil(address.getSslSocketFactory())
-            .normalizeCertificateChain(unverifiedHandshake.peerCertificates());
+        TrustRootIndex trustRootIndex = trustRootIndex(address.getSslSocketFactory());
+        List<Certificate> certificates = new CertificateChainCleaner(trustRootIndex)
+            .clean(unverifiedHandshake.peerCertificates());
         address.getCertificatePinner().check(address.getUriHost(), certificates);
       }
 
@@ -233,22 +235,20 @@ private void connectTls(int readTimeout, int writeTimeout,
   }
 
   private static SSLSocketFactory lastSslSocketFactory;
-  private static CertificateAuthorityCouncil lastCertificateAuthorityCouncil;
+  private static TrustRootIndex lastTrustRootIndex;
 
   /**
-   * Returns a certificate authority council for {@code sslSocketFactory}. This uses a static,
-   * single-element cache to avoid redoing reflection and SSL indexing in the common case where most
-   * SSL connections use the same SSL socket factory.
+   * Returns a trust root index for {@code sslSocketFactory}. This uses a static, single-element
+   * cache to avoid redoing reflection and SSL indexing in the common case where most SSL
+   * connections use the same SSL socket factory.
    */
-  private static synchronized CertificateAuthorityCouncil certificateAuthorityCouncil(
-      SSLSocketFactory sslSocketFactory) {
+  private static synchronized TrustRootIndex trustRootIndex(SSLSocketFactory sslSocketFactory) {
     if (sslSocketFactory != lastSslSocketFactory) {
       X509TrustManager trustManager = Platform.get().trustManager(sslSocketFactory);
-      lastCertificateAuthorityCouncil = new CertificateAuthorityCouncil(
-          trustManager.getAcceptedIssuers());
+      lastTrustRootIndex = Platform.get().trustRootIndex(trustManager);
       lastSslSocketFactory = sslSocketFactory;
     }
-    return lastCertificateAuthorityCouncil;
+    return lastTrustRootIndex;
   }
 
   /**
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/AndroidTrustRootIndex.java b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/AndroidTrustRootIndex.java
new file mode 100644
index 0000000000..7e683a77dc
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/AndroidTrustRootIndex.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.tls;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.security.cert.TrustAnchor;
+import java.security.cert.X509Certificate;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * A index of trusted root certificates that exploits knowledge of Android implementation details.
+ * This class is potentially much faster to initialize than {@link RealTrustRootIndex} because
+ * it doesn't need to load and index trusted CA certificates.
+ */
+public final class AndroidTrustRootIndex implements TrustRootIndex {
+  private final X509TrustManager trustManager;
+  private final Method findByIssuerAndSignatureMethod;
+
+  public AndroidTrustRootIndex(
+      X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
+    this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
+    this.trustManager = trustManager;
+  }
+
+  @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+    try {
+      TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
+          trustManager, cert);
+      return trustAnchor.getTrustedCert();
+    } catch (IllegalAccessException e) {
+      throw new AssertionError();
+    } catch (InvocationTargetException e) {
+      return null;
+    }
+  }
+
+  public static TrustRootIndex get(X509TrustManager trustManager) {
+    // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
+    // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
+    try {
+      Method method = trustManager.getClass().getDeclaredMethod(
+          "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
+      method.setAccessible(true);
+      return new AndroidTrustRootIndex(trustManager, method);
+    } catch (NoSuchMethodException e) {
+      return null;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/CertificateAuthorityCouncil.java b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/CertificateChainCleaner.java
similarity index 57%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/tls/CertificateAuthorityCouncil.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/tls/CertificateChainCleaner.java
index c1c62e1f01..8095dcaada 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/CertificateAuthorityCouncil.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/CertificateChainCleaner.java
@@ -17,56 +17,43 @@
 package com.squareup.okhttp.internal.tls;
 
 import java.security.GeneralSecurityException;
-import java.security.PublicKey;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
 import java.util.Iterator;
-import java.util.LinkedHashMap;
 import java.util.List;
-import java.util.Map;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.security.auth.x500.X500Principal;
 
 /**
- * A set of trusted Certificate Authority (CA) certificates that are trusted to verify the TLS
- * certificates offered by remote web servers.
+ * Computes the effective certificate chain from the raw array returned by Java's built in TLS APIs.
+ * Cleaning a chain returns a list of certificates where the first element is {@code chain[0]}, each
+ * certificate is signed by the certificate that follows, and the last certificate is a trusted CA
+ * certificate.
+ *
+ * <p>Use of the chain cleaner is necessary to omit unexpected certificates that aren't relevant to
+ * the TLS handshake and to extract the trusted CA certificate for the benefit of certificate
+ * pinning.
  *
  * <p>This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> {@code
  * TrustManagerImpl} and {@code TrustedCertificateIndex}.
  */
-public final class CertificateAuthorityCouncil {
-  private final Map<X500Principal, List<X509Certificate>> subjectToCaCerts = new LinkedHashMap<>();
+public final class CertificateChainCleaner {
+  private final TrustRootIndex trustRootIndex;
 
-  public CertificateAuthorityCouncil(X509Certificate... caCerts) {
-    for (X509Certificate caCert : caCerts) {
-      X500Principal subject = caCert.getSubjectX500Principal();
-      List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
-      if (subjectCaCerts == null) {
-        subjectCaCerts = new ArrayList<>(1);
-        subjectToCaCerts.put(subject, subjectCaCerts);
-      }
-      subjectCaCerts.add(caCert);
-    }
+  public CertificateChainCleaner(TrustRootIndex trustRootIndex) {
+    this.trustRootIndex = trustRootIndex;
   }
 
   /**
-   * Computes the effective certificate chain from the raw array returned by Java's built in TLS
-   * APIs. This method returns a list of certificates where the first element is {@code chain[0]},
-   * each certificate is signed by the certificate that follows, and the last certificate is a
-   * trusted CA certificate.
-   *
-   * <p>Use of this method is necessary to omit unexpected certificates that aren't relevant to the
-   * TLS handshake and to extract the trusted CA certificate for the benefit of certificate pinning.
+   * Returns a cleaned chain for {@code chain}.
    *
    * <p>This method throws if the complete chain to a trusted CA certificate cannot be constructed.
-   * This is unexpected unless the X509 trust manager in this class is different from the trust
-   * manager that was used to establish {@code chain}.
+   * This is unexpected unless the trust root index in this class has a different trust manager than
+   * what was used to establish {@code chain}.
    */
-  public List<Certificate> normalizeCertificateChain(List<Certificate> chain)
-      throws SSLPeerUnverifiedException {
+  public List<Certificate> clean(List<Certificate> chain) throws SSLPeerUnverifiedException {
     Deque<Certificate> queue = new ArrayDeque<>(chain);
     List<Certificate> result = new ArrayList<>();
     result.add(queue.removeFirst());
@@ -78,8 +65,8 @@ public CertificateAuthorityCouncil(X509Certificate... caCerts) {
       // If this cert has been signed by a trusted CA cert, we're done. Add the trusted CA
       // certificate to the end of the chain, unless it's already present. (That would happen if the
       // first certificate in the chain is itself a self-signed and trusted CA certificate.)
-      X509Certificate caCert = findByIssuerAndSignature(toVerify);
-      if (caCert != null && verifySignature(toVerify, caCert)) {
+      X509Certificate caCert = trustRootIndex.findByIssuerAndSignature(toVerify);
+      if (caCert != null) {
         if (result.size() > 1 || !toVerify.equals(caCert)) {
           result.add(caCert);
         }
@@ -111,22 +98,4 @@ private boolean verifySignature(X509Certificate toVerify, X509Certificate signin
       return false;
     }
   }
-
-  /** Returns the trusted CA certificate that signed {@code cert}. */
-  private X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-    X500Principal issuer = cert.getIssuerX500Principal();
-    List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
-    if (subjectCaCerts == null) return null;
-
-    for (X509Certificate caCert : subjectCaCerts) {
-      PublicKey publicKey = caCert.getPublicKey();
-      try {
-        cert.verify(publicKey);
-        return caCert;
-      } catch (Exception ignored) {
-      }
-    }
-
-    return null;
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/RealTrustRootIndex.java b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/RealTrustRootIndex.java
new file mode 100644
index 0000000000..885eea4ecf
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/RealTrustRootIndex.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.tls;
+
+import java.security.PublicKey;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import javax.security.auth.x500.X500Principal;
+
+public final class RealTrustRootIndex implements TrustRootIndex {
+  private final Map<X500Principal, List<X509Certificate>> subjectToCaCerts;
+
+  public RealTrustRootIndex(X509Certificate... caCerts) {
+    subjectToCaCerts = new LinkedHashMap<>();
+    for (X509Certificate caCert : caCerts) {
+      X500Principal subject = caCert.getSubjectX500Principal();
+      List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
+      if (subjectCaCerts == null) {
+        subjectCaCerts = new ArrayList<>(1);
+        subjectToCaCerts.put(subject, subjectCaCerts);
+      }
+      subjectCaCerts.add(caCert);
+    }
+  }
+
+  @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+    X500Principal issuer = cert.getIssuerX500Principal();
+    List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
+    if (subjectCaCerts == null) return null;
+
+    for (X509Certificate caCert : subjectCaCerts) {
+      PublicKey publicKey = caCert.getPublicKey();
+      try {
+        cert.verify(publicKey);
+        return caCert;
+      } catch (Exception ignored) {
+      }
+    }
+
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/TrustRootIndex.java
new file mode 100644
index 0000000000..6b0036b70f
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/TrustRootIndex.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.tls;
+
+import java.security.cert.X509Certificate;
+
+public interface TrustRootIndex {
+  /** Returns the trusted CA certificate that signed {@code cert}. */
+  X509Certificate findByIssuerAndSignature(X509Certificate cert);
+}
