From 214c1eefa6422539150a9ad467e65c7839a056b9 Mon Sep 17 00:00:00 2001
From: Jinmei Liao <jiliao@pivotal.io>
Date: Tue, 16 Jan 2018 11:17:24 -0800
Subject: [PATCH 1/5] GEODE-3974: function security improvement

* function executed on a local member does not log out user accidentally
* Mark some internal functions as InternalEntity
* test refactor
---
 .../modules/util/CreateRegionFunction.java    |  12 +-
 ...TouchPartitionedRegionEntriesFunction.java |  16 +-
 .../TouchReplicatedRegionEntriesFunction.java |  24 +-
 .../util/ModuleFunctionsSecurityTest.java     |  72 +--
 .../JDBCConnectorFunctionsSecurityTest.java   | 111 ++---
 .../deadlock/GemFireDeadlockDetector.java     |   5 +-
 .../cache/snapshot/ClientExporter.java        |   4 +-
 .../snapshot/RegionSnapshotServiceImpl.java   |   5 +-
 .../cache/snapshot/WindowedExporter.java      |  11 +-
 .../internal/beans/QueryDataFunction.java     |   5 +-
 .../cli/functions/ExportDataFunction.java     |   8 +-
 .../FetchRegionAttributesFunction.java        |   5 +-
 .../cli/functions/ImportDataFunction.java     |   4 +-
 .../cli/functions/UserFunctionExecution.java  |  20 +-
 .../GetClusterConfigurationFunction.java      |   3 +-
 .../ClientExecuteFunctionAuthDUnitTest.java   | 106 ++---
 .../test/LuceneFunctionSecurityTest.java      | 431 ++----------------
 17 files changed, 185 insertions(+), 657 deletions(-)

diff --git a/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/CreateRegionFunction.java b/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/CreateRegionFunction.java
index bf998d17033..99e0c4425e1 100644
--- a/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/CreateRegionFunction.java
+++ b/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/CreateRegionFunction.java
@@ -33,7 +33,6 @@
 import org.apache.geode.cache.Region;
 import org.apache.geode.cache.RegionAttributes;
 import org.apache.geode.cache.Scope;
-import org.apache.geode.cache.client.ClientCache;
 import org.apache.geode.cache.execute.Function;
 import org.apache.geode.cache.execute.FunctionContext;
 import org.apache.geode.cache.partition.PartitionRegionHelper;
@@ -64,19 +63,10 @@
       "__regionConfigurationMetadata";
 
   public CreateRegionFunction() {
-    this(CacheFactory.getAnyInstance());
-  }
-
-  public CreateRegionFunction(Cache cache) {
-    this.cache = cache;
+    this.cache = CacheFactory.getAnyInstance();
     this.regionConfigurationsRegion = createRegionConfigurationMetadataRegion();
   }
 
-  public CreateRegionFunction(ClientCache cache) {
-    this.cache = null;
-    this.regionConfigurationsRegion = null;
-  }
-
   public void execute(FunctionContext context) {
     RegionConfiguration configuration = (RegionConfiguration) context.getArguments();
     if (this.cache.getLogger().fineEnabled()) {
diff --git a/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/TouchPartitionedRegionEntriesFunction.java b/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/TouchPartitionedRegionEntriesFunction.java
index d503359364d..cc515e2fe6c 100644
--- a/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/TouchPartitionedRegionEntriesFunction.java
+++ b/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/TouchPartitionedRegionEntriesFunction.java
@@ -24,7 +24,6 @@
 
 import org.apache.geode.DataSerializable;
 import org.apache.geode.cache.Cache;
-import org.apache.geode.cache.CacheFactory;
 import org.apache.geode.cache.Declarable;
 import org.apache.geode.cache.Region;
 import org.apache.geode.cache.execute.Function;
@@ -42,31 +41,22 @@
 
   private static final long serialVersionUID = -3700389655056961153L;
 
-  private final Cache cache;
-
   public static final String ID = "touch-partitioned-region-entries";
 
-  public TouchPartitionedRegionEntriesFunction() {
-    this(CacheFactory.getAnyInstance());
-  }
-
-  public TouchPartitionedRegionEntriesFunction(Cache cache) {
-    this.cache = cache;
-  }
-
   @SuppressWarnings("unchecked")
   public void execute(FunctionContext context) {
     RegionFunctionContext rfc = (RegionFunctionContext) context;
     Set<String> keys = (Set<String>) rfc.getFilter();
 
+    Cache cache = context.getCache();
     // Get local (primary) data for the context
     Region primaryDataSet = PartitionRegionHelper.getLocalDataForContext(rfc);
 
-    if (this.cache.getLogger().fineEnabled()) {
+    if (cache.getLogger().fineEnabled()) {
       StringBuilder builder = new StringBuilder();
       builder.append("Function ").append(ID).append(" received request to touch ")
           .append(primaryDataSet.getFullPath()).append("->").append(keys);
-      this.cache.getLogger().fine(builder.toString());
+      cache.getLogger().fine(builder.toString());
     }
 
     // Retrieve each value to update the lastAccessedTime.
diff --git a/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/TouchReplicatedRegionEntriesFunction.java b/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/TouchReplicatedRegionEntriesFunction.java
index 7fcb0e9e494..b220cba4570 100644
--- a/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/TouchReplicatedRegionEntriesFunction.java
+++ b/extensions/geode-modules/src/main/java/org/apache/geode/modules/util/TouchReplicatedRegionEntriesFunction.java
@@ -24,11 +24,11 @@
 
 import org.apache.geode.DataSerializable;
 import org.apache.geode.cache.Cache;
-import org.apache.geode.cache.CacheFactory;
 import org.apache.geode.cache.Declarable;
 import org.apache.geode.cache.Region;
 import org.apache.geode.cache.execute.Function;
 import org.apache.geode.cache.execute.FunctionContext;
+import org.apache.geode.management.internal.security.ResourcePermissions;
 import org.apache.geode.security.ResourcePermission;
 
 /**
@@ -41,31 +41,22 @@
 
   private static final long serialVersionUID = -7424895036162243564L;
 
-  private final Cache cache;
-
   public static final String ID = "touch-replicated-region-entries";
 
-  public TouchReplicatedRegionEntriesFunction() {
-    this(CacheFactory.getAnyInstance());
-  }
-
-  public TouchReplicatedRegionEntriesFunction(Cache cache) {
-    this.cache = cache;
-  }
-
   public void execute(FunctionContext context) {
     Object[] arguments = (Object[]) context.getArguments();
+    Cache cache = context.getCache();
     String regionName = (String) arguments[0];
     Set<String> keys = (Set<String>) arguments[1];
-    if (this.cache.getLogger().fineEnabled()) {
+    if (cache.getLogger().fineEnabled()) {
       StringBuilder builder = new StringBuilder();
       builder.append("Function ").append(ID).append(" received request to touch ")
           .append(regionName).append("->").append(keys);
-      this.cache.getLogger().fine(builder.toString());
+      cache.getLogger().fine(builder.toString());
     }
 
     // Retrieve the appropriate Region and value to update the lastAccessedTime
-    Region region = this.cache.getRegion(regionName);
+    Region region = cache.getRegion(regionName);
     if (region != null) {
       region.getAll(keys);
     }
@@ -75,9 +66,10 @@ public void execute(FunctionContext context) {
   }
 
   @Override
+  // the actual regionName used in the function body is passed in as an function arugment,
+  // this regionName is not really used in function. Hence requiring DATA:READ on all regions
   public Collection<ResourcePermission> getRequiredPermissions(String regionName) {
-    return Collections.singletonList(new ResourcePermission(ResourcePermission.Resource.DATA,
-        ResourcePermission.Operation.READ, regionName));
+    return Collections.singletonList(ResourcePermissions.DATA_READ);
   }
 
   public String getId() {
diff --git a/extensions/geode-modules/src/test/java/org/apache/geode/modules/util/ModuleFunctionsSecurityTest.java b/extensions/geode-modules/src/test/java/org/apache/geode/modules/util/ModuleFunctionsSecurityTest.java
index 469b7c91a7f..3f65bab5d8e 100644
--- a/extensions/geode-modules/src/test/java/org/apache/geode/modules/util/ModuleFunctionsSecurityTest.java
+++ b/extensions/geode-modules/src/test/java/org/apache/geode/modules/util/ModuleFunctionsSecurityTest.java
@@ -15,6 +15,9 @@
 
 package org.apache.geode.modules.util;
 
+import java.util.HashMap;
+import java.util.Map;
+
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
 import org.junit.Rule;
@@ -22,6 +25,7 @@
 import org.junit.experimental.categories.Category;
 
 import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.cache.execute.Function;
 import org.apache.geode.cache.execute.FunctionService;
 import org.apache.geode.examples.SimpleSecurityManager;
 import org.apache.geode.test.junit.categories.IntegrationTest;
@@ -38,66 +42,34 @@
   @ClassRule
   public static ServerStarterRule server =
       new ServerStarterRule().withJMXManager().withSecurityManager(SimpleSecurityManager.class)
-          .withRegion(RegionShortcut.REPLICATE, "REPLICATE_1")
-          .withRegion(RegionShortcut.PARTITION, "PARTITION_1").withAutoStart();
+          .withRegion(RegionShortcut.REPLICATE, "AuthRegion").withAutoStart();
 
   @Rule
   public GfshCommandRule gfsh =
       new GfshCommandRule(server::getJmxPort, GfshCommandRule.PortType.jmxManager);
 
+  private static Map<Function, String> functionStringMap = new HashMap<>();
+
   @BeforeClass
   public static void setupClass() {
-    FunctionService.registerFunction(new BootstrappingFunction());
-    FunctionService.registerFunction(new CreateRegionFunction());
-    FunctionService.registerFunction(new RegionSizeFunction());
-    FunctionService.registerFunction(new TouchPartitionedRegionEntriesFunction());
-    FunctionService.registerFunction(new TouchReplicatedRegionEntriesFunction());
-  }
+    functionStringMap.put(new BootstrappingFunction(), "CLUSTER:MANAGE");
+    functionStringMap.put(new CreateRegionFunction(), "DATA:MANAGE");
+    functionStringMap.put(new RegionSizeFunction(), "DATA:READ:AuthRegion");
+    functionStringMap.put(new TouchPartitionedRegionEntriesFunction(), "DATA:READ:AuthRegion");
+    functionStringMap.put(new TouchReplicatedRegionEntriesFunction(), "DATA:READ");
 
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForBootstrappingFunction() throws Exception {
-    gfsh.executeAndAssertThat("execute function --id=" + BootstrappingFunction.ID)
-        .tableHasColumnWithExactValuesInAnyOrder(RESULT_HEADER,
-            "Exception: dataWrite not authorized for CLUSTER:MANAGE")
-        .statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForCreateRegionFunction() throws Exception {
-    gfsh.executeAndAssertThat("execute function --id=" + CreateRegionFunction.ID)
-        .tableHasColumnWithExactValuesInAnyOrder(RESULT_HEADER,
-            "Exception: dataWrite not authorized for DATA:MANAGE")
-        .statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForRegionSizeFunction() throws Exception {
-    gfsh.executeAndAssertThat("execute function --region=REPLICATE_1 --id=" + RegionSizeFunction.ID)
-        .tableHasColumnWithExactValuesInAnyOrder(RESULT_HEADER,
-            "Exception: dataWrite not authorized for DATA:READ:REPLICATE_1")
-        .statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForTouchPartitionedRegionEntriesFunction() throws Exception {
-    gfsh.executeAndAssertThat(
-        "execute function --region=PARTITION_1 --id=" + TouchPartitionedRegionEntriesFunction.ID)
-        .tableHasColumnWithExactValuesInAnyOrder(RESULT_HEADER,
-            "Exception: dataWrite not authorized for DATA:READ:PARTITION_1")
-        .statusIsError();
+    functionStringMap.keySet().forEach(FunctionService::registerFunction);
   }
 
   @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForTouchReplicatedRegionEntriesFunction() throws Exception {
-    gfsh.executeAndAssertThat(
-        "execute function --region=REPLICATE_1 --id=" + TouchReplicatedRegionEntriesFunction.ID)
-        .tableHasColumnWithExactValuesInAnyOrder(RESULT_HEADER,
-            "Exception: dataWrite not authorized for DATA:READ:REPLICATE_1")
-        .statusIsError();
+  @ConnectionConfiguration(user = "user", password = "user")
+  public void functionRequireExpectedPermission() throws Exception {
+    functionStringMap.entrySet().stream().forEach(entry -> {
+      Function function = entry.getKey();
+      String permission = entry.getValue();
+      gfsh.executeAndAssertThat("execute function --region=AuthRegion --id=" + function.getId())
+          .tableHasRowCount(RESULT_HEADER, 1)
+          .tableHasColumnWithValuesContaining(RESULT_HEADER, permission).statusIsError();
+    });
   }
 }
diff --git a/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/JDBCConnectorFunctionsSecurityTest.java b/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/JDBCConnectorFunctionsSecurityTest.java
index 50f322060be..188c2553670 100644
--- a/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/JDBCConnectorFunctionsSecurityTest.java
+++ b/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/JDBCConnectorFunctionsSecurityTest.java
@@ -15,6 +15,9 @@
 
 package org.apache.geode.connectors.jdbc.internal.cli;
 
+import java.util.HashMap;
+import java.util.Map;
+
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
 import org.junit.Rule;
@@ -48,20 +51,6 @@ CliFunctionResult getFunctionResult(JdbcConnectorService service,
 
 @Category({IntegrationTest.class, SecurityException.class})
 public class JDBCConnectorFunctionsSecurityTest {
-
-  private static Function alterConnectionFunction = new AlterConnectionFunction();
-  private static Function alterMappingFunction = new AlterMappingFunction();
-  private static Function createConnectionFunction = new CreateConnectionFunction();
-  private static Function createMappingFunction = new CreateMappingFunction();
-  private static Function describeConnectionFunction = new DescribeConnectionFunction();
-  private static Function describeMappingFunction = new DescribeMappingFunction();
-  private static Function destroyConnectionFunction = new DestroyConnectionFunction();
-  private static Function destroyMappingFunction = new DestroyMappingFunction();
-  private static Function listConnectionFunction = new ListConnectionFunction();
-  private static Function listMappingFunction = new ListMappingFunction();
-  private static Function inheritsDefaultPermissionsFunction =
-      new InheritsDefaultPermissionsJDBCFunction();
-
   @ClassRule
   public static ServerStarterRule server = new ServerStarterRule().withJMXManager()
       .withSecurityManager(SimpleSecurityManager.class).withAutoStart();
@@ -70,81 +59,35 @@ CliFunctionResult getFunctionResult(JdbcConnectorService service,
   public GfshCommandRule gfsh =
       new GfshCommandRule(server::getJmxPort, GfshCommandRule.PortType.jmxManager);
 
+  private static Map<Function, String> functionStringMap = new HashMap<>();
+
   @BeforeClass
   public static void setupClass() {
-    FunctionService.registerFunction(alterConnectionFunction);
-    FunctionService.registerFunction(alterMappingFunction);
-    FunctionService.registerFunction(createConnectionFunction);
-    FunctionService.registerFunction(createMappingFunction);
-    FunctionService.registerFunction(describeConnectionFunction);
-    FunctionService.registerFunction(describeMappingFunction);
-    FunctionService.registerFunction(destroyConnectionFunction);
-    FunctionService.registerFunction(destroyMappingFunction);
-    FunctionService.registerFunction(listConnectionFunction);
-    FunctionService.registerFunction(listMappingFunction);
-    FunctionService.registerFunction(inheritsDefaultPermissionsFunction);
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForAlterConnectionFunction() {
-    gfsh.executeAndAssertThat("execute function --id=" + alterConnectionFunction.getId())
-        .containsOutput("not authorized for CLUSTER:MANAGE").statusIsError();
+    functionStringMap.put(new AlterConnectionFunction(), "CLUSTER:MANAGE");
+    functionStringMap.put(new AlterMappingFunction(), "CLUSTER:MANAGE");
+    functionStringMap.put(new CreateConnectionFunction(), "CLUSTER:MANAGE");
+    functionStringMap.put(new CreateMappingFunction(), "CLUSTER:MANAGE");
+    functionStringMap.put(new DescribeConnectionFunction(), "CLUSTER:READ");
+    functionStringMap.put(new DescribeMappingFunction(), "CLUSTER:READ");
+    functionStringMap.put(new DestroyConnectionFunction(), "CLUSTER:MANAGE");
+    functionStringMap.put(new DestroyMappingFunction(), "CLUSTER:MANAGE");
+    functionStringMap.put(new ListConnectionFunction(), "CLUSTER:READ");
+    functionStringMap.put(new ListMappingFunction(), "CLUSTER:READ");
+    functionStringMap.put(new InheritsDefaultPermissionsJDBCFunction(), "CLUSTER:READ");
+    functionStringMap.keySet().forEach(FunctionService::registerFunction);
   }
 
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForAlterMappingFunction() {
-    gfsh.executeAndAssertThat("execute function --id=" + alterMappingFunction.getId())
-        .containsOutput("not authorized for CLUSTER:MANAGE").statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForCreateConnectionFunction() {
-    gfsh.executeAndAssertThat("execute function --id=" + createConnectionFunction.getId())
-        .containsOutput("not authorized for CLUSTER:MANAGE").statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForCreateMappingFunction() {
-    gfsh.executeAndAssertThat("execute function --id=" + createMappingFunction.getId())
-        .containsOutput("not authorized for CLUSTER:MANAGE").statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForDescribeConnectionFunction() {
-    gfsh.executeAndAssertThat("execute function --id=" + describeConnectionFunction.getId())
-        .containsOutput("not authorized for CLUSTER:READ").statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForDescribeMappingFunction() {
-    gfsh.executeAndAssertThat("execute function --id=" + describeMappingFunction.getId())
-        .containsOutput("not authorized for CLUSTER:READ").statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForDestroyConnectionFunction() {
-    gfsh.executeAndAssertThat("execute function --id=" + destroyConnectionFunction.getId())
-        .containsOutput("not authorized for CLUSTER:MANAGE").statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForDestroyMappingFunction() {
-    gfsh.executeAndAssertThat("execute function --id=" + destroyMappingFunction.getId())
-        .containsOutput("not authorized for CLUSTER:MANAGE").statusIsError();
-  }
 
   @Test
-  @ConnectionConfiguration(user = "dataWrite", password = "dataWrite")
-  public void testInvalidPermissionsForFunctionInheritingDefaultPermissions() {
-    gfsh.executeAndAssertThat("execute function --id=" + inheritsDefaultPermissionsFunction.getId())
-        .containsOutput("not authorized for CLUSTER:READ").statusIsError();
+  @ConnectionConfiguration(user = "user", password = "user")
+  public void functionRequireExpectedPermission() throws Exception {
+    functionStringMap.entrySet().stream().forEach(entry -> {
+      Function function = entry.getKey();
+      String permission = entry.getValue();
+      gfsh.executeAndAssertThat("execute function --id=" + function.getId())
+          .tableHasRowCount("Function Execution Result", 1)
+          .tableHasColumnWithValuesContaining("Function Execution Result", permission)
+          .statusIsError();
+    });
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/distributed/internal/deadlock/GemFireDeadlockDetector.java b/geode-core/src/main/java/org/apache/geode/distributed/internal/deadlock/GemFireDeadlockDetector.java
index ed6d70b4cd4..2e039d80250 100644
--- a/geode-core/src/main/java/org/apache/geode/distributed/internal/deadlock/GemFireDeadlockDetector.java
+++ b/geode-core/src/main/java/org/apache/geode/distributed/internal/deadlock/GemFireDeadlockDetector.java
@@ -16,7 +16,6 @@
 
 import java.io.Serializable;
 import java.util.HashSet;
-import java.util.LinkedList;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
@@ -27,9 +26,9 @@
 import org.apache.geode.cache.execute.FunctionService;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.distributed.DistributedSystem;
 import org.apache.geode.distributed.internal.InternalDistributedSystem;
 import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
+import org.apache.geode.internal.InternalEntity;
 import org.apache.geode.internal.cache.execute.AbstractExecution;
 
 /**
@@ -104,7 +103,7 @@ public void clearResults() {
     return detector.getDependencyGraph();
   }
 
-  private static class CollectDependencyFunction implements Function {
+  private static class CollectDependencyFunction implements Function, InternalEntity {
 
     private static final long serialVersionUID = 6204378622627095817L;
 
diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/ClientExporter.java b/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/ClientExporter.java
index de26fb4c5c3..9a947c1f426 100644
--- a/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/ClientExporter.java
+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/ClientExporter.java
@@ -30,7 +30,7 @@
 import org.apache.geode.cache.execute.ResultSender;
 import org.apache.geode.cache.snapshot.SnapshotOptions;
 import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.InternalEntity;
 import org.apache.geode.internal.cache.snapshot.RegionSnapshotServiceImpl.ExportSink;
 import org.apache.geode.internal.cache.snapshot.RegionSnapshotServiceImpl.Exporter;
 import org.apache.geode.internal.cache.snapshot.RegionSnapshotServiceImpl.ResultSenderSink;
@@ -118,7 +118,7 @@ public boolean isPRSingleHop() {
    * @param <K> the key type
    * @param <V> the value type
    */
-  static class ProxyExportFunction<K, V> implements Function {
+  static class ProxyExportFunction<K, V> implements Function, InternalEntity {
     private static final long serialVersionUID = 1L;
 
     @Override
diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/RegionSnapshotServiceImpl.java b/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/RegionSnapshotServiceImpl.java
index 2406cc8cfeb..ad7ee72b5ab 100644
--- a/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/RegionSnapshotServiceImpl.java
+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/RegionSnapshotServiceImpl.java
@@ -49,6 +49,7 @@
 import org.apache.geode.distributed.internal.DistributionConfig;
 import org.apache.geode.distributed.internal.InternalDistributedSystem;
 import org.apache.geode.internal.DSCODE;
+import org.apache.geode.internal.InternalEntity;
 import org.apache.geode.internal.cache.CachePerfStats;
 import org.apache.geode.internal.cache.CachedDeserializable;
 import org.apache.geode.internal.cache.CachedDeserializableFactory;
@@ -501,7 +502,7 @@ public SnapshotFormat getFormat() {
     }
   }
 
-  private static class ParallelExportFunction<K, V> implements Function {
+  private static class ParallelExportFunction<K, V> implements Function, InternalEntity {
     @Override
     public boolean hasResult() {
       return true;
@@ -544,7 +545,7 @@ public boolean isHA() {
     }
   }
 
-  private static class ParallelImportFunction<K, V> implements Function {
+  private static class ParallelImportFunction<K, V> implements Function, InternalEntity {
     @Override
     public boolean hasResult() {
       return true;
diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/WindowedExporter.java b/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/WindowedExporter.java
index 2994ad411ce..50c0b784a20 100644
--- a/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/WindowedExporter.java
+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/snapshot/WindowedExporter.java
@@ -32,12 +32,19 @@
 
 import org.apache.geode.cache.EntryDestroyedException;
 import org.apache.geode.cache.Region;
-import org.apache.geode.cache.execute.*;
+import org.apache.geode.cache.execute.Function;
+import org.apache.geode.cache.execute.FunctionContext;
+import org.apache.geode.cache.execute.FunctionException;
+import org.apache.geode.cache.execute.FunctionService;
+import org.apache.geode.cache.execute.RegionFunctionContext;
+import org.apache.geode.cache.execute.ResultCollector;
+import org.apache.geode.cache.execute.ResultSender;
 import org.apache.geode.cache.partition.PartitionRegionHelper;
 import org.apache.geode.cache.snapshot.SnapshotOptions;
 import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.distributed.internal.DistributionConfig;
 import org.apache.geode.distributed.internal.ReplyProcessor21;
+import org.apache.geode.internal.InternalEntity;
 import org.apache.geode.internal.cache.LocalRegion;
 import org.apache.geode.internal.cache.execute.InternalExecution;
 import org.apache.geode.internal.cache.execute.LocalResultCollector;
@@ -150,7 +157,7 @@ public DistributedMember getExporter() {
    *
    * @see FlowController
    */
-  private static class WindowedExportFunction<K, V> implements Function {
+  private static class WindowedExportFunction<K, V> implements Function, InternalEntity {
     private static final long serialVersionUID = 1L;
 
     // We must keep a ref here since the ProcessorKeeper only has a weak ref. If
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/beans/QueryDataFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/beans/QueryDataFunction.java
index 0771f33fe78..92b2a15ce3f 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/beans/QueryDataFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/beans/QueryDataFunction.java
@@ -34,7 +34,6 @@
 import org.apache.geode.cache.DataPolicy;
 import org.apache.geode.cache.Region;
 import org.apache.geode.cache.execute.Function;
-import org.apache.geode.cache.execute.FunctionAdapter;
 import org.apache.geode.cache.execute.FunctionContext;
 import org.apache.geode.cache.execute.FunctionException;
 import org.apache.geode.cache.execute.FunctionService;
@@ -70,7 +69,7 @@
  * DistributedSystemMXBean.queryData()
  */
 @SuppressWarnings({"deprecation", "unchecked"})
-public class QueryDataFunction extends FunctionAdapter implements InternalEntity {
+public class QueryDataFunction implements Function, InternalEntity {
 
   private static final long serialVersionUID = 1L;
 
@@ -487,7 +486,7 @@ public String toString() {
   /**
    * Function to gather data locally. This function is required to execute query with region context
    */
-  private class LocalQueryFunction extends FunctionAdapter {
+  private class LocalQueryFunction implements Function, InternalEntity {
 
     private static final long serialVersionUID = 1L;
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/ExportDataFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/ExportDataFunction.java
index 9d4cf9fe990..d12be4bdb5d 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/ExportDataFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/ExportDataFunction.java
@@ -18,7 +18,7 @@
 
 import org.apache.geode.cache.Cache;
 import org.apache.geode.cache.Region;
-import org.apache.geode.cache.execute.FunctionAdapter;
+import org.apache.geode.cache.execute.Function;
 import org.apache.geode.cache.execute.FunctionContext;
 import org.apache.geode.cache.snapshot.RegionSnapshotService;
 import org.apache.geode.cache.snapshot.SnapshotOptions;
@@ -33,11 +33,7 @@
  *
  *
  */
-public class ExportDataFunction extends FunctionAdapter implements InternalEntity {
-
-  /**
-   *
-   */
+public class ExportDataFunction implements Function, InternalEntity {
   private static final long serialVersionUID = 1L;
 
   public void execute(FunctionContext context) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/FetchRegionAttributesFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/FetchRegionAttributesFunction.java
index 06956fc05d6..0927427fcef 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/FetchRegionAttributesFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/FetchRegionAttributesFunction.java
@@ -20,8 +20,9 @@
 import org.apache.geode.cache.Cache;
 import org.apache.geode.cache.Region;
 import org.apache.geode.cache.RegionAttributes;
-import org.apache.geode.cache.execute.FunctionAdapter;
+import org.apache.geode.cache.execute.Function;
 import org.apache.geode.cache.execute.FunctionContext;
+import org.apache.geode.internal.InternalEntity;
 import org.apache.geode.internal.logging.LogService;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 
@@ -29,7 +30,7 @@
  *
  * @since GemFire 7.0
  */
-public class FetchRegionAttributesFunction extends FunctionAdapter {
+public class FetchRegionAttributesFunction implements Function, InternalEntity {
   private static final Logger logger = LogService.getLogger();
 
   private static final long serialVersionUID = 4366812590788342070L;
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/ImportDataFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/ImportDataFunction.java
index 1aa8522bbe5..afc6bde139d 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/ImportDataFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/ImportDataFunction.java
@@ -18,7 +18,7 @@
 
 import org.apache.geode.cache.Cache;
 import org.apache.geode.cache.Region;
-import org.apache.geode.cache.execute.FunctionAdapter;
+import org.apache.geode.cache.execute.Function;
 import org.apache.geode.cache.execute.FunctionContext;
 import org.apache.geode.cache.snapshot.RegionSnapshotService;
 import org.apache.geode.cache.snapshot.SnapshotOptions;
@@ -31,7 +31,7 @@
  * RegionSnapshotService to import the data
  *
  */
-public class ImportDataFunction extends FunctionAdapter implements InternalEntity {
+public class ImportDataFunction implements Function, InternalEntity {
 
   private static final long serialVersionUID = 1L;
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java
index 9467619e97a..5f8fc5792ea 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java
@@ -20,6 +20,8 @@
 import java.util.Properties;
 import java.util.Set;
 
+import org.apache.shiro.subject.Subject;
+
 import org.apache.geode.cache.Cache;
 import org.apache.geode.cache.Region;
 import org.apache.geode.cache.execute.Execution;
@@ -33,6 +35,7 @@
 import org.apache.geode.internal.cache.InternalCache;
 import org.apache.geode.internal.security.SecurityService;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.security.AuthenticationRequiredException;
 
 /**
  * @since GemFire 7.0
@@ -64,9 +67,20 @@ public void execute(FunctionContext<Object[]> context) {
       Properties credentials = (Properties) args[5];
 
       SecurityService securityService = ((InternalCache) context.getCache()).getSecurityService();
+      boolean loginNeeded = false;
+      try {
+        // if the function is executed on a server with jmx-manager that user is already logged into
+        // then we do not need to do login/logout here.
+        Subject subject = securityService.getSubject();
+        loginNeeded = !subject.isAuthenticated();
+      } catch (AuthenticationRequiredException e) {
+        loginNeeded = true;
+      }
 
       try {
-        securityService.login(credentials);
+        if (loginNeeded) {
+          securityService.login(credentials);
+        }
 
         if (argumentsString != null && argumentsString.length() > 0) {
           functionArgs = argumentsString.split(",");
@@ -157,7 +171,9 @@ public void execute(FunctionContext<Object[]> context) {
         context.getResultSender().lastResult(
             new CliFunctionResult(member.getId(), false, "Exception: " + e.getMessage()));
       } finally {
-        securityService.logout();
+        if (loginNeeded) {
+          securityService.logout();
+        }
       }
 
     } catch (Exception ex) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/GetClusterConfigurationFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/GetClusterConfigurationFunction.java
index c64e876f789..b8c6ff9a24d 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/GetClusterConfigurationFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/GetClusterConfigurationFunction.java
@@ -34,11 +34,12 @@
 import org.apache.geode.cache.execute.FunctionContext;
 import org.apache.geode.distributed.internal.ClusterConfigurationService;
 import org.apache.geode.distributed.internal.InternalLocator;
+import org.apache.geode.internal.InternalEntity;
 import org.apache.geode.internal.logging.LogService;
 import org.apache.geode.management.internal.configuration.messages.ConfigurationResponse;
 import org.apache.geode.security.ResourcePermission;
 
-public class GetClusterConfigurationFunction implements Function {
+public class GetClusterConfigurationFunction implements Function, InternalEntity {
   private static final Logger logger = LogService.getLogger();
 
   @Override
diff --git a/geode-core/src/test/java/org/apache/geode/security/ClientExecuteFunctionAuthDUnitTest.java b/geode-core/src/test/java/org/apache/geode/security/ClientExecuteFunctionAuthDUnitTest.java
index fe18ad3af6f..ead2b352219 100644
--- a/geode-core/src/test/java/org/apache/geode/security/ClientExecuteFunctionAuthDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/security/ClientExecuteFunctionAuthDUnitTest.java
@@ -16,92 +16,84 @@
 
 import static org.apache.geode.cache.execute.FunctionService.onServer;
 import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_MANAGER;
-import static org.apache.geode.security.SecurityTestUtil.assertNotAuthorized;
-import static org.apache.geode.security.SecurityTestUtil.createClientCache;
+import static org.apache.geode.management.internal.security.TestFunctions.WriteFunction.SUCCESS_OUTPUT;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 import java.util.ArrayList;
+import java.util.Properties;
 
-import org.junit.Before;
-import org.junit.Rule;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
+import org.apache.geode.cache.RegionShortcut;
 import org.apache.geode.cache.client.ClientCache;
 import org.apache.geode.cache.execute.Function;
-import org.apache.geode.cache.execute.FunctionService;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.management.internal.security.TestFunctions.ReadFunction;
 import org.apache.geode.management.internal.security.TestFunctions.WriteFunction;
-import org.apache.geode.test.dunit.Host;
-import org.apache.geode.test.dunit.VM;
-import org.apache.geode.test.dunit.internal.JUnit4DistributedTestCase;
+import org.apache.geode.test.dunit.rules.ClientVM;
+import org.apache.geode.test.dunit.rules.ClusterStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
-import org.apache.geode.test.junit.rules.ServerStarterRule;
+import org.apache.geode.test.junit.rules.VMProvider;
 
 @Category({DistributedTest.class, SecurityTest.class})
-public class ClientExecuteFunctionAuthDUnitTest extends JUnit4DistributedTestCase {
-  final Host host = Host.getHost(0);
-  final VM client1 = host.getVM(1);
-  final VM client2 = host.getVM(2);
-
-  private Function writeFunction;
-  private Function readFunction;
-
-  @Rule
-  public ServerStarterRule server = new ServerStarterRule()
-      .withProperty(SECURITY_MANAGER, SimpleTestSecurityManager.class.getName()).withAutoStart();
-
-  @Before
-  public void before() {
-    writeFunction = new WriteFunction();
-    readFunction = new ReadFunction();
-    FunctionService.registerFunction(writeFunction);
-    FunctionService.registerFunction(readFunction);
+public class ClientExecuteFunctionAuthDUnitTest {
+  private static Function writeFunction;
+  private static Function readFunction;
+
+  private static MemberVM server;
+  private static ClientVM client1, client2;
+
+  @ClassRule
+  public static ClusterStartupRule cluster = new ClusterStartupRule();
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    Properties properties = new Properties();
+    properties.setProperty(SECURITY_MANAGER, SimpleTestSecurityManager.class.getName());
+    server = cluster.startServerVM(0, properties);
+
+    server.invoke(() -> {
+      ClusterStartupRule.getCache().createRegionFactory(RegionShortcut.REPLICATE).create("region");
+    });
+    client1 = cluster.startClientVM(1, "dataRead", "dataRead", true, server.getPort());
+    client2 = cluster.startClientVM(2, "dataWrite", "dataWrite", true, server.getPort());
+
+    VMProvider.invokeInEveryMember(() -> {
+      writeFunction = new WriteFunction();
+      readFunction = new ReadFunction();
+    }, server, client1, client2);
   }
 
   @Test
-  public void testExecuteFunctionWithClientRegistration() {
-    client1.invoke("logging in with dataReader", () -> {
-      ClientCache cache = createClientCache("dataRead", "dataRead", server.getPort());
-
-      FunctionService.registerFunction(writeFunction);
-      FunctionService.registerFunction(readFunction);
+  public void testExecuteFunctionWithFunctionObject() throws Exception {
+    client1.invoke(() -> {
+      ClientCache cache = ClusterStartupRule.getClientCache();
 
       // can not write
-      assertNotAuthorized(() -> onServer(cache.getDefaultPool()).execute(writeFunction.getId()),
-          "DATA:WRITE");
+      assertThatThrownBy(() -> onServer(cache.getDefaultPool()).execute(writeFunction))
+          .hasMessageContaining("DATA:WRITE");
 
       // can read
-      ResultCollector rc = onServer(cache.getDefaultPool()).execute(readFunction.getId());
-      assertThat(((ArrayList) rc.getResult()).get(0)).isEqualTo(ReadFunction.SUCCESS_OUTPUT);
+      ResultCollector rc = onServer(cache.getDefaultPool()).execute(readFunction);
+      assertThat(((ArrayList) rc.getResult()).get(0)).isEqualTo(SUCCESS_OUTPUT);
     });
 
-    client2.invoke("logging in with dataWriter", () -> {
-      ClientCache cache = createClientCache("dataWrite", "dataWrite", server.getPort());
-
-      FunctionService.registerFunction(writeFunction);
-      FunctionService.registerFunction(readFunction);
+    client2.invoke(() -> {
+      ClientCache cache = ClusterStartupRule.getClientCache();
       // can write
-      ResultCollector rc = onServer(cache.getDefaultPool()).execute(writeFunction.getId());
-      assertThat(((ArrayList) rc.getResult()).get(0)).isEqualTo(WriteFunction.SUCCESS_OUTPUT);
+      ResultCollector rc = onServer(cache.getDefaultPool()).execute(writeFunction);
+      assertThat(((ArrayList) rc.getResult()).get(0)).isEqualTo(SUCCESS_OUTPUT);
 
       // can not read
-      assertNotAuthorized(() -> onServer(cache.getDefaultPool()).execute(readFunction.getId()),
-          "DATA:READ");
-    });
-  }
-
-  @Test
-  // this would trigger the client to send a GetFunctionAttribute command before executing it
-  public void testExecuteFunctionWithOutClientRegistration() {
-    client1.invoke("logging in with dataReader", () -> {
-      ClientCache cache = createClientCache("dataRead", "dataRead", server.getPort());
-      assertNotAuthorized(() -> onServer(cache.getDefaultPool()).execute(writeFunction.getId()),
-          "DATA:WRITE");
+      assertThatThrownBy(() -> onServer(cache.getDefaultPool()).execute(readFunction))
+          .hasMessageContaining("DATA:READ");
     });
   }
 
-
 }
diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java
index 3973b62700d..f05ac8cdbca 100644
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java
@@ -15,21 +15,14 @@
 
 package org.apache.geode.cache.lucene.test;
 
-import static org.apache.geode.management.internal.security.ResourcePermissions.CLUSTER_MANAGE;
-import static org.apache.geode.management.internal.security.ResourcePermissions.DATA_READ;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.ArgumentMatchers.any;
+import java.util.HashMap;
+import java.util.Map;
 
-import java.util.function.Predicate;
-
-import org.assertj.core.api.Condition;
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
-import org.mockito.Mockito;
-import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 import org.apache.geode.cache.RegionShortcut;
@@ -45,11 +38,7 @@
 import org.apache.geode.cache.lucene.internal.distributed.LuceneQueryFunction;
 import org.apache.geode.cache.lucene.internal.distributed.WaitUntilFlushedFunction;
 import org.apache.geode.cache.lucene.internal.results.LuceneGetPageFunction;
-import org.apache.geode.cache.lucene.internal.security.LucenePermission;
 import org.apache.geode.examples.SimpleSecurityManager;
-import org.apache.geode.security.ResourcePermission;
-import org.apache.geode.security.ResourcePermission.Operation;
-import org.apache.geode.security.ResourcePermission.Resource;
 import org.apache.geode.test.junit.categories.IntegrationTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
 import org.apache.geode.test.junit.rules.ConnectionConfiguration;
@@ -58,40 +47,7 @@
 
 @Category({IntegrationTest.class, SecurityTest.class})
 public class LuceneFunctionSecurityTest {
-  // Note: this region name is embedded below in several @ConnectionConfiguration inputs,
-  // which is itself case-sensitive in parsing.
-  private static String regionName = "this_test_region";
-
-  private static ResourcePermission CLUSTER_MANAGE_LUCENE =
-      new ResourcePermission(Resource.CLUSTER, Operation.MANAGE, LucenePermission.TARGET);
-  private static ResourcePermission CLUSTER_READ_LUCENE =
-      new ResourcePermission(Resource.CLUSTER, Operation.READ, LucenePermission.TARGET);
-  private static ResourcePermission DATA_READ_REGION =
-      new ResourcePermission(Resource.DATA, Operation.READ, regionName);
-
-  private static Function luceneCreateIndexFunction = Mockito.spy(new LuceneCreateIndexFunction());
-  private static Function luceneDescribeIndexFunction =
-      Mockito.spy(new LuceneDescribeIndexFunction());
-  private static Function luceneDestroyIndexFunction =
-      Mockito.spy(new LuceneDestroyIndexFunction());
-  private static Function luceneListIndexFunction = Mockito.spy(new LuceneListIndexFunction());
-  private static Function luceneSearchIndexFunction = Mockito.spy(new LuceneSearchIndexFunction());
-  private static Function dumpDirectoryFiles = Mockito.spy(new DumpDirectoryFiles());
-  private static Function luceneQueryFunction = Mockito.spy(new LuceneQueryFunction());
-  private static Function waitUntilFlushedFunction = Mockito.spy(new WaitUntilFlushedFunction());
-  private static Function luceneGetPageFunction = Mockito.spy(new LuceneGetPageFunction());
-
-  static {
-    Mockito.doAnswer(callLastResult()).when(luceneCreateIndexFunction).execute(any());
-    Mockito.doAnswer(callLastResult()).when(luceneDescribeIndexFunction).execute(any());
-    Mockito.doAnswer(callLastResult()).when(luceneDestroyIndexFunction).execute(any());
-    Mockito.doAnswer(callLastResult()).when(luceneListIndexFunction).execute(any());
-    Mockito.doAnswer(callLastResult()).when(luceneSearchIndexFunction).execute(any());
-    Mockito.doAnswer(callLastResult()).when(dumpDirectoryFiles).execute(any());
-    Mockito.doAnswer(callLastResult()).when(luceneQueryFunction).execute(any());
-    Mockito.doAnswer(callLastResult()).when(waitUntilFlushedFunction).execute(any());
-    Mockito.doAnswer(callLastResult()).when(luceneGetPageFunction).execute(any());
-  }
+  private static final String RESULT_HEADER = "Function Execution Result";
 
   // The FunctionService requires a lastResult to be produced
   private static Answer<Void> callLastResult() {
@@ -105,366 +61,39 @@
   @ClassRule
   public static ServerStarterRule server =
       new ServerStarterRule().withJMXManager().withSecurityManager(SimpleSecurityManager.class)
-          .withRegion(RegionShortcut.PARTITION, regionName).withAutoStart();
+          .withRegion(RegionShortcut.PARTITION, "testRegion").withAutoStart();
 
   @Rule
   public GfshCommandRule gfsh =
       new GfshCommandRule(server::getJmxPort, GfshCommandRule.PortType.jmxManager);
 
+  private static Map<Function, String> functionStringMap = new HashMap<>();
+
   @BeforeClass
   public static void setupClass() {
-    FunctionService.registerFunction(luceneCreateIndexFunction);
-    FunctionService.registerFunction(luceneDescribeIndexFunction);
-    FunctionService.registerFunction(luceneDestroyIndexFunction);
-    FunctionService.registerFunction(luceneListIndexFunction);
-    FunctionService.registerFunction(luceneSearchIndexFunction);
-    FunctionService.registerFunction(dumpDirectoryFiles);
-    FunctionService.registerFunction(luceneQueryFunction);
-    FunctionService.registerFunction(waitUntilFlushedFunction);
-    FunctionService.registerFunction(luceneGetPageFunction);
-  }
-
-  /* Command authorized tests */
-  @Test
-  @ConnectionConfiguration(user = "clusterManageLucene", password = "clusterManageLucene")
-  public void testValidPermissionsForLuceneCreateIndexFunction() {
-    Function thisFunction = luceneCreateIndexFunction;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "clusterReadLucene", password = "clusterReadLucene")
-  public void testValidPermissionsForLuceneDescribeIndexFunction() {
-    Function thisFunction = luceneDescribeIndexFunction;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "clusterManageLucene", password = "clusterManageLucene")
-  public void testValidPermissionsForLuceneDestroyIndexFunction() {
-    Function thisFunction = luceneDestroyIndexFunction;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "clusterReadLucene", password = "clusterReadLucene")
-  public void testValidPermissionsForLuceneListIndexFunction() {
-    Function thisFunction = luceneListIndexFunction;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataReadThis_test_region,clusterManage",
-      password = "dataReadThis_test_region,clusterManage")
-  public void testValidPermissionsForDumpDirectoryFilesWithRegionParameter() {
-    Function thisFunction = dumpDirectoryFiles;
-
-    gfsh.executeAndAssertThat(
-        "execute function  --region=" + regionName + " --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataRead,clusterManage", password = "dataRead,clusterManage")
-  public void testValidPermissionsForDumpDirectoryFilesWithoutRegionParameter() {
-    Function thisFunction = dumpDirectoryFiles;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-
-  @Test
-  @ConnectionConfiguration(user = "dataRead", password = "dataRead")
-  public void testValidPermissionsForLuceneSearchIndexFunctionWithoutRegionParameter() {
-    Function thisFunction = luceneSearchIndexFunction;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataReadThis_test_region", password = "dataReadThis_test_region")
-  public void testValidPermissionsForLuceneSearchIndexFunctionWithRegionParameter() {
-    Function thisFunction = luceneSearchIndexFunction;
-
-    gfsh.executeAndAssertThat(
-        "execute function --region=" + regionName + " --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataRead", password = "dataRead")
-  public void testValidPermissionsForLuceneQueryFunctionWithoutRegionParameter() {
-    Function thisFunction = luceneQueryFunction;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataReadThis_test_region", password = "dataReadThis_test_region")
-  public void testValidPermissionsForLuceneQueryFunctionWithRegionParameter() {
-    Function thisFunction = luceneQueryFunction;
-
-    gfsh.executeAndAssertThat(
-        "execute function --region=" + regionName + " --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataRead", password = "dataRead")
-  public void testValidPermissionsForWaitUntilFlushedFunctionWithoutRegionParameter() {
-    Function thisFunction = waitUntilFlushedFunction;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataReadThis_test_region", password = "dataReadThis_test_region")
-  public void testValidPermissionsForWaitUntilFlushedFunctionWithRegionParameter() {
-    Function thisFunction = waitUntilFlushedFunction;
-
-    gfsh.executeAndAssertThat(
-        "execute function --region=" + regionName + " --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataRead", password = "dataRead")
-  public void testValidPermissionsForLuceneGetPageFunctionWithoutRegionParameter() {
-    Function thisFunction = luceneGetPageFunction;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataReadThis_test_region", password = "dataReadThis_test_region")
-  public void testValidPermissionsForLuceneGetPageFunctionWithRegionParameter() {
-    Function thisFunction = luceneGetPageFunction;
-
-    gfsh.executeAndAssertThat(
-        "execute function --region=" + regionName + " --id=" + thisFunction.getId())
-        .doesNotContainOutput("not authorized for").statusIsSuccess();
-  }
-
-
-  /* Command refused tests */
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForLuceneCreateIndexFunction() {
-    Function thisFunction = luceneCreateIndexFunction;
-    ResourcePermission thisRequiredPermission = CLUSTER_MANAGE_LUCENE;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForLuceneDescribeIndexFunction() {
-    Function thisFunction = luceneDescribeIndexFunction;
-    ResourcePermission thisRequiredPermission = CLUSTER_READ_LUCENE;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForLuceneDestroyIndexFunction() {
-    Function thisFunction = luceneDestroyIndexFunction;
-    ResourcePermission thisRequiredPermission = CLUSTER_MANAGE_LUCENE;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForLuceneListIndexFunction() {
-    Function thisFunction = luceneListIndexFunction;
-    ResourcePermission thisRequiredPermission = CLUSTER_READ_LUCENE;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForDumpDirectoryFilesWithoutRegionParameter_noPermission()
-      throws Exception {
-    Function thisFunction = dumpDirectoryFiles;
-
-    Predicate<String> notAuthForDataRead =
-        s -> s.contains("not authorized for " + DATA_READ.toString());
-    Predicate<String> notAuthForClusterManage =
-        s -> s.contains("not authorized for " + CLUSTER_MANAGE.toString());
-    Predicate<String> notAuthForSomePermission =
-        s -> notAuthForDataRead.test(s) || notAuthForClusterManage.test(s);
-
-    String output = gfsh.execute("execute function --id=" + thisFunction.getId());
-
-    Condition<String> containsSomeAuthFailure = new Condition<>(notAuthForSomePermission,
-        "not authorized for for [DATA:MANAGE|CLUSTER:MANAGE]", output);
-    assertThat(output).has(containsSomeAuthFailure);
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataRead", password = "dataRead")
-  public void testInvalidPermissionsForDumpDirectoryFilesWithoutRegionParameter_withDataRead() {
-    Function thisFunction = dumpDirectoryFiles;
-    ResourcePermission thisMissingPermission = CLUSTER_MANAGE;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisMissingPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "clusterManage", password = "clusterManage")
-  public void testInvalidPermissionsForDumpDirectoryFilesWithoutRegionParameter_withClusterManage() {
-    Function thisFunction = dumpDirectoryFiles;
-    ResourcePermission thisMissingPermission = DATA_READ;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisMissingPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForDumpDirectoryFilesWithRegionParameter_noPermission()
-      throws Exception {
-    Function thisFunction = dumpDirectoryFiles;
-
-    Predicate<String> notAuthForDataReadRegion =
-        s -> s.contains("not authorized for " + DATA_READ_REGION.toString());
-    Predicate<String> notAuthForClusterManage =
-        s -> s.contains("not authorized for " + CLUSTER_MANAGE.toString());
-    Predicate<String> notAuthForSomePermission =
-        s -> notAuthForDataReadRegion.test(s) || notAuthForClusterManage.test(s);
-
-    String output =
-        gfsh.execute("execute function --region=" + regionName + " --id=" + thisFunction.getId());
-
-    Condition<String> containsSomeAuthFailure =
-        new Condition<>(notAuthForSomePermission, "D:R or C:M:L auth failure", output);
-    assertThat(output).has(containsSomeAuthFailure);
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "dataReadThis_test_region", password = "dataReadThis_test_region")
-  public void testInvalidPermissionsForDumpDirectoryFilesWithRegionParameter_withDataReadRegion() {
-    Function thisFunction = dumpDirectoryFiles;
-    ResourcePermission thisMissingPermission = CLUSTER_MANAGE;
-
-    gfsh.executeAndAssertThat(
-        "execute function  --region=" + regionName + " --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisMissingPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "clusterManage", password = "clusterManage")
-  public void testInvalidPermissionsForDumpDirectoryFilesWithRegionParameter_withClusterManage() {
-    Function thisFunction = dumpDirectoryFiles;
-    ResourcePermission thisMissingPermission = DATA_READ;
-
-    gfsh.executeAndAssertThat(
-        "execute function  --region=" + regionName + " --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisMissingPermission.toString()).statusIsError();
-  }
-
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForLuceneSearchIndexFunctionWithoutRegionParameter() {
-    Function thisFunction = luceneSearchIndexFunction;
-    ResourcePermission thisRequiredPermission = DATA_READ;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForLuceneSearchIndexFunctionWithRegionParameter() {
-    Function thisFunction = luceneSearchIndexFunction;
-    ResourcePermission thisRequiredPermission = DATA_READ_REGION;
-
-    gfsh.executeAndAssertThat(
-        "execute function --region=" + regionName + " --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForLuceneQueryFunctionWithoutRegionParameter() {
-    Function thisFunction = luceneQueryFunction;
-    ResourcePermission thisRequiredPermission = DATA_READ;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForLuceneQueryFunctionWithRegionParameter() {
-    Function thisFunction = luceneQueryFunction;
-    ResourcePermission thisRequiredPermission = DATA_READ_REGION;
-
-    gfsh.executeAndAssertThat(
-        "execute function --region=" + regionName + " --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForWaitUntilFlushedFunctionWithoutRegionParameter() {
-    Function thisFunction = waitUntilFlushedFunction;
-    ResourcePermission thisRequiredPermission = DATA_READ;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForWaitUntilFlushedFunctionWithRegionParameter() {
-    Function thisFunction = waitUntilFlushedFunction;
-    ResourcePermission thisRequiredPermission = DATA_READ_REGION;
-
-    gfsh.executeAndAssertThat(
-        "execute function --region=" + regionName + " --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForLuceneGetPageFunctionWithoutRegionParameter() {
-    Function thisFunction = luceneGetPageFunction;
-    ResourcePermission thisRequiredPermission = DATA_READ;
-
-    gfsh.executeAndAssertThat("execute function --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
-  }
-
-  @Test
-  @ConnectionConfiguration(user = "noPermissions", password = "noPermissions")
-  public void testInvalidPermissionsForLuceneGetPageFunctionWithRegionParameter() {
-    Function thisFunction = luceneGetPageFunction;
-    ResourcePermission thisRequiredPermission = DATA_READ_REGION;
-
-    gfsh.executeAndAssertThat(
-        "execute function --region=" + regionName + " --id=" + thisFunction.getId())
-        .containsOutput("not authorized for " + thisRequiredPermission.toString()).statusIsError();
+    functionStringMap.put(new LuceneCreateIndexFunction(), "CLUSTER:MANAGE:LUCENE");
+    functionStringMap.put(new LuceneDescribeIndexFunction(), "CLUSTER:READ:LUCENE");
+    functionStringMap.put(new LuceneDestroyIndexFunction(), "CLUSTER:MANAGE:LUCENE");
+    functionStringMap.put(new LuceneListIndexFunction(), "CLUSTER:READ:LUCENE");
+    functionStringMap.put(new LuceneSearchIndexFunction(), "DATA:READ:testRegion");
+    functionStringMap.put(new DumpDirectoryFiles(), "CLUSTER:MANAGE");
+    functionStringMap.put(new LuceneQueryFunction(), "DATA:READ:testRegion");
+    functionStringMap.put(new WaitUntilFlushedFunction(), "DATA:READ:testRegion");
+    functionStringMap.put(new LuceneGetPageFunction(), "DATA:READ:testRegion");
+
+    functionStringMap.keySet().forEach(FunctionService::registerFunction);
+  }
+
+
+  @Test
+  @ConnectionConfiguration(user = "user", password = "user")
+  public void functionRequireExpectedPermission() throws Exception {
+    functionStringMap.entrySet().stream().forEach(entry -> {
+      Function function = entry.getKey();
+      String permission = entry.getValue();
+      gfsh.executeAndAssertThat("execute function --region=testRegion --id=" + function.getId())
+          .tableHasRowCount(RESULT_HEADER, 1)
+          .tableHasColumnWithValuesContaining(RESULT_HEADER, permission).statusIsError();
+    });
   }
 }

From b06506d5ecfa0777f9f2cac7527add56161f41ca Mon Sep 17 00:00:00 2001
From: Jinmei Liao <jiliao@pivotal.io>
Date: Wed, 17 Jan 2018 08:26:56 -0800
Subject: [PATCH 2/5] fix test error

---
 .../cache/MemberFunctionStreamingMessage.java |   7 +-
 .../cli/functions/UserFunctionExecution.java  | 218 +++++++++---------
 .../cache/functions/TestFunction.java         |   4 +-
 3 files changed, 113 insertions(+), 116 deletions(-)

diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/MemberFunctionStreamingMessage.java b/geode-core/src/main/java/org/apache/geode/internal/cache/MemberFunctionStreamingMessage.java
index 85ab9a8fd08..94280513054 100644
--- a/geode-core/src/main/java/org/apache/geode/internal/cache/MemberFunctionStreamingMessage.java
+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/MemberFunctionStreamingMessage.java
@@ -215,10 +215,9 @@ protected void process(final ClusterDistributionManager dm) {
       rex = new ReplyException(thr);
       replyWithException(dm, rex);
     } catch (Exception exception) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Exception occurred on remote member while executing Function: {}",
-            this.functionObject.getId(), exception);
-      }
+      logger.error("Exception occurred on remote member while executing Function: {}",
+          this.functionObject.getId(), exception);
+
       stats.endFunctionExecutionWithException(this.functionObject.hasResult());
       rex = new ReplyException(exception);
       replyWithException(dm, rex);
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java
index 5f8fc5792ea..9338c629371 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java
@@ -20,6 +20,7 @@
 import java.util.Properties;
 import java.util.Set;
 
+import org.apache.logging.log4j.Logger;
 import org.apache.shiro.subject.Subject;
 
 import org.apache.geode.cache.Cache;
@@ -33,6 +34,7 @@
 import org.apache.geode.internal.ClassPathLoader;
 import org.apache.geode.internal.InternalEntity;
 import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.logging.LogService;
 import org.apache.geode.internal.security.SecurityService;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.security.AuthenticationRequiredException;
@@ -43,6 +45,7 @@
 public class UserFunctionExecution implements Function<Object[]>, InternalEntity {
   public static final String ID = UserFunctionExecution.class.getName();
 
+  private static Logger logger = LogService.getLogger();
   private static final long serialVersionUID = 1L;
 
   @Override
@@ -50,135 +53,130 @@ public void execute(FunctionContext<Object[]> context) {
     Cache cache = context.getCache();
     DistributedMember member = cache.getDistributedSystem().getDistributedMember();
 
+    String[] functionArgs = null;
+    Object[] args = context.getArguments();
+    if (args == null) {
+      context.getResultSender().lastResult(new CliFunctionResult(member.getId(), false,
+          CliStrings.EXECUTE_FUNCTION__MSG__COULD_NOT_RETRIEVE_ARGUMENTS));
+      return;
+    }
+
+    String functionId = ((String) args[0]);
+    String filterString = ((String) args[1]);
+    String resultCollectorName = ((String) args[2]);
+    String argumentsString = ((String) args[3]);
+    String onRegion = ((String) args[4]);
+    Properties credentials = (Properties) args[5];
+
+    SecurityService securityService = ((InternalCache) context.getCache()).getSecurityService();
+    boolean loginNeeded = false;
     try {
-      String[] functionArgs = null;
-      Object[] args = context.getArguments();
-      if (args == null) {
-        context.getResultSender().lastResult(new CliFunctionResult(member.getId(), false,
-            CliStrings.EXECUTE_FUNCTION__MSG__COULD_NOT_RETRIEVE_ARGUMENTS));
-        return;
+      // if the function is executed on a server with jmx-manager that user is already logged into
+      // then we do not need to do login/logout here.
+      Subject subject = securityService.getSubject();
+      loginNeeded = subject == null || !subject.isAuthenticated();
+    } catch (AuthenticationRequiredException e) {
+      loginNeeded = true;
+    }
+
+    try {
+      if (loginNeeded) {
+        securityService.login(credentials);
       }
 
-      String functionId = ((String) args[0]);
-      String filterString = ((String) args[1]);
-      String resultCollectorName = ((String) args[2]);
-      String argumentsString = ((String) args[3]);
-      String onRegion = ((String) args[4]);
-      Properties credentials = (Properties) args[5];
-
-      SecurityService securityService = ((InternalCache) context.getCache()).getSecurityService();
-      boolean loginNeeded = false;
-      try {
-        // if the function is executed on a server with jmx-manager that user is already logged into
-        // then we do not need to do login/logout here.
-        Subject subject = securityService.getSubject();
-        loginNeeded = !subject.isAuthenticated();
-      } catch (AuthenticationRequiredException e) {
-        loginNeeded = true;
+      if (argumentsString != null && argumentsString.length() > 0) {
+        functionArgs = argumentsString.split(",");
+      }
+      Set<String> filters = new HashSet<>();
+      ResultCollector resultCollectorInstance = null;
+      if (resultCollectorName != null && resultCollectorName.length() > 0) {
+        resultCollectorInstance = (ResultCollector) ClassPathLoader.getLatest()
+            .forName(resultCollectorName).newInstance();
+      }
+      if (filterString != null && filterString.length() > 0) {
+        filters.add(filterString);
       }
 
-      try {
-        if (loginNeeded) {
-          securityService.login(credentials);
-        }
+      Function<?> function = FunctionService.getFunction(functionId);
+      if (function == null) {
+        context.getResultSender()
+            .lastResult(new CliFunctionResult(member.getId(), false,
+                (CliStrings.format(
+                    CliStrings.EXECUTE_FUNCTION__MSG__DOES_NOT_HAVE_FUNCTION_0_REGISTERED,
+                    functionId))));
+        return;
+      }
 
-        if (argumentsString != null && argumentsString.length() > 0) {
-          functionArgs = argumentsString.split(",");
-        }
-        Set<String> filters = new HashSet<>();
-        ResultCollector resultCollectorInstance = null;
-        if (resultCollectorName != null && resultCollectorName.length() > 0) {
-          resultCollectorInstance = (ResultCollector) ClassPathLoader.getLatest()
-              .forName(resultCollectorName).newInstance();
-        }
-        if (filterString != null && filterString.length() > 0) {
-          filters.add(filterString);
-        }
+      // security check
+      function.getRequiredPermissions(onRegion).forEach(securityService::authorize);
 
-        Function<?> function = FunctionService.getFunction(functionId);
-        if (function == null) {
-          context.getResultSender()
-              .lastResult(new CliFunctionResult(member.getId(), false,
-                  (CliStrings.format(
-                      CliStrings.EXECUTE_FUNCTION__MSG__DOES_NOT_HAVE_FUNCTION_0_REGISTERED,
-                      functionId))));
+      Execution execution = null;
+      if (onRegion != null && onRegion.length() > 0) {
+        Region region = cache.getRegion(onRegion);
+        if (region == null) {
+          context.getResultSender().lastResult(
+              new CliFunctionResult(member.getId(), false, onRegion + " does not exist"));
           return;
         }
+        execution = FunctionService.onRegion(region);
+      } else {
+        execution = FunctionService.onMember(member);
+      }
 
-        // security check
-        function.getRequiredPermissions(onRegion).forEach(securityService::authorize);
-
-        Execution execution = null;
-        if (onRegion != null && onRegion.length() > 0) {
-          Region region = cache.getRegion(onRegion);
-          if (region == null) {
-            context.getResultSender().lastResult(
-                new CliFunctionResult(member.getId(), false, onRegion + " does not exist"));
-            return;
-          }
-          execution = FunctionService.onRegion(region);
-        } else {
-          execution = FunctionService.onMember(member);
-        }
-
-        if (execution == null) {
-          context.getResultSender()
-              .lastResult(new CliFunctionResult(member.getId(), false,
-                  CliStrings.format(
-                      CliStrings.EXECUTE_FUNCTION__MSG__ERROR_IN_EXECUTING_0_ON_MEMBER_1_ON_REGION_2_DETAILS_3,
-                      functionId, member.getId(), onRegion,
-                      CliStrings.EXECUTE_FUNCTION__MSG__ERROR_IN_RETRIEVING_EXECUTOR)));
-          return;
-        }
+      if (execution == null) {
+        context.getResultSender()
+            .lastResult(new CliFunctionResult(member.getId(), false,
+                CliStrings.format(
+                    CliStrings.EXECUTE_FUNCTION__MSG__ERROR_IN_EXECUTING_0_ON_MEMBER_1_ON_REGION_2_DETAILS_3,
+                    functionId, member.getId(), onRegion,
+                    CliStrings.EXECUTE_FUNCTION__MSG__ERROR_IN_RETRIEVING_EXECUTOR)));
+        return;
+      }
 
-        if (resultCollectorInstance != null) {
-          execution = execution.withCollector(resultCollectorInstance);
-        }
+      if (resultCollectorInstance != null) {
+        execution = execution.withCollector(resultCollectorInstance);
+      }
 
-        if (functionArgs != null && functionArgs.length > 0) {
-          execution = execution.setArguments(functionArgs);
-        }
-        if (filters.size() > 0) {
-          execution = execution.withFilter(filters);
-        }
+      if (functionArgs != null && functionArgs.length > 0) {
+        execution = execution.setArguments(functionArgs);
+      }
+      if (filters.size() > 0) {
+        execution = execution.withFilter(filters);
+      }
 
-        List<Object> results = (List<Object>) execution.execute(function.getId()).getResult();
-        List<String> resultMessage = new ArrayList<>();
-        boolean functionSuccess = true;
-
-        if (results != null) {
-          for (Object resultObj : results) {
-            if (resultObj != null) {
-              if (resultObj instanceof Exception) {
-                resultMessage.add(((Exception) resultObj).getMessage());
-                functionSuccess = false;
-              } else {
-                resultMessage.add(resultObj.toString());
-              }
+      List<Object> results = (List<Object>) execution.execute(function.getId()).getResult();
+      List<String> resultMessage = new ArrayList<>();
+      boolean functionSuccess = true;
+
+      if (results != null) {
+        for (Object resultObj : results) {
+          if (resultObj != null) {
+            if (resultObj instanceof Exception) {
+              resultMessage.add(((Exception) resultObj).getMessage());
+              functionSuccess = false;
+            } else {
+              resultMessage.add(resultObj.toString());
             }
           }
         }
-        context.getResultSender().lastResult(
-            new CliFunctionResult(member.getId(), functionSuccess, resultMessage.toString()));
-
-      } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {
-        context.getResultSender()
-            .lastResult(new CliFunctionResult(member.getId(), false,
-                CliStrings.format(
-                    CliStrings.EXECUTE_FUNCTION__MSG__RESULT_COLLECTOR_0_NOT_FOUND_ERROR_1,
-                    resultCollectorName, e.getMessage())));
-      } catch (Exception e) {
-        context.getResultSender().lastResult(
-            new CliFunctionResult(member.getId(), false, "Exception: " + e.getMessage()));
-      } finally {
-        if (loginNeeded) {
-          securityService.logout();
-        }
       }
+      context.getResultSender().lastResult(
+          new CliFunctionResult(member.getId(), functionSuccess, resultMessage.toString()));
 
-    } catch (Exception ex) {
+    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {
       context.getResultSender()
-          .lastResult(new CliFunctionResult(member.getId(), false, ex.getMessage()));
+          .lastResult(new CliFunctionResult(member.getId(), false,
+              CliStrings.format(
+                  CliStrings.EXECUTE_FUNCTION__MSG__RESULT_COLLECTOR_0_NOT_FOUND_ERROR_1,
+                  resultCollectorName, e.getMessage())));
+    } catch (Exception e) {
+      logger.error("error executing function " + functionId, e);
+      context.getResultSender()
+          .lastResult(new CliFunctionResult(member.getId(), false, "Exception: " + e.getMessage()));
+    } finally {
+      if (loginNeeded) {
+        securityService.logout();
+      }
     }
   }
 
diff --git a/geode-core/src/test/java/org/apache/geode/internal/cache/functions/TestFunction.java b/geode-core/src/test/java/org/apache/geode/internal/cache/functions/TestFunction.java
index e9ec481fa76..d89f187676d 100755
--- a/geode-core/src/test/java/org/apache/geode/internal/cache/functions/TestFunction.java
+++ b/geode-core/src/test/java/org/apache/geode/internal/cache/functions/TestFunction.java
@@ -36,7 +36,7 @@
 import org.apache.geode.cache.control.RebalanceOperation;
 import org.apache.geode.cache.control.RebalanceResults;
 import org.apache.geode.cache.control.ResourceManager;
-import org.apache.geode.cache.execute.FunctionAdapter;
+import org.apache.geode.cache.execute.Function;
 import org.apache.geode.cache.execute.FunctionContext;
 import org.apache.geode.cache.execute.FunctionInvocationTargetException;
 import org.apache.geode.cache.execute.RegionFunctionContext;
@@ -56,7 +56,7 @@
 import org.apache.geode.test.dunit.Wait;
 import org.apache.geode.test.dunit.WaitCriterion;
 
-public class TestFunction extends FunctionAdapter implements Declarable2, DataSerializable {
+public class TestFunction implements Function, Declarable2, DataSerializable {
   public static final String TEST_FUNCTION10 = "TestFunction10";
   public static final String TEST_FUNCTION9 = "TestFunction9";
   public static final String TEST_FUNCTION8 = "TestFunction8";

From dd89fc4f0c7c16f0f22e945e949490685487fb17 Mon Sep 17 00:00:00 2001
From: Jinmei Liao <jiliao@pivotal.io>
Date: Wed, 17 Jan 2018 08:35:22 -0800
Subject: [PATCH 3/5] add missing test

---
 .../lucene/test/LuceneFunctionSecurityTest.java    | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java
index f05ac8cdbca..2f91182d26a 100644
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java
@@ -15,6 +15,11 @@
 
 package org.apache.geode.cache.lucene.test;
 
+import static org.apache.geode.management.internal.security.ResourcePermissions.CLUSTER_MANAGE;
+import static org.apache.geode.security.ResourcePermission.Operation.READ;
+import static org.apache.geode.security.ResourcePermission.Resource.DATA;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import java.util.HashMap;
 import java.util.Map;
 
@@ -39,6 +44,7 @@
 import org.apache.geode.cache.lucene.internal.distributed.WaitUntilFlushedFunction;
 import org.apache.geode.cache.lucene.internal.results.LuceneGetPageFunction;
 import org.apache.geode.examples.SimpleSecurityManager;
+import org.apache.geode.security.ResourcePermission;
 import org.apache.geode.test.junit.categories.IntegrationTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
 import org.apache.geode.test.junit.rules.ConnectionConfiguration;
@@ -76,7 +82,6 @@ public static void setupClass() {
     functionStringMap.put(new LuceneDestroyIndexFunction(), "CLUSTER:MANAGE:LUCENE");
     functionStringMap.put(new LuceneListIndexFunction(), "CLUSTER:READ:LUCENE");
     functionStringMap.put(new LuceneSearchIndexFunction(), "DATA:READ:testRegion");
-    functionStringMap.put(new DumpDirectoryFiles(), "CLUSTER:MANAGE");
     functionStringMap.put(new LuceneQueryFunction(), "DATA:READ:testRegion");
     functionStringMap.put(new WaitUntilFlushedFunction(), "DATA:READ:testRegion");
     functionStringMap.put(new LuceneGetPageFunction(), "DATA:READ:testRegion");
@@ -96,4 +101,11 @@ public void functionRequireExpectedPermission() throws Exception {
           .tableHasColumnWithValuesContaining(RESULT_HEADER, permission).statusIsError();
     });
   }
+
+  @Test
+  public void dumpDirectoryFileRequires() {
+    Function function = new DumpDirectoryFiles();
+    assertThat(function.getRequiredPermissions("testRegion")).containsExactlyInAnyOrder(
+        CLUSTER_MANAGE, new ResourcePermission(DATA, READ, "testRegion"));
+  }
 }

From 271fd0677cce9fbf2492a297719ad2b2f509dcf6 Mon Sep 17 00:00:00 2001
From: Jinmei Liao <jiliao@pivotal.io>
Date: Wed, 17 Jan 2018 11:14:44 -0800
Subject: [PATCH 4/5] fix test failures

---
 .../internal/cache/execute/FunctionServiceBase.java      | 9 ++++++---
 .../security/ClientExecuteFunctionAuthDUnitTest.java     | 5 ++---
 2 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/geode-core/src/test/java/org/apache/geode/internal/cache/execute/FunctionServiceBase.java b/geode-core/src/test/java/org/apache/geode/internal/cache/execute/FunctionServiceBase.java
index 10f78f2614f..5cd858dd863 100644
--- a/geode-core/src/test/java/org/apache/geode/internal/cache/execute/FunctionServiceBase.java
+++ b/geode-core/src/test/java/org/apache/geode/internal/cache/execute/FunctionServiceBase.java
@@ -49,6 +49,7 @@
 import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.distributed.internal.InternalDistributedSystem;
 import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
+import org.apache.geode.test.dunit.IgnoredException;
 import org.apache.geode.test.dunit.cache.internal.JUnit4CacheTestCase;
 
 /*
@@ -126,6 +127,7 @@ public void defaultCollectorReturnsAllIntermediateResults() {
 
   @Test()
   public void defaultCollectorThrowsExceptionAfterFunctionThrowsIllegalState() {
+    IgnoredException.addIgnoredException("java.lang.IllegalStateException");
     // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
     thrown.expect(FunctionException.class);
     // GEODE-1762 - clients wrap cause in a ServerOperationException
@@ -163,7 +165,7 @@ public void defaultCollectorThrowsExceptionAfterFunctionReturnsIllegalStateExcep
     final Object result = rc.getResult();
   }
 
-  @Test()
+  @Test
   public void defaultCollectorThrowsExceptionAfterFunctionReturnsFunctionException() {
     // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
     thrown.expect(FunctionException.class);
@@ -174,7 +176,7 @@ public void defaultCollectorThrowsExceptionAfterFunctionReturnsFunctionException
     final Object result = rc.getResult();
   }
 
-  @Test()
+  @Test
   public void defaultCollectorThrowsExceptionAfterFunctionReturnsIllegalStateExceptionAsIntermediateResult() {
     // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
     // GEODE-1762 - client throws a ServerOperationException
@@ -188,7 +190,7 @@ public void defaultCollectorThrowsExceptionAfterFunctionReturnsIllegalStateExcep
     final Object result = rc.getResult();
   }
 
-  @Test()
+  @Test
   public void defaultCollectorThrowsExceptionAfterFunctionReturnsFunctionExceptionAsIntermediateResult() {
     // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
     thrown.expect(FunctionException.class);
@@ -224,6 +226,7 @@ public void defaultCollectorReturnsResultOfSendFunctionException() {
   @Test
   public void customCollectorDoesNotSeeExceptionFunctionThrowsIllegalState() {
     // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    IgnoredException.addIgnoredException("java.lang.IllegalStateException");
     try {
       ResultCollector rc = getExecution().withCollector(customCollector).execute((context) -> {
         throw new IllegalStateException();
diff --git a/geode-core/src/test/java/org/apache/geode/security/ClientExecuteFunctionAuthDUnitTest.java b/geode-core/src/test/java/org/apache/geode/security/ClientExecuteFunctionAuthDUnitTest.java
index ead2b352219..4b20ee305dc 100644
--- a/geode-core/src/test/java/org/apache/geode/security/ClientExecuteFunctionAuthDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/security/ClientExecuteFunctionAuthDUnitTest.java
@@ -16,7 +16,6 @@
 
 import static org.apache.geode.cache.execute.FunctionService.onServer;
 import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_MANAGER;
-import static org.apache.geode.management.internal.security.TestFunctions.WriteFunction.SUCCESS_OUTPUT;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
@@ -81,14 +80,14 @@ public void testExecuteFunctionWithFunctionObject() throws Exception {
 
       // can read
       ResultCollector rc = onServer(cache.getDefaultPool()).execute(readFunction);
-      assertThat(((ArrayList) rc.getResult()).get(0)).isEqualTo(SUCCESS_OUTPUT);
+      assertThat(((ArrayList) rc.getResult()).get(0)).isEqualTo(ReadFunction.SUCCESS_OUTPUT);
     });
 
     client2.invoke(() -> {
       ClientCache cache = ClusterStartupRule.getClientCache();
       // can write
       ResultCollector rc = onServer(cache.getDefaultPool()).execute(writeFunction);
-      assertThat(((ArrayList) rc.getResult()).get(0)).isEqualTo(SUCCESS_OUTPUT);
+      assertThat(((ArrayList) rc.getResult()).get(0)).isEqualTo(WriteFunction.SUCCESS_OUTPUT);
 
       // can not read
       assertThatThrownBy(() -> onServer(cache.getDefaultPool()).execute(readFunction))

From 9fa354f5853403bdcddaf6baa1443ce21e5321ae Mon Sep 17 00:00:00 2001
From: Jinmei Liao <jiliao@pivotal.io>
Date: Thu, 18 Jan 2018 09:38:44 -0800
Subject: [PATCH 5/5] review changes

---
 .../cli/functions/UserFunctionExecution.java  |  4 +-
 .../geode/security/ResourcePermission.java    |  4 +-
 .../junit/assertions/CommandResultAssert.java |  3 +-
 .../test/LuceneFunctionSecurityTest.java      | 64 ++++++++++++-------
 4 files changed, 49 insertions(+), 26 deletions(-)

diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java
index 9338c629371..da74dffae5f 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/UserFunctionExecution.java
@@ -79,9 +79,11 @@ public void execute(FunctionContext<Object[]> context) {
       loginNeeded = true;
     }
 
+    boolean loginSuccessful = false;
     try {
       if (loginNeeded) {
         securityService.login(credentials);
+        loginSuccessful = true;
       }
 
       if (argumentsString != null && argumentsString.length() > 0) {
@@ -174,7 +176,7 @@ public void execute(FunctionContext<Object[]> context) {
       context.getResultSender()
           .lastResult(new CliFunctionResult(member.getId(), false, "Exception: " + e.getMessage()));
     } finally {
-      if (loginNeeded) {
+      if (loginSuccessful) {
         securityService.logout();
       }
     }
diff --git a/geode-core/src/main/java/org/apache/geode/security/ResourcePermission.java b/geode-core/src/main/java/org/apache/geode/security/ResourcePermission.java
index 74db186fc49..3d8dd1e72a4 100644
--- a/geode-core/src/main/java/org/apache/geode/security/ResourcePermission.java
+++ b/geode-core/src/main/java/org/apache/geode/security/ResourcePermission.java
@@ -145,7 +145,6 @@ public Resource getResource() {
     if (ALL.equals(resource)) {
       return Resource.ALL;
     }
-
     return Resource.valueOf(resource);
   }
 
@@ -153,8 +152,9 @@ public Resource getResource() {
    * Returns the operation, could be either ALL, NULL, MANAGE, WRITE or READ
    */
   public Operation getOperation() {
-    if (ALL.equals(operation))
+    if (ALL.equals(operation)) {
       return Operation.ALL;
+    }
     return Operation.valueOf(operation);
   }
 
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/assertions/CommandResultAssert.java b/geode-core/src/test/java/org/apache/geode/test/junit/assertions/CommandResultAssert.java
index fc10639f1f2..4336edf6ade 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/assertions/CommandResultAssert.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/assertions/CommandResultAssert.java
@@ -243,7 +243,8 @@ public CommandResultAssert tableHasColumnWithValuesContaining(String header,
           Arrays.stream(expectedValues).anyMatch(actualValueString::contains);
 
       if (!actualValueContainsAnExpectedValue) {
-        failWithMessage("Found unexpected value: " + actualValue);
+        failWithMessage(
+            "Expecting: " + Arrays.toString(expectedValues) + ", but found: " + actualValue);
       }
     }
 
diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java
index 2f91182d26a..2deb244b28a 100644
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/test/LuceneFunctionSecurityTest.java
@@ -15,11 +15,6 @@
 
 package org.apache.geode.cache.lucene.test;
 
-import static org.apache.geode.management.internal.security.ResourcePermissions.CLUSTER_MANAGE;
-import static org.apache.geode.security.ResourcePermission.Operation.READ;
-import static org.apache.geode.security.ResourcePermission.Resource.DATA;
-import static org.assertj.core.api.Assertions.assertThat;
-
 import java.util.HashMap;
 import java.util.Map;
 
@@ -28,11 +23,9 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
-import org.mockito.stubbing.Answer;
 
 import org.apache.geode.cache.RegionShortcut;
 import org.apache.geode.cache.execute.Function;
-import org.apache.geode.cache.execute.FunctionContext;
 import org.apache.geode.cache.execute.FunctionService;
 import org.apache.geode.cache.lucene.internal.cli.functions.LuceneCreateIndexFunction;
 import org.apache.geode.cache.lucene.internal.cli.functions.LuceneDescribeIndexFunction;
@@ -44,7 +37,6 @@
 import org.apache.geode.cache.lucene.internal.distributed.WaitUntilFlushedFunction;
 import org.apache.geode.cache.lucene.internal.results.LuceneGetPageFunction;
 import org.apache.geode.examples.SimpleSecurityManager;
-import org.apache.geode.security.ResourcePermission;
 import org.apache.geode.test.junit.categories.IntegrationTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
 import org.apache.geode.test.junit.rules.ConnectionConfiguration;
@@ -55,15 +47,6 @@
 public class LuceneFunctionSecurityTest {
   private static final String RESULT_HEADER = "Function Execution Result";
 
-  // The FunctionService requires a lastResult to be produced
-  private static Answer<Void> callLastResult() {
-    return invocation -> {
-      FunctionContext context = invocation.getArgument(0);
-      context.getResultSender().lastResult(null);
-      return null;
-    };
-  }
-
   @ClassRule
   public static ServerStarterRule server =
       new ServerStarterRule().withJMXManager().withSecurityManager(SimpleSecurityManager.class)
@@ -87,9 +70,9 @@ public static void setupClass() {
     functionStringMap.put(new LuceneGetPageFunction(), "DATA:READ:testRegion");
 
     functionStringMap.keySet().forEach(FunctionService::registerFunction);
+    FunctionService.registerFunction(new DumpDirectoryFiles());
   }
 
-
   @Test
   @ConnectionConfiguration(user = "user", password = "user")
   public void functionRequireExpectedPermission() throws Exception {
@@ -102,10 +85,47 @@ public void functionRequireExpectedPermission() throws Exception {
     });
   }
 
+  // use DumpDirectoryFile function to verify that all the permissions returned by the
+  // getRequiredPermission are all enforced before trying to execute
+  @Test
+  @ConnectionConfiguration(user = "clusterManage", password = "clusterManage")
+  public void dumpDirectoryFileRequiresBoth_AsClusterManage() {
+    gfsh.executeAndAssertThat("execute function --region=testRegion --id=" + DumpDirectoryFiles.ID)
+        .tableHasRowCount(RESULT_HEADER, 1)
+        .tableHasColumnWithValuesContaining(RESULT_HEADER, "DATA:READ:testRegion").statusIsError();
+  }
+
+  @Test
+  @ConnectionConfiguration(user = "dataRead", password = "dataRead")
+  public void dumpDirectoryFileRequiresBoth_AsDataRead() {
+    gfsh.executeAndAssertThat("execute function --region=testRegion --id=" + DumpDirectoryFiles.ID)
+        .tableHasRowCount(RESULT_HEADER, 1)
+        .tableHasColumnWithValuesContaining(RESULT_HEADER, "CLUSTER:MANAGE").statusIsError();
+  }
+
+  @Test
+  @ConnectionConfiguration(user = "clusterManage,dataReadRegionB",
+      password = "clusterManage,dataReadRegionB")
+  public void dumpDirectoryFileRequiresBoth_dataReadAnotherRegion() {
+    gfsh.executeAndAssertThat("execute function --region=testRegion --id=" + DumpDirectoryFiles.ID)
+        .tableHasRowCount(RESULT_HEADER, 1)
+        .tableHasColumnWithValuesContaining(RESULT_HEADER, "DATA:READ:testRegion").statusIsError();
+  }
+
+  @Test
+  @ConnectionConfiguration(user = "clusterManage,dataReadTestRegionA",
+      password = "clusterManage,dataReadTestRegionA")
+  public void dumpDirectoryFileRequiresBoth_dataReadInsufficient() {
+    gfsh.executeAndAssertThat("execute function --region=testRegion --id=" + DumpDirectoryFiles.ID)
+        .tableHasRowCount(RESULT_HEADER, 1)
+        .tableHasColumnWithValuesContaining(RESULT_HEADER, "DATA:READ:testRegion").statusIsError();
+  }
+
   @Test
-  public void dumpDirectoryFileRequires() {
-    Function function = new DumpDirectoryFiles();
-    assertThat(function.getRequiredPermissions("testRegion")).containsExactlyInAnyOrder(
-        CLUSTER_MANAGE, new ResourcePermission(DATA, READ, "testRegion"));
+  @ConnectionConfiguration(user = "clusterManage,dataReadTestRegion",
+      password = "clusterManage,dataReadTestRegion")
+  public void dumpDirectoryFileRequiresBoth_validUser() {
+    gfsh.executeAndAssertThat("execute function --region=testRegion --id=" + DumpDirectoryFiles.ID)
+        .tableHasRowCount(RESULT_HEADER, 1).doesNotContainOutput("not authorized").statusIsError();
   }
 }
