import angr
import claripy
from parse_helpers import hex2str
from util.info_print import fetch_str, fetch_args_array


def remove_all_bps(state):
    if hasattr(state.project, "heap_analysis"):
        inuse_bps = state.project.heap_analysis.inuse_bps
        for inuse_addr, bp in inuse_bps.items():
            state.inspect.remove_breakpoint(event_type='mem_write', bp=bp)
        free_bps = state.project.heap_analysis.free_bps
        for free_addr, bp in free_bps.items():
            state.inspect.remove_breakpoint(event_type='mem_write', bp=bp)
    if hasattr(state.project, "call_analysis"):
        bps = state.project.call_analysis.bps
        if len(bps) == 2:
            state.inspect.remove_breakpoint(event_type='call', bp=bps[0])
            state.inspect.remove_breakpoint(event_type='return', bp=bps[1])


class exploited_execve(angr.SimProcedure):
    """
    Sample hook procedure to check if the programme is going to do `execve("/bin/sh"...)`
    If the check pass, project.exploited_state will be set.
    """
    def run(self, filename, args, envp):
        # check if the first arg is like '/bin/sh'
        # fname = self.state.memory.load(filename, 9)
        fname = fetch_str(self.state, filename.args[0])
        args_array = fetch_args_array(self.state, args.args[0])
        # assert(fname.concrete)
        # if b"sh" in hex2str(fname.args[0]):
        if "sh" in fname:
            # print("""Found exploited state: execve("%s", ...)"""% fetch_str(self.state, filename.args[0]))

            # set exploited_state, so we can get the final state from project
            assert(self.project and self.state)
            self.project.exploited_state = self.state
            self.project.exploited_state_method = "execve('%s', %s, ...)" % (fname, args_array)
            self.project.end_timestamp = len(self.state.history.bbl_addrs)
            self.project.cfg_sequence = list(self.state.history.bbl_addrs)
            if isinstance(self.project.report_logger, int):
                print("""Found exploited state: execve('%s', %s, ...)""" % (fname, args_array))
                print("Replay finished.")
            else:
                self.project.report_logger.warn(self.project.exploited_state_method, type='tips')
            # i=1
            # output = ""
            # for addr in self.state.history.bbl_addrs:
            #     output += "%s:\t%s\n" % (i, hex(addr))
            #     i += 1
            # with open("addr", 'w') as f:
            #     f.write(output)
            #     f.close()
            remove_all_bps(self.state)
            # we don't need to continue
            self.exit(0)
        else:
            return claripy.BVV(0, 64)

    def __repr__(self):
        return '<exploited execve stub>'

def exploited_system(project):
    """
    Sample hook func to check if the programe is going to do `system("/bin/sh")`
    If the check pass, project.exploited_state will be set.

    :param:     replayer project, used to set exploited state
    """
    def hook_func(state):
        rdi = state.regs.rdi
        if rdi.concrete:
            command = state.memory.load(rdi, 8)
            if b"sh" in hex2str(command.args[0]):
                print("""Found exploited state: system(".*sh.*")""")
                project.exploited_state = state
        else:
            return
    return hook_func