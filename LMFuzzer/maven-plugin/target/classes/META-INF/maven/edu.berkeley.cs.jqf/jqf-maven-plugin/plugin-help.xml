<?xml version="1.0" encoding="UTF-8"?>

<!-- Generated by maven-plugin-tools 3.5 -->

<plugin>
  <name>jqf-maven-plugin</name>
  <description>JQF: Feedback-directed Quickcheck for Java - Maven plugin</description>
  <groupId>edu.berkeley.cs.jqf</groupId>
  <artifactId>jqf-maven-plugin</artifactId>
  <version>1.4-SNAPSHOT</version>
  <goalPrefix>jqf</goalPrefix>
  <mojos>
    <mojo>
      <goal>fuzz</goal>
      <description>Maven plugin for feedback-directed fuzzing using JQF.
Performs code-coverage-guided generator-based fuzz testing using a provided entry point.
</description>
      <requiresDependencyResolution>test</requiresDependencyResolution>
      <requiresDirectInvocation>false</requiresDirectInvocation>
      <requiresProject>true</requiresProject>
      <requiresReports>false</requiresReports>
      <aggregator>false</aggregator>
      <requiresOnline>false</requiresOnline>
      <inheritedByDefault>true</inheritedByDefault>
      <phase>verify</phase>
      <implementation>edu.berkeley.cs.jqf.plugin.FuzzGoal</implementation>
      <language>java</language>
      <instantiationStrategy>per-lookup</instantiationStrategy>
      <executionStrategy>once-per-session</executionStrategy>
      <threadSafe>false</threadSafe>
      <parameters>
        <parameter>
          <name>blind</name>
          <type>boolean</type>
          <required>false</required>
          <editable>true</editable>
          <description>Whether to generate inputs blindly without taking into account coverage feedback. Blind input generation is equivalent to running QuickCheck.
If this property is set to true, then the fuzzing algorithm does not maintain a queue. Every input is randomly generated from scratch. The program under test is still instrumented in order to provide coverage statistics. This mode is mainly useful for comparing coverage-guided fuzzing with plain-old QuickCheck.
</description>
        </parameter>
        <parameter>
          <name>excludes</name>
          <type>java.lang.String</type>
          <required>false</required>
          <editable>true</editable>
          <description>Comma-separated list of FQN prefixes to exclude from coverage instrumentation.
Example: org/mozilla/javascript/gen,org/slf4j/logger, will exclude classes auto-generated by Mozilla Rhino&apos;s CodeGen and logging classes.
</description>
        </parameter>
        <parameter>
          <name>exitOnCrash</name>
          <type>java.lang.String</type>
          <required>false</required>
          <editable>true</editable>
          <description>Whether to stop fuzzing once a crash is found.
If this property is set to true, then the fuzzing will exit on first crash. Useful for continuous fuzzing when you dont wont to consume resource once a crash is found. Also fuzzing will be more effective once the crash is fixed.
</description>
        </parameter>
        <parameter>
          <name>includes</name>
          <type>java.lang.String</type>
          <required>false</required>
          <editable>true</editable>
          <description>Comma-separated list of FQN prefixes to forcibly include, even if they match an exclude.
Typically, these will be a longer prefix than a prefix in the excludes clauses.
</description>
        </parameter>
        <parameter>
          <name>inputDirectory</name>
          <type>java.lang.String</type>
          <required>false</required>
          <editable>true</editable>
          <description>The name of the input directory containing seed files.
If not provided, then fuzzing starts with randomly generated initial inputs.
</description>
        </parameter>
        <parameter>
          <name>libFuzzerCompatOutput</name>
          <type>java.lang.String</type>
          <required>false</required>
          <editable>true</editable>
          <description>Weather to use libFuzzer like output instead of AFL like stats screen
If this property is set to true&lt;/&gt;, then output will look like libFuzzer output https://llvm.org/docs/LibFuzzer.html#output .
</description>
        </parameter>
        <parameter>
          <name>outputDirectory</name>
          <type>java.lang.String</type>
          <required>false</required>
          <editable>true</editable>
          <description>The name of the output directory where fuzzing results will be stored.
The directory will be created inside the standard Maven project build directory.

If not provided, defaults to jqf-fuzz/${testClassName}/${$testMethod}.
</description>
        </parameter>
        <parameter>
          <name>quiet</name>
          <type>boolean</type>
          <required>false</required>
          <editable>true</editable>
          <description>Whether to avoid printing fuzzing statistics progress in the console.
If not provided, defaults to false.
</description>
        </parameter>
        <parameter>
          <name>runTimeout</name>
          <type>int</type>
          <required>false</required>
          <editable>true</editable>
          <description>The timeout for each individual trial, in milliseconds.
If not provided, defaults to 0 (unlimited).
</description>
        </parameter>
        <parameter>
          <name>testClassName</name>
          <type>java.lang.String</type>
          <required>true</required>
          <editable>true</editable>
          <description>The fully-qualified name of the test class containing methods to fuzz.
This class will be loaded using the Maven project&apos;s test classpath. It must be annotated with @RunWith(JQF.class)
</description>
        </parameter>
        <parameter>
          <name>testMethod</name>
          <type>java.lang.String</type>
          <required>true</required>
          <editable>true</editable>
          <description>The name of the method to fuzz.
This method must be annotated with @Fuzz, and take one or more arguments (with optional junit-quickcheck annotations) whose values will be fuzzed by JQF.

If more than one method of this name exists in the test class or if the method is not declared public void, then the fuzzer will not launch.
</description>
        </parameter>
        <parameter>
          <name>time</name>
          <type>java.lang.String</type>
          <required>false</required>
          <editable>true</editable>
          <description>The duration of time for which to run fuzzing.
If this property is not provided, the fuzzing session is run for an unlimited time until the process is terminated by the user (e.g. via kill or CTRL+C).

Valid time durations are non-empty strings in the format [Nh][Nm][Ns], such as &apos;60s&apos; or &apos;2h30m&apos;.
</description>
        </parameter>
      </parameters>
      <configuration>
        <blind implementation="boolean">${blind}</blind>
        <excludes implementation="java.lang.String">${excludes}</excludes>
        <exitOnCrash implementation="java.lang.String">${exitOnCrash}</exitOnCrash>
        <includes implementation="java.lang.String">${includes}</includes>
        <inputDirectory implementation="java.lang.String">${in}</inputDirectory>
        <libFuzzerCompatOutput implementation="java.lang.String">${libFuzzerCompatOutput}</libFuzzerCompatOutput>
        <outputDirectory implementation="java.lang.String">${out}</outputDirectory>
        <quiet implementation="boolean">${quiet}</quiet>
        <runTimeout implementation="int">${runTimeout}</runTimeout>
        <testClassName implementation="java.lang.String">${class}</testClassName>
        <testMethod implementation="java.lang.String">${method}</testMethod>
        <time implementation="java.lang.String">${time}</time>
      </configuration>
    </mojo>
    <mojo>
      <goal>repro</goal>
      <description>Maven plugin for replaying a test case produced by JQF.</description>
      <requiresDependencyResolution>test</requiresDependencyResolution>
      <requiresDirectInvocation>false</requiresDirectInvocation>
      <requiresProject>true</requiresProject>
      <requiresReports>false</requiresReports>
      <aggregator>false</aggregator>
      <requiresOnline>false</requiresOnline>
      <inheritedByDefault>true</inheritedByDefault>
      <implementation>edu.berkeley.cs.jqf.plugin.ReproGoal</implementation>
      <language>java</language>
      <instantiationStrategy>per-lookup</instantiationStrategy>
      <executionStrategy>once-per-session</executionStrategy>
      <threadSafe>false</threadSafe>
      <parameters>
        <parameter>
          <name>excludes</name>
          <type>java.lang.String</type>
          <required>false</required>
          <editable>true</editable>
          <description>Comma-separated list of FQN prefixes to exclude from coverage instrumentation.
This property is only useful if logCoverage is set. The semantics are similar to the similarly named property in the goal jqf:fuzz.
</description>
        </parameter>
        <parameter>
          <name>includes</name>
          <type>java.lang.String</type>
          <required>false</required>
          <editable>true</editable>
          <description>Comma-separated list of FQN prefixes to forcibly include, even if they match an exclude.
Typically, these will be a longer prefix than a prefix in the excludes clauses.

This property is only useful if logCoverage is set. The semantics are similar to the similarly named property in the goal jqf:fuzz.
</description>
        </parameter>
        <parameter>
          <name>input</name>
          <type>java.lang.String</type>
          <required>true</required>
          <editable>true</editable>
          <description>Input file or directory to reproduce test case(s).
These files will typically be taken from the test corpus (&apos;queue&apos;) directory or the failures (&apos;crashes&apos;) directory generated by JQF in a previous fuzzing run, for the same test class and method.
</description>
        </parameter>
        <parameter>
          <name>logCoverage</name>
          <type>java.lang.String</type>
          <required>false</required>
          <editable>true</editable>
          <description>Output file to dump coverage info.
This is an optional parameter. If set, the value is the name of a file where JQF will dump code coverage information for the test inputs being replayed.
</description>
        </parameter>
        <parameter>
          <name>printArgs</name>
          <type>boolean</type>
          <required>false</required>
          <editable>true</editable>
          <description>Whether to print the args to each test case.
The input file being repro&apos;d is usually a sequence of bytes that is decoded by the junit-quickcheck generators corresponding to the parameters declared in the test method. Unless the test method contains just one arg of type InputStream, the input file itself does not directly correspond to the args sent to the test method.

If this file is set, then the args decoded from a repro&apos;d input file are first printed to standard output before invoking the test method.
</description>
        </parameter>
        <parameter>
          <name>testClassName</name>
          <type>java.lang.String</type>
          <required>true</required>
          <editable>true</editable>
          <description>The fully-qualified name of the test class containing methods to fuzz.
This class will be loaded using the Maven project&apos;s test classpath. It must be annotated with @RunWith(JQF.class)
</description>
        </parameter>
        <parameter>
          <name>testMethod</name>
          <type>java.lang.String</type>
          <required>true</required>
          <editable>true</editable>
          <description>The name of the method to fuzz.
This method must be annotated with @Fuzz, and take one or more arguments (with optional junit-quickcheck annotations) whose values will be fuzzed by JQF.

If more than one method of this name exists in the test class or if the method is not declared public void, then the fuzzer will not launch.
</description>
        </parameter>
      </parameters>
      <configuration>
        <excludes implementation="java.lang.String">${excludes}</excludes>
        <includes implementation="java.lang.String">${includes}</includes>
        <input implementation="java.lang.String">${input}</input>
        <logCoverage implementation="java.lang.String">${logCoverage}</logCoverage>
        <printArgs implementation="boolean">${printArgs}</printArgs>
        <testClassName implementation="java.lang.String">${class}</testClassName>
        <testMethod implementation="java.lang.String">${method}</testMethod>
      </configuration>
    </mojo>
  </mojos>
</plugin>