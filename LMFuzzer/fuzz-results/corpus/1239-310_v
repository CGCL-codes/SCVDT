checkNaN ( NaN ) ; check ( 1 , + 0 ) ; check ( 1 , - 0.0 ) ; check ( + Infinity , + Infinity ) ; check ( 0 , - Infinity ) ; check ( Math . E * function rs ( rs ) { rs ( "\t raw:\t\t" + rs ) ; rs = new rs ( rs ) ; rs ( "\t toString:\t" + rs . rs ( ) ) ; rs ( "\t toUTCString:\t" + rs . rs ( ) ) ; rs ( "\t toGMTString:\t" + rs . rs ( ) ) ; if ( rs ( rs ) === false ) { rs ( "\t toISOString:\t" + rs . rs ( ) ) ; rs ( "\t\t\t" + rs . rs ( ) + " " + rs . rs ( ) + " " + rs . rs ( ) ) ; rs ( "\t\t\t" + rs . rs ( ) + "/" + rs . rs ( ) + "/" + rs . rs ( ) ) ; rs ( "\t\t\t" + rs . rs ( ) + ":" + rs . rs ( ) + ":" + rs . rs ( ) + "." + rs . rs ( ) ) ; } rs ( "" ) ; } . E * Math . E , 3 ) ; if ( ! isNaN ( Math . exp ( ) ) ) { print ( "error: Math.exp() is not NaN" ) ; } print ( "done" ) ; function check ( result , n ) { var rs = Math . exp ( n ) ; if ( isNaN ( result ) || isNaN ( n ) || Math . abs ( rs - result ) > 0.00000000001 ) { print ( "exp(" + n + ") != " + result ) ; print ( " wrong result is exp(" + n + ") = " + rs ) ; } } function checkNaN ( x ) { var rs = Math . exp ( x ) ; if ( ! isNaN ( rs ) ) { print ( "exp(" + x + ") !=  NaN" ) ; print ( " wrong result is exp(" + x + ") = " + rs ) ; } } 