static bool AnalyzePoppedThis(JSContext* cx, ObjectGroup* group,
                              MDefinition* thisValue, MInstruction* ins,
                              bool definitelyExecuted,
                              HandlePlainObject baseobj,
                              Vector<TypeNewScriptInitializer>* initializerList,
                              Vector<PropertyName*>* accessedProperties,
                              bool* phandled) {
  // Determine the effect that a use of the |this| value when calling |new|
  // on a script has on the properties definitely held by the new object.

  if (ins->isCallSetProperty()) {
    MCallSetProperty* setprop = ins->toCallSetProperty();

    if (setprop->object() != thisValue) {
      return true;
    }

    if (setprop->name() == cx->names().prototype ||
        setprop->name() == cx->names().proto ||
        setprop->name() == cx->names().constructor) {
      return true;
    }

    // Ignore assignments to properties that were already written to.
    if (baseobj->lookup(cx, NameToId(setprop->name()))) {
      *phandled = true;
      return true;
    }

    // Don't add definite properties for properties that were already
    // read in the constructor.
    for (size_t i = 0; i < accessedProperties->length(); i++) {
      if ((*accessedProperties)[i] == setprop->name()) {
        return true;
      }
    }

    // Assignments to new properties must always execute.
    if (!definitelyExecuted) {
      return true;
    }

    RootedId id(cx, NameToId(setprop->name()));
    if (!AddClearDefiniteGetterSetterForPrototypeChain(cx, group, id)) {
      // The prototype chain already contains a getter/setter for this
      // property, or type information is too imprecise.
      return true;
    }

    // Add the property to the object, being careful not to update type
    // information.
    DebugOnly<unsigned> slotSpan = baseobj->slotSpan();
    MOZ_ASSERT(!baseobj->containsPure(id));
    if (!NativeObject::addDataProperty(cx, baseobj, id, SHAPE_INVALID_SLOT,
                                       JSPROP_ENUMERATE)) {
      return false;
    }
    MOZ_ASSERT(baseobj->slotSpan() != slotSpan);
    MOZ_ASSERT(!baseobj->inDictionaryMode());

    Vector<MResumePoint*> callerResumePoints(cx);
    for (MResumePoint* rp = ins->block()->callerResumePoint(); rp;
         rp = rp->block()->callerResumePoint()) {
      if (!callerResumePoints.append(rp)) {
        return false;
      }
    }

    for (int i = callerResumePoints.length() - 1; i >= 0; i--) {
      MResumePoint* rp = callerResumePoints[i];
      JSScript* script = rp->block()->info().script();
      TypeNewScriptInitializer entry(TypeNewScriptInitializer::SETPROP_FRAME,
                                     script->pcToOffset(rp->pc()));
      if (!initializerList->append(entry)) {
        return false;
      }
    }

    JSScript* script = ins->block()->info().script();
    TypeNewScriptInitializer entry(
        TypeNewScriptInitializer::SETPROP,
        script->pcToOffset(setprop->resumePoint()->pc()));
    if (!initializerList->append(entry)) {
      return false;
    }

    *phandled = true;
    return true;
  }

  if (ins->isCallGetProperty()) {
    MCallGetProperty* get = ins->toCallGetProperty();

    /*
     * Properties can be read from the 'this' object if the following hold:
     *
     * - The read is not on a getter along the prototype chain, which
     *   could cause 'this' to escape.
     *
     * - The accessed property is either already a definite property or
     *   is not later added as one. Since the definite properties are
     *   added to the object at the point of its creation, reading a
     *   definite property before it is assigned could incorrectly hit.
     */
    RootedId id(cx, NameToId(get->name()));
    if (!baseobj->lookup(cx, id) && !accessedProperties->append(get->name())) {
      return false;
    }

    if (!AddClearDefiniteGetterSetterForPrototypeChain(cx, group, id)) {
      // The |this| value can escape if any property reads it does go
      // through a getter.
      return true;
    }

    *phandled = true;
    return true;
  }

  if (ins->isPostWriteBarrier()) {
    *phandled = true;
    return true;
  }

  return true;
}
