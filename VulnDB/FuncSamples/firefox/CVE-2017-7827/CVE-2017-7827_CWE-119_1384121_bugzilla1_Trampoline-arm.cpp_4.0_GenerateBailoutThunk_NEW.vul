static void
GenerateBailoutThunk(JSContext* cx, MacroAssembler& masm, uint32_t frameClass)
{
    PushBailoutFrame(masm, frameClass, r0);

    // SP % 8 == 4
    // STEP 1c: Call the bailout function, giving a pointer to the
    //          structure we just blitted onto the stack.
    const int sizeOfBailoutInfo = sizeof(void*)*2;
    masm.reserveStack(sizeOfBailoutInfo);
    masm.mov(sp, r1);
    masm.setupAlignedABICall();

    // Decrement sp by another 4, so we keep alignment. Not Anymore! Pushing
    // both the snapshotoffset as well as the: masm.as_sub(sp, sp, Imm8(4));

    // Set the old (4-byte aligned) value of the sp as the first argument.
    masm.passABIArg(r0);
    masm.passABIArg(r1);

    // Sp % 8 == 0
    masm.callWithABI(JS_FUNC_TO_DATA_PTR(void*, Bailout), MoveOp::GENERAL,
                     CheckUnsafeCallWithABI::DontCheckOther);
    masm.ma_ldr(DTRAddr(sp, DtrOffImm(0)), r2);
    {
        ScratchRegisterScope scratch(masm);
        masm.ma_add(sp, Imm32(sizeOfBailoutInfo), sp, scratch);
    }

    // Common size of a bailout frame.
    uint32_t bailoutFrameSize = 0
        + sizeof(void*) // frameClass
        + sizeof(RegisterDump);

    if (frameClass == NO_FRAME_SIZE_CLASS_ID) {
        // Make sure the bailout frame size fits into the offset for a load.
        masm.as_dtr(IsLoad, 32, Offset,
                    r4, DTRAddr(sp, DtrOffImm(4)));
        // Used to be: offsetof(BailoutStack, frameSize_)
        // This structure is no longer available to us :(
        // We add 12 to the bailoutFrameSize because:
        // sizeof(uint32_t) for the tableOffset that was pushed onto the stack
        // sizeof(uintptr_t) for the snapshotOffset;
        // alignment to round the uintptr_t up to a multiple of 8 bytes.
        ScratchRegisterScope scratch(masm);
        masm.ma_add(sp, Imm32(bailoutFrameSize+12), sp, scratch);
        masm.as_add(sp, sp, O2Reg(r4));
    } else {
        ScratchRegisterScope scratch(masm);
        uint32_t frameSize = FrameSizeClass::FromClass(frameClass).frameSize();
        masm.ma_add(Imm32(// The frame that was added when we entered the most
                          // recent function.
                          frameSize
                          // The size of the "return address" that was dumped on
                          // the stack.
                          + sizeof(void*)
                          // Everything else that was pushed on the stack.
                          + bailoutFrameSize)
                    , sp, scratch);
    }

    // Jump to shared bailout tail. The BailoutInfo pointer has to be in r2.
    JitCode* bailoutTail = cx->runtime()->jitRuntime()->getBailoutTail();
    masm.branch(bailoutTail);
}
