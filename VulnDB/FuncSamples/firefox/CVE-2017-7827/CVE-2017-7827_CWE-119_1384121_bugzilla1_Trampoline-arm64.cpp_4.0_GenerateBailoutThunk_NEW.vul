static void
GenerateBailoutThunk(JSContext* cx, MacroAssembler& masm, uint32_t frameClass)
{
    PushBailoutFrame(masm, frameClass, r0);

    // SP % 8 == 4
    // STEP 1c: Call the bailout function, giving a pointer to the
    //          structure we just blitted onto the stack.
    // Make space for the BaselineBailoutInfo* outparam.
    const int sizeOfBailoutInfo = sizeof(void*) * 2;
    masm.reserveStack(sizeOfBailoutInfo);
    masm.moveStackPtrTo(r1);

    masm.setupUnalignedABICall(r2);
    masm.passABIArg(r0);
    masm.passABIArg(r1);
    masm.callWithABI(JS_FUNC_TO_DATA_PTR(void*, Bailout), MoveOp::GENERAL,
                     CheckUnsafeCallWithABI::DontCheckOther);

    masm.Ldr(x2, MemOperand(masm.GetStackPointer64(), 0));
    masm.addToStackPtr(Imm32(sizeOfBailoutInfo));

    static const uint32_t BailoutDataSize = sizeof(void*) * Registers::Total +
                                            sizeof(double) * FloatRegisters::TotalPhys;

    if (frameClass == NO_FRAME_SIZE_CLASS_ID) {
        vixl::UseScratchRegisterScope temps(&masm.asVIXL());
        const ARMRegister scratch64 = temps.AcquireX();

        masm.Ldr(scratch64, MemOperand(masm.GetStackPointer64(), sizeof(uintptr_t)));
        masm.addToStackPtr(Imm32(BailoutDataSize + 32));
        masm.addToStackPtr(scratch64.asUnsized());
    } else {
        uint32_t frameSize = FrameSizeClass::FromClass(frameClass).frameSize();
        masm.addToStackPtr(Imm32(frameSize + BailoutDataSize + sizeof(void*)));
    }

    // Jump to shared bailout tail. The BailoutInfo pointer has to be in r9.
    JitCode* bailoutTail = cx->runtime()->jitRuntime()->getBailoutTail();
    masm.branch(bailoutTail);
}
