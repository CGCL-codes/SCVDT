bool
BytecodeEmitter::emitTree(ParseNode* pn, ValueUsage valueUsage /* = ValueUsage::WantValue */,
                          EmitLineNumberNote emitLineNote /* = EMIT_LINENOTE */)
{
    if (!CheckRecursionLimit(cx))
        return false;

    EmitLevelManager elm(this);

    /* Emit notes to tell the current bytecode's source line number.
       However, a couple trees require special treatment; see the
       relevant emitter functions for details. */
    if (emitLineNote == EMIT_LINENOTE && !ParseNodeRequiresSpecialLineNumberNotes(pn)) {
        if (!updateLineNumberNotes(pn->pn_pos.begin))
            return false;
    }

    switch (pn->getKind()) {
      case ParseNodeKind::Function:
        if (!emitFunction(pn))
            return false;
        break;

      case ParseNodeKind::ParamsBody:
        if (!emitFunctionFormalParametersAndBody(pn))
            return false;
        break;

      case ParseNodeKind::If:
        if (!emitIf(pn))
            return false;
        break;

      case ParseNodeKind::Switch:
        if (!emitSwitch(pn))
            return false;
        break;

      case ParseNodeKind::While:
        if (!emitWhile(pn))
            return false;
        break;

      case ParseNodeKind::DoWhile:
        if (!emitDo(pn))
            return false;
        break;

      case ParseNodeKind::For:
        if (!emitFor(pn))
            return false;
        break;

      case ParseNodeKind::Break:
        if (!emitBreak(pn->as<BreakStatement>().label()))
            return false;
        break;

      case ParseNodeKind::Continue:
        if (!emitContinue(pn->as<ContinueStatement>().label()))
            return false;
        break;

      case ParseNodeKind::With:
        if (!emitWith(pn))
            return false;
        break;

      case ParseNodeKind::Try:
        if (!emitTry(pn))
            return false;
        break;

      case ParseNodeKind::Catch:
        if (!emitCatch(pn))
            return false;
        break;

      case ParseNodeKind::Var:
        if (!emitDeclarationList(pn))
            return false;
        break;

      case ParseNodeKind::Return:
        if (!emitReturn(pn))
            return false;
        break;

      case ParseNodeKind::YieldStar:
        if (!emitYieldStar(pn->pn_kid))
            return false;
        break;

      case ParseNodeKind::Generator:
        if (!emit1(JSOP_GENERATOR))
            return false;
        break;

      case ParseNodeKind::InitialYield:
        if (!emitInitialYield(pn))
            return false;
        break;

      case ParseNodeKind::Yield:
        if (!emitYield(pn))
            return false;
        break;

      case ParseNodeKind::Await:
        if (!emitAwait(pn))
            return false;
        break;

      case ParseNodeKind::StatementList:
        if (!emitStatementList(pn))
            return false;
        break;

      case ParseNodeKind::EmptyStatement:
        break;

      case ParseNodeKind::ExpressionStatement:
        if (!emitExpressionStatement(pn))
            return false;
        break;

      case ParseNodeKind::Label:
        if (!emitLabeledStatement(&pn->as<LabeledStatement>()))
            return false;
        break;

      case ParseNodeKind::Comma:
        if (!emitSequenceExpr(pn, valueUsage))
            return false;
        break;

      case ParseNodeKind::Assign:
      case ParseNodeKind::AddAssign:
      case ParseNodeKind::SubAssign:
      case ParseNodeKind::BitOrAssign:
      case ParseNodeKind::BitXorAssign:
      case ParseNodeKind::BitAndAssign:
      case ParseNodeKind::LshAssign:
      case ParseNodeKind::RshAssign:
      case ParseNodeKind::UrshAssign:
      case ParseNodeKind::MulAssign:
      case ParseNodeKind::DivAssign:
      case ParseNodeKind::ModAssign:
      case ParseNodeKind::PowAssign:
        if (!emitAssignment(pn->pn_left, pn->getKind(), pn->pn_right))
            return false;
        break;

      case ParseNodeKind::Conditional:
        if (!emitConditionalExpression(pn->as<ConditionalExpression>(), valueUsage))
            return false;
        break;

      case ParseNodeKind::Or:
      case ParseNodeKind::And:
        if (!emitLogical(pn))
            return false;
        break;

      case ParseNodeKind::Add:
      case ParseNodeKind::Sub:
      case ParseNodeKind::BitOr:
      case ParseNodeKind::BitXor:
      case ParseNodeKind::BitAnd:
      case ParseNodeKind::StrictEq:
      case ParseNodeKind::Eq:
      case ParseNodeKind::StrictNe:
      case ParseNodeKind::Ne:
      case ParseNodeKind::Lt:
      case ParseNodeKind::Le:
      case ParseNodeKind::Gt:
      case ParseNodeKind::Ge:
      case ParseNodeKind::In:
      case ParseNodeKind::InstanceOf:
      case ParseNodeKind::Lsh:
      case ParseNodeKind::Rsh:
      case ParseNodeKind::Ursh:
      case ParseNodeKind::Star:
      case ParseNodeKind::Div:
      case ParseNodeKind::Mod:
        if (!emitLeftAssociative(pn))
            return false;
        break;

      case ParseNodeKind::Pow:
        if (!emitRightAssociative(pn))
            return false;
        break;

      case ParseNodeKind::Pipeline:
        if (!emitPipeline(pn))
            return false;
        break;

      case ParseNodeKind::TypeOfName:
        if (!emitTypeof(pn, JSOP_TYPEOF))
            return false;
        break;

      case ParseNodeKind::TypeOfExpr:
        if (!emitTypeof(pn, JSOP_TYPEOFEXPR))
            return false;
        break;

      case ParseNodeKind::Throw:
      case ParseNodeKind::Void:
      case ParseNodeKind::Not:
      case ParseNodeKind::BitNot:
      case ParseNodeKind::Pos:
      case ParseNodeKind::Neg:
        if (!emitUnary(pn))
            return false;
        break;

      case ParseNodeKind::PreIncrement:
      case ParseNodeKind::PreDecrement:
      case ParseNodeKind::PostIncrement:
      case ParseNodeKind::PostDecrement:
        if (!emitIncOrDec(pn))
            return false;
        break;

      case ParseNodeKind::DeleteName:
        if (!emitDeleteName(pn))
            return false;
        break;

      case ParseNodeKind::DeleteProp:
        if (!emitDeleteProperty(pn))
            return false;
        break;

      case ParseNodeKind::DeleteElem:
        if (!emitDeleteElement(pn))
            return false;
        break;

      case ParseNodeKind::DeleteExpr:
        if (!emitDeleteExpression(pn))
            return false;
        break;

      case ParseNodeKind::Dot:
        if (pn->as<PropertyAccess>().isSuper()) {
            if (!emitSuperPropOp(pn, JSOP_GETPROP_SUPER))
                return false;
        } else {
            if (!emitPropOp(pn, JSOP_GETPROP))
                return false;
        }
        break;

      case ParseNodeKind::Elem:
        if (pn->as<PropertyByValue>().isSuper()) {
            if (!emitSuperElemOp(pn, JSOP_GETELEM_SUPER))
                return false;
        } else {
            if (!emitElemOp(pn, JSOP_GETELEM))
                return false;
        }
        break;

      case ParseNodeKind::New:
      case ParseNodeKind::TaggedTemplate:
      case ParseNodeKind::Call:
      case ParseNodeKind::SuperCall:
        if (!emitCallOrNew(pn, valueUsage))
            return false;
        break;

      case ParseNodeKind::LexicalScope:
        if (!emitLexicalScope(pn))
            return false;
        break;

      case ParseNodeKind::Const:
      case ParseNodeKind::Let:
        if (!emitDeclarationList(pn))
            return false;
        break;

      case ParseNodeKind::Import:
        MOZ_ASSERT(sc->isModuleContext());
        break;

      case ParseNodeKind::Export:
        MOZ_ASSERT(sc->isModuleContext());
        if (pn->pn_kid->getKind() != ParseNodeKind::ExportSpecList) {
            if (!emitTree(pn->pn_kid))
                return false;
        }
        break;

      case ParseNodeKind::ExportDefault:
        MOZ_ASSERT(sc->isModuleContext());
        if (!emitExportDefault(pn))
            return false;
        break;

      case ParseNodeKind::ExportFrom:
        MOZ_ASSERT(sc->isModuleContext());
        break;

      case ParseNodeKind::CallSiteObj:
        if (!emitCallSiteObject(pn))
            return false;
        break;

      case ParseNodeKind::Array:
        if (!emitArrayLiteral(pn))
            return false;
        break;

      case ParseNodeKind::Object:
        if (!emitObject(pn))
            return false;
        break;

      case ParseNodeKind::Name:
        if (!emitGetName(pn))
            return false;
        break;

      case ParseNodeKind::TemplateStringList:
        if (!emitTemplateString(pn))
            return false;
        break;

      case ParseNodeKind::TemplateString:
      case ParseNodeKind::String:
        if (!emitAtomOp(pn, JSOP_STRING))
            return false;
        break;

      case ParseNodeKind::Number:
        if (!emitNumberOp(pn->pn_dval))
            return false;
        break;

      case ParseNodeKind::RegExp:
        if (!emitRegExp(objectList.add(pn->as<RegExpLiteral>().objbox())))
            return false;
        break;

      case ParseNodeKind::True:
      case ParseNodeKind::False:
      case ParseNodeKind::Null:
      case ParseNodeKind::RawUndefined:
        if (!emit1(pn->getOp()))
            return false;
        break;

      case ParseNodeKind::This:
        if (!emitThisLiteral(pn))
            return false;
        break;

      case ParseNodeKind::Debugger:
        if (!updateSourceCoordNotes(pn->pn_pos.begin))
            return false;
        if (!emit1(JSOP_DEBUGGER))
            return false;
        break;

      case ParseNodeKind::Class:
        if (!emitClass(pn))
            return false;
        break;

      case ParseNodeKind::NewTarget:
        if (!emit1(JSOP_NEWTARGET))
            return false;
        break;

      case ParseNodeKind::SetThis:
        if (!emitSetThis(pn))
            return false;
        break;

      case ParseNodeKind::PosHolder:
        MOZ_FALLTHROUGH_ASSERT("Should never try to emit ParseNodeKind::PosHolder");

      default:
        MOZ_ASSERT(0);
    }

    /* bce->emitLevel == 1 means we're last on the stack, so finish up. */
    if (emitLevel == 1) {
        if (!updateSourceCoordNotes(pn->pn_pos.end))
            return false;
    }
    return true;
}
