static bool
DecodeMemoryLimits(Decoder& d, ModuleEnvironment* env)
{
    if (env->usesMemory())
        return d.fail("already have default memory");

    Limits memory;
    if (!DecodeLimits(d, &memory, Shareable::True))
        return false;

    if (memory.initial > MaxMemoryInitialPages)
        return d.fail("initial memory size too big");

    CheckedInt<uint32_t> initialBytes = memory.initial;
    initialBytes *= PageSize;
    MOZ_ASSERT(initialBytes.isValid());
    memory.initial = initialBytes.value();

    if (memory.maximum) {
        if (*memory.maximum > MaxMemoryMaximumPages)
            return d.fail("maximum memory size too big");

        CheckedInt<uint32_t> maximumBytes = *memory.maximum;
        maximumBytes *= PageSize;

        // Clamp the maximum memory value to UINT32_MAX; it's not semantically
        // visible since growing will fail for values greater than INT32_MAX.
        memory.maximum = Some(maximumBytes.isValid() ? maximumBytes.value() : UINT32_MAX);
    }

    if (memory.shared == Shareable::True && env->sharedMemoryEnabled == Shareable::False)
        return d.fail("shared memory is disabled");

    env->memoryUsage = memory.shared == Shareable::True
                     ? MemoryUsage::Shared
                     : MemoryUsage::Unshared;
    env->minMemoryLength = memory.initial;
    env->maxMemoryLength = memory.maximum;
    return true;
}
