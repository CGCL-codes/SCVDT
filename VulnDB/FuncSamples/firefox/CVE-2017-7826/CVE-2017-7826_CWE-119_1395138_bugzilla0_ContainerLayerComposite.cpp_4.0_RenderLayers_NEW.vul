template<class ContainerT> void
RenderLayers(ContainerT* aContainer, LayerManagerComposite* aManager,
             const RenderTargetIntRect& aClipRect,
             const Maybe<gfx::Polygon>& aGeometry)
{
  Compositor* compositor = aManager->GetCompositor();

  for (size_t i = 0u; i < aContainer->mPrepared->mLayers.Length(); i++) {
    PreparedLayer& preparedData = aContainer->mPrepared->mLayers[i];

    const gfx::IntRect clipRect = preparedData.mClipRect.ToUnknownRect();
    LayerComposite* layerToRender = static_cast<LayerComposite*>(preparedData.mLayer->ImplData());
    const Maybe<gfx::Polygon>& childGeometry = preparedData.mGeometry;

    Layer* layer = layerToRender->GetLayer();

    if (layerToRender->HasStaleCompositor()) {
      continue;
    }

    if (gfxPrefs::LayersDrawFPS()) {
      for (const auto& metadata : layer->GetAllScrollMetadata()) {
        if (metadata.IsApzForceDisabled()) {
          aManager->DisabledApzWarning();
          break;
        }
      }
    }

    if (layerToRender->HasLayerBeenComposited()) {
      // Composer2D will compose this layer so skip GPU composition
      // this time. The flag will be reset for the next composition phase
      // at the beginning of LayerManagerComposite::Rener().
      gfx::IntRect clearRect = layerToRender->GetClearRect();
      if (!clearRect.IsEmpty()) {
        // Clear layer's visible rect on FrameBuffer with transparent pixels
        gfx::Rect fbRect(clearRect.x, clearRect.y, clearRect.Width(), clearRect.Height());
        compositor->ClearRect(fbRect);
        layerToRender->SetClearRect(gfx::IntRect(0, 0, 0, 0));
      }
    } else {
      // Since we force an intermediate surface for nested 3D contexts,
      // aGeometry and childGeometry are both in the same coordinate space.
      Maybe<gfx::Polygon> geometry =
        SelectLayerGeometry(aGeometry, childGeometry);

      // If we are dealing with a nested 3D context, we might need to transform
      // the geometry back to the coordinate space of the current layer before
      // rendering the layer.
      ContainerLayer* container = layer->AsContainerLayer();
      const bool isLeafLayer = !container || container->UseIntermediateSurface();

      if (geometry && isLeafLayer) {
        TransformLayerGeometry(layer, geometry);
      }

      layerToRender->RenderLayer(clipRect, geometry);
    }

    if (gfxPrefs::UniformityInfo()) {
      PrintUniformityInfo(layer);
    }

    if (gfxPrefs::DrawLayerInfo()) {
      DrawLayerInfo(preparedData.mClipRect, aManager, layer);
    }

    // Draw a border around scrollable layers.
    // A layer can be scrolled by multiple scroll frames. Draw a border
    // for each.
    // Within the list of scroll frames for a layer, the layer border for a
    // scroll frame lower down is affected by the async transforms on scroll
    // frames higher up, so loop from the top down, and accumulate an async
    // transform as we go along.
    Matrix4x4 asyncTransform;
    for (uint32_t i = layer->GetScrollMetadataCount(); i > 0; --i) {
      if (layer->GetFrameMetrics(i - 1).IsScrollable()) {
        // Since the composition bounds are in the parent layer's coordinates,
        // use the parent's effective transform rather than the layer's own.
        ParentLayerRect compositionBounds = layer->GetFrameMetrics(i - 1).GetCompositionBounds();
        aManager->GetCompositor()->DrawDiagnostics(DiagnosticFlags::CONTAINER,
                                                   compositionBounds.ToUnknownRect(),
                                                   aClipRect.ToUnknownRect(),
                                                   asyncTransform * aContainer->GetEffectiveTransform());
        if (AsyncPanZoomController* apzc = layer->GetAsyncPanZoomController(i - 1)) {
          asyncTransform =
              apzc->GetCurrentAsyncTransformWithOverscroll(AsyncPanZoomController::eForCompositing).ToUnknownMatrix()
            * asyncTransform;
        }
      }
    }

    if (gfxPrefs::APZMinimap()) {
      RenderMinimap(aContainer, aManager, aClipRect, layer);
    }

    // invariant: our GL context should be current here, I don't think we can
    // assert it though
  }
}
