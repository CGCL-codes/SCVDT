bool
UnshareUserNamespace()
{
  // The uid and gid need to be retrieved before the unshare; see
  // below.
  uid_t uid = getuid();
  gid_t gid = getgid();
  char buf[80];
  size_t len;

  if (syscall(__NR_unshare, CLONE_NEWUSER) != 0) {
    return false;
  }

  // As mentioned in the header, this function sets up uid/gid
  // mappings that preserve the process's previous ids.  Mapping the
  // uid/gid to something is necessary in order to nest user
  // namespaces (not used yet, but we'll need this in the future for
  // pid namespace support), and leaving the ids unchanged is the
  // least confusing option.
  //
  // In recent kernels (3.19, 3.18.2, 3.17.8), for security reasons,
  // establishing gid mappings will fail unless the process first
  // revokes its ability to call setgroups() by using a /proc node
  // added in the same set of patches.
  //
  // Note that /proc/self points to the thread group leader, not the
  // current thread.  However, CLONE_NEWUSER can be unshared only in a
  // single-threaded process, so those are equivalent if we reach this
  // point.
  len = size_t(SprintfLiteral(buf, "%u %u 1\n", uid, uid));
  MOZ_ASSERT(len < sizeof(buf));
  if (!WriteStringToFile("/proc/self/uid_map", buf, len)) {
    MOZ_CRASH("Failed to write /proc/self/uid_map");
  }

  Unused << WriteStringToFile("/proc/self/setgroups", "deny", 4);

  len = size_t(SprintfLiteral(buf, "%u %u 1\n", gid, gid));
  MOZ_ASSERT(len < sizeof(buf));
  if (!WriteStringToFile("/proc/self/gid_map", buf, len)) {
    MOZ_CRASH("Failed to write /proc/self/gid_map");
  }
  return true;
}
