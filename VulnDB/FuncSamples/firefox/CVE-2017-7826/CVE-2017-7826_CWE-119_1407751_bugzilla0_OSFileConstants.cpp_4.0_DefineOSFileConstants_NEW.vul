bool DefineOSFileConstants(JSContext *cx, JS::Handle<JSObject*> global)
{
  if (!gInitialized || gPaths == nullptr) {
    // If an initialization error was ignored, we may end up with
    // |gInitialized == true| but |gPaths == nullptr|. We cannot
    // |MOZ_ASSERT| this, as this would kill precompile_cache.js,
    // so we simply return an error.
    JS_ReportErrorNumberASCII(cx, js::GetErrorMessage, nullptr,
                              JSMSG_CANT_OPEN,
                              "OSFileConstants", "initialization has failed");
    return false;
  }

  JS::Rooted<JSObject*> objOS(cx);
  if (!(objOS = GetOrCreateObjectProperty(cx, global, "OS"))) {
    return false;
  }
  JS::Rooted<JSObject*> objConstants(cx);
  if (!(objConstants = GetOrCreateObjectProperty(cx, objOS, "Constants"))) {
    return false;
  }

  // Build OS.Constants.libc

  JS::Rooted<JSObject*> objLibc(cx);
  if (!(objLibc = GetOrCreateObjectProperty(cx, objConstants, "libc"))) {
    return false;
  }
  if (!dom::DefineConstants(cx, objLibc, gLibcProperties)) {
    return false;
  }

#if defined(XP_WIN)
  // Build OS.Constants.Win

  JS::Rooted<JSObject*> objWin(cx);
  if (!(objWin = GetOrCreateObjectProperty(cx, objConstants, "Win"))) {
    return false;
  }
  if (!dom::DefineConstants(cx, objWin, gWinProperties)) {
    return false;
  }
#endif // defined(XP_WIN)

  // Build OS.Constants.Sys

  JS::Rooted<JSObject*> objSys(cx);
  if (!(objSys = GetOrCreateObjectProperty(cx, objConstants, "Sys"))) {
    return false;
  }

  nsCOMPtr<nsIXULRuntime> runtime = do_GetService(XULRUNTIME_SERVICE_CONTRACTID);
  if (runtime) {
    nsAutoCString os;
    DebugOnly<nsresult> rv = runtime->GetOS(os);
    MOZ_ASSERT(NS_SUCCEEDED(rv));

    JSString* strVersion = JS_NewStringCopyZ(cx, os.get());
    if (!strVersion) {
      return false;
    }

    JS::Rooted<JS::Value> valVersion(cx, JS::StringValue(strVersion));
    if (!JS_SetProperty(cx, objSys, "Name", valVersion)) {
      return false;
    }
  }

#if defined(DEBUG)
  JS::Rooted<JS::Value> valDebug(cx, JS::TrueValue());
  if (!JS_SetProperty(cx, objSys, "DEBUG", valDebug)) {
    return false;
  }
#endif

#if defined(HAVE_64BIT_BUILD)
  JS::Rooted<JS::Value> valBits(cx, JS::Int32Value(64));
#else
  JS::Rooted<JS::Value> valBits(cx, JS::Int32Value(32));
#endif //defined (HAVE_64BIT_BUILD)
  if (!JS_SetProperty(cx, objSys, "bits", valBits)) {
    return false;
  }

  if (!JS_DefineProperty(cx, objSys, "umask", gUserUmask,
                         JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT)) {
      return false;
  }

  // Build OS.Constants.Path

  JS::Rooted<JSObject*> objPath(cx);
  if (!(objPath = GetOrCreateObjectProperty(cx, objConstants, "Path"))) {
    return false;
  }

  // Locate libxul
  // Note that we don't actually provide the full path, only the name of the
  // library, which is sufficient to link to the library using js-ctypes.

#if defined(XP_MACOSX)
  // Under MacOS X, for some reason, libxul is called simply "XUL",
  // and we need to provide the full path.
  nsAutoString libxul;
  libxul.Append(gPaths->libDir);
  libxul.AppendLiteral("/XUL");
#else
  // On other platforms, libxul is a library "xul" with regular
  // library prefix/suffix.
  nsAutoString libxul;
  libxul.AppendLiteral(DLL_PREFIX);
  libxul.AppendLiteral("xul");
  libxul.AppendLiteral(DLL_SUFFIX);
#endif // defined(XP_MACOSX)

  if (!SetStringProperty(cx, objPath, "libxul", libxul)) {
    return false;
  }

  if (!SetStringProperty(cx, objPath, "libDir", gPaths->libDir)) {
    return false;
  }

  if (!SetStringProperty(cx, objPath, "tmpDir", gPaths->tmpDir)) {
    return false;
  }

  // Configure profileDir only if it is available at this stage
  if (!gPaths->profileDir.IsVoid()
    && !SetStringProperty(cx, objPath, "profileDir", gPaths->profileDir)) {
    return false;
  }

  // Configure localProfileDir only if it is available at this stage
  if (!gPaths->localProfileDir.IsVoid()
    && !SetStringProperty(cx, objPath, "localProfileDir", gPaths->localProfileDir)) {
    return false;
  }

  if (!SetStringProperty(cx, objPath, "homeDir", gPaths->homeDir)) {
    return false;
  }

  if (!SetStringProperty(cx, objPath, "desktopDir", gPaths->desktopDir)) {
    return false;
  }

  if (!SetStringProperty(cx, objPath, "userApplicationDataDir", gPaths->userApplicationDataDir)) {
    return false;
  }

#if defined(XP_WIN)
  if (!SetStringProperty(cx, objPath, "winAppDataDir", gPaths->winAppDataDir)) {
    return false;
  }

  if (!SetStringProperty(cx, objPath, "winStartMenuProgsDir", gPaths->winStartMenuProgsDir)) {
    return false;
  }
#endif // defined(XP_WIN)

#if defined(XP_MACOSX)
  if (!SetStringProperty(cx, objPath, "macUserLibDir", gPaths->macUserLibDir)) {
    return false;
  }

  if (!SetStringProperty(cx, objPath, "macLocalApplicationsDir", gPaths->macLocalApplicationsDir)) {
    return false;
  }

  if (!SetStringProperty(cx, objPath, "macTrashDir", gPaths->macTrashDir)) {
    return false;
  }
#endif // defined(XP_MACOSX)

  // sqlite3 is linked from different places depending on the platform
  nsAutoString libsqlite3;
#if defined(ANDROID)
  // On Android, we use the system's libsqlite3
  libsqlite3.AppendLiteral(DLL_PREFIX);
  libsqlite3.AppendLiteral("sqlite3");
  libsqlite3.AppendLiteral(DLL_SUFFIX);
#elif defined(XP_WIN)
  // On Windows, for some reason, this is part of nss3.dll
  libsqlite3.AppendLiteral(DLL_PREFIX);
  libsqlite3.AppendLiteral("nss3");
  libsqlite3.AppendLiteral(DLL_SUFFIX);
#else
    // On other platforms, we link sqlite3 into libxul
  libsqlite3 = libxul;
#endif // defined(ANDROID) || defined(XP_WIN)

  if (!SetStringProperty(cx, objPath, "libsqlite3", libsqlite3)) {
    return false;
  }

  return true;
}
