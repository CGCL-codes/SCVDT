  MOZ_MUST_USE bool beginFunction() {
    JitSpew(JitSpew_Codegen, "# ========================================");
    JitSpew(JitSpew_Codegen, "# Emitting wasm baseline code");
    JitSpew(JitSpew_Codegen,
            "# beginFunction: start of function prologue for index %d",
            (int)func_.index);

    // Make a start on the stack map for this function.  Inspect the args so
    // as to determine which of them are both in-memory and pointer-typed, and
    // add entries to mst_ as appropriate.

    const ValTypeVector& argTys = env_.funcTypes[func_.index]->args();

    size_t nStackArgBytes = stackArgAreaSize(argTys);
    MOZ_ASSERT(nStackArgBytes % sizeof(void*) == 0);
    smgen_.numStackArgWords_ = nStackArgBytes / sizeof(void*);

    MOZ_ASSERT(smgen_.mst_.length() == 0);
    if (!smgen_.mst_.pushNonGCPointers(smgen_.numStackArgWords_)) {
      return false;
    }

    for (ABIArgIter<const ValTypeVector> i(argTys); !i.done(); i++) {
      ABIArg argLoc = *i;
      if (argLoc.kind() != ABIArg::Stack) {
        continue;
      }
      const ValType& ty = argTys[i.index()];
      if (!ty.isReference()) {
        continue;
      }
      uint32_t offset = argLoc.offsetFromArgBase();
      MOZ_ASSERT(offset < nStackArgBytes);
      MOZ_ASSERT(offset % sizeof(void*) == 0);
      smgen_.mst_.setGCPointer(offset / sizeof(void*));
    }

    GenerateFunctionPrologue(
        masm, env_.funcTypes[func_.index]->id,
        env_.mode() == CompileMode::Tier1 ? Some(func_.index) : Nothing(),
        &offsets_);

    // GenerateFunctionPrologue pushes exactly one wasm::Frame's worth of
    // stuff, and none of the values are GC pointers.  Hence:
    if (!smgen_.mst_.pushNonGCPointers(sizeof(Frame) / sizeof(void*))) {
      return false;
    }

    // Initialize DebugFrame fields before the stack overflow trap so that
    // we have the invariant that all observable Frames in a debugEnabled
    // Module have valid DebugFrames.
    if (env_.debugEnabled()) {
#ifdef JS_CODEGEN_ARM64
      static_assert(DebugFrame::offsetOfFrame() % WasmStackAlignment == 0,
                    "aligned");
#endif
      masm.reserveStack(DebugFrame::offsetOfFrame());
      if (!smgen_.mst_.pushNonGCPointers(DebugFrame::offsetOfFrame() /
                                         sizeof(void*))) {
        return false;
      }

      masm.store32(
          Imm32(func_.index),
          Address(masm.getStackPointer(), DebugFrame::offsetOfFuncIndex()));
      masm.storePtr(ImmWord(0), Address(masm.getStackPointer(),
                                        DebugFrame::offsetOfFlagsWord()));
      // Zero out pointer values for safety, since it's not easy to establish
      // whether they will always be defined before a GC.

      // DebugFrame::resultRef_ and ::resultAnyRef_
      masm.storePtr(ImmWord(0), Address(masm.getStackPointer(),
                                        DebugFrame::offsetOfResults()));

      // DebugFrame::cachedReturnJSValue_
      for (size_t i = 0; i < sizeof(js::Value) / sizeof(void*); i++) {
        masm.storePtr(ImmWord(0),
                      Address(masm.getStackPointer(),
                              DebugFrame::offsetOfCachedReturnJSValue() +
                                  i * sizeof(void*)));
      }
    }

    // Generate a stack-overflow check and its associated stack map.

    fr.checkStack(ABINonArgReg0, BytecodeOffset(func_.lineOrBytecode));

    const ValTypeVector& args = funcType().args();
    ExitStubMapVector extras;
    if (!smgen_.generateStackmapEntriesForTrapExit(args, extras)) {
      return false;
    }
    if (!createStackMap("stack check", extras, masm.currentOffset(),
                        HasRefTypedDebugFrame::No)) {
      return false;
    }

    size_t reservedBytes = fr.fixedSize() - masm.framePushed();
    MOZ_ASSERT(0 == (reservedBytes % sizeof(void*)));

    masm.reserveStack(reservedBytes);
    fr.onFixedStackAllocated();
    if (!smgen_.mst_.pushNonGCPointers(reservedBytes / sizeof(void*))) {
      return false;
    }

    // Copy arguments from registers to stack.
    for (ABIArgIter<const ValTypeVector> i(args); !i.done(); i++) {
      if (!i->argInRegister()) {
        continue;
      }
      Local& l = localInfo_[i.index()];
      switch (i.mirType()) {
        case MIRType::Int32:
          fr.storeLocalI32(RegI32(i->gpr()), l);
          break;
        case MIRType::Int64:
          fr.storeLocalI64(RegI64(i->gpr64()), l);
          break;
        case MIRType::Pointer: {
          uint32_t offs = fr.localOffset(l);
          MOZ_ASSERT(0 == (offs % sizeof(void*)));
          fr.storeLocalPtr(RegPtr(i->gpr()), l);
          smgen_.mst_.setGCPointer(offs / sizeof(void*));
          break;
        }
        case MIRType::Double:
          fr.storeLocalF64(RegF64(i->fpu()), l);
          break;
        case MIRType::Float32:
          fr.storeLocalF32(RegF32(i->fpu()), l);
          break;
        default:
          MOZ_CRASH("Function argument type");
      }
    }

    fr.zeroLocals(&ra);

    if (env_.debugEnabled()) {
      insertBreakablePoint(CallSiteDesc::EnterFrame);
      if (!createStackMap("debug: breakable point")) {
        return false;
      }
    }

    JitSpew(JitSpew_Codegen,
            "# beginFunction: enter body with masm.framePushed = %u",
            masm.framePushed());
    MOZ_ASSERT(smgen_.framePushedAtEntryToBody_.isNothing());
    smgen_.framePushedAtEntryToBody_.emplace(masm.framePushed());

    return true;
  }
