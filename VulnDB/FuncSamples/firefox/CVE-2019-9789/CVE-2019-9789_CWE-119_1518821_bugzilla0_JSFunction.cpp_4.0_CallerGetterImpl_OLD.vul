bool CallerGetterImpl(JSContext* cx, const CallArgs& args) {
  MOZ_ASSERT(IsFunction(args.thisv()));

  // Beware!  This function can be invoked on *any* function!  It can't
  // assume it'll never be invoked on natives, strict mode functions, bound
  // functions, or anything else that ordinarily has immutable .caller
  // defined with [[ThrowTypeError]].
  RootedFunction fun(cx, &args.thisv().toObject().as<JSFunction>());
  if (!CallerRestrictions(cx, fun)) {
    return false;
  }

  // Also return null if this function wasn't found on the stack.
  NonBuiltinScriptFrameIter iter(cx);
  if (!AdvanceToActiveCallLinear(cx, iter, fun)) {
    args.rval().setNull();
    return true;
  }

  ++iter;
  while (!iter.done() && iter.isEvalFrame()) {
    ++iter;
  }

  if (iter.done() || !iter.isFunctionFrame()) {
    args.rval().setNull();
    return true;
  }

  RootedObject caller(cx, iter.callee(cx));
  if (caller->is<JSFunction>() && caller->as<JSFunction>().isAsync()) {
    caller = GetWrappedAsyncFunction(&caller->as<JSFunction>());
  }
  if (!cx->compartment()->wrap(cx, &caller)) {
    return false;
  }

  // Censor the caller if we don't have full access to it.  If we do, but the
  // caller is a function with strict mode code, throw a TypeError per ES5.
  // If we pass these checks, we can return the computed caller.
  {
    JSObject* callerObj = CheckedUnwrap(caller);
    if (!callerObj) {
      args.rval().setNull();
      return true;
    }

    JSFunction* callerFun = &callerObj->as<JSFunction>();
    if (IsWrappedAsyncFunction(callerFun)) {
      callerFun = GetUnwrappedAsyncFunction(callerFun);
    } else if (IsWrappedAsyncGenerator(callerFun)) {
      callerFun = GetUnwrappedAsyncGenerator(callerFun);
    }
    MOZ_ASSERT(!callerFun->isBuiltin(),
               "non-builtin iterator returned a builtin?");

    if (callerFun->strict()) {
      JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                JSMSG_CALLER_IS_STRICT);
      return false;
    }
  }

  args.rval().setObject(*caller);
  return true;
}
