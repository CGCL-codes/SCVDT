static bool DoSetElemFallback(JSContext* cx, BaselineFrame* frame,
                              ICSetElem_Fallback* stub, Value* stack,
                              HandleValue objv, HandleValue index,
                              HandleValue rhs) {
  stub->incrementEnteredCount();

  RootedScript script(cx, frame->script());
  RootedScript outerScript(cx, script);
  jsbytecode* pc = stub->icEntry()->pc(script);
  JSOp op = JSOp(*pc);
  FallbackICSpew(cx, stub, "SetElem(%s)", CodeName[JSOp(*pc)]);

  MOZ_ASSERT(op == JSOP_SETELEM || op == JSOP_STRICTSETELEM ||
             op == JSOP_INITELEM || op == JSOP_INITHIDDENELEM ||
             op == JSOP_INITELEM_ARRAY || op == JSOP_INITELEM_INC);

  RootedObject obj(cx, ToObjectFromStack(cx, objv));
  if (!obj) {
    return false;
  }

  RootedShape oldShape(cx, obj->maybeShape());
  RootedObjectGroup oldGroup(cx, JSObject::getGroup(cx, obj));
  if (!oldGroup) {
    return false;
  }

  if (obj->is<UnboxedPlainObject>()) {
    MOZ_ASSERT(!oldShape);
    if (UnboxedExpandoObject* expando =
            obj->as<UnboxedPlainObject>().maybeExpando()) {
      oldShape = expando->lastProperty();
    }
  }

  bool isTemporarilyUnoptimizable = false;
  bool canAddSlot = false;
  bool attached = false;

  if (stub->state().maybeTransition()) {
    stub->discardStubs(cx);
  }

  if (stub->state().canAttachStub()) {
    SetPropIRGenerator gen(cx, script, pc, CacheKind::SetElem,
                           stub->state().mode(), &isTemporarilyUnoptimizable,
                           &canAddSlot, objv, index, rhs);
    if (gen.tryAttachStub()) {
      ICStub* newStub = AttachBaselineCacheIRStub(
          cx, gen.writerRef(), gen.cacheKind(),
          BaselineCacheIRStubKind::Updated, frame->script(), stub, &attached);
      if (newStub) {
        JitSpew(JitSpew_BaselineIC, "  Attached SetElem CacheIR stub");

        SetUpdateStubData(newStub->toCacheIR_Updated(), gen.typeCheckInfo());

        if (gen.shouldNotePreliminaryObjectStub()) {
          newStub->toCacheIR_Updated()->notePreliminaryObject();
        } else if (gen.shouldUnlinkPreliminaryObjectStubs()) {
          StripPreliminaryObjectStubs(cx, stub);
        }

        if (gen.attachedTypedArrayOOBStub()) {
          stub->noteHasTypedArrayOOB();
        }
      }
    }
  }

  if (op == JSOP_INITELEM || op == JSOP_INITHIDDENELEM) {
    if (!InitElemOperation(cx, pc, obj, index, rhs)) {
      return false;
    }
  } else if (op == JSOP_INITELEM_ARRAY) {
    MOZ_ASSERT(uint32_t(index.toInt32()) <= INT32_MAX,
               "the bytecode emitter must fail to compile code that would "
               "produce JSOP_INITELEM_ARRAY with an index exceeding "
               "int32_t range");
    MOZ_ASSERT(uint32_t(index.toInt32()) == GET_UINT32(pc));
    if (!InitArrayElemOperation(cx, pc, obj, index.toInt32(), rhs)) {
      return false;
    }
  } else if (op == JSOP_INITELEM_INC) {
    if (!InitArrayElemOperation(cx, pc, obj, index.toInt32(), rhs)) {
      return false;
    }
  } else {
    if (!SetObjectElement(cx, obj, index, rhs, objv,
                          JSOp(*pc) == JSOP_STRICTSETELEM, script, pc)) {
      return false;
    }
  }

  // Don't try to attach stubs that wish to be hidden. We don't know how to
  // have different enumerability in the stubs for the moment.
  if (op == JSOP_INITHIDDENELEM) {
    return true;
  }

  // Overwrite the object on the stack (pushed for the decompiler) with the rhs.
  MOZ_ASSERT(stack[2] == objv);
  stack[2] = rhs;

  if (attached) {
    return true;
  }

  // The SetObjectElement call might have entered this IC recursively, so try
  // to transition.
  if (stub->state().maybeTransition()) {
    stub->discardStubs(cx);
  }

  if (stub->state().canAttachStub()) {
    SetPropIRGenerator gen(cx, script, pc, CacheKind::SetElem,
                           stub->state().mode(), &isTemporarilyUnoptimizable,
                           &canAddSlot, objv, index, rhs);
    if (canAddSlot && gen.tryAttachAddSlotStub(oldGroup, oldShape)) {
      ICStub* newStub = AttachBaselineCacheIRStub(
          cx, gen.writerRef(), gen.cacheKind(),
          BaselineCacheIRStubKind::Updated, frame->script(), stub, &attached);
      if (newStub) {
        JitSpew(JitSpew_BaselineIC, "  Attached SetElem CacheIR stub");

        SetUpdateStubData(newStub->toCacheIR_Updated(), gen.typeCheckInfo());

        if (gen.shouldNotePreliminaryObjectStub()) {
          newStub->toCacheIR_Updated()->notePreliminaryObject();
        } else if (gen.shouldUnlinkPreliminaryObjectStubs()) {
          StripPreliminaryObjectStubs(cx, stub);
        }
        return true;
      }
    } else {
      gen.trackAttached(IRGenerator::NotAttached);
    }
    if (!attached && !isTemporarilyUnoptimizable) {
      stub->state().trackNotAttached();
    }
  }

  return true;
}
