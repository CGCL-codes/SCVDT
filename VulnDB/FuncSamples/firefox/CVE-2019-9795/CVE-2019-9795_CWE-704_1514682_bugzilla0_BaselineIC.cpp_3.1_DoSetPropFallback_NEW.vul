static bool DoSetPropFallback(JSContext* cx, BaselineFrame* frame,
                              ICSetProp_Fallback* stub, Value* stack,
                              HandleValue lhs, HandleValue rhs) {
  stub->incrementEnteredCount();

  RootedScript script(cx, frame->script());
  jsbytecode* pc = stub->icEntry()->pc(script);
  JSOp op = JSOp(*pc);
  FallbackICSpew(cx, stub, "SetProp(%s)", CodeName[op]);

  MOZ_ASSERT(op == JSOP_SETPROP || op == JSOP_STRICTSETPROP ||
             op == JSOP_SETNAME || op == JSOP_STRICTSETNAME ||
             op == JSOP_SETGNAME || op == JSOP_STRICTSETGNAME ||
             op == JSOP_INITPROP || op == JSOP_INITLOCKEDPROP ||
             op == JSOP_INITHIDDENPROP || op == JSOP_INITGLEXICAL);

  RootedPropertyName name(cx, script->getName(pc));
  RootedId id(cx, NameToId(name));

  RootedObject obj(cx, ToObjectFromStack(cx, lhs));
  if (!obj) {
    return false;
  }
  RootedShape oldShape(cx, obj->maybeShape());
  RootedObjectGroup oldGroup(cx, JSObject::getGroup(cx, obj));
  if (!oldGroup) {
    return false;
  }

  if (obj->is<UnboxedPlainObject>()) {
    MOZ_ASSERT(!oldShape);
    if (UnboxedExpandoObject* expando =
            obj->as<UnboxedPlainObject>().maybeExpando()) {
      oldShape = expando->lastProperty();
    }
  }

  // There are some reasons we can fail to attach a stub that are temporary.
  // We want to avoid calling noteUnoptimizableAccess() if the reason we
  // failed to attach a stub is one of those temporary reasons, since we might
  // end up attaching a stub for the exact same access later.
  bool isTemporarilyUnoptimizable = false;
  bool canAddSlot = false;

  bool attached = false;
  if (stub->state().maybeTransition()) {
    stub->discardStubs(cx);
  }

  if (stub->state().canAttachStub()) {
    RootedValue idVal(cx, StringValue(name));
    SetPropIRGenerator gen(cx, script, pc, CacheKind::SetProp,
                           stub->state().mode(), &isTemporarilyUnoptimizable,
                           &canAddSlot, lhs, idVal, rhs);
    if (gen.tryAttachStub()) {
      ICStub* newStub = AttachBaselineCacheIRStub(
          cx, gen.writerRef(), gen.cacheKind(),
          BaselineCacheIRStubKind::Updated, frame->script(), stub, &attached);
      if (newStub) {
        JitSpew(JitSpew_BaselineIC, "  Attached SetProp CacheIR stub");

        SetUpdateStubData(newStub->toCacheIR_Updated(), gen.typeCheckInfo());

        if (gen.shouldNotePreliminaryObjectStub()) {
          newStub->toCacheIR_Updated()->notePreliminaryObject();
        } else if (gen.shouldUnlinkPreliminaryObjectStubs()) {
          StripPreliminaryObjectStubs(cx, stub);
        }
      }
    }
  }

  if (op == JSOP_INITPROP || op == JSOP_INITLOCKEDPROP ||
      op == JSOP_INITHIDDENPROP) {
    if (!InitPropertyOperation(cx, op, obj, name, rhs)) {
      return false;
    }
  } else if (op == JSOP_SETNAME || op == JSOP_STRICTSETNAME ||
             op == JSOP_SETGNAME || op == JSOP_STRICTSETGNAME) {
    if (!SetNameOperation(cx, script, pc, obj, rhs)) {
      return false;
    }
  } else if (op == JSOP_INITGLEXICAL) {
    RootedValue v(cx, rhs);
    LexicalEnvironmentObject* lexicalEnv;
    if (script->hasNonSyntacticScope()) {
      lexicalEnv = &NearestEnclosingExtensibleLexicalEnvironment(
          frame->environmentChain());
    } else {
      lexicalEnv = &cx->global()->lexicalEnvironment();
    }
    InitGlobalLexicalOperation(cx, lexicalEnv, script, pc, v);
  } else {
    MOZ_ASSERT(op == JSOP_SETPROP || op == JSOP_STRICTSETPROP);

    ObjectOpResult result;
    if (!SetProperty(cx, obj, id, rhs, lhs, result) ||
        !result.checkStrictErrorOrWarning(cx, obj, id,
                                          op == JSOP_STRICTSETPROP)) {
      return false;
    }
  }

  // Overwrite the LHS on the stack (pushed for the decompiler) with the RHS.
  MOZ_ASSERT(stack[1] == lhs);
  stack[1] = rhs;

  if (attached) {
    return true;
  }

  // The SetProperty call might have entered this IC recursively, so try
  // to transition.
  if (stub->state().maybeTransition()) {
    stub->discardStubs(cx);
  }

  if (stub->state().canAttachStub()) {
    RootedValue idVal(cx, StringValue(name));
    SetPropIRGenerator gen(cx, script, pc, CacheKind::SetProp,
                           stub->state().mode(), &isTemporarilyUnoptimizable,
                           &canAddSlot, lhs, idVal, rhs);
    if (canAddSlot && gen.tryAttachAddSlotStub(oldGroup, oldShape)) {
      ICStub* newStub = AttachBaselineCacheIRStub(
          cx, gen.writerRef(), gen.cacheKind(),
          BaselineCacheIRStubKind::Updated, frame->script(), stub, &attached);
      if (newStub) {
        JitSpew(JitSpew_BaselineIC, "  Attached SetProp CacheIR stub");

        SetUpdateStubData(newStub->toCacheIR_Updated(), gen.typeCheckInfo());

        if (gen.shouldNotePreliminaryObjectStub()) {
          newStub->toCacheIR_Updated()->notePreliminaryObject();
        } else if (gen.shouldUnlinkPreliminaryObjectStubs()) {
          StripPreliminaryObjectStubs(cx, stub);
        }
      }
    } else {
      gen.trackAttached(IRGenerator::NotAttached);
    }
    if (!attached && !isTemporarilyUnoptimizable) {
      stub->state().trackNotAttached();
    }
  }

  return true;
}
