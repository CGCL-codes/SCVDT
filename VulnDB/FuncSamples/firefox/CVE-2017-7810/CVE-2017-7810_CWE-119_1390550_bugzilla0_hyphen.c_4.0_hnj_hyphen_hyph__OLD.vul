int hnj_hyphen_hyph_(HyphenDict *dict, const char *word, int word_size,
    char * hyphens, char *** rep, int ** pos, int ** cut,
    int clhmin, int crhmin, int lend, int rend)
{
  char *prep_word;
  int i, j, k;
  int state;
  char ch;
  HyphenState *hstate;
  char *match;
  char *repl;
  signed char replindex;
  signed char replcut;
  int offset;
  int * matchlen;
  int * matchindex;
  char ** matchrepl;  
  int isrepl = 0;
  int nHyphCount;

  size_t prep_word_size = word_size + 3;
  prep_word = (char*) hnj_malloc (prep_word_size);
  matchlen = (int*) hnj_malloc ((word_size + 3) * sizeof(int));
  matchindex = (int*) hnj_malloc ((word_size + 3) * sizeof(int));
  matchrepl = (char**) hnj_malloc ((word_size + 3) * sizeof(char *));

  j = 0;
  prep_word[j++] = '.';
  
  for (i = 0; i < word_size; i++) {
    if (word[i] <= '9' && word[i] >= '0') {
      prep_word[j++] = '.';
    } else {
      prep_word[j++] = word[i];
    }
  }



  prep_word[j++] = '.';
  prep_word[j] = '\0';

  for (i = 0; i < j; i++)
    hyphens[i] = '0';    

#ifdef VERBOSE
  printf ("prep_word = %s\n", prep_word);
#endif

  /* now, run the finite state machine */
  state = 0;
  for (i = 0; i < j; i++)
    {
      ch = prep_word[i];
      for (;;)
	{

	  if (state == -1) {
            /* return 1; */
	    /*  KBH: FIXME shouldn't this be as follows? */
            state = 0;
            goto try_next_letter;
          }          

#ifdef VERBOSE
	  char *state_str;
	  state_str = get_state_str (state, 1);

	  for (k = 0; k < i - strlen (state_str); k++)
	    putchar (' ');
	  printf ("%s", state_str);
#endif

	  hstate = &dict->states[state];
	  for (k = 0; k < hstate->num_trans; k++)
	    if (hstate->trans[k].ch == ch)
	      {
		state = hstate->trans[k].new_state;
		goto found_state;
	      }
	  state = hstate->fallback_state;
#ifdef VERBOSE
	  printf (" falling back, fallback_state %d\n", state);
#endif
	}
    found_state:
#ifdef VERBOSE
      printf ("found state %d\n",state);
#endif
      /* Additional optimization is possible here - especially,
	 elimination of trailing zeroes from the match. Leading zeroes
	 have already been optimized. */
      match = dict->states[state].match;
      repl = dict->states[state].repl;
      replindex = dict->states[state].replindex;
      replcut = dict->states[state].replcut;
      /* replacing rules not handled by hyphen_hyphenate() */
      if (match)
	{
	  offset = i + 1 - strlen (match);
#ifdef VERBOSE
	  for (k = 0; k < offset; k++)
	    putchar (' ');
	  printf ("%s (%s)\n", match, repl);
#endif
          if (repl) {
            if (!isrepl) for(; isrepl < word_size; isrepl++) {
                matchrepl[isrepl] = NULL;
                matchindex[isrepl] = -1;
            }
            matchlen[offset + replindex] = replcut;
          }
	  /* This is a linear search because I tried a binary search and
	     found it to be just a teeny bit slower. */
	  for (k = 0; match[k]; k++) {
	    if ((hyphens[offset + k] < match[k])) {
	      hyphens[offset + k] = match[k];
              if (match[k]&1) {
                matchrepl[offset + k] = repl;
                if (repl && (k >= replindex) && (k <= replindex + replcut)) {
                    matchindex[offset + replindex] = offset + k;
                }
              }
            }
          }
          
	}

      /* KBH: we need this to make sure we keep looking in a word */
      /* for patterns even if the current character is not known in state 0 */
      /* since patterns for hyphenation may occur anywhere in the word */
      try_next_letter: ;

    }
#ifdef VERBOSE
  for (i = 0; i < j; i++)
    putchar (hyphens[i]);
  putchar ('\n');
#endif

  for (i = 0; i < j - 3; i++)
#if 0
    if (hyphens[i + 1] & 1)
      hyphens[i] = '-';
#else
    hyphens[i] = hyphens[i + 1];
#endif
  for (; i < word_size; i++)
    hyphens[i] = '0';
  hyphens[word_size] = '\0';

       /* now create a new char string showing hyphenation positions */
       /* count the hyphens and allocate space for the new hyphenated string */
       nHyphCount = 0;
       for (i = 0; i < word_size; i++)
          if (hyphens[i]&1)
             nHyphCount++;
       j = 0;
       for (i = 0; i < word_size; i++) {
           if (isrepl && (matchindex[i] >= 0) && matchrepl[matchindex[i]]) { 
                if (rep && pos && cut) {
                    if (!*rep)
                        *rep = (char **) calloc(word_size, sizeof(char *));
                    if (!*pos)
                        *pos = (int *) calloc(word_size, sizeof(int));
                    if (!*cut) {
                        *cut = (int *) calloc(word_size, sizeof(int));
                    }
                    (*rep)[matchindex[i] - 1] = hnj_strdup(matchrepl[matchindex[i]]);
                    (*pos)[matchindex[i] - 1] = matchindex[i] - i;
                    (*cut)[matchindex[i] - 1] = matchlen[i];
                }
                j += strlen(matchrepl[matchindex[i]]);
                i += matchlen[i] - 1;
          }
       }

  hnj_free (matchrepl);
  hnj_free (matchlen);
  hnj_free (matchindex);

  // recursive hyphenation of the first (compound) level segments
  if (dict->nextlevel) {
     char ** rep2;
     int * pos2;
     int * cut2;
     char * hyphens2;
     int begin = 0;

     rep2 = (char**) hnj_malloc (word_size * sizeof(char *));
     pos2 = (int*) hnj_malloc (word_size * sizeof(int));
     cut2 = (int*) hnj_malloc (word_size * sizeof(int));
     hyphens2 = (char*) hnj_malloc (word_size + 3);
     for (i = 0; i < word_size; i++) rep2[i] = NULL;
     for (i = 0; i < word_size; i++) if 
        (hyphens[i]&1 || (begin > 0 && i + 1 == word_size)) {
        if (i - begin > 1) {
            int hyph = 0;
            prep_word[i + 2] = '\0';
            /* non-standard hyphenation at compound boundary (Schiffahrt) */
            if (rep && *rep && *pos && *cut && (*rep)[i]) {
                char * l = strchr((*rep)[i], '=');
                size_t offset = 2 + i - (*pos)[i];
                strncpy(prep_word + offset, (*rep)[i], prep_word_size - offset - 1);
                prep_word[prep_word_size - 1] = '\0';
                if (l) {
                    hyph = (l - (*rep)[i]) - (*pos)[i];
                    prep_word[2 + i + hyph] = '\0';
                }
            }
            hnj_hyphen_hyph_(dict, prep_word + begin + 1, i - begin + 1 + hyph,
                hyphens2, &rep2, &pos2, &cut2, clhmin,
                crhmin, (begin > 0 ? 0 : lend), (hyphens[i]&1 ? 0 : rend));
            for (j = 0; j < i - begin - 1; j++) {
                hyphens[begin + j] = hyphens2[j];
                if (rep2[j] && rep && pos && cut) {
                    if (!*rep && !*pos && !*cut) {
                        int k;
                        *rep = (char **) malloc(sizeof(char *) * word_size);
                        *pos = (int *) malloc(sizeof(int) * word_size);
                        *cut = (int *) malloc(sizeof(int) * word_size);
                        for (k = 0; k < word_size; k++) {
                            (*rep)[k] = NULL;
                            (*pos)[k] = 0;
                            (*cut)[k] = 0;
                        }
                    }
                    (*rep)[begin + j] = rep2[j];
                    (*pos)[begin + j] = pos2[j];
                    (*cut)[begin + j] = cut2[j];
                }
            }
            prep_word[i + 2] = word[i + 1];
            if (*rep && *pos && *cut && (*rep)[i]) {
                size_t offset = 1;
                strncpy(prep_word + offset, word, prep_word_size - offset - 1);
                prep_word[prep_word_size - 1] = '\0';
            }
        }
        begin = i + 1;
        for (j = 0; j < word_size; j++) rep2[j] = NULL;
     }
     
     // non-compound
     if (begin == 0) {
        hnj_hyphen_hyph_(dict->nextlevel, word, word_size,
            hyphens, rep, pos, cut, clhmin, crhmin, lend, rend);
        if (!lend) hnj_hyphen_lhmin(dict->utf8, word, word_size, hyphens,
            rep, pos, cut, clhmin);
        if (!rend) hnj_hyphen_rhmin(dict->utf8, word, word_size, hyphens,
            rep, pos, cut, crhmin);
     }
     
     free(rep2);
     free(cut2);
     free(pos2);
     free(hyphens2);
  }

  hnj_free (prep_word);
  return 0;
}
