void hnj_hyphen_load_line(char * buf, HyphenDict * dict, HashTab * hashtab) {
  int i, j;
  char word[MAX_CHARS];
  char pattern[MAX_CHARS];
  char * repl;
  signed char replindex;
  signed char replcut;
  int state_num = 0;
  int last_state;
  char ch;
  int found;

	  if (strncmp(buf, "LEFTHYPHENMIN", 13) == 0) {
	    dict->lhmin = atoi(buf + 13);
	    return;
	  } else if (strncmp(buf, "RIGHTHYPHENMIN", 14) == 0) {
	    dict->rhmin = atoi(buf + 14);
	    return;
	  } else if (strncmp(buf, "COMPOUNDLEFTHYPHENMIN", 21) == 0) {
	    dict->clhmin = atoi(buf + 21);
	    return;
	  } else if (strncmp(buf, "COMPOUNDRIGHTHYPHENMIN", 22) == 0) {
	    dict->crhmin = atoi(buf + 22);
	    return;
	  } else if (strncmp(buf, "NOHYPHEN", 8) == 0) {
	    char * space = buf + 8;
	    while (*space != '\0' && (*space == ' ' || *space == '\t')) space++;
	    if (*buf != '\0') dict->nohyphen = hnj_strdup(space);
	    if (dict->nohyphen) {
	        char * nhe = dict->nohyphen + strlen(dict->nohyphen) - 1;
	        *nhe = 0;
	        for (nhe = nhe - 1; nhe > dict->nohyphen; nhe--) {
	                if (*nhe == ',') {
	                    dict->nohyphenl++;
	                    *nhe = 0;
	                }
	        }
	    }
	    return;
	  } 
	  j = 0;
	  pattern[j] = '0';
          repl = strchr(buf, '/');
          replindex = 0;
          replcut = 0;
          if (repl) {
            char * index = strchr(repl + 1, ',');
            *repl = '\0';
            if (index) {
                char * index2 = strchr(index + 1, ',');
                *index = '\0';
                if (index2) {
                    *index2 = '\0';
                    replindex = (signed char) atoi(index + 1) - 1;
                    replcut = (signed char) atoi(index2 + 1);                
                }
            } else {
                hnj_strchomp(repl + 1);
                replindex = 0;
                replcut = (signed char) strlen(buf);
            }
            repl = hnj_strdup(repl + 1);
          }
	  for (i = 0; ((buf[i] > ' ') || (buf[i] < 0)); i++)
	    {
	      if (buf[i] >= '0' && buf[i] <= '9')
		pattern[j] = buf[i];
	      else
		{
		  word[j] = buf[i];
		  pattern[++j] = '0';
		}
	    }
	  word[j] = '\0';
	  pattern[j + 1] = '\0';

          i = 0;
	  if (!repl) {
	    /* Optimize away leading zeroes */
            for (; pattern[i] == '0'; i++);
          } else {
            if (*word == '.') i++;
            /* convert UTF-8 char. positions of discretionary hyph. replacements to 8-bit */
            if (dict->utf8) {
                int pu = -1;        /* unicode character position */
                int ps = -1;        /* unicode start position (original replindex) */
                int pc = (*word == '.') ? 1: 0; /* 8-bit character position */
                for (; pc < (strlen(word) + 1); pc++) {
                /* beginning of an UTF-8 character (not '10' start bits) */
                    if ((((unsigned char) word[pc]) >> 6) != 2) pu++;
                    if ((ps < 0) && (replindex == pu)) {
                        ps = replindex;
                        replindex = (signed char) pc;
                    }
                    if ((ps >= 0) && ((pu - ps) == replcut)) {
                        replcut = (signed char) (pc - replindex);
                        break;
                    }
                }
                if (*word == '.') replindex--;
            }
          }

#ifdef VERBOSE
	  printf ("word %s pattern %s, j = %d  repl: %s\n", word, pattern + i, j, repl);
#endif
	  found = hnj_hash_lookup (hashtab, word);
	  state_num = hnj_get_state (dict, hashtab, word);
	  dict->states[state_num].match = hnj_strdup (pattern + i);
	  dict->states[state_num].repl = repl;
	  dict->states[state_num].replindex = replindex;
          if (!replcut) {
            dict->states[state_num].replcut = (signed char) strlen(word);
          } else {
            dict->states[state_num].replcut = replcut;
          }

	  /* now, put in the prefix transitions */
          for (; found < 0 && j > 0; --j)
	    {
	      last_state = state_num;
	      ch = word[j - 1];
	      word[j - 1] = '\0';
	      found = hnj_hash_lookup (hashtab, word);
	      state_num = hnj_get_state (dict, hashtab, word);
	      hnj_add_trans (dict, state_num, last_state, ch);
	    }
}
