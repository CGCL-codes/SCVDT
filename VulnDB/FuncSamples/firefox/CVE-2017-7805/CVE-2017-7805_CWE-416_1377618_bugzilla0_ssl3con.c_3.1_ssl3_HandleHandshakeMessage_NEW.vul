SECStatus
ssl3_HandleHandshakeMessage(sslSocket *ss, PRUint8 *b, PRUint32 length,
                            PRBool endOfRecord)
{
    SECStatus rv = SECSuccess;
    SSL3HandshakeType type = ss->ssl3.hs.msg_type;
    SSL3Hashes hashes;            /* computed hashes are put here. */
    SSL3Hashes *hashesPtr = NULL; /* Set when hashes are computed */
    PRUint8 hdr[4];
    PRUint8 dtlsData[8];
    PRBool computeHashes = PR_FALSE;
    PRUint16 epoch;

    PORT_Assert(ss->opt.noLocks || ssl_HaveRecvBufLock(ss));
    PORT_Assert(ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
    /*
     * We have to compute the hashes before we update them with the
     * current message.
     */
    if (ss->version < SSL_LIBRARY_VERSION_TLS_1_3) {
        if ((type == finished) && (ss->ssl3.hs.ws == wait_finished)) {
            computeHashes = PR_TRUE;
        } else if ((type == certificate_verify) && (ss->ssl3.hs.ws == wait_cert_verify)) {
            if (ss->ssl3.hs.hashType == handshake_hash_record) {
                /* We cannot compute the hash yet. We must wait until we have
                 * decoded the certificate_verify message in
                 * ssl3_HandleCertificateVerify, which will tell us which
                 * hash function we must use.
                 *
                 * (ssl3_HandleCertificateVerify cannot simply look at the
                 * buffer length itself, because at the time we reach it,
                 * additional handshake messages will have been added to the
                 * buffer, e.g. the certificate_verify message itself.)
                 *
                 * Therefore, we use SSL3Hashes.u.transcriptLen to save how much
                 * data there is and read directly from ss->ssl3.hs.messages
                 * when calculating the hashes.
                 *
                 * ssl3_HandleCertificateVerify will detect
                 *     hashType == handshake_hash_record
                 * and use that information to calculate the hash.
                 */
                hashes.u.transcriptLen = ss->ssl3.hs.messages.len;
                hashesPtr = &hashes;
            } else {
                computeHashes = PR_TRUE;
            }
        }
    } else {
        if (type == certificate_verify) {
            computeHashes = TLS13_IN_HS_STATE(ss, wait_cert_verify);
        } else if (type == finished) {
            computeHashes =
                TLS13_IN_HS_STATE(ss, wait_cert_request, wait_finished);
        }
    }

    ssl_GetSpecReadLock(ss); /************************************/
    if (computeHashes) {
        SSL3Sender sender = (SSL3Sender)0;
        ssl3CipherSpec *rSpec = ss->version >= SSL_LIBRARY_VERSION_TLS_1_3 ? ss->ssl3.crSpec
                                                                           : ss->ssl3.prSpec;

        if (type == finished) {
            sender = ss->sec.isServer ? sender_client : sender_server;
            rSpec = ss->ssl3.crSpec;
        }
        rv = ssl3_ComputeHandshakeHashes(ss, rSpec, &hashes, sender);
        if (rv == SECSuccess) {
            hashesPtr = &hashes;
        }
    }
    ssl_ReleaseSpecReadLock(ss); /************************************/
    if (rv != SECSuccess) {
        return rv; /* error code was set by ssl3_ComputeHandshakeHashes*/
    }
    SSL_TRC(30, ("%d: SSL3[%d]: handle handshake message: %s", SSL_GETPID(),
                 ss->fd, ssl3_DecodeHandshakeType(ss->ssl3.hs.msg_type)));

    hdr[0] = (PRUint8)ss->ssl3.hs.msg_type;
    hdr[1] = (PRUint8)(length >> 16);
    hdr[2] = (PRUint8)(length >> 8);
    hdr[3] = (PRUint8)(length);

    /* Start new handshake hashes when we start a new handshake.  Unless this is
     * TLS 1.3 and we sent a HelloRetryRequest. */
    if (ss->ssl3.hs.msg_type == client_hello && !ss->ssl3.hs.helloRetry) {
        ssl3_RestartHandshakeHashes(ss);
    }
    /* We should not include hello_request and hello_verify_request messages
     * in the handshake hashes */
    if ((ss->ssl3.hs.msg_type != hello_request) &&
        (ss->ssl3.hs.msg_type != hello_verify_request)) {
        rv = ssl3_UpdateHandshakeHashes(ss, (unsigned char *)hdr, 4);
        if (rv != SECSuccess)
            return rv; /* err code already set. */

        /* Extra data to simulate a complete DTLS handshake fragment */
        if (IS_DTLS(ss)) {
            /* Sequence number */
            dtlsData[0] = MSB(ss->ssl3.hs.recvMessageSeq);
            dtlsData[1] = LSB(ss->ssl3.hs.recvMessageSeq);

            /* Fragment offset */
            dtlsData[2] = 0;
            dtlsData[3] = 0;
            dtlsData[4] = 0;

            /* Fragment length */
            dtlsData[5] = (PRUint8)(length >> 16);
            dtlsData[6] = (PRUint8)(length >> 8);
            dtlsData[7] = (PRUint8)(length);

            rv = ssl3_UpdateHandshakeHashes(ss, (unsigned char *)dtlsData,
                                            sizeof(dtlsData));
            if (rv != SECSuccess)
                return rv; /* err code already set. */
        }

        /* The message body */
        rv = ssl3_UpdateHandshakeHashes(ss, b, length);
        if (rv != SECSuccess)
            return rv; /* err code already set. */
    }

    PORT_SetError(0); /* each message starts with no error. */

    if (ss->ssl3.hs.ws == wait_certificate_status &&
        ss->ssl3.hs.msg_type != certificate_status) {
        /* If we negotiated the certificate_status extension then we deferred
         * certificate validation until we get the CertificateStatus messsage.
         * But the CertificateStatus message is optional. If the server did
         * not send it then we need to validate the certificate now. If the
         * server does send the CertificateStatus message then we will
         * authenticate the certificate in ssl3_HandleCertificateStatus.
         */
        rv = ssl3_AuthCertificate(ss); /* sets ss->ssl3.hs.ws */
        PORT_Assert(rv != SECWouldBlock);
        if (rv != SECSuccess) {
            return rv;
        }
    }

    epoch = ss->ssl3.crSpec->epoch;
    switch (ss->ssl3.hs.msg_type) {
        case client_hello:
            if (!ss->sec.isServer) {
                (void)SSL3_SendAlert(ss, alert_fatal, unexpected_message);
                PORT_SetError(SSL_ERROR_RX_UNEXPECTED_CLIENT_HELLO);
                return SECFailure;
            }
            rv = ssl3_HandleClientHello(ss, b, length);
            break;
        case server_hello:
            if (ss->sec.isServer) {
                (void)SSL3_SendAlert(ss, alert_fatal, unexpected_message);
                PORT_SetError(SSL_ERROR_RX_UNEXPECTED_SERVER_HELLO);
                return SECFailure;
            }
            rv = ssl3_HandleServerHello(ss, b, length);
            break;
        default:
            if (ss->version < SSL_LIBRARY_VERSION_TLS_1_3) {
                rv = ssl3_HandlePostHelloHandshakeMessage(ss, b, length, hashesPtr);
            } else {
                rv = tls13_HandlePostHelloHandshakeMessage(ss, b, length,
                                                           hashesPtr);
            }
            break;
    }
    if (ss->version >= SSL_LIBRARY_VERSION_TLS_1_3 &&
        (epoch != ss->ssl3.crSpec->epoch) && !endOfRecord) {
        /* If we changed read cipher states, there must not be any
         * data in the input queue. */
        (void)SSL3_SendAlert(ss, alert_fatal, unexpected_message);
        PORT_SetError(SSL_ERROR_RX_UNEXPECTED_HANDSHAKE);
        return SECFailure;
    }

    if (IS_DTLS(ss) && (rv != SECFailure)) {
        /* Increment the expected sequence number */
        ss->ssl3.hs.recvMessageSeq++;
    }
    return rv;
}
