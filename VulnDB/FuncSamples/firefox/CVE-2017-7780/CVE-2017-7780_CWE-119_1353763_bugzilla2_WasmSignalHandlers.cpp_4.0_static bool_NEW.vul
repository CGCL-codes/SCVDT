static bool
HandleFault(PEXCEPTION_POINTERS exception)
{
    EXCEPTION_RECORD* record = exception->ExceptionRecord;
    CONTEXT* context = exception->ContextRecord;

    if (record->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
        return false;

    uint8_t** ppc = ContextToPC(context);
    uint8_t* pc = *ppc;

    if (record->NumberParameters < 2)
        return false;

    // Don't allow recursive handling of signals, see AutoSetHandlingSegFault.
    JSContext* cx = TlsContext.get();
    if (!cx || cx->handlingSegFault)
        return false;
    AutoSetHandlingSegFault handling(cx);

    WasmActivation* activation = cx->wasmActivationStack();
    if (!activation)
        return false;

    Code* code = activation->compartment()->wasm.lookupCode(pc);
    if (!code)
        return false;

    if (!code->segment().containsFunctionPC(pc)) {
        // On Windows, it is possible for InterruptRunningJitCode to execute
        // between a faulting heap access and the handling of the fault due
        // to InterruptRunningJitCode's use of SuspendThread. When this happens,
        // after ResumeThread, the exception handler is called with pc equal to
        // CodeSegment.interrupt, which is logically wrong. The Right Thing would
        // be for the OS to make fault-handling atomic (so that CONTEXT.pc was
        // always the logically-faulting pc). Fortunately, we can detect this
        // case and silence the exception ourselves (the exception will
        // retrigger after the interrupt jumps back to resumePC).
        return pc == code->segment().interruptCode() &&
               activation->interrupted() &&
               code->segment().containsFunctionPC(activation->resumePC());
    }

    const Instance* instance = LookupFaultingInstance(activation, pc, ContextToFP(context));
    if (!instance)
        return false;

    uint8_t* faultingAddress = reinterpret_cast<uint8_t*>(record->ExceptionInformation[1]);

    // This check isn't necessary, but, since we can, check anyway to make
    // sure we aren't covering up a real bug.
    if (!IsHeapAccessAddress(*instance, faultingAddress))
        return false;

    HandleMemoryAccess(context, pc, faultingAddress, *instance, activation, ppc);
    return true;
}
