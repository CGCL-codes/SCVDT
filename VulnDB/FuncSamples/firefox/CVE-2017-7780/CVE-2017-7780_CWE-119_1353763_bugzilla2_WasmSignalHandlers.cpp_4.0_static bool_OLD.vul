template<Signal signal>
static bool
HandleFault(int signum, siginfo_t* info, void* ctx)
{
    // The signals we're expecting come from access violations, accessing
    // mprotected memory. If the signal originates anywhere else, don't try
    // to handle it.
    if (signal == Signal::SegFault)
        MOZ_RELEASE_ASSERT(signum == SIGSEGV);
    else
        MOZ_RELEASE_ASSERT(signum == SIGBUS);

    CONTEXT* context = (CONTEXT*)ctx;
    uint8_t** ppc = ContextToPC(context);
    uint8_t* pc = *ppc;

    // Don't allow recursive handling of signals, see AutoSetHandlingSegFault.
    JSContext* cx = TlsContext.get();
    if (!cx || cx->handlingSegFault)
        return false;
    AutoSetHandlingSegFault handling(cx);

    WasmActivation* activation = cx->wasmActivationStack();
    if (!activation)
        return false;

    const Instance* instance = LookupFaultingInstance(activation, pc, ContextToFP(context));
    if (!instance || !instance->codeSegment().containsFunctionPC(pc))
        return false;

    uint8_t* faultingAddress = reinterpret_cast<uint8_t*>(info->si_addr);

    // Although it's not strictly necessary, to make sure we're not covering up
    // any real bugs, check that the faulting address is indeed in the
    // instance's memory.
    if (!faultingAddress) {
        // On some Linux systems, the kernel apparently sometimes "gives up" and
        // passes a null faultingAddress with si_code set to SI_KERNEL.
        // This is observed on some automation machines for some out-of-bounds
        // atomic accesses on x86/64.
#ifdef SI_KERNEL
        if (info->si_code != SI_KERNEL)
            return false;
#else
        return false;
#endif
    } else {
        if (!IsHeapAccessAddress(*instance, faultingAddress))
            return false;
    }

#ifdef JS_CODEGEN_ARM
    if (signal == Signal::BusError) {
        // TODO: We may see a bus error for something that is an unaligned access that
        // partly overlaps the end of the heap.  In this case, it is an out-of-bounds
        // error and we should signal that properly, but to do so we must inspect
        // the operand of the failed access.
        *ppc = instance->codeSegment().unalignedAccessCode();
        return true;
    }
#endif

    HandleMemoryAccess(context, pc, faultingAddress, *instance, ppc);
    return true;
}
