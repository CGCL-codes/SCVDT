static WasmActivation*
WasmHandleThrow()
{
    JSContext* cx = TlsContext.get();

    WasmActivation* activation = cx->wasmActivationStack();
    MOZ_ASSERT(activation);

    // FrameIterator iterates down wasm frames in the activation starting at
    // WasmActivation::exitFP. Pass Unwind::True to pop WasmActivation::exitFP
    // once each time FrameIterator is incremented, ultimately leaving exitFP
    // null when the FrameIterator is done(). This is necessary to prevent a
    // DebugFrame from being observed again after we just called onLeaveFrame
    // (which would lead to the frame being re-added to the map of live frames,
    // right as it becomes trash).
    FrameIterator iter(activation, FrameIterator::Unwind::True);
    if (iter.done())
        return activation;

    // Live wasm code on the stack is kept alive (in wasm::TraceActivations) by
    // marking the instance of every wasm::Frame found by FrameIterator.
    // However, as explained above, we're popping frames while iterating which
    // means that a GC during this loop could collect the code of frames whose
    // code is still on the stack. This is actually mostly fine: as soon as we
    // return to the throw stub, the entire stack will be popped as a whole,
    // returning to the C++ caller. However, we must keep the throw stub alive
    // itself which is owned by the innermost instance.
    RootedWasmInstanceObject keepAlive(cx, iter.instance()->object());

    for (; !iter.done(); ++iter) {
        if (!iter.debugEnabled())
            continue;

        DebugFrame* frame = iter.debugFrame();
        frame->clearReturnJSValue();

        // Assume JSTRAP_ERROR status if no exception is pending --
        // no onExceptionUnwind handlers must be fired.
        if (cx->isExceptionPending()) {
            JSTrapStatus status = Debugger::onExceptionUnwind(cx, frame);
            if (status == JSTRAP_RETURN) {
                // Unexpected trap return -- raising error since throw recovery
                // is not yet implemented in the wasm baseline.
                // TODO properly handle JSTRAP_RETURN and resume wasm execution.
                JS_ReportErrorASCII(cx, "Unexpected resumption value from onExceptionUnwind");
            }
        }

        bool ok = Debugger::onLeaveFrame(cx, frame, nullptr, false);
        if (ok) {
            // Unexpected success from the handler onLeaveFrame -- raising error
            // since throw recovery is not yet implemented in the wasm baseline.
            // TODO properly handle success and resume wasm execution.
            JS_ReportErrorASCII(cx, "Unexpected success from onLeaveFrame");
        }
        frame->leave(cx);
     }

    return activation;
}
