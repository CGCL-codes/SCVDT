static bool
RedirectJitCodeToInterruptCheck(JSContext* cx, CONTEXT* context)
{
    // Jitcode may only be modified on the runtime's active thread.
    if (cx != cx->runtime()->activeContext())
        return false;

    RedirectIonBackedgesToInterruptCheck(cx);

    if (WasmActivation* activation = cx->wasmActivationStack()) {
#ifdef JS_SIMULATOR
        (void)ContextToPC(context);  // silence static 'unused' errors

        void* pc = cx->simulator()->get_pc_as<void*>();

        const Code* code = activation->compartment()->wasm.lookupCode(pc);
        if (code && code->segment().containsFunctionPC(pc))
            cx->simulator()->trigger_wasm_interrupt();
#else
        uint8_t** ppc = ContextToPC(context);
        uint8_t* pc = *ppc;
        uint8_t* fp = ContextToFP(context);

        // Only interrupt in function code so that the frame iterators have the
        // invariant that resumePC always has a function CodeRange and we can't
        // get into any weird interrupt-during-interrupt-stub cases. Note that
        // the out-of-bounds/unaligned trap paths which call startInterrupt() go
        // through function code, so test if already interrupted. All these
        // paths are temporary though, so this case can be removed later.
        const Code* code = activation->compartment()->wasm.lookupCode(pc);
        if (code && code->segment().containsFunctionPC(pc) && fp && !activation->interrupted()) {
            activation->startInterrupt(pc, fp);
            *ppc = code->segment().interruptCode();
            return true;
        }
#endif
    }

    return false;
}
