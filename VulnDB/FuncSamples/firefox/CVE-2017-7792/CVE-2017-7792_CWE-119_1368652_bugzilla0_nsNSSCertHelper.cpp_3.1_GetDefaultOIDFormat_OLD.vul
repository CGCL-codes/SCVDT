static nsresult
GetDefaultOIDFormat(SECItem* oid, nsAString& outString, char separator)
{
  char buf[300];
  unsigned int len = 0;
  int written, invalidCount = 0;

  unsigned int i;
  unsigned long val = 0;
  bool invalid = false;
  bool first = true;

  val = 0;
  for (i = 0; i < oid->len; ++i) {
    // In this loop, we have to parse a DER formatted
    // If the first bit is a 1, then the integer is
    // represented by more than one byte.  If the
    // first bit is set then we continue on and add
    // the values of the later bytes until we get
    // a byte without the first bit set.
    unsigned long j;

    j = oid->data[i];
    val = (val << 7) | (j & 0x7f);
    if (j & 0x80) {
      // - If val is 0 in this block, the OID number particle starts with 0x80
      // what is specified as an invalid formating.
      // - If val is larger then 2^32-7, on next left shift by 7 we will loose
      // the most significant bits, this OID number particle cannot be read
      // by our implementation.
      // - If the first bit is set while this is the last component of the OID
      // we are also in an invalid state.
      if (val == 0 || (val >= (1 << (32 - 7))) || (i == oid->len - 1)) {
        invalid = true;
      }

      if (i < oid->len - 1)
        continue;
    }

    if (!invalid) {
      if (first) {
        unsigned long one = std::min(val / 40, 2UL); // never > 2
        unsigned long two = val - (one * 40);

        written = snprintf(
          &buf[len], sizeof(buf) - len, "%lu%c%lu", one, separator, two);
      } else {
        written =
          snprintf(&buf[len], sizeof(buf) - len, "%c%lu", separator, val);
      }
    } else {
      nsAutoString unknownText;
      GetPIPNSSBundleString("CertUnknown", unknownText);
      if (first) {
        written = snprintf(&buf[len],
                           sizeof(buf) - len,
                           "%s",
                           NS_ConvertUTF16toUTF8(unknownText).get());
      } else {
        written = snprintf(&buf[len],
                           sizeof(buf) - len,
                           "%c%s",
                           separator,
                           NS_ConvertUTF16toUTF8(unknownText).get());
      }

      if (++invalidCount > 3) {
        // Allow only 3 occurences of Unknown in OID display string to
        // prevent bloat.
        break;
      }
    }

    if (written < 0)
      return NS_ERROR_FAILURE;

    len += written;
    MOZ_ASSERT(len < sizeof(buf), "OID data too big to display in 300 chars.");
    val = 0;
    invalid = false;
    first = false;
  }

  CopyASCIItoUTF16(buf, outString);
  return NS_OK;
}
