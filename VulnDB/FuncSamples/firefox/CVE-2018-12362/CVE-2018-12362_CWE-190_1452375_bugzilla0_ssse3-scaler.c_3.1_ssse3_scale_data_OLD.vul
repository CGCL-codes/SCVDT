void ssse3_scale_data(uint32_t *src, int src_width, int src_height, int src_stride,
                      uint32_t *dest, int dest_width, int dest_height,
                      int dest_stride,
                      int x, int y,
                      int width, int height)
{
    //XXX: assert(src_width > 1)
    pixman_transform_t transform = {
        { { pixman_fixed_1, 0, 0 },
            { 0, pixman_fixed_1, 0 },
            { 0, 0, pixman_fixed_1 } }
    };
    double width_scale = ((double)src_width)/dest_width;
    double height_scale = ((double)src_height)/dest_height;
#define AVOID_PADDING
#ifdef AVOID_PADDING
    // scale up by enough that we don't read outside of the bounds of the source surface
    // currently this is required to avoid reading out of bounds.
    if (width_scale < 1) {
        width_scale = (double)(src_width-1)/dest_width;
        transform.matrix[0][2] = pixman_fixed_1/2;
    }
    if (height_scale < 1) {
        height_scale = (double)(src_height-1)/dest_height;
        transform.matrix[1][2] = pixman_fixed_1/2;
    }
#endif
    transform.matrix[0][0] = pixman_double_to_fixed(width_scale);
    transform.matrix[1][1] = pixman_double_to_fixed(height_scale);
    transform.matrix[2][2] = pixman_fixed_1;

    bits_image_t image;
    image.bits = src;
    image.transform = &transform;
    image.rowstride = src_stride;

    pixman_iter_t iter;
    iter.image = &image;
    iter.x = x;
    iter.y = y;
    iter.width = width;
    iter.height = src_height;
    iter.buffer = dest;
    iter.data = NULL;

    ssse3_bilinear_cover_iter_init(&iter);
    if (iter.data) {
        for (int iy = 0; iy < height; iy++) {
            ssse3_fetch_bilinear_cover(&iter, NULL);
            iter.buffer += dest_stride;
        }
        ssse3_bilinear_cover_iter_fini(&iter);
    }
}
