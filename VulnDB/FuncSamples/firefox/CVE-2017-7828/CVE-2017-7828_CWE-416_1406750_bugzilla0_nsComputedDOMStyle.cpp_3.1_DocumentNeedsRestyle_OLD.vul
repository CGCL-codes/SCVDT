static bool
DocumentNeedsRestyle(const nsIDocument* aDocument, Element* aElement)
{
  nsIPresShell* shell = aDocument->GetShell();
  if (!shell) {
    return true;
  }
  // Unfortunately we don't know if the sheet change affects mContent or not, so
  // just assume it will and that we need to flush normally.
  StyleSetHandle styleSet = shell->StyleSet();
  if (styleSet->StyleSheetsHaveChanged()) {
    return true;
  }
  // If any ancestor has pending animation, flush it.
  nsPresContext* context = shell->GetPresContext();
  if (context->EffectCompositor()->HasPendingStyleUpdatesFor(aElement)) {
    return true;
  }
  if (styleSet->IsServo()) {
    // For Servo, we need to process the restyle-hint-invalidations first, to
    // expand LaterSiblings hint, so that we can look whether ancestors need
    // restyling.
    ServoRestyleManager* restyleManager = context->RestyleManager()->AsServo();
    restyleManager->ProcessAllPendingAttributeAndStateInvalidations();

    // Then if there is a restyle root, we check if the root is an ancestor of
    // this content. If it is not, then we don't need to restyle immediately.
    // Note this is different from Gecko: we only check if any ancestor needs
    // to restyle _itself_, not descendants, since dirty descendants can be
    // another subtree.
    if (aDocument->GetServoRestyleRoot() &&
        restyleManager->HasPendingRestyleAncestor(aElement)) {
      return true;
    }
  } else {
    // For Gecko, first check if there is any pending restyle, then we check if
    // any ancestor has dirty bits for restyle.
    GeckoRestyleManager* restyleManager = context->RestyleManager()->AsGecko();
    if (restyleManager->HasPendingRestyles() && ContentNeedsRestyle(aElement)) {
      return true;
    }
  }
  return false;
}
