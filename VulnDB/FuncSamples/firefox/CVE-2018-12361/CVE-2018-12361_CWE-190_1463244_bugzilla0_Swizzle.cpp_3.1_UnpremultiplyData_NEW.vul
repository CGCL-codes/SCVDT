bool
UnpremultiplyData(const uint8_t* aSrc, int32_t aSrcStride, SurfaceFormat aSrcFormat,
                  uint8_t* aDst, int32_t aDstStride, SurfaceFormat aDstFormat,
                  const IntSize& aSize)
{
  if (aSize.IsEmpty()) {
    return true;
  }
  IntSize size = CollapseSize(aSize, aSrcStride, aDstStride);
  // Find gap from end of row to the start of the next row.
  int32_t srcGap = GetStrideGap(aSize.width, aSrcFormat, aSrcStride);
  int32_t dstGap = GetStrideGap(aSize.width, aDstFormat, aDstStride);
  MOZ_ASSERT(srcGap >= 0 && dstGap >= 0);
  if (srcGap < 0 || dstGap < 0) {
    return false;
  }

#define FORMAT_CASE_CALL(...) __VA_ARGS__(aSrc, srcGap, aDst, dstGap, size)

#ifdef USE_SSE2
  switch (FORMAT_KEY(aSrcFormat, aDstFormat)) {
  UNPREMULTIPLY_SSE2(SurfaceFormat::B8G8R8A8, SurfaceFormat::B8G8R8A8)
  UNPREMULTIPLY_SSE2(SurfaceFormat::B8G8R8A8, SurfaceFormat::R8G8B8A8)
  UNPREMULTIPLY_SSE2(SurfaceFormat::R8G8B8A8, SurfaceFormat::R8G8B8A8)
  UNPREMULTIPLY_SSE2(SurfaceFormat::R8G8B8A8, SurfaceFormat::B8G8R8A8)
  default: break;
  }
#endif

#ifdef BUILD_ARM_NEON
  if (mozilla::supports_neon()) switch (FORMAT_KEY(aSrcFormat, aDstFormat)) {
  UNPREMULTIPLY_NEON(SurfaceFormat::B8G8R8A8, SurfaceFormat::B8G8R8A8)
  UNPREMULTIPLY_NEON(SurfaceFormat::B8G8R8A8, SurfaceFormat::R8G8B8A8)
  UNPREMULTIPLY_NEON(SurfaceFormat::R8G8B8A8, SurfaceFormat::R8G8B8A8)
  UNPREMULTIPLY_NEON(SurfaceFormat::R8G8B8A8, SurfaceFormat::B8G8R8A8)
  default: break;
  }
#endif

  switch (FORMAT_KEY(aSrcFormat, aDstFormat)) {
  UNPREMULTIPLY_FALLBACK(SurfaceFormat::B8G8R8A8)
  UNPREMULTIPLY_FALLBACK(SurfaceFormat::R8G8B8A8)
  UNPREMULTIPLY_FALLBACK(SurfaceFormat::A8R8G8B8)
  default: break;
  }

#undef FORMAT_CASE_CALL

  MOZ_ASSERT(false, "Unsupported unpremultiply formats");
  return false;
}
