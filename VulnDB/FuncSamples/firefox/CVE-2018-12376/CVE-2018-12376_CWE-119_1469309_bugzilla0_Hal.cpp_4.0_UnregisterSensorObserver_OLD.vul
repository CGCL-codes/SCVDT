void
UnregisterSensorObserver(SensorType aSensor, ISensorObserver *aObserver) {
  AssertMainThread();

  if (!gSensorObservers) {
    return;
  }

  SensorObserverList &observers = GetSensorObservers(aSensor);
  if (!observers.RemoveObserver(aObserver) || observers.Length() > 0) {
    return;
  }
  DisableSensorNotifications(aSensor);

  for (int i = 0; i < NUM_SENSOR_TYPE; i++) {
    if (gSensorObservers[i].Length() > 0) {
      return;
    }
  }

  // We want to destroy gSensorObservers if all observer lists are
  // empty, but we have to defer the deallocation via a runnable to
  // mainthread (since we may be inside NotifySensorChange()/Broadcast()
  // when it calls UnregisterSensorObserver()).
  SensorObserverList* sensorlists = gSensorObservers;
  gSensorObservers = nullptr;

  // Unlike DispatchToMainThread, DispatchToCurrentThread doesn't leak a runnable if
  // it fails (and we assert we're on MainThread).
  if (NS_FAILED(NS_DispatchToCurrentThread(NS_NewRunnableFunction("UnregisterSensorObserver",
                                                                  [sensorlists]() -> void {
      delete [] sensorlists;
      }))))
  {
    // Still need to delete sensorlists if the dispatch fails
    delete [] sensorlists;
  }
}
