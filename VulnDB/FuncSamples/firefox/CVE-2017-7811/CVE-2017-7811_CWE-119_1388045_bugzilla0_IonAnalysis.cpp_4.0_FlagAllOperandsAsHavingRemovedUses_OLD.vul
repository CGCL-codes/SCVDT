static bool
FlagAllOperandsAsHavingRemovedUses(MIRGenerator* mir, MBasicBlock* block)
{
    const CompileInfo& info = block->info();

    // Flag all instructions operands as having removed uses.
    MInstructionIterator end = block->end();
    for (MInstructionIterator it = block->begin(); it != end; it++) {
        if (mir->shouldCancel("FlagAllOperandsAsHavingRemovedUses loop 1"))
            return false;

        MInstruction* ins = *it;
        for (size_t i = 0, e = ins->numOperands(); i < e; i++)
            ins->getOperand(i)->setUseRemovedUnchecked();

        // Flag observable resume point operands as having removed uses.
        if (MResumePoint* rp = ins->resumePoint()) {
            // Note: no need to iterate over the caller's of the resume point as
            // this is the same as the entry resume point.
            for (size_t i = 0, e = rp->numOperands(); i < e; i++) {
                if (info.isObservableSlot(i))
                    rp->getOperand(i)->setUseRemovedUnchecked();
            }
        }
    }

    // Flag observable operands of the entry resume point as having removed uses.
    MResumePoint* rp = block->entryResumePoint();
    while (rp) {
        if (mir->shouldCancel("FlagAllOperandsAsHavingRemovedUses loop 2"))
            return false;

        for (size_t i = 0, e = rp->numOperands(); i < e; i++) {
            if (info.isObservableSlot(i))
                rp->getOperand(i)->setUseRemovedUnchecked();
        }

        rp = rp->caller();
    }

    // Flag Phi inputs of the successors has having removed uses.
    MPhiVector worklist;
    for (size_t i = 0, e = block->numSuccessors(); i < e; i++) {
        if (mir->shouldCancel("FlagAllOperandsAsHavingRemovedUses loop 3"))
            return false;

        if (!FlagPhiInputsAsHavingRemovedUses(mir, block, block->getSuccessor(i), worklist))
            return false;
    }

    return true;
}
