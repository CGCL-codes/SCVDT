template <typename ConcreteScope, XDRMode mode>
/* static */ XDRResult
Scope::XDRSizedBindingNames(XDRState<mode>* xdr, Handle<ConcreteScope*> scope,
                            MutableHandle<typename ConcreteScope::Data*> data)
{
    MOZ_ASSERT(!data);

    JSContext* cx = xdr->cx();

    uint32_t length;
    if (mode == XDR_ENCODE) {
        length = scope->data().length;
    }
    MOZ_TRY(xdr->codeUint32(&length));

    if (mode == XDR_ENCODE) {
        data.set(&scope->data());
    } else {
        data.set(NewEmptyScopeData<ConcreteScope>(cx, length).release());
        if (!data) {
            return xdr->fail(JS::TranscodeResult_Throw);
        }
    }

    auto dataGuard = mozilla::MakeScopeExit([&] () {
        if (mode == XDR_DECODE) {
            DeleteScopeData(data.get());
            data.set(nullptr);
        }
    });

    for (uint32_t i = 0; i < length; i++) {
        if (mode == XDR_DECODE) {
            MOZ_ASSERT(i == data->length, "must be decoding at the end");
        }
        MOZ_TRY(XDRTrailingName(xdr, &data->trailingNames[i], &data->length));
    }
    MOZ_ASSERT(data->length == length);

    dataGuard.release();
    return Ok();
}
