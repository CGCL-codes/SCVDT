SECStatus
PrioClient_encode(const_PrioConfig cfg, const bool* data_in,
                  unsigned char** for_server_a, unsigned int* aLen,
                  unsigned char** for_server_b, unsigned int* bLen)
{
  SECStatus rv = SECSuccess;
  PrioPacketClient pA = NULL;
  PrioPacketClient pB = NULL;
  *for_server_a = NULL;
  *for_server_b = NULL;

  P_CHECKA(pA = PrioPacketClient_new(cfg, PRIO_SERVER_A));
  P_CHECKA(pB = PrioPacketClient_new(cfg, PRIO_SERVER_B));

  msgpack_sbuffer sbufA, sbufB;
  msgpack_packer packerA, packerB;

  msgpack_sbuffer_init(&sbufA);
  msgpack_sbuffer_init(&sbufB);
  msgpack_packer_init(&packerA, &sbufA, msgpack_sbuffer_write);
  msgpack_packer_init(&packerB, &sbufB, msgpack_sbuffer_write);

  P_CHECKC(PrioPacketClient_set_data(cfg, data_in, pA, pB));
  P_CHECKC(serial_write_packet_client(&packerA, pA, cfg));
  P_CHECKC(serial_write_packet_client(&packerB, pB, cfg));

  P_CHECKC(PublicKey_encryptSize(sbufA.size, aLen));
  P_CHECKC(PublicKey_encryptSize(sbufB.size, bLen));

  P_CHECKA(*for_server_a = malloc(*aLen));
  P_CHECKA(*for_server_b = malloc(*bLen));

  unsigned int writtenA;
  unsigned int writtenB;
  P_CHECKC(PublicKey_encrypt(cfg->server_a_pub, *for_server_a, &writtenA, *aLen,
                             (unsigned char*)sbufA.data, sbufA.size));
  P_CHECKC(PublicKey_encrypt(cfg->server_b_pub, *for_server_b, &writtenB, *bLen,
                             (unsigned char*)sbufB.data, sbufB.size));

  P_CHECKCB(writtenA == *aLen);
  P_CHECKCB(writtenB == *bLen);

cleanup:
  if (rv != SECSuccess) {
    if (*for_server_a)
      free(*for_server_a);
    if (*for_server_b)
      free(*for_server_b);
    *for_server_a = NULL;
    *for_server_b = NULL;
  }

  PrioPacketClient_clear(pA);
  PrioPacketClient_clear(pB);
  msgpack_sbuffer_destroy(&sbufA);
  msgpack_sbuffer_destroy(&sbufB);

  return rv;
}
