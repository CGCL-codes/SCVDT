template<typename M>
bool
BuildClonedMessageData(M* aManager, StructuredCloneData& aData,
                       ClonedMessageData& aClonedData)
{
  SerializedStructuredCloneBuffer& buffer = aClonedData.data();
  auto iter = aData.Data().Start();
  size_t size = aData.Data().Size();
  bool success;
  buffer.data = aData.Data().Borrow<js::SystemAllocPolicy>(iter, size, &success);
  if (NS_WARN_IF(!success)) {
    return false;
  }
  if (aData.SupportsTransferring()) {
    aClonedData.identfiers().AppendElements(aData.PortIdentifiers());
  }

  const nsTArray<RefPtr<BlobImpl>>& blobImpls = aData.BlobImpls();

  if (!blobImpls.IsEmpty()) {
    if (NS_WARN_IF(!aClonedData.blobs().SetLength(blobImpls.Length(), fallible))) {
      return false;
    }

    for (uint32_t i = 0; i < blobImpls.Length(); ++i) {
      nsresult rv = IPCBlobUtils::Serialize(blobImpls[i], aManager,
                                            aClonedData.blobs()[i]);
      if (NS_WARN_IF(NS_FAILED(rv))) {
        return false;
      }
    }
  }

  const nsTArray<nsCOMPtr<nsIInputStream>>& inputStreams = aData.InputStreams();
  if (!inputStreams.IsEmpty()) {
    if (NS_WARN_IF(!aData.IPCStreams().SetCapacity(inputStreams.Length(),
                                                   fallible))) {
      return false;
    }

    InfallibleTArray<IPCStream>& streams = aClonedData.inputStreams();
    uint32_t length = inputStreams.Length();
    streams.SetCapacity(length);
    for (uint32_t i = 0; i < length; ++i) {
      AutoIPCStream* stream = aData.IPCStreams().AppendElement(fallible);
      if (NS_WARN_IF(!stream)) {
        return false;
      }

      if (!stream->Serialize(inputStreams[i], aManager)) {
        return false;
      }
      streams.AppendElement(stream->TakeValue());
    }
  }

  return true;
}
