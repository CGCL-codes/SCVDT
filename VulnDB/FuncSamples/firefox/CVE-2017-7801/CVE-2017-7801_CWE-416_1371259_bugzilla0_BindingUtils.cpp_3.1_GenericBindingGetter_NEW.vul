bool
GenericBindingGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(args.calleev());
  prototypes::ID protoID = static_cast<prototypes::ID>(info->protoID);
  if (!args.thisv().isObject()) {
    return ThrowInvalidThis(cx, args, false, protoID);
  }
  JS::Rooted<JSObject*> obj(cx, &args.thisv().toObject());

  // NOTE: we want to leave obj in its initial compartment, so don't want to
  // pass it to UnwrapObject.
  JS::Rooted<JSObject*> rootSelf(cx, obj);
  void* self;
  {
    binding_detail::MutableObjectHandleWrapper wrapper(&rootSelf);
    nsresult rv = binding_detail::UnwrapObjectInternal<void, true>(wrapper,
                                                                   self,
                                                                   protoID,
                                                                   info->depth);
    if (NS_FAILED(rv)) {
      return ThrowInvalidThis(cx, args,
                              rv == NS_ERROR_XPC_SECURITY_MANAGER_VETO,
                              protoID);
    }
  }

  MOZ_ASSERT(info->type() == JSJitInfo::Getter);
  JSJitGetterOp getter = info->getter;
  bool ok = getter(cx, obj, self, JSJitGetterCallArgs(args));
#ifdef DEBUG
  if (ok) {
    AssertReturnTypeMatchesJitinfo(info, args.rval());
  }
#endif
  return ok;
}
