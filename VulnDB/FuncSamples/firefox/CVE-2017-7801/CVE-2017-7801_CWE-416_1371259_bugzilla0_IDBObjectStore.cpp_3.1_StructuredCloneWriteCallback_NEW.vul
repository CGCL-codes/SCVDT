bool
StructuredCloneWriteCallback(JSContext* aCx,
                             JSStructuredCloneWriter* aWriter,
                             JS::Handle<JSObject*> aObj,
                             void* aClosure)
{
  MOZ_ASSERT(aCx);
  MOZ_ASSERT(aWriter);
  MOZ_ASSERT(aClosure);

  auto* cloneWriteInfo =
    static_cast<IDBObjectStore::StructuredCloneWriteInfo*>(aClosure);

  if (JS_GetClass(aObj) == IDBObjectStore::DummyPropClass()) {
    MOZ_ASSERT(!cloneWriteInfo->mOffsetToKeyProp);
    cloneWriteInfo->mOffsetToKeyProp = js::GetSCOffset(aWriter);

    uint64_t value = 0;
    // Omit endian swap
    return JS_WriteBytes(aWriter, &value, sizeof(value));
  }

  // UNWRAP_OBJECT calls might mutate this.
  JS::Rooted<JSObject*> obj(aCx, aObj);

  IDBMutableFile* mutableFile;
  if (NS_SUCCEEDED(UNWRAP_OBJECT(IDBMutableFile, &obj, mutableFile))) {
    if (cloneWriteInfo->mDatabase->IsFileHandleDisabled()) {
      return false;
    }

    IDBDatabase* database = mutableFile->Database();
    MOZ_ASSERT(database);

    // Throw when trying to store IDBMutableFile objects that live in a
    // different database.
    if (database != cloneWriteInfo->mDatabase) {
      MOZ_ASSERT(!SameCOMIdentity(database, cloneWriteInfo->mDatabase));

      if (database->Name() != cloneWriteInfo->mDatabase->Name()) {
        return false;
      }

      nsCString fileOrigin, databaseOrigin;
      PersistenceType filePersistenceType, databasePersistenceType;

      if (NS_WARN_IF(NS_FAILED(database->GetQuotaInfo(fileOrigin,
                                                      &filePersistenceType)))) {
        return false;
      }

      if (NS_WARN_IF(NS_FAILED(cloneWriteInfo->mDatabase->GetQuotaInfo(
                                                  databaseOrigin,
                                                  &databasePersistenceType)))) {
        return false;
      }

      if (filePersistenceType != databasePersistenceType ||
          fileOrigin != databaseOrigin) {
        return false;
      }
    }

    if (cloneWriteInfo->mFiles.Length() > size_t(UINT32_MAX)) {
      MOZ_ASSERT(false, "Fix the structured clone data to use a bigger type!");
      return false;
    }

    const uint32_t index = cloneWriteInfo->mFiles.Length();

    NS_ConvertUTF16toUTF8 convType(mutableFile->Type());
    uint32_t convTypeLength =
      NativeEndian::swapToLittleEndian(convType.Length());

    NS_ConvertUTF16toUTF8 convName(mutableFile->Name());
    uint32_t convNameLength =
      NativeEndian::swapToLittleEndian(convName.Length());

    if (!JS_WriteUint32Pair(aWriter, SCTAG_DOM_MUTABLEFILE, uint32_t(index)) ||
        !JS_WriteBytes(aWriter, &convTypeLength, sizeof(uint32_t)) ||
        !JS_WriteBytes(aWriter, convType.get(), convType.Length()) ||
        !JS_WriteBytes(aWriter, &convNameLength, sizeof(uint32_t)) ||
        !JS_WriteBytes(aWriter, convName.get(), convName.Length())) {
      return false;
    }

    StructuredCloneFile* newFile = cloneWriteInfo->mFiles.AppendElement();
    newFile->mMutableFile = mutableFile;
    newFile->mType = StructuredCloneFile::eMutableFile;

    return true;
  }

  {
    Blob* blob = nullptr;
    if (NS_SUCCEEDED(UNWRAP_OBJECT(Blob, &obj, blob))) {
      ErrorResult rv;
      uint64_t size = blob->GetSize(rv);
      MOZ_ASSERT(!rv.Failed());

      size = NativeEndian::swapToLittleEndian(size);

      nsString type;
      blob->GetType(type);

      NS_ConvertUTF16toUTF8 convType(type);
      uint32_t convTypeLength =
        NativeEndian::swapToLittleEndian(convType.Length());

      if (cloneWriteInfo->mFiles.Length() > size_t(UINT32_MAX)) {
        MOZ_ASSERT(false,
                   "Fix the structured clone data to use a bigger type!");
        return false;
      }

      const uint32_t index = cloneWriteInfo->mFiles.Length();

      if (!JS_WriteUint32Pair(aWriter,
                              blob->IsFile() ? SCTAG_DOM_FILE : SCTAG_DOM_BLOB,
                              index) ||
          !JS_WriteBytes(aWriter, &size, sizeof(size)) ||
          !JS_WriteBytes(aWriter, &convTypeLength, sizeof(convTypeLength)) ||
          !JS_WriteBytes(aWriter, convType.get(), convType.Length())) {
        return false;
      }

      RefPtr<File> file = blob->ToFile();
      if (file) {
        ErrorResult rv;
        int64_t lastModifiedDate = file->GetLastModified(rv);
        MOZ_ALWAYS_TRUE(!rv.Failed());

        lastModifiedDate = NativeEndian::swapToLittleEndian(lastModifiedDate);

        nsString name;
        file->GetName(name);

        NS_ConvertUTF16toUTF8 convName(name);
        uint32_t convNameLength =
          NativeEndian::swapToLittleEndian(convName.Length());

        if (!JS_WriteBytes(aWriter, &lastModifiedDate, sizeof(lastModifiedDate)) ||
            !JS_WriteBytes(aWriter, &convNameLength, sizeof(convNameLength)) ||
            !JS_WriteBytes(aWriter, convName.get(), convName.Length())) {
          return false;
        }
      }

      StructuredCloneFile* newFile = cloneWriteInfo->mFiles.AppendElement();
      newFile->mBlob = blob;
      newFile->mType = StructuredCloneFile::eBlob;

      return true;
    }
  }

  if (JS::IsWasmModuleObject(aObj)) {
    RefPtr<JS::WasmModule> module = JS::GetWasmModule(aObj);
    MOZ_ASSERT(module);

    size_t bytecodeSize;
    size_t compiledSize;
    module->serializedSize(&bytecodeSize, &compiledSize);

    UniquePtr<uint8_t[]> bytecode(new uint8_t[bytecodeSize]);
    MOZ_ASSERT(bytecode);

    UniquePtr<uint8_t[]> compiled(new uint8_t[compiledSize]);
    MOZ_ASSERT(compiled);

    module->serialize(bytecode.get(),
                      bytecodeSize,
                      compiled.get(),
                      compiledSize);

    RefPtr<BlobImpl> blobImpl =
      new MemoryBlobImpl(bytecode.release(), bytecodeSize, EmptyString());
    RefPtr<Blob> bytecodeBlob = Blob::Create(nullptr, blobImpl);

    blobImpl =
      new MemoryBlobImpl(compiled.release(), compiledSize, EmptyString());
    RefPtr<Blob> compiledBlob = Blob::Create(nullptr, blobImpl);

    if (cloneWriteInfo->mFiles.Length() + 1 > size_t(UINT32_MAX)) {
      MOZ_ASSERT(false, "Fix the structured clone data to use a bigger type!");
      return false;
    }

    const uint32_t index = cloneWriteInfo->mFiles.Length();

    // The ordering of the bytecode and compiled file is significant and must
    // never be changed. These two files must always form a pair
    // [eWasmBytecode, eWasmCompiled]. Everything else depends on it!
    if (!JS_WriteUint32Pair(aWriter, SCTAG_DOM_WASM, /* flags */ 0) ||
        !JS_WriteUint32Pair(aWriter, index, index + 1)) {
      return false;
    }

    StructuredCloneFile* newFile = cloneWriteInfo->mFiles.AppendElement();
    newFile->mBlob = bytecodeBlob;
    newFile->mType = StructuredCloneFile::eWasmBytecode;

    newFile = cloneWriteInfo->mFiles.AppendElement();
    newFile->mBlob = compiledBlob;
    newFile->mType = StructuredCloneFile::eWasmCompiled;

    return true;
  }

  return StructuredCloneHolder::WriteFullySerializableObjects(aCx, aWriter, aObj);
}
