SYSCALL_DEFINE0(rt_sigreturn)
{
	struct pt_regs *regs = current_pt_regs();
	struct ucontext __user *uc = (struct ucontext __user *)regs->gpr[1];
	sigset_t set;
#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
	unsigned long msr;
#endif

	/* Always make any pending restarted system calls return -EINTR */
	current->restart_block.fn = do_no_restart_syscall;

	if (!access_ok(uc, sizeof(*uc)))
		goto badframe;

	if (__copy_from_user(&set, &uc->uc_sigmask, sizeof(set)))
		goto badframe;
	set_current_blocked(&set);

#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
	/*
	 * If there is a transactional state then throw it away.
	 * The purpose of a sigreturn is to destroy all traces of the
	 * signal frame, this includes any transactional state created
	 * within in. We only check for suspended as we can never be
	 * active in the kernel, we are active, there is nothing better to
	 * do than go ahead and Bad Thing later.
	 * The cause is not important as there will never be a
	 * recheckpoint so it's not user visible.
	 */
	if (MSR_TM_SUSPENDED(mfmsr()))
		tm_reclaim_current(0);

	/*
	 * Disable MSR[TS] bit also, so, if there is an exception in the
	 * code below (as a page fault in copy_ckvsx_to_user()), it does
	 * not recheckpoint this task if there was a context switch inside
	 * the exception.
	 *
	 * A major page fault can indirectly call schedule(). A reschedule
	 * process in the middle of an exception can have a side effect
	 * (Changing the CPU MSR[TS] state), since schedule() is called
	 * with the CPU MSR[TS] disable and returns with MSR[TS]=Suspended
	 * (switch_to() calls tm_recheckpoint() for the 'new' process). In
	 * this case, the process continues to be the same in the CPU, but
	 * the CPU state just changed.
	 *
	 * This can cause a TM Bad Thing, since the MSR in the stack will
	 * have the MSR[TS]=0, and this is what will be used to RFID.
	 *
	 * Clearing MSR[TS] state here will avoid a recheckpoint if there
	 * is any process reschedule in kernel space. The MSR[TS] state
	 * does not need to be saved also, since it will be replaced with
	 * the MSR[TS] that came from user context later, at
	 * restore_tm_sigcontexts.
	 */
	regs->msr &= ~MSR_TS_MASK;

	if (__get_user(msr, &uc->uc_mcontext.gp_regs[PT_MSR]))
		goto badframe;
	if (MSR_TM_ACTIVE(msr)) {
		/* We recheckpoint on return. */
		struct ucontext __user *uc_transact;
		if (__get_user(uc_transact, &uc->uc_link))
			goto badframe;
		if (restore_tm_sigcontexts(current, &uc->uc_mcontext,
					   &uc_transact->uc_mcontext))
			goto badframe;
	} else
#endif
	{
		/*
		 * Fall through, for non-TM restore
		 *
		 * Unset MSR[TS] on the thread regs since MSR from user
		 * context does not have MSR active, and recheckpoint was
		 * not called since restore_tm_sigcontexts() was not called
		 * also.
		 *
		 * If not unsetting it, the code can RFID to userspace with
		 * MSR[TS] set, but without CPU in the proper state,
		 * causing a TM bad thing.
		 */
		current->thread.regs->msr &= ~MSR_TS_MASK;
		if (restore_sigcontext(current, NULL, 1, &uc->uc_mcontext))
			goto badframe;
	}

	if (restore_altstack(&uc->uc_stack))
		goto badframe;

	set_thread_flag(TIF_RESTOREALL);
	return 0;

badframe:
	if (show_unhandled_signals)
		printk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,
				   current->comm, current->pid, "rt_sigreturn",
				   (long)uc, regs->nip, regs->link);

	force_sig(SIGSEGV);
	return 0;
}
