static int mos7840_ioctl(struct tty_struct *tty, struct file *file,
			 unsigned int cmd, unsigned long arg)
{
	struct usb_serial_port *port = tty->driver_data;
	void __user *argp = (void __user *)arg;
	struct moschip_port *mos7840_port;

	struct async_icount cnow;
	struct async_icount cprev;
	struct serial_icounter_struct icount;

	if (mos7840_port_paranoia_check(port, __func__)) {
		dbg("%s", "Invalid port");
		return -1;
	}

	mos7840_port = mos7840_get_port_private(port);

	if (mos7840_port == NULL)
		return -1;

	dbg("%s - port %d, cmd = 0x%x", __func__, port->number, cmd);

	switch (cmd) {
		/* return number of bytes available */

	case TIOCSERGETLSR:
		dbg("%s (%d) TIOCSERGETLSR", __func__, port->number);
		return mos7840_get_lsr_info(tty, argp);
		return 0;

	case TIOCGSERIAL:
		dbg("%s (%d) TIOCGSERIAL", __func__, port->number);
		return mos7840_get_serial_info(mos7840_port, argp);

	case TIOCSSERIAL:
		dbg("%s (%d) TIOCSSERIAL", __func__, port->number);
		break;

	case TIOCMIWAIT:
		dbg("%s (%d) TIOCMIWAIT", __func__, port->number);
		cprev = mos7840_port->icount;
		while (1) {
			/* interruptible_sleep_on(&mos7840_port->delta_msr_wait); */
			mos7840_port->delta_msr_cond = 0;
			wait_event_interruptible(mos7840_port->delta_msr_wait,
						 (mos7840_port->
						  delta_msr_cond == 1));

			/* see if a signal did it */
			if (signal_pending(current))
				return -ERESTARTSYS;
			cnow = mos7840_port->icount;
			smp_rmb();
			if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&
			    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts)
				return -EIO;	/* no change => error */
			if (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
			    ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
			    ((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd)) ||
			    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {
				return 0;
			}
			cprev = cnow;
		}
		/* NOTREACHED */
		break;

	case TIOCGICOUNT:
		cnow = mos7840_port->icount;
		smp_rmb();

		memset(&icount, 0, sizeof(struct serial_icounter_struct));

		icount.cts = cnow.cts;
		icount.dsr = cnow.dsr;
		icount.rng = cnow.rng;
		icount.dcd = cnow.dcd;
		icount.rx = cnow.rx;
		icount.tx = cnow.tx;
		icount.frame = cnow.frame;
		icount.overrun = cnow.overrun;
		icount.parity = cnow.parity;
		icount.brk = cnow.brk;
		icount.buf_overrun = cnow.buf_overrun;

		dbg("%s (%d) TIOCGICOUNT RX=%d, TX=%d", __func__,
		    port->number, icount.rx, icount.tx);
		if (copy_to_user(argp, &icount, sizeof(icount)))
			return -EFAULT;
		return 0;
	default:
		break;
	}
	return -ENOIOCTLCMD;
}
