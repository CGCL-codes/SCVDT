int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
	       void __user *newval, size_t newlen)
{
	struct list_head *tmp;
	int error = -ENOTDIR;

	if (nlen <= 0 || nlen >= CTL_MAXNAME)
		return -ENOTDIR;
	if (oldval) {
		int old_len;
		if (!oldlenp || get_user(old_len, oldlenp))
			return -EFAULT;
	}
	spin_lock(&sysctl_lock);
	tmp = &root_table_header.ctl_entry;
	do {
		struct ctl_table_header *head =
			list_entry(tmp, struct ctl_table_header, ctl_entry);
		void *context = NULL;

		if (!use_table(head))
			continue;

		spin_unlock(&sysctl_lock);

		error = parse_table(name, nlen, oldval, oldlenp, 
					newval, newlen, head->ctl_table,
					&context);
		kfree(context);

		spin_lock(&sysctl_lock);
		unuse_table(head);
		if (error != -ENOTDIR)
			break;
	} while ((tmp = tmp->next) != &root_table_header.ctl_entry);
	spin_unlock(&sysctl_lock);
	return error;
}
