static int snd_hdsp_hwdep_ioctl(struct snd_hwdep *hw, struct file *file, unsigned int cmd, unsigned long arg)
{
	struct hdsp *hdsp = (struct hdsp *)hw->private_data;
	void __user *argp = (void __user *)arg;
	int err;

	switch (cmd) {
	case SNDRV_HDSP_IOCTL_GET_PEAK_RMS: {
		struct hdsp_peak_rms __user *peak_rms = (struct hdsp_peak_rms __user *)arg;

		err = hdsp_check_for_iobox(hdsp);
		if (err < 0)
			return err;

		err = hdsp_check_for_firmware(hdsp, 1);
		if (err < 0)
			return err;

		if (!(hdsp->state & HDSP_FirmwareLoaded)) {
			snd_printk(KERN_ERR "Hammerfall-DSP: firmware needs to be uploaded to the card.\n");
			return -EINVAL;
		}

		switch (hdsp->io_type) {
		case H9652:
			return hdsp_9652_get_peak(hdsp, peak_rms);
		case H9632:
			return hdsp_9632_get_peak(hdsp, peak_rms);
		default:
			return hdsp_get_peak(hdsp, peak_rms);
		}
	}
	case SNDRV_HDSP_IOCTL_GET_CONFIG_INFO: {
		struct hdsp_config_info info;
		unsigned long flags;
		int i;

		err = hdsp_check_for_iobox(hdsp);
		if (err < 0)
			return err;

		err = hdsp_check_for_firmware(hdsp, 1);
		if (err < 0)
			return err;

		spin_lock_irqsave(&hdsp->lock, flags);
		info.pref_sync_ref = (unsigned char)hdsp_pref_sync_ref(hdsp);
		info.wordclock_sync_check = (unsigned char)hdsp_wc_sync_check(hdsp);
		if (hdsp->io_type != H9632)
		    info.adatsync_sync_check = (unsigned char)hdsp_adatsync_sync_check(hdsp);
		info.spdif_sync_check = (unsigned char)hdsp_spdif_sync_check(hdsp);
		for (i = 0; i < ((hdsp->io_type != Multiface && hdsp->io_type != H9632) ? 3 : 1); ++i)
			info.adat_sync_check[i] = (unsigned char)hdsp_adat_sync_check(hdsp, i);
		info.spdif_in = (unsigned char)hdsp_spdif_in(hdsp);
		info.spdif_out = (unsigned char)hdsp_spdif_out(hdsp);
		info.spdif_professional = (unsigned char)hdsp_spdif_professional(hdsp);
		info.spdif_emphasis = (unsigned char)hdsp_spdif_emphasis(hdsp);
		info.spdif_nonaudio = (unsigned char)hdsp_spdif_nonaudio(hdsp);
		info.spdif_sample_rate = hdsp_spdif_sample_rate(hdsp);
		info.system_sample_rate = hdsp->system_sample_rate;
		info.autosync_sample_rate = hdsp_external_sample_rate(hdsp);
		info.system_clock_mode = (unsigned char)hdsp_system_clock_mode(hdsp);
		info.clock_source = (unsigned char)hdsp_clock_source(hdsp);
		info.autosync_ref = (unsigned char)hdsp_autosync_ref(hdsp);
		info.line_out = (unsigned char)hdsp_line_out(hdsp);
		if (hdsp->io_type == H9632) {
			info.da_gain = (unsigned char)hdsp_da_gain(hdsp);
			info.ad_gain = (unsigned char)hdsp_ad_gain(hdsp);
			info.phone_gain = (unsigned char)hdsp_phone_gain(hdsp);
			info.xlr_breakout_cable = (unsigned char)hdsp_xlr_breakout_cable(hdsp);

		}
		if (hdsp->io_type == H9632 || hdsp->io_type == H9652)
			info.analog_extension_board = (unsigned char)hdsp_aeb(hdsp);
		spin_unlock_irqrestore(&hdsp->lock, flags);
		if (copy_to_user(argp, &info, sizeof(info)))
			return -EFAULT;
		break;
	}
	case SNDRV_HDSP_IOCTL_GET_9632_AEB: {
		struct hdsp_9632_aeb h9632_aeb;

		if (hdsp->io_type != H9632) return -EINVAL;
		h9632_aeb.aebi = hdsp->ss_in_channels - H9632_SS_CHANNELS;
		h9632_aeb.aebo = hdsp->ss_out_channels - H9632_SS_CHANNELS;
		if (copy_to_user(argp, &h9632_aeb, sizeof(h9632_aeb)))
			return -EFAULT;
		break;
	}
	case SNDRV_HDSP_IOCTL_GET_VERSION: {
		struct hdsp_version hdsp_version;
		int err;

		if (hdsp->io_type == H9652 || hdsp->io_type == H9632) return -EINVAL;
		if (hdsp->io_type == Undefined) {
			if ((err = hdsp_get_iobox_version(hdsp)) < 0)
				return err;
		}
		hdsp_version.io_type = hdsp->io_type;
		hdsp_version.firmware_rev = hdsp->firmware_rev;
		if ((err = copy_to_user(argp, &hdsp_version, sizeof(hdsp_version))))
		    	return -EFAULT;
		break;
	}
	case SNDRV_HDSP_IOCTL_UPLOAD_FIRMWARE: {
		struct hdsp_firmware __user *firmware;
		u32 __user *firmware_data;
		int err;

		if (hdsp->io_type == H9652 || hdsp->io_type == H9632) return -EINVAL;
		/* SNDRV_HDSP_IOCTL_GET_VERSION must have been called */
		if (hdsp->io_type == Undefined) return -EINVAL;

		if (hdsp->state & (HDSP_FirmwareCached | HDSP_FirmwareLoaded))
			return -EBUSY;

		snd_printk(KERN_INFO "Hammerfall-DSP: initializing firmware upload\n");
		firmware = (struct hdsp_firmware __user *)argp;

		if (get_user(firmware_data, &firmware->firmware_data))
			return -EFAULT;

		if (hdsp_check_for_iobox (hdsp))
			return -EIO;

		if (copy_from_user(hdsp->firmware_cache, firmware_data, sizeof(hdsp->firmware_cache)) != 0)
			return -EFAULT;

		hdsp->state |= HDSP_FirmwareCached;

		if ((err = snd_hdsp_load_firmware_from_cache(hdsp)) < 0)
			return err;

		if (!(hdsp->state & HDSP_InitializationComplete)) {
			if ((err = snd_hdsp_enable_io(hdsp)) < 0)
				return err;

			snd_hdsp_initialize_channels(hdsp);
			snd_hdsp_initialize_midi_flush(hdsp);

			if ((err = snd_hdsp_create_alsa_devices(hdsp->card, hdsp)) < 0) {
				snd_printk(KERN_ERR "Hammerfall-DSP: error creating alsa devices\n");
				return err;
			}
		}
		break;
	}
	case SNDRV_HDSP_IOCTL_GET_MIXER: {
		struct hdsp_mixer __user *mixer = (struct hdsp_mixer __user *)argp;
		if (copy_to_user(mixer->matrix, hdsp->mixer_matrix, sizeof(unsigned short)*HDSP_MATRIX_MIXER_SIZE))
			return -EFAULT;
		break;
	}
	default:
		return -EINVAL;
	}
	return 0;
}
