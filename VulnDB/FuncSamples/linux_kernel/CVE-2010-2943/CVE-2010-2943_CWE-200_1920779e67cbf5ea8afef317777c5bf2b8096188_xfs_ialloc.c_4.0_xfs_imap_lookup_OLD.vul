STATIC int
xfs_imap_lookup(
	struct xfs_mount	*mp,
	struct xfs_trans	*tp,
	xfs_agnumber_t		agno,
	xfs_agino_t		agino,
	xfs_agblock_t		agbno,
	xfs_agblock_t		*chunk_agbno,
	xfs_agblock_t		*offset_agbno,
	int			flags)
{
	struct xfs_inobt_rec_incore rec;
	struct xfs_btree_cur	*cur;
	struct xfs_buf		*agbp;
	xfs_agino_t		startino;
	int			error;
	int			i;

	error = xfs_ialloc_read_agi(mp, tp, agno, &agbp);
	if (error) {
		xfs_fs_cmn_err(CE_ALERT, mp, "xfs_imap: "
				"xfs_ialloc_read_agi() returned "
				"error %d, agno %d",
				error, agno);
		return error;
	}

	/*
	 * derive and lookup the exact inode record for the given agino. If the
	 * record cannot be found, then it's an invalid inode number and we
	 * should abort.
	 */
	cur = xfs_inobt_init_cursor(mp, tp, agbp, agno);
	startino = agino & ~(XFS_IALLOC_INODES(mp) - 1);
	error = xfs_inobt_lookup(cur, startino, XFS_LOOKUP_EQ, &i);
	if (!error) {
		if (i)
			error = xfs_inobt_get_rec(cur, &rec, &i);
		if (!error && i == 0)
			error = EINVAL;
	}

	xfs_trans_brelse(tp, agbp);
	xfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);
	if (error)
		return error;

	/* for untrusted inodes check it is allocated first */
	if ((flags & XFS_IGET_BULKSTAT) &&
	    (rec.ir_free & XFS_INOBT_MASK(agino - rec.ir_startino)))
		return EINVAL;

	*chunk_agbno = XFS_AGINO_TO_AGBNO(mp, rec.ir_startino);
	*offset_agbno = agbno - *chunk_agbno;
	return 0;
}
