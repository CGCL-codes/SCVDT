static int bcm_open(struct hci_uart *hu)
{
	struct bcm_data *bcm;
	struct list_head *p;
	int err;

	bt_dev_dbg(hu->hdev, "hu %p", hu);

	if (!hci_uart_has_flow_control(hu))
		return -EOPNOTSUPP;

	bcm = kzalloc(sizeof(*bcm), GFP_KERNEL);
	if (!bcm)
		return -ENOMEM;

	skb_queue_head_init(&bcm->txq);

	hu->priv = bcm;

	mutex_lock(&bcm_device_lock);

	if (hu->serdev) {
		bcm->dev = serdev_device_get_drvdata(hu->serdev);
		goto out;
	}

	if (!hu->tty->dev)
		goto out;

	list_for_each(p, &bcm_device_list) {
		struct bcm_device *dev = list_entry(p, struct bcm_device, list);

		/* Retrieve saved bcm_device based on parent of the
		 * platform device (saved during device probe) and
		 * parent of tty device used by hci_uart
		 */
		if (hu->tty->dev->parent == dev->dev->parent) {
			bcm->dev = dev;
#ifdef CONFIG_PM
			dev->hu = hu;
#endif
			break;
		}
	}

out:
	if (bcm->dev) {
		hu->init_speed = bcm->dev->init_speed;
		hu->oper_speed = bcm->dev->oper_speed;
		err = bcm_gpio_set_power(bcm->dev, true);
		if (err)
			goto err_unset_hu;
	}

	mutex_unlock(&bcm_device_lock);
	return 0;

err_unset_hu:
#ifdef CONFIG_PM
	if (!hu->serdev)
		bcm->dev->hu = NULL;
#endif
	mutex_unlock(&bcm_device_lock);
	hu->priv = NULL;
	kfree(bcm);
	return err;
}
