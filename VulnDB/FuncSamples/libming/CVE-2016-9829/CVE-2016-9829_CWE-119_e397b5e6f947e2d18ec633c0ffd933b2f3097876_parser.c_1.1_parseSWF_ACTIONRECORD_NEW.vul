int
parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
{
	int thisaction = *thisactionp;
	SWF_ACTION *action = &(actions[thisaction]);

	//fprintf(stderr,"ACTION[%d] Offset %d\n", thisaction, fileOffset );

	action->SWF_ACTIONRECORD.Offset = fileOffset; /* remember where it came from */
	if( (action->SWF_ACTIONRECORD.ActionCode = readUInt8(f)) == SWFACTION_END )
		return 0;
	/*
	 * Actions without the high bit set take no additional
	 * arguments, so we are done for these types.
	 */
	if( !(action->SWF_ACTIONRECORD.ActionCode&0x80) ) {
		action->SWF_ACTIONRECORD.Length = 1; /* Fill in the size for later use */
		return 1;
	}

	action->SWF_ACTIONRECORD.Length = 0; /* make valgrind happy */
	/*
	 * Actions with the high bit set take additional
	 * arguments, so we have to parse each one uniquely.
	 */
	switch( action->SWF_ACTIONRECORD.ActionCode ) {
		/* v3 actions */
	case SWFACTION_GOTOFRAME:
		{
		ACT_BEGIN(SWF_ACTIONGOTOFRAME)
		act->Frame = readUInt16(f);
		break;
		}
	case SWFACTION_GETURL:
		{
		ACT_BEGIN(SWF_ACTIONGETURL)
		act->UrlString = readString(f);
		act->TargetString = readString(f);
		break;
		}
	case SWFACTION_WAITFORFRAME:
		{
		ACT_BEGIN(SWF_ACTIONWAITFORFRAME)
		act->Frame = readUInt16(f);
		act->SkipCount = readUInt8(f);
		break;
		}
	case SWFACTION_SETTARGET:
		{
		ACT_BEGIN(SWF_ACTIONSETTARGET)
		act->TargetName = readString(f);
		break;
		}
	case SWFACTION_GOTOLABEL:
		{
		ACT_BEGIN(SWF_ACTIONGOTOLABEL)
		act->FrameLabel = readString(f);
		break;
		}


		/* v4 actions */
	case SWFACTION_PUSH:
		{
		int end;
		struct SWF_ACTIONPUSHPARAM *param;
		ACT_BEGIN(SWF_ACTIONPUSH)

		end = fileOffset + act->Length;
  		act->Params = (struct SWF_ACTIONPUSHPARAM *) calloc (1, sizeof (struct SWF_ACTIONPUSHPARAM));
  		act->NumParam = 0;
  		while ( fileOffset < end ) {
			param = &(act->Params[act->NumParam++]);
			param->Type = readUInt8(f);
			switch( param->Type ) {
			case 0: /* STRING */
				param->p.String = readString(f);
				break;
			case 1: /* FLOAT */
				param->p.Float = readFloat(f);
				break;
			case 2: /* NULL */
			case 3: /* Undefined */
				break;
			case 4: /* Register */
				param->p.RegisterNumber = readUInt8(f);
				break;
			case 5: /* BOOLEAN */
				param->p.Boolean = readUInt8(f);
				break;
			case 6: /* DOUBLE */
				param->p.Double = readDouble(f);
				break;
			case 7: /* INTEGER */
				param->p.Integer = readSInt32(f);
				break;
			case 8: /* CONSTANT8 */
				param->p.Constant8 = readUInt8(f);
				break;
			case 9: /* CONSTANT16 */
				param->p.Constant16 = readUInt16(f);
				break;
			default:
				printf("Unknown data type to push %x\n", param->Type );
				exit(1);
			}
      			act->Params = (struct SWF_ACTIONPUSHPARAM *) realloc (act->Params,
							 (act->NumParam + 1) *
							 sizeof (struct SWF_ACTIONPUSHPARAM));
    		}
		break;
		}
	case SWFACTION_LOGICALNOT:
		{
		ACT_BEGIN_NOLEN(SWF_ACTIONNOT)
		act->Boolean = readUInt32(f);
		fprintf(stderr,"NOT param: %d\n", act->Boolean );
		break;
		}
	case SWFACTION_CALLFRAME:
		{
		ACT_BEGIN(SWF_ACTIONCALL)
		// readUInt16(f);		/* seems to be an exception: NO reading here */
		break;
		}
	case SWFACTION_JUMP:
		{
		ACT_BEGIN(SWF_ACTIONJUMP)
		act->BranchOffset = readUInt16(f);
		break;
		}
	case SWFACTION_IF:
		{
		int i,j,k, curroffset;
		ACT_BEGIN(SWF_ACTIONIF)

		act->BranchOffset = readUInt16(f);
		/*
		 * Set curroffset to point to the next action so that an
		 * offset of zero matches it.
		 */
		curroffset=(action->SWF_ACTIONRECORD.Offset-actions[0].SWF_ACTIONRECORD.Offset)+
			    action->SWF_ACTIONRECORD.Length+3; /* Action + Length bytes not included in the length */
		if( act->BranchOffset < 0 ) {
			/*
			 * We are branching to records that we already have in the array. Just
			 * allocate new space for the if clause, and copy the records there, and then
			 * fix the count of records in actions[], and put this record at the new
			 * end of actions[].
			 */
		    for(i=0;i<=thisaction;i++) {
			if( (actions[i].SWF_ACTIONRECORD.Offset-actions[0].SWF_ACTIONRECORD.Offset) == curroffset+act->BranchOffset ) break;
		    }
		    if( i>=thisaction ) {
                            SWF_warn("Failed to find branch target!!!\n");
                            SWF_warn("Looking for: %d\n\n", curroffset + act->BranchOffset);
                            act->BranchOffset=0;	/* despite the problem ..*/
                            i=thisaction;		/* ..continue with empty block */
		    }
		    act->numActions = thisaction-i;
		    act->Actions = (union SWF_ACTION *) calloc (act->numActions, sizeof (SWF_ACTION));
		    for(j=i,k=0;j<thisaction;j++,k++)
			    act->Actions[k] = actions[j];
		    actions[i]=*((SWF_ACTION *)act);	/* added by ak,2006 */
		    *thisactionp = i;
		} else {
			/*
			 * We are branching to records not yet parsed. Just handle this in the
			 * same manner used for with, try, etc.
			 */
		    act->Actions = (union SWF_ACTION *) calloc (1, sizeof (SWF_ACTION));
		    act->numActions = 0;
		    while ( (fileOffset-actions[0].SWF_ACTIONRECORD.Offset) < curroffset+act->BranchOffset ) {
			parseSWF_ACTIONRECORD (f, &(act->numActions), (SWF_ACTION *)act->Actions);
			act->Actions = (union SWF_ACTION *) realloc (act->Actions,
							 (++act->numActions + 1) *
							 sizeof (SWF_ACTION));
		    }
		}
		break;
		}
	case SWFACTION_GETURL2:
		{
		ACT_BEGIN(SWF_ACTIONGETURL2)
		// act->f.Flags = readUInt8(f);
		act->f.FlagBits.LoadTargetFlag = readBits(f,1);
		act->f.FlagBits.LoadVariableFlag = readBits(f,1);
		act->f.FlagBits.Reserved = readBits(f,4);
		act->f.FlagBits.SendVarsMethod = readBits(f,2);
		break;
		}
	case SWFACTION_GOTOFRAME2:
		{
		ACT_BEGIN(SWF_ACTIONGOTOFRAME2)
		act->f.FlagBits.Reserved = readBits(f,6);
		act->f.FlagBits.SceneBiasFlag = readBits(f,1);
		act->f.FlagBits.PlayFlag = readBits(f,1);
		if( act->f.FlagBits.SceneBiasFlag ) {
			act->SceneBias = readUInt16(f);
		}
		break;
		}
	case SWFACTION_WAITFORFRAME2:
		{
		ACT_BEGIN(SWF_ACTIONWAITFORFRAME2)
		act->SkipCount = readUInt8(f);
		break;
		}


		/* v5 actions */
	case SWFACTION_CONSTANTPOOL:
		{
		int i, count;
		ACT_BEGIN(SWF_ACTIONCONSTANTPOOL)

		count = readUInt16(f);
		if (count == EOF)
                {
                  SWF_error("unexpected end of file");
                }
		act->Count = count;
		act->ConstantPool = malloc(act->Count*sizeof(char *));
		for(i=0;i<act->Count;i++) {
			act->ConstantPool[i] = readString(f);
		}
		break;
		}
	case SWFACTION_DEFINEFUNCTION:
		{
		int i, end2, num_params;
		ACT_BEGIN(SWF_ACTIONDEFINEFUNCTION)

		act->FunctionName = readString(f);
                num_params = readUInt16(f);
                if (num_params == EOF) {
                  SWF_error("unexpected end of file");
                }
		act->NumParams = num_params;

		act->Params = (STRING *)malloc(act->NumParams*sizeof(char *));
		for(i=0;i<act->NumParams;i++) {
			act->Params[i] = readString(f);
			/* printf("Read %s\n", act->ConstantPool[i] ); */
		}
		act->CodeSize = readSInt16(f);
		end2 = fileOffset + act->CodeSize;
		act->Actions = (union SWF_ACTION *) calloc (1, sizeof (SWF_ACTION));
		act->numActions = 0;
		while ( fileOffset < end2 ) {
			parseSWF_ACTIONRECORD (f, &(act->numActions), (SWF_ACTION *)act->Actions);
			act->Actions = (union SWF_ACTION *) realloc (act->Actions,
							 (++act->numActions + 1) *
							 sizeof (SWF_ACTION));
		    }
		break;
		}
	case SWFACTION_WITH:
		{
		int end;
		ACT_BEGIN(SWF_ACTIONWITH)

		act->Size = readUInt16(f);
		end = fileOffset + act->Size;
		act->Actions = (union SWF_ACTION *) calloc (1, sizeof (SWF_ACTION));
		act->numActions = 0;
		while ( fileOffset < end ) {
			parseSWF_ACTIONRECORD (f, &(act->numActions), (SWF_ACTION *)act->Actions);
			act->Actions = (union SWF_ACTION *) realloc (act->Actions,
							 (++act->numActions + 1) *
							 sizeof (SWF_ACTION));
		    }
		break;
		}
	case SWFACTION_STOREREGISTER:
		{
		ACT_BEGIN(SWF_ACTIONSTOREREGISTER)

		act->Register = readUInt8(f);
		break;
		}


		/* v6 actions */

		/* v7 actions */
	case SWFACTION_DEFINEFUNCTION2:
		{
		int i, end2, num_params;
		ACT_BEGIN(SWF_ACTIONDEFINEFUNCTION2)

		act->FunctionName = readString(f);
		num_params = readUInt16(f);
		if (num_params == EOF) {
		  SWF_error("unexpected end of file");
		}
		act->NumParams = num_params;
		act->RegisterCount = readSInt8(f);
		act->PreloadParentFlag = readBits(f,1);
		act->PreloadRootFlag = readBits(f,1);
		act->SuppressSuperFlag = readBits(f,1);
		act->PreloadSuperFlag = readBits(f,1);
		act->SuppressArgumentsFlag = readBits(f,1);
		act->PreloadArgumentsFlag = readBits(f,1);
		act->SuppressThisFlag = readBits(f,1);
		act->PreloadThisFlag = readBits(f,1);
		act->Reserved = readBits(f,7);
		act->PreloadGlobalFlag = readBits(f,1);
		act->Params = (struct REGISTERPARAM *)malloc(act->NumParams*sizeof(struct REGISTERPARAM));
		for(i=0;i<act->NumParams;i++) {
			act->Params[i].Register = readUInt8(f);
			act->Params[i].ParamName = readString(f);
		}
		act->CodeSize = readSInt16(f);
		end2 = fileOffset + act->CodeSize;
		act->Actions = (union SWF_ACTION *) calloc (1, sizeof (SWF_ACTION));
		act->numActions = 0;
		while ( fileOffset < end2 ) {
			parseSWF_ACTIONRECORD (f, &(act->numActions), (SWF_ACTION *)act->Actions);
			act->Actions = (union SWF_ACTION *) realloc (act->Actions,
							 (++act->numActions + 1) *
							 sizeof (SWF_ACTION));
		    }
		break;
		}
	case SWFACTION_TRY:
		{
		int end2;
		ACT_BEGIN(SWF_ACTIONTRY)

		act->Reserved = readBits(f,5);
		act->CatchInRegisterFlag = readBits(f,1);
		act->FinallyBlockFlag = readBits(f,1);
		act->CatchBlockFlag = readBits(f,1);
		act->TrySize = readSInt16(f);
		act->CatchSize = readSInt16(f);
		act->FinallySize = readSInt16(f);
		if( act->CatchInRegisterFlag == 0 ) {
			act->CatchName = readString(f);
		} else {
			act->CatchRegister = readUInt8(f);
		}

		/* Try Body */
		end2 = fileOffset + act->TrySize;
		act->TryActs = (union SWF_ACTION *) calloc (1, sizeof (SWF_ACTION));
		act->numTryActs = 0;
		while ( fileOffset < end2 ) {
			parseSWF_ACTIONRECORD (f, &(act->numTryActs), (SWF_ACTION *)act->TryActs);
			act->TryActs = (union SWF_ACTION *) realloc (act->TryActs,
							 (++act->numTryActs + 1) *
							 sizeof (SWF_ACTION));
		    }

		/* Catch Body */
		end2 = fileOffset + act->CatchSize;
		act->CatchActs = (union SWF_ACTION *) calloc (1, sizeof (SWF_ACTION));
		act->numCatchActs = 0;
		while ( fileOffset < end2 ) {
			parseSWF_ACTIONRECORD (f, &(act->numCatchActs), (SWF_ACTION *)act->CatchActs);
			act->CatchActs = (union SWF_ACTION *) realloc (act->CatchActs,
							 (++act->numCatchActs + 1) *
							 sizeof (SWF_ACTION));
		    }

		/* Finally Body */
		end2 = fileOffset + act->FinallySize;
		act->FinallyActs = (union SWF_ACTION *) calloc (1, sizeof (SWF_ACTION));
		act->numFinallyActs = 0;
		while ( fileOffset < end2 ) {
			parseSWF_ACTIONRECORD (f, &(act->numFinallyActs), (SWF_ACTION *)act->FinallyActs);
			act->FinallyActs = (union SWF_ACTION *) realloc (act->FinallyActs,
							 (++act->numFinallyActs + 1) *
							 sizeof (SWF_ACTION));
		    }
		break;
		}
	default:
		printf("Not parsing action %x length %x\n", action->SWF_ACTIONRECORD.ActionCode, action->SWF_ACTIONRECORD.Length );
		peekBytes(f,100);
		exit(1);
	}
	return 1;
}
