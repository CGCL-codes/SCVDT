static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
                        AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    UtvideoContext *c = avctx->priv_data;
    int i, j;
    const uint8_t *plane_start[5];
    int plane_size, max_slice_size = 0, slice_start, slice_end, slice_size;
    int ret;
    GetByteContext gb;
    ThreadFrame frame = { .f = data };

    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)
        return ret;

    /* parse plane structure to get frame flags and validate slice offsets */
    bytestream2_init(&gb, buf, buf_size);

    if (c->pack) {
        const uint8_t *packed_stream;
        const uint8_t *control_stream;
        GetByteContext pb;
        uint32_t nb_cbs;
        int left;

        c->frame_info = PRED_GRADIENT << 8;

        if (bytestream2_get_byte(&gb) != 1)
            return AVERROR_INVALIDDATA;
        bytestream2_skip(&gb, 3);
        c->offset = bytestream2_get_le32(&gb);

        if (buf_size <= c->offset + 8LL)
            return AVERROR_INVALIDDATA;

        bytestream2_init(&pb, buf + 8 + c->offset, buf_size - 8 - c->offset);

        nb_cbs = bytestream2_get_le32(&pb);
        if (nb_cbs > c->offset)
            return AVERROR_INVALIDDATA;

        packed_stream = buf + 8;
        control_stream = packed_stream + (c->offset - nb_cbs);
        left = control_stream - packed_stream;

        for (i = 0; i < c->planes; i++) {
            for (j = 0; j < c->slices; j++) {
                c->packed_stream[i][j] = packed_stream;
                c->packed_stream_size[i][j] = bytestream2_get_le32(&pb);
                if (c->packed_stream_size[i][j] > left)
                    return AVERROR_INVALIDDATA;
                left -= c->packed_stream_size[i][j];
                packed_stream += c->packed_stream_size[i][j];
            }
        }

        left = buf + buf_size - control_stream;

        for (i = 0; i < c->planes; i++) {
            for (j = 0; j < c->slices; j++) {
                c->control_stream[i][j] = control_stream;
                c->control_stream_size[i][j] = bytestream2_get_le32(&pb);
                if (c->control_stream_size[i][j] > left)
                    return AVERROR_INVALIDDATA;
                left -= c->control_stream_size[i][j];
                control_stream += c->control_stream_size[i][j];
            }
        }
    } else if (c->pro) {
        if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {
            av_log(avctx, AV_LOG_ERROR, "Not enough data for frame information\n");
            return AVERROR_INVALIDDATA;
        }
        c->frame_info = bytestream2_get_le32u(&gb);
        c->slices = ((c->frame_info >> 16) & 0xff) + 1;
        for (i = 0; i < c->planes; i++) {
            plane_start[i] = gb.buffer;
            if (bytestream2_get_bytes_left(&gb) < 1024 + 4 * c->slices) {
                av_log(avctx, AV_LOG_ERROR, "Insufficient data for a plane\n");
                return AVERROR_INVALIDDATA;
            }
            slice_start = 0;
            slice_end   = 0;
            for (j = 0; j < c->slices; j++) {
                slice_end   = bytestream2_get_le32u(&gb);
                if (slice_end < 0 || slice_end < slice_start ||
                    bytestream2_get_bytes_left(&gb) < slice_end + 1024LL) {
                    av_log(avctx, AV_LOG_ERROR, "Incorrect slice size\n");
                    return AVERROR_INVALIDDATA;
                }
                slice_size  = slice_end - slice_start;
                slice_start = slice_end;
                max_slice_size = FFMAX(max_slice_size, slice_size);
            }
            plane_size = slice_end;
            bytestream2_skipu(&gb, plane_size);
            bytestream2_skipu(&gb, 1024);
        }
        plane_start[c->planes] = gb.buffer;
    } else {
        for (i = 0; i < c->planes; i++) {
            plane_start[i] = gb.buffer;
            if (bytestream2_get_bytes_left(&gb) < 256 + 4 * c->slices) {
                av_log(avctx, AV_LOG_ERROR, "Insufficient data for a plane\n");
                return AVERROR_INVALIDDATA;
            }
            bytestream2_skipu(&gb, 256);
            slice_start = 0;
            slice_end   = 0;
            for (j = 0; j < c->slices; j++) {
                slice_end   = bytestream2_get_le32u(&gb);
                if (slice_end < 0 || slice_end < slice_start ||
                    bytestream2_get_bytes_left(&gb) < slice_end) {
                    av_log(avctx, AV_LOG_ERROR, "Incorrect slice size\n");
                    return AVERROR_INVALIDDATA;
                }
                slice_size  = slice_end - slice_start;
                slice_start = slice_end;
                max_slice_size = FFMAX(max_slice_size, slice_size);
            }
            plane_size = slice_end;
            bytestream2_skipu(&gb, plane_size);
        }
        plane_start[c->planes] = gb.buffer;
        if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {
            av_log(avctx, AV_LOG_ERROR, "Not enough data for frame information\n");
            return AVERROR_INVALIDDATA;
        }
        c->frame_info = bytestream2_get_le32u(&gb);
    }
    av_log(avctx, AV_LOG_DEBUG, "frame information flags %"PRIX32"\n",
           c->frame_info);

    c->frame_pred = (c->frame_info >> 8) & 3;

    max_slice_size += 4*avctx->width;

    if (!c->pack) {
        av_fast_malloc(&c->slice_bits, &c->slice_bits_size,
                       max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);

        if (!c->slice_bits) {
            av_log(avctx, AV_LOG_ERROR, "Cannot allocate temporary buffer\n");
            return AVERROR(ENOMEM);
        }
    }

    switch (c->avctx->pix_fmt) {
    case AV_PIX_FMT_GBRP:
    case AV_PIX_FMT_GBRAP:
        for (i = 0; i < c->planes; i++) {
            ret = decode_plane(c, i, frame.f->data[i],
                               frame.f->linesize[i], avctx->width,
                               avctx->height, plane_start[i],
                               c->frame_pred == PRED_LEFT);
            if (ret)
                return ret;
            if (c->frame_pred == PRED_MEDIAN) {
                if (!c->interlaced) {
                    restore_median_planar(c, frame.f->data[i],
                                          frame.f->linesize[i], avctx->width,
                                          avctx->height, c->slices, 0);
                } else {
                    restore_median_planar_il(c, frame.f->data[i],
                                             frame.f->linesize[i],
                                             avctx->width, avctx->height, c->slices,
                                             0);
                }
            } else if (c->frame_pred == PRED_GRADIENT) {
                if (!c->interlaced) {
                    restore_gradient_planar(c, frame.f->data[i],
                                            frame.f->linesize[i], avctx->width,
                                            avctx->height, c->slices, 0);
                } else {
                    restore_gradient_planar_il(c, frame.f->data[i],
                                               frame.f->linesize[i],
                                               avctx->width, avctx->height, c->slices,
                                               0);
                }
            }
        }
        c->utdsp.restore_rgb_planes(frame.f->data[2], frame.f->data[0], frame.f->data[1],
                                    frame.f->linesize[2], frame.f->linesize[0], frame.f->linesize[1],
                                    avctx->width, avctx->height);
        break;
    case AV_PIX_FMT_GBRAP10:
    case AV_PIX_FMT_GBRP10:
        for (i = 0; i < c->planes; i++) {
            ret = decode_plane10(c, i, (uint16_t *)frame.f->data[i],
                                 frame.f->linesize[i] / 2, avctx->width,
                                 avctx->height, plane_start[i],
                                 plane_start[i + 1] - 1024,
                                 c->frame_pred == PRED_LEFT);
            if (ret)
                return ret;
        }
        c->utdsp.restore_rgb_planes10((uint16_t *)frame.f->data[2], (uint16_t *)frame.f->data[0], (uint16_t *)frame.f->data[1],
                                      frame.f->linesize[2] / 2, frame.f->linesize[0] / 2, frame.f->linesize[1] / 2,
                                      avctx->width, avctx->height);
        break;
    case AV_PIX_FMT_YUV420P:
        for (i = 0; i < 3; i++) {
            ret = decode_plane(c, i, frame.f->data[i], frame.f->linesize[i],
                               avctx->width >> !!i, avctx->height >> !!i,
                               plane_start[i], c->frame_pred == PRED_LEFT);
            if (ret)
                return ret;
            if (c->frame_pred == PRED_MEDIAN) {
                if (!c->interlaced) {
                    restore_median_planar(c, frame.f->data[i], frame.f->linesize[i],
                                          avctx->width >> !!i, avctx->height >> !!i,
                                          c->slices, !i);
                } else {
                    restore_median_planar_il(c, frame.f->data[i], frame.f->linesize[i],
                                             avctx->width  >> !!i,
                                             avctx->height >> !!i,
                                             c->slices, !i);
                }
            } else if (c->frame_pred == PRED_GRADIENT) {
                if (!c->interlaced) {
                    restore_gradient_planar(c, frame.f->data[i], frame.f->linesize[i],
                                            avctx->width >> !!i, avctx->height >> !!i,
                                            c->slices, !i);
                } else {
                    restore_gradient_planar_il(c, frame.f->data[i], frame.f->linesize[i],
                                               avctx->width  >> !!i,
                                               avctx->height >> !!i,
                                               c->slices, !i);
                }
            }
        }
        break;
    case AV_PIX_FMT_YUV422P:
        for (i = 0; i < 3; i++) {
            ret = decode_plane(c, i, frame.f->data[i], frame.f->linesize[i],
                               avctx->width >> !!i, avctx->height,
                               plane_start[i], c->frame_pred == PRED_LEFT);
            if (ret)
                return ret;
            if (c->frame_pred == PRED_MEDIAN) {
                if (!c->interlaced) {
                    restore_median_planar(c, frame.f->data[i], frame.f->linesize[i],
                                          avctx->width >> !!i, avctx->height,
                                          c->slices, 0);
                } else {
                    restore_median_planar_il(c, frame.f->data[i], frame.f->linesize[i],
                                             avctx->width >> !!i, avctx->height,
                                             c->slices, 0);
                }
            } else if (c->frame_pred == PRED_GRADIENT) {
                if (!c->interlaced) {
                    restore_gradient_planar(c, frame.f->data[i], frame.f->linesize[i],
                                            avctx->width >> !!i, avctx->height,
                                            c->slices, 0);
                } else {
                    restore_gradient_planar_il(c, frame.f->data[i], frame.f->linesize[i],
                                               avctx->width  >> !!i, avctx->height,
                                               c->slices, 0);
                }
            }
        }
        break;
    case AV_PIX_FMT_YUV444P:
        for (i = 0; i < 3; i++) {
            ret = decode_plane(c, i, frame.f->data[i], frame.f->linesize[i],
                               avctx->width, avctx->height,
                               plane_start[i], c->frame_pred == PRED_LEFT);
            if (ret)
                return ret;
            if (c->frame_pred == PRED_MEDIAN) {
                if (!c->interlaced) {
                    restore_median_planar(c, frame.f->data[i], frame.f->linesize[i],
                                          avctx->width, avctx->height,
                                          c->slices, 0);
                } else {
                    restore_median_planar_il(c, frame.f->data[i], frame.f->linesize[i],
                                             avctx->width, avctx->height,
                                             c->slices, 0);
                }
            } else if (c->frame_pred == PRED_GRADIENT) {
                if (!c->interlaced) {
                    restore_gradient_planar(c, frame.f->data[i], frame.f->linesize[i],
                                            avctx->width, avctx->height,
                                            c->slices, 0);
                } else {
                    restore_gradient_planar_il(c, frame.f->data[i], frame.f->linesize[i],
                                               avctx->width, avctx->height,
                                               c->slices, 0);
                }
            }
        }
        break;
    case AV_PIX_FMT_YUV422P10:
        for (i = 0; i < 3; i++) {
            ret = decode_plane10(c, i, (uint16_t *)frame.f->data[i], frame.f->linesize[i] / 2,
                                 avctx->width >> !!i, avctx->height,
                                 plane_start[i], plane_start[i + 1] - 1024, c->frame_pred == PRED_LEFT);
            if (ret)
                return ret;
        }
        break;
    }

    frame.f->key_frame = 1;
    frame.f->pict_type = AV_PICTURE_TYPE_I;
    frame.f->interlaced_frame = !!c->interlaced;

    *got_frame = 1;

    /* always report that the buffer was completely consumed */
    return buf_size;
}
