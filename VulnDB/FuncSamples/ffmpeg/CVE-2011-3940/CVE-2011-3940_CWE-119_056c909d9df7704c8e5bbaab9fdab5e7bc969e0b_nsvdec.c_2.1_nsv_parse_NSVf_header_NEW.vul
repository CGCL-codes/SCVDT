static int nsv_parse_NSVf_header(AVFormatContext *s, AVFormatParameters *ap)
{
    NSVContext *nsv = s->priv_data;
    ByteIOContext *pb = s->pb;
    unsigned int file_size, size;
    int64_t duration;
    int strings_size;
    int table_entries;
    int table_entries_used;

    PRINT(("%s()\n", __FUNCTION__));

    nsv->state = NSV_UNSYNC; /* in case we fail */

    size = get_le32(pb);
    if (size < 28)
        return -1;
    nsv->NSVf_end = size;

    //s->file_size = (uint32_t)get_le32(pb);
    file_size = (uint32_t)get_le32(pb);
    PRINT(("NSV NSVf chunk_size %u\n", size));
    PRINT(("NSV NSVf file_size %u\n", file_size));

    nsv->duration = duration = get_le32(pb); /* in ms */
    PRINT(("NSV NSVf duration %"PRId64" ms\n", duration));
    // XXX: store it in AVStreams

    strings_size = get_le32(pb);
    table_entries = get_le32(pb);
    table_entries_used = get_le32(pb);
    PRINT(("NSV NSVf info-strings size: %d, table entries: %d, bis %d\n",
            strings_size, table_entries, table_entries_used));
    if (url_feof(pb))
        return -1;

    PRINT(("NSV got header; filepos %"PRId64"\n", url_ftell(pb)));

    if (strings_size > 0) {
        char *strings; /* last byte will be '\0' to play safe with str*() */
        char *p, *endp;
        char *token, *value;
        char quote;

        p = strings = av_mallocz((size_t)strings_size + 1);
        if (!p)
            return AVERROR(ENOMEM);
        endp = strings + strings_size;
        get_buffer(pb, strings, strings_size);
        while (p < endp) {
            while (*p == ' ')
                p++; /* strip out spaces */
            if (p >= endp-2)
                break;
            token = p;
            p = strchr(p, '=');
            if (!p || p >= endp-2)
                break;
            *p++ = '\0';
            quote = *p++;
            value = p;
            p = strchr(p, quote);
            if (!p || p >= endp)
                break;
            *p++ = '\0';
            PRINT(("NSV NSVf INFO: %s='%s'\n", token, value));
            av_metadata_set(&s->metadata, token, value);
        }
        av_free(strings);
    }
    if (url_feof(pb))
        return -1;

    PRINT(("NSV got infos; filepos %"PRId64"\n", url_ftell(pb)));

    if (table_entries_used > 0) {
        nsv->index_entries = table_entries_used;
        if((unsigned)table_entries >= UINT_MAX / sizeof(uint32_t))
            return -1;
        nsv->nsvf_index_data = av_malloc(table_entries * sizeof(uint32_t));
        if (!nsv->nsvf_index_data)
            return AVERROR(ENOMEM);
#warning "FIXME: Byteswap buffer as needed"
        get_buffer(pb, (unsigned char *)nsv->nsvf_index_data, table_entries * sizeof(uint32_t));
    }

    PRINT(("NSV got index; filepos %"PRId64"\n", url_ftell(pb)));

#ifdef DEBUG_DUMP_INDEX
#define V(v) ((v<0x20 || v > 127)?'.':v)
    /* dump index */
    PRINT(("NSV %d INDEX ENTRIES:\n", table_entries));
    PRINT(("NSV [dataoffset][fileoffset]\n", table_entries));
    for (i = 0; i < table_entries; i++) {
        unsigned char b[8];
        url_fseek(pb, size + nsv->nsvf_index_data[i], SEEK_SET);
        get_buffer(pb, b, 8);
        PRINT(("NSV [0x%08lx][0x%08lx]: %02x %02x %02x %02x %02x %02x %02x %02x"
           "%c%c%c%c%c%c%c%c\n",
           nsv->nsvf_index_data[i], size + nsv->nsvf_index_data[i],
           b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7],
           V(b[0]), V(b[1]), V(b[2]), V(b[3]), V(b[4]), V(b[5]), V(b[6]), V(b[7]) ));
    }
    //url_fseek(pb, size, SEEK_SET); /* go back to end of header */
#undef V
#endif

    url_fseek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */

    if (url_feof(pb))
        return -1;
    nsv->state = NSV_HAS_READ_NSVF;
    return 0;
}
