static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
                        AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size       = avpkt->size;
    HYuvContext *s = avctx->priv_data;
    const int width  = s->width;
    const int width2 = s->width >> 1;
    const int height = s->height;
    int fake_ystride, fake_ustride, fake_vstride;
    ThreadFrame frame = { .f = data };
    AVFrame *const p = data;
    int table_size = 0;

    av_fast_malloc(&s->bitstream_buffer,
                   &s->bitstream_buffer_size,
                   buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
    if (!s->bitstream_buffer)
        return AVERROR(ENOMEM);

    memset(s->bitstream_buffer + buf_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
    s->bdsp.bswap_buf((uint32_t *) s->bitstream_buffer,
                      (const uint32_t *) buf, buf_size / 4);

    if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {
        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
        return -1;
    }

    if (s->context) {
        table_size = read_huffman_tables(s, s->bitstream_buffer, buf_size);
        if (table_size < 0)
            return -1;
    }

    if ((unsigned) (buf_size - table_size) >= INT_MAX / 8)
        return AVERROR_INVALIDDATA;

    init_get_bits(&s->gb, s->bitstream_buffer + table_size,
                  (buf_size - table_size) * 8);

    fake_ystride = s->interlaced ? p->linesize[0] * 2 : p->linesize[0];
    fake_ustride = s->interlaced ? p->linesize[1] * 2 : p->linesize[1];
    fake_vstride = s->interlaced ? p->linesize[2] * 2 : p->linesize[2];

    s->last_slice_end = 0;

    if (s->bitstream_bpp < 24) {
        int y, cy;
        int lefty, leftu, leftv;
        int lefttopy, lefttopu, lefttopv;

        if (s->yuy2) {
            p->data[0][3] = get_bits(&s->gb, 8);
            p->data[0][2] = get_bits(&s->gb, 8);
            p->data[0][1] = get_bits(&s->gb, 8);
            p->data[0][0] = get_bits(&s->gb, 8);

            avpriv_report_missing_feature(avctx, "YUY2 output");
            return AVERROR_PATCHWELCOME;
        } else {
            leftv         =
            p->data[2][0] = get_bits(&s->gb, 8);
            lefty         =
            p->data[0][1] = get_bits(&s->gb, 8);
            leftu         =
            p->data[1][0] = get_bits(&s->gb, 8);
            p->data[0][0] = get_bits(&s->gb, 8);

            switch (s->predictor) {
            case LEFT:
            case PLANE:
                decode_422_bitstream(s, width - 2);
                lefty = s->hdsp.add_hfyu_left_pred(p->data[0] + 2, s->temp[0],
                                                   width - 2, lefty);
                if (!(s->flags & CODEC_FLAG_GRAY)) {
                    leftu = s->hdsp.add_hfyu_left_pred(p->data[1] + 1, s->temp[1], width2 - 1, leftu);
                    leftv = s->hdsp.add_hfyu_left_pred(p->data[2] + 1, s->temp[2], width2 - 1, leftv);
                }

                for (cy = y = 1; y < s->height; y++, cy++) {
                    uint8_t *ydst, *udst, *vdst;

                    if (s->bitstream_bpp == 12) {
                        decode_gray_bitstream(s, width);

                        ydst = p->data[0] + p->linesize[0] * y;

                        lefty = s->hdsp.add_hfyu_left_pred(ydst, s->temp[0],
                                                           width, lefty);
                        if (s->predictor == PLANE) {
                            if (y > s->interlaced)
                                s->hdsp.add_bytes(ydst, ydst - fake_ystride, width);
                        }
                        y++;
                        if (y >= s->height)
                            break;
                    }

                    draw_slice(s, p, y);

                    ydst = p->data[0] + p->linesize[0] * y;
                    udst = p->data[1] + p->linesize[1] * cy;
                    vdst = p->data[2] + p->linesize[2] * cy;

                    decode_422_bitstream(s, width);
                    lefty = s->hdsp.add_hfyu_left_pred(ydst, s->temp[0],
                                                       width, lefty);
                    if (!(s->flags & CODEC_FLAG_GRAY)) {
                        leftu = s->hdsp.add_hfyu_left_pred(udst, s->temp[1], width2, leftu);
                        leftv = s->hdsp.add_hfyu_left_pred(vdst, s->temp[2], width2, leftv);
                    }
                    if (s->predictor == PLANE) {
                        if (cy > s->interlaced) {
                            s->hdsp.add_bytes(ydst, ydst - fake_ystride, width);
                            if (!(s->flags & CODEC_FLAG_GRAY)) {
                                s->hdsp.add_bytes(udst, udst - fake_ustride, width2);
                                s->hdsp.add_bytes(vdst, vdst - fake_vstride, width2);
                            }
                        }
                    }
                }
                draw_slice(s, p, height);

                break;
            case MEDIAN:
                /* first line except first 2 pixels is left predicted */
                decode_422_bitstream(s, width - 2);
                lefty = s->hdsp.add_hfyu_left_pred(p->data[0] + 2, s->temp[0],
                                                   width - 2, lefty);
                if (!(s->flags & CODEC_FLAG_GRAY)) {
                    leftu = s->hdsp.add_hfyu_left_pred(p->data[1] + 1, s->temp[1], width2 - 1, leftu);
                    leftv = s->hdsp.add_hfyu_left_pred(p->data[2] + 1, s->temp[2], width2 - 1, leftv);
                }

                cy = y = 1;

                /* second line is left predicted for interlaced case */
                if (s->interlaced) {
                    decode_422_bitstream(s, width);
                    lefty = s->hdsp.add_hfyu_left_pred(p->data[0] + p->linesize[0],
                                                       s->temp[0], width, lefty);
                    if (!(s->flags & CODEC_FLAG_GRAY)) {
                        leftu = s->hdsp.add_hfyu_left_pred(p->data[1] + p->linesize[2], s->temp[1], width2, leftu);
                        leftv = s->hdsp.add_hfyu_left_pred(p->data[2] + p->linesize[1], s->temp[2], width2, leftv);
                    }
                    y++;
                    cy++;
                }

                /* next 4 pixels are left predicted too */
                decode_422_bitstream(s, 4);
                lefty = s->hdsp.add_hfyu_left_pred(p->data[0] + fake_ystride,
                                                   s->temp[0], 4, lefty);
                if (!(s->flags & CODEC_FLAG_GRAY)) {
                    leftu = s->hdsp.add_hfyu_left_pred(p->data[1] + fake_ustride, s->temp[1], 2, leftu);
                    leftv = s->hdsp.add_hfyu_left_pred(p->data[2] + fake_vstride, s->temp[2], 2, leftv);
                }

                /* next line except the first 4 pixels is median predicted */
                lefttopy = p->data[0][3];
                decode_422_bitstream(s, width - 4);
                s->hdsp.add_hfyu_median_pred(p->data[0] + fake_ystride + 4,
                                             p->data[0] + 4, s->temp[0],
                                             width - 4, &lefty, &lefttopy);
                if (!(s->flags & CODEC_FLAG_GRAY)) {
                    lefttopu = p->data[1][1];
                    lefttopv = p->data[2][1];
                    s->hdsp.add_hfyu_median_pred(p->data[1] + fake_ustride + 2, p->data[1] + 2, s->temp[1], width2 - 2, &leftu, &lefttopu);
                    s->hdsp.add_hfyu_median_pred(p->data[2] + fake_vstride + 2, p->data[2] + 2, s->temp[2], width2 - 2, &leftv, &lefttopv);
                }
                y++;
                cy++;

                for (; y < height; y++, cy++) {
                    uint8_t *ydst, *udst, *vdst;

                    if (s->bitstream_bpp == 12) {
                        while (2 * cy > y) {
                            decode_gray_bitstream(s, width);
                            ydst = p->data[0] + p->linesize[0] * y;
                            s->hdsp.add_hfyu_median_pred(ydst, ydst - fake_ystride,
                                                         s->temp[0], width,
                                                         &lefty, &lefttopy);
                            y++;
                        }
                        if (y >= height)
                            break;
                    }
                    draw_slice(s, p, y);

                    decode_422_bitstream(s, width);

                    ydst = p->data[0] + p->linesize[0] * y;
                    udst = p->data[1] + p->linesize[1] * cy;
                    vdst = p->data[2] + p->linesize[2] * cy;

                    s->hdsp.add_hfyu_median_pred(ydst, ydst - fake_ystride,
                                                 s->temp[0], width,
                                                 &lefty, &lefttopy);
                    if (!(s->flags & CODEC_FLAG_GRAY)) {
                        s->hdsp.add_hfyu_median_pred(udst, udst - fake_ustride, s->temp[1], width2, &leftu, &lefttopu);
                        s->hdsp.add_hfyu_median_pred(vdst, vdst - fake_vstride, s->temp[2], width2, &leftv, &lefttopv);
                    }
                }

                draw_slice(s, p, height);
                break;
            }
        }
    } else {
        int y;
        int leftr, leftg, leftb, lefta;
        const int last_line = (height - 1) * p->linesize[0];

        if (s->bitstream_bpp == 32) {
            lefta = p->data[0][last_line + A] = get_bits(&s->gb, 8);
            leftr = p->data[0][last_line + R] = get_bits(&s->gb, 8);
            leftg = p->data[0][last_line + G] = get_bits(&s->gb, 8);
            leftb = p->data[0][last_line + B] = get_bits(&s->gb, 8);
        } else {
            leftr = p->data[0][last_line + R] = get_bits(&s->gb, 8);
            leftg = p->data[0][last_line + G] = get_bits(&s->gb, 8);
            leftb = p->data[0][last_line + B] = get_bits(&s->gb, 8);
            lefta = p->data[0][last_line + A] = 255;
            skip_bits(&s->gb, 8);
        }

        if (s->bgr32) {
            switch (s->predictor) {
            case LEFT:
            case PLANE:
                decode_bgr_bitstream(s, width - 1);
                s->hdsp.add_hfyu_left_pred_bgr32(p->data[0] + last_line + 4,
                                                 s->temp[0], width - 1, &leftr,
                                                 &leftg, &leftb, &lefta);

                for (y = s->height - 2; y >= 0; y--) { // Yes it is stored upside down.
                    decode_bgr_bitstream(s, width);

                    s->hdsp.add_hfyu_left_pred_bgr32(p->data[0] + p->linesize[0] * y,
                                                     s->temp[0], width, &leftr,
                                                     &leftg, &leftb, &lefta);
                    if (s->predictor == PLANE) {
                        if (s->bitstream_bpp != 32)
                            lefta = 0;
                        if ((y & s->interlaced) == 0 &&
                            y < s->height - 1 - s->interlaced) {
                            s->hdsp.add_bytes(p->data[0] + p->linesize[0] * y,
                                              p->data[0] + p->linesize[0] * y +
                                              fake_ystride, fake_ystride);
                        }
                    }
                }
                // just 1 large slice as this is not possible in reverse order
                draw_slice(s, p, height);
                break;
            default:
                av_log(avctx, AV_LOG_ERROR,
                       "prediction type not supported!\n");
            }
        } else {
            avpriv_report_missing_feature(avctx, "BGR24 output");
            return AVERROR_PATCHWELCOME;
        }
    }
    emms_c();

    *got_frame = 1;

    return (get_bits_count(&s->gb) + 31) / 32 * 4 + table_size;
}
