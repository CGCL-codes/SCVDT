static int ebml_parse_elem(MatroskaDemuxContext *matroska,
                           EbmlSyntax *syntax, void *data)
{
    ByteIOContext *pb = matroska->ctx->pb;
    uint32_t id = syntax->id;
    uint64_t length;
    int res;

    data = (char *)data + syntax->data_offset;
    if (syntax->list_elem_size) {
        EbmlList *list = data;
        list->elem = av_realloc(list->elem, (list->nb_elem+1)*syntax->list_elem_size);
        data = (char*)list->elem + list->nb_elem*syntax->list_elem_size;
        memset(data, 0, syntax->list_elem_size);
        list->nb_elem++;
    }

    if (syntax->type != EBML_PASS && syntax->type != EBML_STOP)
        if ((res = ebml_read_num(matroska, pb, 8, &length)) < 0)
            return res;

    switch (syntax->type) {
    case EBML_UINT:  res = ebml_read_uint  (pb, length, data);  break;
    case EBML_FLOAT: res = ebml_read_float (pb, length, data);  break;
    case EBML_STR:
    case EBML_UTF8:  res = ebml_read_ascii (pb, length, data);  break;
    case EBML_BIN:   res = ebml_read_binary(pb, length, data);  break;
    case EBML_NEST:  if ((res=ebml_read_master(matroska, length)) < 0)
                         return res;
                     if (id == MATROSKA_ID_SEGMENT)
                         matroska->segment_start = url_ftell(matroska->ctx->pb);
                     return ebml_parse_nest(matroska, syntax->def.n, data);
    case EBML_PASS:  return ebml_parse_id(matroska, syntax->def.n, id, data);
    case EBML_STOP:  *(int *)data = 1;      return 1;
    default:         return url_fseek(pb,length,SEEK_CUR)<0 ? AVERROR(EIO) : 0;
    }
    if (res == AVERROR_INVALIDDATA)
        av_log(matroska->ctx, AV_LOG_ERROR, "Invalid element\n");
    else if (res == AVERROR(EIO))
        av_log(matroska->ctx, AV_LOG_ERROR, "Read error\n");
    return res;
}
