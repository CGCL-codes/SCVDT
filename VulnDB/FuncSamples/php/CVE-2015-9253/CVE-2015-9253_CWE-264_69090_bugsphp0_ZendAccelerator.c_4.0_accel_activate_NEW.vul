static void accel_activate(void)
{
	TSRMLS_FETCH();

	if (!ZCG(enabled) || !accel_startup_ok) {
		return;
	}

#ifndef ZEND_WIN32
	if (ZCG(accel_directives).validate_root) {
		struct stat buf;

		if (stat("/", &buf) != 0) {
			ZCG(root_hash) = 0;
		} else {
			unsigned long x = buf.st_ino;

#if SIZEOF_LONG == 4
			x = ((x >> 16) ^ x) * 0x45d9f3b;
			x = ((x >> 16) ^ x) * 0x45d9f3b;
			x = (x >> 16) ^ x;
#elif SIZEOF_LONG == 8
			x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
			x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
			x = x ^ (x >> 31);
#endif
			ZCG(root_hash) = x;
		}
	} else {
		ZCG(root_hash) = 0;
	}
#endif

	SHM_UNPROTECT();
	/* PHP-5.4 and above return "double", but we use 1 sec precision */
	ZCG(request_time) = (time_t)sapi_get_request_time(TSRMLS_C);
	ZCG(cache_opline) = NULL;
	ZCG(cache_persistent_script) = NULL;
	ZCG(include_path_check) = !ZCG(include_path_key);

	if (ZCG(counted)) {
#ifdef ZTS
		zend_accel_error(ACCEL_LOG_WARNING, "Stuck count for thread id %d", tsrm_thread_id());
#else
		zend_accel_error(ACCEL_LOG_WARNING, "Stuck count for pid %d", getpid());
#endif
		accel_unlock_all(TSRMLS_C);
		ZCG(counted) = 0;
	}

	if (ZCSG(restart_pending)) {
		zend_shared_alloc_lock(TSRMLS_C);
		if (ZCSG(restart_pending) != 0) { /* check again, to ensure that the cache wasn't already cleaned by another process */
			if (accel_is_inactive(TSRMLS_C) == SUCCESS) {
				zend_accel_error(ACCEL_LOG_DEBUG, "Restarting!");
				ZCSG(restart_pending) = 0;
				switch ZCSG(restart_reason) {
					case ACCEL_RESTART_OOM:
						ZCSG(oom_restarts)++;
						break;
					case ACCEL_RESTART_HASH:
						ZCSG(hash_restarts)++;
						break;
					case ACCEL_RESTART_USER:
						ZCSG(manual_restarts)++;
						break;
				}
				accel_restart_enter(TSRMLS_C);

				zend_reset_cache_vars(TSRMLS_C);
				zend_accel_hash_clean(&ZCSG(hash));

				/* include_paths keeps only the first path */
				if (ZCSG(include_paths).num_entries > 1) {
					ZCSG(include_paths).num_entries = 1;
					ZCSG(include_paths).num_direct_entries = 1;
					memset(ZCSG(include_paths).hash_table, 0, sizeof(zend_accel_hash_entry*) * ZCSG(include_paths).max_num_entries);
					ZCSG(include_paths).hash_table[zend_inline_hash_func(ZCSG(include_paths).hash_entries[0].key, ZCSG(include_paths).hash_entries[0].key_length) % ZCSG(include_paths).max_num_entries] = &ZCSG(include_paths).hash_entries[0];
				}

#if (ZEND_EXTENSION_API_NO > PHP_5_3_X_API_NO) && !defined(ZTS)
				if (ZCG(accel_directives).interned_strings_buffer) {
					accel_interned_strings_restore_state(TSRMLS_C);
				}
#endif

				zend_shared_alloc_restore_state();
				ZCSG(accelerator_enabled) = ZCSG(cache_status_before_restart);
				ZCSG(last_restart_time) = ZCG(request_time);
				accel_restart_leave(TSRMLS_C);
			}
		}
		zend_shared_alloc_unlock(TSRMLS_C);
	}

	/* check if ZCG(function_table) wasn't somehow polluted on the way */
	if (ZCG(internal_functions_count) != zend_hash_num_elements(&ZCG(function_table))) {
		zend_accel_error(ACCEL_LOG_WARNING, "Internal functions count changed - was %d, now %d", ZCG(internal_functions_count), zend_hash_num_elements(&ZCG(function_table)));
	}

	ZCG(cwd) = NULL;

	SHM_PROTECT();
}
