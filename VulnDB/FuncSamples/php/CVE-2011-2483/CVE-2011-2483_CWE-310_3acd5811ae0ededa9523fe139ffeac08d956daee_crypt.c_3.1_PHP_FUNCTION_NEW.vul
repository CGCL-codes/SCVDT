PHP_FUNCTION(crypt)
{
	char salt[PHP_MAX_SALT_LEN + 1];
	char *str, *salt_in = NULL;
	int str_len, salt_in_len = 0;
	char *crypt_res;
	salt[0] = salt[PHP_MAX_SALT_LEN] = '\0';

	/* This will produce suitable results if people depend on DES-encryption
	 * available (passing always 2-character salt). At least for glibc6.1 */
	memset(&salt[1], '$', PHP_MAX_SALT_LEN - 1);

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|s", &str, &str_len, &salt_in, &salt_in_len) == FAILURE) {
		return;
	}

	if (salt_in) {
		memcpy(salt, salt_in, MIN(PHP_MAX_SALT_LEN, salt_in_len));
	}

	/* The automatic salt generation covers standard DES, md5-crypt and Blowfish (simple) */
	if (!*salt) {
#if PHP_MD5_CRYPT
		strcpy(salt, "$1$");
		php_to64(&salt[3], PHP_CRYPT_RAND, 4);
		php_to64(&salt[7], PHP_CRYPT_RAND, 4);
		strcpy(&salt[11], "$");
#elif PHP_STD_DES_CRYPT
		php_to64(&salt[0], PHP_CRYPT_RAND, 2);
		salt[2] = '\0';
#endif
		salt_in_len = strlen(salt);
	}

/* Windows (win32/crypt) has a stripped down version of libxcrypt and 
	a CryptoApi md5_crypt implementation */
#if PHP_USE_PHP_CRYPT_R
	{
		struct php_crypt_extended_data buffer;

		if (salt[0]=='$' && salt[1]=='1' && salt[2]=='$') {
			char output[MD5_HASH_MAX_LEN];

			RETURN_STRING(php_md5_crypt_r(str, salt, output), 1);
		} else if (salt[0]=='$' && salt[1]=='6' && salt[2]=='$') {
			const char sha512_salt_prefix[] = "$6$";
			const char sha512_rounds_prefix[] = "rounds=";
			char *output;
			int needed = (sizeof(sha512_salt_prefix) - 1
						+ sizeof(sha512_rounds_prefix) + 9 + 1
						+ strlen(salt) + 1 + 43 + 1);
			output = emalloc(needed * sizeof(char *));
			salt[salt_in_len] = '\0';

			crypt_res = php_sha512_crypt_r(str, salt, output, needed);
			if (!crypt_res) {
				if (salt[0]=='*' && salt[1]=='0') {
					RETVAL_STRING("*1", 1);
				} else {
					RETVAL_STRING("*0", 1);
				}
			} else {
				RETVAL_STRING(output, 1);
			}

			memset(output, 0, PHP_MAX_SALT_LEN + 1);
			efree(output);
		} else if (salt[0]=='$' && salt[1]=='5' && salt[2]=='$') {
			const char sha256_salt_prefix[] = "$5$";
			const char sha256_rounds_prefix[] = "rounds=";
			char *output;
			int needed = (sizeof(sha256_salt_prefix) - 1
						+ sizeof(sha256_rounds_prefix) + 9 + 1
						+ strlen(salt) + 1 + 43 + 1);
			output = emalloc(needed * sizeof(char *));
			salt[salt_in_len] = '\0';

			crypt_res = php_sha256_crypt_r(str, salt, output, needed);
			if (!crypt_res) {
				if (salt[0]=='*' && salt[1]=='0') {
					RETVAL_STRING("*1", 1);
				} else {
					RETVAL_STRING("*0", 1);
				}
			} else {
				RETVAL_STRING(output, 1);
			}

			memset(output, 0, PHP_MAX_SALT_LEN + 1);
			efree(output);
		} else if (
				salt[0] == '$' &&
				salt[1] == '2' &&
			    (salt[2] != 'a' && salt[2] != 'x') ||
				salt[3] == '$' &&
				salt[4] >= '0' && salt[4] <= '3' &&
				salt[5] >= '0' && salt[5] <= '9' &&
				salt[6] == '$') {
			char output[PHP_MAX_SALT_LEN + 1];

			memset(output, 0, PHP_MAX_SALT_LEN + 1);

			crypt_res = php_crypt_blowfish_rn(str, salt, output, sizeof(output));
			if (!crypt_res) {
				if (salt[0]=='*' && salt[1]=='0') {
					RETVAL_STRING("*1", 1);
				} else {
					RETVAL_STRING("*0", 1);
				}
			} else {
				RETVAL_STRING(output, 1);
			}

			memset(output, 0, PHP_MAX_SALT_LEN + 1);
		} else {
			memset(&buffer, 0, sizeof(buffer));
			_crypt_extended_init_r();

			crypt_res = _crypt_extended_r(str, salt, &buffer);
			if (!crypt_res) {
				if (salt[0]=='*' && salt[1]=='0') {
					RETURN_STRING("*1", 1);
				} else {
					RETURN_STRING("*0", 1);
				}
			} else {
				RETURN_STRING(crypt_res, 1);
			}
		}
	}
#else

# if defined(HAVE_CRYPT_R) && (defined(_REENTRANT) || defined(_THREAD_SAFE))
	{
#  if defined(CRYPT_R_STRUCT_CRYPT_DATA)
		struct crypt_data buffer;
		memset(&buffer, 0, sizeof(buffer));
#  elif defined(CRYPT_R_CRYPTD)
		CRYPTD buffer;
#  else
#    error Data struct used by crypt_r() is unknown. Please report.
#  endif
		crypt_res = crypt_r(str, salt, &buffer);
		if (!crypt_res) {
				if (salt[0]=='*' && salt[1]=='0') {
					RETURN_STRING("*1", 1);
				} else {
					RETURN_STRING("*0", 1);
				}
		} else {
			RETURN_STRING(crypt_res, 1);
		}
	}
# endif
#endif
}
