PHPAPI int php_network_getaddresses(const char *host, int socktype, struct sockaddr ***sal, zend_string **error_string)
{
	struct sockaddr **sap;
	int n;
#if HAVE_GETADDRINFO
# if HAVE_IPV6
	static int ipv6_borked = -1; /* the way this is used *is* thread safe */
# endif
	struct addrinfo hints, *res, *sai;
#else
	struct hostent *host_info;
	struct in_addr in;
#endif

	if (host == NULL) {
		return 0;
	}
#if HAVE_GETADDRINFO
	memset(&hints, '\0', sizeof(hints));

	hints.ai_family = AF_INET; /* default to regular inet (see below) */
	hints.ai_socktype = socktype;

# if HAVE_IPV6
	/* probe for a working IPv6 stack; even if detected as having v6 at compile
	 * time, at runtime some stacks are slow to resolve or have other issues
	 * if they are not correctly configured.
	 * static variable use is safe here since simple store or fetch operations
	 * are atomic and because the actual probe process is not in danger of
	 * collisions or race conditions. */
	if (ipv6_borked == -1) {
		int s;

		s = socket(PF_INET6, SOCK_DGRAM, 0);
		if (s == SOCK_ERR) {
			ipv6_borked = 1;
		} else {
			ipv6_borked = 0;
			closesocket(s);
		}
	}
	hints.ai_family = ipv6_borked ? AF_INET : AF_UNSPEC;
# endif

	if ((n = getaddrinfo(host, NULL, &hints, &res))) {
		if (error_string) {
			*error_string = strpprintf(0, "php_network_getaddresses: getaddrinfo failed: %s", PHP_GAI_STRERROR(n));
			php_error_docref(NULL, E_WARNING, "%s", (*error_string)->val);
		} else {
			php_error_docref(NULL, E_WARNING, "php_network_getaddresses: getaddrinfo failed: %s", PHP_GAI_STRERROR(n));
		}
		return 0;
	} else if (res == NULL) {
		if (error_string) {
			*error_string = strpprintf(0, "php_network_getaddresses: getaddrinfo failed (null result pointer) errno=%d", errno);
			php_error_docref(NULL, E_WARNING, "%s", (*error_string)->val);
		} else {
			php_error_docref(NULL, E_WARNING, "php_network_getaddresses: getaddrinfo failed (null result pointer)");
		}
		return 0;
	}

	sai = res;
	for (n = 1; (sai = sai->ai_next) != NULL; n++)
		;

	*sal = safe_emalloc((n + 1), sizeof(*sal), 0);
	sai = res;
	sap = *sal;

	do {
		*sap = emalloc(sai->ai_addrlen);
		memcpy(*sap, sai->ai_addr, sai->ai_addrlen);
		sap++;
	} while ((sai = sai->ai_next) != NULL);

	freeaddrinfo(res);
#else
	if (!inet_aton(host, &in)) {
		/* XXX NOT THREAD SAFE (is safe under win32) */
		if(strlen(host) > MAXHOSTNAMELEN) {
			host_info = NULL;
			errno = E2BIG;
		} else {
			host_info = gethostbyname(host);
		}
		if (host_info == NULL) {
			if (error_string) {
				error_string = strpprintf(0, "php_network_getaddresses: gethostbyname failed. errno=%d", errno);
				php_error_docref(NULL, E_WARNING, "%s", (*error_string)->val);
			} else {
				php_error_docref(NULL, E_WARNING, "php_network_getaddresses: gethostbyname failed");
			}
			return 0;
		}
		in = *((struct in_addr *) host_info->h_addr);
	}

	*sal = safe_emalloc(2, sizeof(*sal), 0);
	sap = *sal;
	*sap = emalloc(sizeof(struct sockaddr_in));
	(*sap)->sa_family = AF_INET;
	((struct sockaddr_in *)*sap)->sin_addr = in;
	sap++;
	n = 1;
#endif

	*sap = NULL;
	return n;
}
