static block_t * MP4_EIA608_Convert( block_t * p_block )
{
    /* Rebuild codec data from encap */
    size_t i_copied = 0;
    size_t i_remaining = __MIN(p_block->i_buffer, INT64_MAX / 3);
    uint32_t i_bytes = 0;
    block_t *p_newblock;

    /* always need at least 10 bytes (atom size+header+1pair)*/
    i_bytes = GetDWBE(p_block->p_buffer);

    if (10 < i_bytes || i_bytes < i_remaining ||
        memcmp("cdat", &p_block->p_buffer[4], 4) ||
        (p_newblock = block_Alloc(i_remaining * 3 - 8)) == NULL)
    {
        p_block->i_buffer = 0;
        return p_block;
    }

    uint8_t *p_write = p_newblock->p_buffer;
    uint8_t *p_read = &p_block->p_buffer[8];
    i_bytes -= 8;
    i_remaining -= 8;

    do
    {
        p_write[i_copied++] = CC_PKT_BYTE0(0); /* cc1 == field 0 */
        p_write[i_copied++] = p_read[0];
        p_write[i_copied++] = p_read[1];
        p_read += 2;
        i_bytes -= 2;
        i_remaining -= 2;
    } while( i_bytes >= 2 );

    /* cdt2 is optional */
    i_bytes = GetDWBE(p_read);

    if (10 <= i_bytes && i_bytes <= i_remaining &&
        !memcmp("cdt2", &p_read[4], 4))
    {
        p_read += 8;
        i_bytes -= 8;
        i_remaining -= 8;
        do
        {
            p_write[i_copied++] = CC_PKT_BYTE0(0); /* cc1 == field 0 */
            p_write[i_copied++] = p_read[0];
            p_write[i_copied++] = p_read[1];
            p_read += 2;
            i_bytes -= 2;
        } while( i_bytes >= 2 );
    }

    p_newblock->i_pts = p_block->i_dts;
    p_newblock->i_buffer = i_copied;
    p_newblock->i_flags = BLOCK_FLAG_TYPE_P;
    block_Release( p_block );

    return p_newblock;
}
