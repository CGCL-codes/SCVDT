static int ASF_ReadObject_Index( stream_t *s, asf_object_t *p_obj )
{
    asf_object_index_t *p_index = &p_obj->index;
    const uint8_t      *p_peek;
    unsigned int       i;

    /* We just ignore error on the index */
    if( p_index->i_object_size < 56
     || p_index->i_object_size > INT32_MAX
     || vlc_stream_Peek( s, &p_peek, p_index->i_object_size )
        < (int64_t)p_index->i_object_size )
        return VLC_SUCCESS;

    ASF_GetGUID( &p_index->i_file_id, p_peek + ASF_OBJECT_COMMON_SIZE );
    p_index->i_index_entry_time_interval = GetQWLE( p_peek + 40 );
    p_index->i_max_packet_count = GetDWLE( p_peek + 48 );
    p_index->i_index_entry_count = GetDWLE( p_peek + 52 );
    p_index->index_entry = NULL;

#ifdef ASF_DEBUG
    msg_Dbg( s,
            "read \"index object\" file_id:" GUID_FMT
            " index_entry_time_interval:%"PRId64" max_packet_count:%u "
            "index_entry_count:%u",
            GUID_PRINT( p_index->i_file_id ),
            p_index->i_index_entry_time_interval,
            p_index->i_max_packet_count,
            p_index->i_index_entry_count );
#endif

    /* Sanity checking */
    if( !p_index->i_index_entry_time_interval )
    {
        /* We can't use this index if it has an invalid time interval */
        p_index->i_index_entry_count = 0;
        return VLC_ENOMEM;
    }
    if( p_index->i_index_entry_count > (p_index->i_object_size - 56) / 6 )
        p_index->i_index_entry_count = (p_index->i_object_size - 56) / 6;

    p_index->index_entry = calloc( p_index->i_index_entry_count,
                                   sizeof(asf_index_entry_t) );
    if( !p_index->index_entry )
    {
        p_index->i_index_entry_count = 0;
        return VLC_ENOMEM;
    }

    for( i = 0, p_peek += 56; i < p_index->i_index_entry_count; i++, p_peek += 6 )
    {
        p_index->index_entry[i].i_packet_number = GetDWLE( p_peek );
        p_index->index_entry[i].i_packet_count = GetWLE( p_peek + 4 );
    }

    return VLC_SUCCESS;
}
