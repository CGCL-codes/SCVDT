static void Run( intf_thread_t *p_intf )
{
    input_thread_t * p_input;
    playlist_t *     p_playlist;

    char       p_buffer[ MAX_LINE_LENGTH + 1 ];
    vlc_bool_t b_showpos = config_GetInt( p_intf, "rc-show-pos" );
    vlc_bool_t b_longhelp = VLC_FALSE;

    int        i_size = 0;
    int        i_oldpos = 0;
    int        i_newpos;

    p_buffer[0] = 0;
    p_input = NULL;
    p_playlist = NULL;

    /* Register commands that will be cleaned up upon object destruction */
    RegisterCallbacks( p_intf );

    /* status callbacks */
    /* Listen to audio volume updates */
    var_AddCallback( p_intf->p_libvlc, "volume-change", VolumeChanged, p_intf );

#ifdef WIN32
    /* Get the file descriptor of the console input */
    p_intf->p_sys->hConsoleIn = GetStdHandle(STD_INPUT_HANDLE);
    if( p_intf->p_sys->hConsoleIn == INVALID_HANDLE_VALUE )
    {
        msg_Err( p_intf, "couldn't find user input handle" );
        vlc_object_kill( p_intf );
    }
#endif

    while( !intf_ShouldDie( p_intf ) )
    {
        char *psz_cmd, *psz_arg;
        vlc_bool_t b_complete;

        if( p_intf->p_sys->pi_socket_listen != NULL &&
            p_intf->p_sys->i_socket == -1 )
        {
            p_intf->p_sys->i_socket =
                net_Accept( p_intf, p_intf->p_sys->pi_socket_listen,
                            INTF_IDLE_SLEEP );
            if( p_intf->p_sys->i_socket == -1 ) continue;
        }

        b_complete = ReadCommand( p_intf, p_buffer, &i_size );

        /* Manage the input part */
        if( p_input == NULL )
        {
            if( p_playlist )
            {
                p_input = vlc_object_find( p_playlist, VLC_OBJECT_INPUT,
                                                       FIND_CHILD );
            }
            else
            {
                p_input = vlc_object_find( p_intf, VLC_OBJECT_INPUT,
                                                   FIND_ANYWHERE );
                if( p_input )
                {
                    p_playlist = vlc_object_find( p_input, VLC_OBJECT_PLAYLIST,
                                                           FIND_PARENT );
                }
            }
            /* New input has been registered */
            if( p_input )
            {
                if( !p_input->b_dead || !p_input->b_die )
                {
                    char *psz_uri =
                            input_item_GetURI( input_GetItem( p_input ) );
                    msg_rc( STATUS_CHANGE "( new input: %s )", psz_uri );
                    free( psz_uri );
                    msg_rc( STATUS_CHANGE "( audio volume: %d )",
                            config_GetInt( p_intf, "volume" ));
                }
                var_AddCallback( p_input, "state", StateChanged, p_intf );
                var_AddCallback( p_input, "rate-faster", RateChanged, p_intf );
                var_AddCallback( p_input, "rate-slower", RateChanged, p_intf );
                var_AddCallback( p_input, "rate", RateChanged, p_intf );
                var_AddCallback( p_input, "time-offset", TimeOffsetChanged,
                                 p_intf );
            }
        }
        else if( p_input->b_dead )
        {
            var_DelCallback( p_input, "state", StateChanged, p_intf );
            var_DelCallback( p_input, "rate-faster", RateChanged, p_intf );
            var_DelCallback( p_input, "rate-slower", RateChanged, p_intf );
            var_DelCallback( p_input, "rate", RateChanged, p_intf );
            var_DelCallback( p_input, "time-offset", TimeOffsetChanged,
                             p_intf );
            vlc_object_release( p_input );
            p_input = NULL;

            if( p_playlist )
            {
                vlc_mutex_lock( &p_playlist->object_lock );
                p_intf->p_sys->i_last_state = (int) PLAYLIST_STOPPED;
                msg_rc( STATUS_CHANGE "( stop state: 0 )" );
                vlc_mutex_unlock( &p_playlist->object_lock );
            }
        }

        if( (p_input != NULL) && !p_input->b_dead && !p_input->b_die &&
            (p_playlist != NULL) )
        {
            vlc_mutex_lock( &p_playlist->object_lock );
            if( (p_intf->p_sys->i_last_state != p_playlist->status.i_status) &&
                (p_playlist->status.i_status == PLAYLIST_STOPPED) )
            {
                p_intf->p_sys->i_last_state = PLAYLIST_STOPPED;
                msg_rc( STATUS_CHANGE "( stop state: 0 )" );
            }
            else if(
                (p_intf->p_sys->i_last_state != p_playlist->status.i_status) &&
                (p_playlist->status.i_status == PLAYLIST_RUNNING) )
            {
                p_intf->p_sys->i_last_state = p_playlist->status.i_status;
                msg_rc( STATUS_CHANGE "( play state: 1 )" );
            }
            else if(
                (p_intf->p_sys->i_last_state != p_playlist->status.i_status) &&
                (p_playlist->status.i_status == PLAYLIST_PAUSED) )
            {
                p_intf->p_sys->i_last_state = p_playlist->status.i_status;
                msg_rc( STATUS_CHANGE "( pause state: 2 )" );
            }
            vlc_mutex_unlock( &p_playlist->object_lock );
        }

        if( p_input && b_showpos )
        {
            i_newpos = 100 * var_GetFloat( p_input, "position" );
            if( i_oldpos != i_newpos )
            {
                i_oldpos = i_newpos;
                msg_rc( "pos: %d%%", i_newpos );
            }
        }

        /* Is there something to do? */
        if( !b_complete ) continue;


        /* Skip heading spaces */
        psz_cmd = p_buffer;
        while( *psz_cmd == ' ' )
        {
            psz_cmd++;
        }

        /* Split psz_cmd at the first space and make sure that
         * psz_arg is valid */
        psz_arg = strchr( psz_cmd, ' ' );
        if( psz_arg )
        {
            *psz_arg++ = 0;
            while( *psz_arg == ' ' )
            {
                psz_arg++;
            }
        }
        else
        {
            psz_arg = "";
        }

        /* module specfic commands: @<module name> <command> <args...> */
        if( *psz_cmd == '@' && *psz_arg )
        {
            /* Parse miscellaneous commands */
            char *psz_alias = psz_cmd + 1;
            char *psz_mycmd = strdup( psz_arg );
            char *psz_myarg = strchr( psz_mycmd, ' ' );
            char *psz_msg;

            if( !psz_myarg )
            {
                msg_rc( "Not enough parameters." );
            }
            else
            {
                *psz_myarg = '\0';
                psz_myarg ++;

                var_Command( p_intf, psz_alias, psz_mycmd, psz_myarg,
                             &psz_msg );

                if( psz_msg )
                {
                    msg_rc( psz_msg );
                    free( psz_msg );
                }
            }
            free( psz_mycmd );
        }
        /* If the user typed a registered local command, try it */
        else if( var_Type( p_intf, psz_cmd ) & VLC_VAR_ISCOMMAND )
        {
            vlc_value_t val;
            int i_ret;

            val.psz_string = psz_arg;
            i_ret = var_Set( p_intf, psz_cmd, val );
            msg_rc( "%s: returned %i (%s)",
                    psz_cmd, i_ret, vlc_error( i_ret ) );
        }
        /* Or maybe it's a global command */
        else if( var_Type( p_intf->p_libvlc, psz_cmd ) & VLC_VAR_ISCOMMAND )
        {
            vlc_value_t val;
            int i_ret;

            val.psz_string = psz_arg;
            /* FIXME: it's a global command, but we should pass the
             * local object as an argument, not p_intf->p_libvlc. */
            i_ret = var_Set( p_intf->p_libvlc, psz_cmd, val );
            if( i_ret != 0 )
            {
                msg_rc( "%s: returned %i (%s)",
                         psz_cmd, i_ret, vlc_error( i_ret ) );
            }
        }
        else if( !strcmp( psz_cmd, "logout" ) )
        {
            /* Close connection */
            if( p_intf->p_sys->i_socket != -1 )
            {
                net_Close( p_intf->p_sys->i_socket );
            }
            p_intf->p_sys->i_socket = -1;
        }
        else if( !strcmp( psz_cmd, "info" ) )
        {
            if( p_input )
            {
                int i, j;
                vlc_mutex_lock( &input_GetItem(p_input)->lock );
                for ( i = 0; i < input_GetItem(p_input)->i_categories; i++ )
                {
                    info_category_t *p_category = input_GetItem(p_input)
                                                        ->pp_categories[i];

                    msg_rc( "+----[ %s ]", p_category->psz_name );
                    msg_rc( "| " );
                    for ( j = 0; j < p_category->i_infos; j++ )
                    {
                        info_t *p_info = p_category->pp_infos[j];
                        msg_rc( "| %s: %s", p_info->psz_name,
                                p_info->psz_value );
                    }
                    msg_rc( "| " );
                }
                msg_rc( "+----[ end of stream info ]" );
                vlc_mutex_unlock( &input_GetItem(p_input)->lock );
            }
            else
            {
                msg_rc( "no input" );
            }
        }
        else if( !strcmp( psz_cmd, "is_playing" ) )
        {
            if( ! p_input )
            {
                msg_rc( "0" );
            }
            else
            {
                msg_rc( "1" );
            }
        }
        else if( !strcmp( psz_cmd, "get_time" ) )
        {
            if( ! p_input )
            {
                msg_rc("0");
            }
            else
            {
                vlc_value_t time;
                var_Get( p_input, "time", &time );
                msg_rc( "%i", time.i_time / 1000000);
            }
        }
        else if( !strcmp( psz_cmd, "get_length" ) )
        {
            if( ! p_input )
            {
                msg_rc("0");
            }
            else
            {
                vlc_value_t time;
                var_Get( p_input, "length", &time );
                msg_rc( "%i", time.i_time / 1000000);
            }
        }
        else if( !strcmp( psz_cmd, "get_title" ) )
        {
            if( ! p_input )
            {
                msg_rc("");
            }
            else
            {
                msg_rc( "%s", input_GetItem(p_input)->psz_name );
            }
        }
        else if( !strcmp( psz_cmd, "longhelp" ) || !strncmp( psz_cmd, "h", 1 )
                 || !strncmp( psz_cmd, "H", 1 ) || !strncmp( psz_cmd, "?", 1 ) )
        {
            if( !strcmp( psz_cmd, "longhelp" ) || !strncmp( psz_cmd, "H", 1 ) )
                 b_longhelp = VLC_TRUE;
            else b_longhelp = VLC_FALSE;

            Help( p_intf, b_longhelp );
        }
#if 0
        else if( !strcmp( psz_cmd, "check-updates" ) )
        {
            checkUpdates( p_intf, psz_arg );
        }
#endif
        else if( !strcmp( psz_cmd, "key" ) || !strcmp( psz_cmd, "hotkey" ) )
        {
            var_SetInteger( p_intf->p_libvlc, "key-pressed",
                            config_GetInt( p_intf, psz_arg ) );
        }
        else switch( psz_cmd[0] )
        {
        case 'f':
        case 'F':
            if( p_input )
            {
                vout_thread_t *p_vout;
                p_vout = vlc_object_find( p_input,
                                          VLC_OBJECT_VOUT, FIND_CHILD );

                if( p_vout )
                {
                    vlc_value_t val;
                    vlc_bool_t b_update = VLC_FALSE;
                    var_Get( p_vout, "fullscreen", &val );
                    val.b_bool = !val.b_bool;
                    if( !strncmp( psz_arg, "on", 2 )
                        && ( val.b_bool == VLC_TRUE ) )
                    {
                        b_update = VLC_TRUE;
                        val.b_bool = VLC_TRUE;
                    }
                    else if( !strncmp( psz_arg, "off", 3 )
                             && ( val.b_bool == VLC_FALSE ) )
                    {
                        b_update = VLC_TRUE;
                        val.b_bool = VLC_FALSE;
                    }
                    else if( strncmp( psz_arg, "off", 3 )
                             && strncmp( psz_arg, "on", 2 ) )
                        b_update = VLC_TRUE;
                    if( b_update ) var_Set( p_vout, "fullscreen", val );
                    vlc_object_release( p_vout );
                }
            }
            break;

        case 's':
        case 'S':
            ;
            break;

        case '\0':
            /* Ignore empty lines */
            break;

        default:
            msg_rc(_("Unknown command `%s'. Type `help' for help."), psz_cmd);
            break;
        }

        /* Command processed */
        i_size = 0; p_buffer[0] = 0;
    }

    msg_rc( STATUS_CHANGE "( stop state: 0 )" );
    msg_rc( STATUS_CHANGE "( quit )" );

    if( p_input )
    {
        var_DelCallback( p_input, "state", StateChanged, p_intf );
        var_DelCallback( p_input, "rate-faster", RateChanged, p_intf );
        var_DelCallback( p_input, "rate-slower", RateChanged, p_intf );
        var_DelCallback( p_input, "rate", RateChanged, p_intf );
        var_DelCallback( p_input, "time-offset", TimeOffsetChanged, p_intf );
        vlc_object_release( p_input );
        p_input = NULL;
    }

    if( p_playlist )
    {
        vlc_object_release( p_playlist );
        p_playlist = NULL;
    }

    var_DelCallback( p_intf->p_libvlc, "volume-change", VolumeChanged, p_intf );
}
