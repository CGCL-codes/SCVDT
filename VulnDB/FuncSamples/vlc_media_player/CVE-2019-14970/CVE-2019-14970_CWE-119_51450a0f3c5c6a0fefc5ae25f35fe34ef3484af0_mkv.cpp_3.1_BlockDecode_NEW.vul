void BlockDecode( demux_t *p_demux, KaxBlock *block, KaxSimpleBlock *simpleblock,
                  vlc_tick_t i_pts, int64_t i_duration, bool b_key_picture,
                  bool b_discardable_picture )
{
    demux_sys_t *p_sys = (demux_sys_t *)p_demux->p_sys;
    matroska_segment_c *p_segment = p_sys->p_current_vsegment->CurrentSegment();

    KaxInternalBlock& internal_block = simpleblock
        ? static_cast<KaxInternalBlock&>( *simpleblock )
        : static_cast<KaxInternalBlock&>( *block );

    if( !p_segment ) return;

    mkv_track_t *p_track = p_segment->FindTrackByBlock( block, simpleblock );
    if( p_track == NULL )
    {
        msg_Err( p_demux, "invalid track number" );
        return;
    }

    mkv_track_t &track = *p_track;

    if( track.fmt.i_cat != DATA_ES && track.p_es == NULL )
    {
        msg_Err( p_demux, "unknown track number" );
        return;
    }

    i_pts -= track.i_codec_delay;

    if ( track.fmt.i_cat != DATA_ES )
    {
        bool b;
        es_out_Control( p_demux->out, ES_OUT_GET_ES_STATE, track.p_es, &b );

        if( !b )
        {
            if( track.fmt.i_cat == VIDEO_ES || track.fmt.i_cat == AUDIO_ES )
                track.i_last_dts = VLC_TICK_INVALID;
            return;
        }
    }

    size_t frame_size = 0;
    size_t block_size = internal_block.GetSize();
    const unsigned i_number_frames = internal_block.NumberFrames();

    for( unsigned int i_frame = 0; i_frame < i_number_frames; i_frame++ )
    {
        block_t *p_block;
        DataBuffer *data = &internal_block.GetBuffer(i_frame);

        frame_size += data->Size();
        if( !data->Buffer() || data->Size() > frame_size || frame_size > block_size  )
        {
            msg_Warn( p_demux, "Cannot read frame (too long or no frame)" );
            break;
        }
        size_t extra_data = track.fmt.i_codec == VLC_CODEC_PRORES ? 8 : 0;

        if( track.i_compression_type == MATROSKA_COMPRESSION_HEADER &&
            track.p_compression_data != NULL &&
            track.i_encoding_scope & MATROSKA_ENCODING_SCOPE_ALL_FRAMES )
            p_block = MemToBlock( data->Buffer(), data->Size(), track.p_compression_data->GetSize() + extra_data );
        else if( unlikely( track.fmt.i_codec == VLC_CODEC_WAVPACK ) )
            p_block = packetize_wavpack( track, data->Buffer(), data->Size() );
        else
            p_block = MemToBlock( data->Buffer(), data->Size(), extra_data );

        if( p_block == NULL )
        {
            break;
        }

#if defined(HAVE_ZLIB_H)
        if( track.i_compression_type == MATROSKA_COMPRESSION_ZLIB &&
            track.i_encoding_scope & MATROSKA_ENCODING_SCOPE_ALL_FRAMES )
        {
            p_block = block_zlib_decompress( VLC_OBJECT(p_demux), p_block );
            if( p_block == NULL )
                break;
        }
        else
#endif
        if( track.i_compression_type == MATROSKA_COMPRESSION_HEADER &&
            track.i_encoding_scope & MATROSKA_ENCODING_SCOPE_ALL_FRAMES )
        {
            memcpy( p_block->p_buffer, track.p_compression_data->GetBuffer(), track.p_compression_data->GetSize() );
        }
        if ( track.fmt.i_codec == VLC_CODEC_PRORES )
            memcpy( p_block->p_buffer + 4, "icpf", 4 );

        if ( b_key_picture )
            p_block->i_flags |= BLOCK_FLAG_TYPE_I;

        switch( track.fmt.i_codec )
        {
        case VLC_CODEC_COOK:
        case VLC_CODEC_ATRAC3:
        {
            handle_real_audio(p_demux, &track, p_block, i_pts);
            block_Release(p_block);
            i_pts = ( track.i_default_duration )?
                i_pts + track.i_default_duration:
                VLC_TICK_INVALID;
            continue;
         }

         case VLC_CODEC_WEBVTT:
            {
                p_block = block_Realloc( p_block, 16, p_block->i_buffer );
                if( !p_block )
                    continue;
                SetDWBE( p_block->p_buffer, p_block->i_buffer );
                memcpy( &p_block->p_buffer[4], "vttc", 4 );
                SetDWBE( &p_block->p_buffer[8], p_block->i_buffer - 8 );
                memcpy( &p_block->p_buffer[12], "payl", 4 );
            }
            break;

         case VLC_CODEC_OPUS:
            {
                vlc_tick_t i_length = VLC_TICK_FROM_NS(i_duration * track.f_timecodescale *
                                                       p_segment->i_timescale);
                if ( i_length < 0 ) i_length = 0;
                p_block->i_nb_samples = samples_from_vlc_tick(i_length, track.fmt.audio.i_rate);
            }
            break;

         case VLC_CODEC_DVBS:
            {
                p_block = block_Realloc( p_block, 2, p_block->i_buffer + 1);

                if( unlikely( !p_block ) )
                    continue;

                p_block->p_buffer[0] = 0x20; // data identifier
                p_block->p_buffer[1] = 0x00; // subtitle stream id
                p_block->p_buffer[ p_block->i_buffer - 1 ] = 0x3f; // end marker
            }
            break;

          case VLC_CODEC_AV1:
            p_block = AV1_Unpack_Sample( p_block );
            if( unlikely( !p_block ) )
                continue;
            break;
        }

        if( track.fmt.i_cat != VIDEO_ES )
        {
            if ( track.fmt.i_cat == DATA_ES )
            {
                // TODO handle the start/stop times of this packet
                if( p_block->i_size >= sizeof(pci_t))
                    p_sys->ev.SetPci( (const pci_t *)&p_block->p_buffer[1]);
                block_Release( p_block );
                return;
            }
            p_block->i_dts = p_block->i_pts = i_pts;
        }
        else
        {
            // correct timestamping when B frames are used
            if( track.b_dts_only )
            {
                p_block->i_pts = VLC_TICK_INVALID;
                p_block->i_dts = i_pts;
            }
            else if( track.b_pts_only )
            {
                p_block->i_pts = i_pts;
                p_block->i_dts = i_pts;
            }
            else
            {
                p_block->i_pts = i_pts;
                // condition when the DTS is correct (keyframe or B frame == NOT P frame)
                if ( b_key_picture || b_discardable_picture )
                        p_block->i_dts = p_block->i_pts;
                else if ( track.i_last_dts == VLC_TICK_INVALID )
                    p_block->i_dts = i_pts;
                else
                    p_block->i_dts = std::min( i_pts, track.i_last_dts + track.i_default_duration );
            }
        }

        send_Block( p_demux, &track, p_block, i_number_frames, i_duration );

        /* use time stamp only for first block */
        i_pts = ( track.i_default_duration )?
                 i_pts + track.i_default_duration:
                 ( track.fmt.b_packetized ) ? VLC_TICK_INVALID : i_pts + 1;
    }
}
