static int Open( vlc_object_t * p_this )
{
    demux_t     *p_demux = (demux_t*)p_this;
    demux_sys_t *p_sys;

    const uint8_t *p_peek;
    unsigned int i_size, i_extended;
    const char        *psz_name;

    WAVEFORMATEXTENSIBLE *p_wf_ext = NULL;
    WAVEFORMATEX         *p_wf = NULL;

    /* Is it a wav file ? */
    if( stream_Peek( p_demux->s, &p_peek, 12 ) < 12 ) return VLC_EGENERIC;

    if( memcmp( p_peek, "RIFF", 4 ) || memcmp( &p_peek[8], "WAVE", 4 ) )
    {
        return VLC_EGENERIC;
    }

    p_demux->pf_demux   = Demux;
    p_demux->pf_control = Control;
    p_demux->p_sys      = p_sys = malloc( sizeof( demux_sys_t ) );
    if( p_sys == NULL )
        return VLC_ENOMEM;

    p_sys->p_es         = NULL;
    p_sys->b_chan_reorder = 0;
    p_sys->i_channel_mask = 0;

    /* skip riff header */
    stream_Read( p_demux->s, NULL, 12 );  /* cannot fail as peek succeed */

    /* search fmt chunk */
    if( ChunkFind( p_demux, "fmt ", &i_size ) )
    {
        msg_Err( p_demux, "cannot find 'fmt ' chunk" );
        goto error;
    }
    if( i_size < sizeof( WAVEFORMATEX ) - 2 )   /* XXX -2 isn't a typo */
    {
        msg_Err( p_demux, "invalid 'fmt ' chunk" );
        goto error;
    }
    stream_Read( p_demux->s, NULL, 8 );   /* Cannot fail */

    /* load waveformatex */
    p_wf_ext = malloc( __EVEN( i_size ) + 2 );
    if( p_wf_ext == NULL )
         goto error;

    p_wf = (WAVEFORMATEX *)p_wf_ext;
    p_wf->cbSize = 0;
    if( stream_Read( p_demux->s,
                     p_wf, __EVEN( i_size ) ) < (int)__EVEN( i_size ) )
    {
        msg_Err( p_demux, "cannot load 'fmt ' chunk" );
        goto error;
    }

    es_format_Init( &p_sys->fmt, AUDIO_ES, 0 );
    wf_tag_to_fourcc( GetWLE( &p_wf->wFormatTag ), &p_sys->fmt.i_codec,
                      &psz_name );
    p_sys->fmt.audio.i_channels = GetWLE ( &p_wf->nChannels );
    p_sys->fmt.audio.i_rate = GetDWLE( &p_wf->nSamplesPerSec );
    p_sys->fmt.audio.i_blockalign = GetWLE( &p_wf->nBlockAlign );
    p_sys->fmt.i_bitrate = GetDWLE( &p_wf->nAvgBytesPerSec ) * 8;
    p_sys->fmt.audio.i_bitspersample = GetWLE( &p_wf->wBitsPerSample );
    p_sys->fmt.i_extra = GetWLE( &p_wf->cbSize );
    i_extended = 0;

    /* Handle new WAVE_FORMAT_EXTENSIBLE wav files */
    /* see the following link for more information:
     * http://www.microsoft.com/whdc/device/audio/multichaud.mspx#EFAA */
    if( GetWLE( &p_wf->wFormatTag ) == WAVE_FORMAT_EXTENSIBLE &&
        i_size >= sizeof( WAVEFORMATEXTENSIBLE ) )
    {
        unsigned i, i_channel_mask;
        GUID guid_subformat;

        guid_subformat = p_wf_ext->SubFormat;
        guid_subformat.Data1 = GetDWLE( &p_wf_ext->SubFormat.Data1 );
        guid_subformat.Data2 = GetWLE( &p_wf_ext->SubFormat.Data2 );
        guid_subformat.Data3 = GetWLE( &p_wf_ext->SubFormat.Data3 );

        sf_tag_to_fourcc( &guid_subformat, &p_sys->fmt.i_codec, &psz_name );

        i_extended = sizeof( WAVEFORMATEXTENSIBLE ) - sizeof( WAVEFORMATEX );
        p_sys->fmt.i_extra -= i_extended;

        i_channel_mask = GetDWLE( &p_wf_ext->dwChannelMask );
        if( i_channel_mask )
        {
            for( i = 0; i < sizeof(pi_channels_src)/sizeof(uint32_t); i++ )
            {
                if( i_channel_mask & pi_channels_src[i] )
                    p_sys->i_channel_mask |= pi_channels_in[i];
            }

            if( p_sys->fmt.i_codec == VLC_FOURCC('a','r','a','w') ||
                p_sys->fmt.i_codec == VLC_FOURCC('p','c','m',' ') ||
                p_sys->fmt.i_codec == VLC_FOURCC('a','f','l','t') )

            p_sys->b_chan_reorder =
                aout_CheckChannelReorder( pi_channels_in, pi_channels_out,
                                          p_sys->i_channel_mask,
                                          p_sys->fmt.audio.i_channels,
                                          p_sys->pi_chan_table );

            msg_Dbg( p_demux, "channel mask: %x, reordering: %i",
                     p_sys->i_channel_mask, (int)p_sys->b_chan_reorder );
        }
        p_sys->fmt.audio.i_physical_channels =
            p_sys->fmt.audio.i_original_channels =
                p_sys->i_channel_mask;
    }

    if( p_sys->fmt.i_extra > 0 )
    {
        p_sys->fmt.p_extra = malloc( p_sys->fmt.i_extra );
        memcpy( p_sys->fmt.p_extra, ((uint8_t *)p_wf) + i_extended,
                p_sys->fmt.i_extra );
    }

    msg_Dbg( p_demux, "format: 0x%4.4x, fourcc: %4.4s, channels: %d, "
             "freq: %u Hz, bitrate: %uKo/s, blockalign: %d, bits/samples: %d, "
             "extra size: %d",
             GetWLE( &p_wf->wFormatTag ), (char *)&p_sys->fmt.i_codec,
             p_sys->fmt.audio.i_channels, p_sys->fmt.audio.i_rate,
             p_sys->fmt.i_bitrate / 8 / 1024, p_sys->fmt.audio.i_blockalign,
             p_sys->fmt.audio.i_bitspersample, p_sys->fmt.i_extra );

    free( p_wf );
    p_wf = NULL;

    switch( p_sys->fmt.i_codec )
    {
    case VLC_FOURCC( 'a', 'r', 'a', 'w' ):
    case VLC_FOURCC( 'a', 'f', 'l', 't' ):
    case VLC_FOURCC( 'u', 'l', 'a', 'w' ):
    case VLC_FOURCC( 'a', 'l', 'a', 'w' ):
    case VLC_FOURCC( 'm', 'l', 'a', 'w' ):
    case VLC_FOURCC( 'p', 'c', 'm', ' ' ):
        FrameInfo_PCM( p_demux, &p_sys->i_frame_size,
                       &p_sys->i_frame_samples );
        break;
    case VLC_FOURCC( 'm', 's', 0x00, 0x02 ):
        FrameInfo_MS_ADPCM( p_demux, &p_sys->i_frame_size,
                            &p_sys->i_frame_samples );
        break;
    case VLC_FOURCC( 'm', 's', 0x00, 0x11 ):
        FrameInfo_IMA_ADPCM( p_demux, &p_sys->i_frame_size,
                             &p_sys->i_frame_samples );
        break;
    case VLC_FOURCC( 'm', 's', 0x00, 0x61 ):
    case VLC_FOURCC( 'm', 's', 0x00, 0x62 ):
        /* FIXME not sure at all FIXME */
        FrameInfo_MS_ADPCM( p_demux, &p_sys->i_frame_size,
                            &p_sys->i_frame_samples );
        break;
    case VLC_FOURCC( 'm', 'p', 'g', 'a' ):
    case VLC_FOURCC( 'a', '5', '2', ' ' ):
        /* FIXME set end of area FIXME */
        goto error;
    default:
        msg_Err( p_demux, "unsupported codec (%4.4s)",
                 (char*)&p_sys->fmt.i_codec );
        goto error;
    }

    msg_Dbg( p_demux, "found %s audio format", psz_name );

    if( ChunkFind( p_demux, "data", &p_sys->i_data_size ) )
    {
        msg_Err( p_demux, "cannot find 'data' chunk" );
        goto error;
    }
    stream_Read( p_demux->s, NULL, 8 );   /* Cannot fail */
    p_sys->i_data_pos = stream_Tell( p_demux->s );

    if( p_sys->fmt.i_bitrate <= 0 )
    {
        p_sys->fmt.i_bitrate = (mtime_t)p_sys->i_frame_size *
            p_sys->fmt.audio.i_rate * 8 / p_sys->i_frame_samples;
    }

    p_sys->p_es = es_out_Add( p_demux->out, &p_sys->fmt );

    date_Init( &p_sys->pts, p_sys->fmt.audio.i_rate, 1 );
    date_Set( &p_sys->pts, 1 );

    return VLC_SUCCESS;

error:
    free( p_wf );
    free( p_sys );
    return VLC_EGENERIC;
}
