static int ty_stream_seek_pct(demux_t *p_demux, double seek_pct)
{
    demux_sys_t *p_sys = p_demux->p_sys;
    int64_t seek_pos = p_sys->i_stream_size * seek_pct;
    int i, i_cur_part;
    long l_skip_amt;

    /* if we're not seekable, there's nothing to do */
    if (!p_sys->b_seekable)
        return VLC_EGENERIC;

    /* figure out which part & chunk we want & go there */
    i_cur_part = seek_pos / TIVO_PART_LENGTH;
    p_sys->i_cur_chunk = seek_pos / CHUNK_SIZE;
    
    /* try to read the part header (master chunk) if it's there */
    if ( stream_Seek( p_demux->s, i_cur_part * TIVO_PART_LENGTH ))
    {
        /* can't seek stream */
        return VLC_EGENERIC;
    }
    parse_master(p_demux);

    /* now for the actual chunk */
    if ( stream_Seek( p_demux->s, p_sys->i_cur_chunk * CHUNK_SIZE))
    {
        /* can't seek stream */
        return VLC_EGENERIC;
    }
    /* load the chunk */
    p_sys->i_stuff_cnt = 0;
    get_chunk_header(p_demux);
  
    /* seek within the chunk to get roughly to where we want */
    p_sys->i_cur_rec = (int)
      ((double) ((seek_pos % CHUNK_SIZE) / (double) (CHUNK_SIZE)) * p_sys->i_num_recs);
    msg_Dbg(p_demux, "Seeked to file pos %"PRId64, seek_pos);
    msg_Dbg(p_demux, " (chunk %d, record %d)",
             p_sys->i_cur_chunk - 1, p_sys->i_cur_rec);

    /* seek to the start of this record's data.
     * to do that, we have to skip past all prior records */
    l_skip_amt = 0;
    for (i=0; i<p_sys->i_cur_rec; i++)
        l_skip_amt += p_sys->rec_hdrs[i].l_rec_size;
    stream_Seek(p_demux->s, ((p_sys->i_cur_chunk-1) * CHUNK_SIZE) +
                 (p_sys->i_num_recs * 16) + l_skip_amt + 4);

    /* to hell with syncing any audio or video, just start reading records... :) */
    /*p_sys->lastAudioPTS = p_sys->lastVideoPTS = 0;*/
    return VLC_SUCCESS;
}
