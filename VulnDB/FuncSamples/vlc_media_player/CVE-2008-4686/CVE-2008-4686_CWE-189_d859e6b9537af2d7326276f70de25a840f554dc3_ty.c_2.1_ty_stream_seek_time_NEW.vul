static int ty_stream_seek_time(demux_t *p_demux, uint64_t l_seek_time)
{
    demux_sys_t *p_sys = p_demux->p_sys;
    int i_seq_entry = 0;
    int i_skip_cnt;
    unsigned i;
    long l_cur_pos = stream_Tell(p_demux->s);
    unsigned i_cur_part = l_cur_pos / TIVO_PART_LENGTH;
    long l_seek_secs = l_seek_time / 1000000000;
    uint64_t l_fwd_stamp = 1;

    /* if we're not seekable, there's nothing to do */
    if (!p_sys->b_seekable || !p_sys->b_have_master)
        return VLC_EGENERIC;

    msg_Dbg(p_demux, "Skipping to time %02ld:%02ld:%02ld",
            l_seek_secs / 3600, (l_seek_secs / 60) % 60, l_seek_secs % 60);

    /* seek to the proper segment if necessary */
    /* first see if we need to go back */
    while (l_seek_time < p_sys->l_first_ty_pts) {
        msg_Dbg(p_demux, "skipping to prior segment.");
        /* load previous part */
        if (i_cur_part == 0) {
            stream_Seek(p_demux->s, l_cur_pos);
            msg_Err(p_demux, "Attempt to seek past BOF");
            return VLC_EGENERIC;
        }
        stream_Seek(p_demux->s, (i_cur_part - 1) * TIVO_PART_LENGTH);
        i_cur_part--;
        parse_master(p_demux);
    }
    /* maybe we need to go forward */
    while (l_seek_time > p_sys->l_final_ty_pts) {
        msg_Dbg(p_demux, "skipping to next segment.");
        /* load next part */
        if ((i_cur_part + 1) * TIVO_PART_LENGTH > p_sys->i_stream_size) {
            /* error; restore previous file position */
            stream_Seek(p_demux->s, l_cur_pos);
            msg_Err(p_demux, "seek error");
            return VLC_EGENERIC;
        }
        stream_Seek(p_demux->s, (i_cur_part + 1) * TIVO_PART_LENGTH);
        i_cur_part++;
        parse_master(p_demux);
    }

    /* our target is somewhere within this part;
       find the proper chunk using seq_table */
    for (i=1; i<p_sys->i_seq_table_size; i++) {
        if (p_sys->seq_table[i].l_timestamp > l_seek_time) {
            /* i-1 is the section we want; remember the next timestamp in case
               we have to use it (this section may not have a proper SEQ hdr
               for the time we're seeking) */
            msg_Dbg(p_demux, "stopping at seq entry %d.", i);
            l_fwd_stamp = p_sys->seq_table[i].l_timestamp;
            i_seq_entry = i-1;
            break;
        }
    }
    
    /* if we went through the entire last loop and didn't find our target,
       then we skip to the next part.  What has happened is that the actual
       time we're seeking is within this part, but there isn't a SEQ hdr
       for it here.  So we skip to the next part */
    if (i == p_sys->i_seq_table_size) {
        if ((i_cur_part + 1) * TIVO_PART_LENGTH > p_sys->i_stream_size) {
            /* error; restore previous file position */
            stream_Seek(p_demux->s, l_cur_pos);
            msg_Err(p_demux, "seek error");
            return VLC_EGENERIC;
        }
        stream_Seek(p_demux->s, (i_cur_part + 1) * TIVO_PART_LENGTH);
        i_cur_part++;
        parse_master(p_demux);
        i_seq_entry = 0;
    }     
     
    /* determine which chunk has our seek_time */
    for (i=0; i<p_sys->i_bits_per_seq_entry; i++) {
        long l_chunk_nr = i_seq_entry * p_sys->i_bits_per_seq_entry + i;
        long l_chunk_offset = (l_chunk_nr + 1) * CHUNK_SIZE;
        msg_Dbg(p_demux, "testing part %d chunk %ld mask 0x%02X bit %d",
            i_cur_part, l_chunk_nr,
            p_sys->seq_table[i_seq_entry].chunk_bitmask[i/8], i%8);
        if (p_sys->seq_table[i_seq_entry].chunk_bitmask[i/8] & (1 << (i%8))) {
            /* check this chunk's SEQ header timestamp */
            msg_Dbg(p_demux, "has SEQ. seeking to chunk at 0x%lX",
                (i_cur_part * TIVO_PART_LENGTH) + l_chunk_offset);
            stream_Seek(p_demux->s, (i_cur_part * TIVO_PART_LENGTH) +
                l_chunk_offset);
            // TODO: we don't have to parse the full header set;
            // just test the seq_rec entry for its timestamp
            p_sys->i_stuff_cnt = 0;
            get_chunk_header(p_demux);
            // check ty PTS for the SEQ entry in this chunk
            if (p_sys->i_seq_rec < 0 || p_sys->i_seq_rec > p_sys->i_num_recs) {
                msg_Err(p_demux, "no SEQ hdr in chunk; table had one.");
                /* Seek to beginning of original chunk & reload it */
                stream_Seek(p_demux->s, (l_cur_pos / CHUNK_SIZE) * CHUNK_SIZE);
                p_sys->i_stuff_cnt = 0;
                get_chunk_header(p_demux);
                return VLC_EGENERIC;
            }
            l_seek_secs = p_sys->rec_hdrs[p_sys->i_seq_rec].l_ty_pts /
                1000000000;
            msg_Dbg(p_demux, "found SEQ hdr for timestamp %02ld:%02ld:%02ld",
                l_seek_secs / 3600,
                (l_seek_secs / 60) % 60, l_seek_secs % 60);
            if (p_sys->rec_hdrs[p_sys->i_seq_rec].l_ty_pts >= l_seek_time) {
                // keep this one?  go back?
                /* for now, we take this one.  it's the first SEQ hdr AFTER
                   the time we were searching for. */
                msg_Dbg(p_demux, "seek target found.");
                break;
            }
            msg_Dbg(p_demux, "timestamp too early. still scanning.");
        }
    }
    /* if we made it through this entire loop without finding our target,
       then we skip to the next section.  What has happened is that the actual
       time we're seeking is within this section, but there isn't a SEQ hdr
       for it here.  So we skip to the next closest one (l_fwd_stamp) */
    if (i == p_sys->i_bits_per_seq_entry)
        return ty_stream_seek_time(p_demux, l_fwd_stamp);

    /* current stream ptr is at beginning of data for this chunk,
       so we need to skip past any stream data prior to the seq_rec
       in this chunk */
    i_skip_cnt = 0;
    for (int j=0; j<p_sys->i_seq_rec; j++)
        i_skip_cnt += p_sys->rec_hdrs[j].l_rec_size;
    stream_Read(p_demux->s, NULL, i_skip_cnt);
    p_sys->i_cur_rec = p_sys->i_seq_rec;
    //p_sys->l_last_ty_pts = p_sys->rec_hdrs[p_sys->i_seq_rec].l_ty_pts;
    //p_sys->l_last_ty_pts_sync = p_sys->lastAudioPTS;

    return VLC_SUCCESS;
}
