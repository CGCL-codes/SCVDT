static bfd_boolean
get_unwind_section_word (struct arm_unw_aux_info *  aux,
			 struct arm_section *       arm_sec,
			 Elf_Internal_Shdr *        sec,
			 bfd_vma 		    word_offset,
			 unsigned int *             wordp,
			 struct absaddr *           addr,
			 bfd_vma *		    sym_name)
{
  Elf_Internal_Rela *rp;
  Elf_Internal_Sym *sym;
  const char * relname;
  unsigned int word;
  bfd_boolean wrapped;

  if (sec == NULL || arm_sec == NULL)
    return FALSE;

  addr->section = SHN_UNDEF;
  addr->offset = 0;

  if (sym_name != NULL)
    *sym_name = (bfd_vma) -1;

  /* If necessary, update the section cache.  */
  if (sec != arm_sec->sec)
    {
      Elf_Internal_Shdr *relsec;

      arm_free_section (arm_sec);

      arm_sec->sec = sec;
      arm_sec->data = get_data (NULL, aux->file, sec->sh_offset, 1,
				sec->sh_size, _("unwind data"));
      arm_sec->rela = NULL;
      arm_sec->nrelas = 0;

      for (relsec = section_headers;
	   relsec < section_headers + elf_header.e_shnum;
	   ++relsec)
	{
	  if (relsec->sh_info >= elf_header.e_shnum
	      || section_headers + relsec->sh_info != sec
	      /* PR 15745: Check the section type as well.  */
	      || (relsec->sh_type != SHT_REL
		  && relsec->sh_type != SHT_RELA))
	    continue;

	  arm_sec->rel_type = relsec->sh_type;
	  if (relsec->sh_type == SHT_REL)
	    {
	      if (!slurp_rel_relocs (aux->file, relsec->sh_offset,
				     relsec->sh_size,
				     & arm_sec->rela, & arm_sec->nrelas))
		return FALSE;
	    }
	  else /* relsec->sh_type == SHT_RELA */
	    {
	      if (!slurp_rela_relocs (aux->file, relsec->sh_offset,
				      relsec->sh_size,
				      & arm_sec->rela, & arm_sec->nrelas))
		return FALSE;
	    }
	  break;
	}

      arm_sec->next_rela = arm_sec->rela;
    }

  /* If there is no unwind data we can do nothing.  */
  if (arm_sec->data == NULL)
    return FALSE;

  /* If the offset is invalid then fail.  */
  if (word_offset > (sec->sh_size - 4)
      /* PR 18879 */
      || (sec->sh_size < 5 && word_offset >= sec->sh_size)
      || ((bfd_signed_vma) word_offset) < 0)
    return FALSE;

  /* Get the word at the required offset.  */
  word = byte_get (arm_sec->data + word_offset, 4);

  /* PR 17531: file: id:000001,src:001266+003044,op:splice,rep:128.  */
  if (arm_sec->rela == NULL)
    {
      * wordp = word;
      return TRUE;
    }

  /* Look through the relocs to find the one that applies to the provided offset.  */
  wrapped = FALSE;
  for (rp = arm_sec->next_rela; rp != arm_sec->rela + arm_sec->nrelas; rp++)
    {
      bfd_vma prelval, offset;

      if (rp->r_offset > word_offset && !wrapped)
	{
	  rp = arm_sec->rela;
	  wrapped = TRUE;
	}
      if (rp->r_offset > word_offset)
	break;

      if (rp->r_offset & 3)
	{
	  warn (_("Skipping unexpected relocation at offset 0x%lx\n"),
		(unsigned long) rp->r_offset);
	  continue;
	}

      if (rp->r_offset < word_offset)
	continue;

      /* PR 17531: file: 027-161405-0.004  */
      if (aux->symtab == NULL)
	continue;

      if (arm_sec->rel_type == SHT_REL)
	{
	  offset = word & 0x7fffffff;
	  if (offset & 0x40000000)
	    offset |= ~ (bfd_vma) 0x7fffffff;
	}
      else if (arm_sec->rel_type == SHT_RELA)
	offset = rp->r_addend;
      else
	{
	  error (_("Unknown section relocation type %d encountered\n"),
		 arm_sec->rel_type);
	  break;
	}

      /* PR 17531 file: 027-1241568-0.004.  */
      if (ELF32_R_SYM (rp->r_info) >= aux->nsyms)
	{
	  error (_("Bad symbol index in unwind relocation (%lu > %lu)\n"),
		 (unsigned long) ELF32_R_SYM (rp->r_info), aux->nsyms);
	  break;
	}

      sym = aux->symtab + ELF32_R_SYM (rp->r_info);
      offset += sym->st_value;
      prelval = offset - (arm_sec->sec->sh_addr + rp->r_offset);

      /* Check that we are processing the expected reloc type.  */
      if (elf_header.e_machine == EM_ARM)
	{
	  relname = elf_arm_reloc_type (ELF32_R_TYPE (rp->r_info));
	  if (relname == NULL)
	    {
	      warn (_("Skipping unknown ARM relocation type: %d\n"),
		    (int) ELF32_R_TYPE (rp->r_info));
	      continue;
	    }

	  if (streq (relname, "R_ARM_NONE"))
	      continue;

	  if (! streq (relname, "R_ARM_PREL31"))
	    {
	      warn (_("Skipping unexpected ARM relocation type %s\n"), relname);
	      continue;
	    }
	}
      else if (elf_header.e_machine == EM_TI_C6000)
	{
	  relname = elf_tic6x_reloc_type (ELF32_R_TYPE (rp->r_info));
	  if (relname == NULL)
	    {
	      warn (_("Skipping unknown C6000 relocation type: %d\n"),
		    (int) ELF32_R_TYPE (rp->r_info));
	      continue;
	    }

	  if (streq (relname, "R_C6000_NONE"))
	    continue;

	  if (! streq (relname, "R_C6000_PREL31"))
	    {
	      warn (_("Skipping unexpected C6000 relocation type %s\n"), relname);
	      continue;
	    }

	  prelval >>= 1;
	}
      else
	{
	  /* This function currently only supports ARM and TI unwinders.  */
	  warn (_("Only TI and ARM unwinders are currently supported\n"));
	  break;
	}

      word = (word & ~ (bfd_vma) 0x7fffffff) | (prelval & 0x7fffffff);
      addr->section = sym->st_shndx;
      addr->offset = offset;

      if (sym_name)
	* sym_name = sym->st_name;
      break;
    }

  *wordp = word;
  arm_sec->next_rela = rp;

  return TRUE;
}
