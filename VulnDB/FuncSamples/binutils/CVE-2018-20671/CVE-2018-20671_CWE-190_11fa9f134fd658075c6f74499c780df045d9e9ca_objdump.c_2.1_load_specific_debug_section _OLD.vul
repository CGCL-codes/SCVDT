static bfd_boolean
load_specific_debug_section (enum dwarf_section_display_enum debug,
			     asection *sec, void *file)
{
  struct dwarf_section *section = &debug_displays [debug].section;
  bfd *abfd = (bfd *) file;
  bfd_byte *contents;
  bfd_size_type amt;

  if (section->start != NULL)
    {
      /* If it is already loaded, do nothing.  */
      if (streq (section->filename, bfd_get_filename (abfd)))
	return TRUE;
      free (section->start);
    }

  section->filename = bfd_get_filename (abfd);
  section->reloc_info = NULL;
  section->num_relocs = 0;
  section->address = bfd_get_section_vma (abfd, sec);
  section->size = bfd_get_section_size (sec);
  amt = section->size + 1;
  section->start = contents = malloc (amt);
  section->user_data = sec;
  if (amt == 0
      || section->start == NULL
      || !bfd_get_full_section_contents (abfd, sec, &contents))
    {
      free_debug_section (debug);
      printf (_("\nCan't get contents for section '%s'.\n"),
	      section->name);
      return FALSE;
    }
  /* Ensure any string section has a terminating NUL.  */
  section->start[section->size] = 0;

  if (is_relocatable && debug_displays [debug].relocate)
    {
      long         reloc_size;
      bfd_boolean  ret;

      bfd_cache_section_contents (sec, section->start);

      ret = bfd_simple_get_relocated_section_contents (abfd,
						       sec,
						       section->start,
						       syms) != NULL;

      if (! ret)
        {
          free_debug_section (debug);
          printf (_("\nCan't get contents for section '%s'.\n"),
	          section->name);
          return FALSE;
        }

      reloc_size = bfd_get_reloc_upper_bound (abfd, sec);
      if (reloc_size > 0)
	{
	  unsigned long reloc_count;
	  arelent **relocs;

	  relocs = (arelent **) xmalloc (reloc_size);

	  reloc_count = bfd_canonicalize_reloc (abfd, sec, relocs, NULL);
	  if (reloc_count == 0)
	    free (relocs);
	  else
	    {
	      section->reloc_info = relocs;
	      section->num_relocs = reloc_count;
	    }
	}
    }

  return TRUE;
}
