static void
print_symbol (bfd *        abfd,
	      asymbol *    sym,
	      bfd_vma      ssize,
	      bfd *        archive_bfd)
{
  symbol_info syminfo;
  struct extended_symbol_info info;

  PROGRESS (1);

  format->print_symbol_filename (archive_bfd, abfd);

  bfd_get_symbol_info (abfd, sym, &syminfo);

  info.sinfo = &syminfo;
  info.ssize = ssize;
  /* Synthetic symbols do not have a full symbol type set of data available.
     Nor do bfd/section.c:global_syms like *ABS*.  */
  if ((sym->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) != 0)
    {
      info.elfinfo = NULL;
      info.coffinfo = NULL;
    }
  else
    {
      info.elfinfo = elf_symbol_from (abfd, sym);
      info.coffinfo = coff_symbol_from (sym);
    }

  format->print_symbol_info (&info, abfd);

  if (with_symbol_versions)
    {
      const char *  version_string = NULL;
      bfd_boolean   hidden = FALSE;

      if ((sym->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) == 0)
	version_string = bfd_get_symbol_version_string (abfd, sym, &hidden);

      if (bfd_is_und_section (bfd_get_section (sym)))
	hidden = TRUE;

      if (version_string && *version_string != '\0')
	printf (hidden ? "@%s" : "@@%s", version_string);
    }

  if (line_numbers)
    {
      static asymbol **syms;
      static long symcount;
      const char *filename, *functionname;
      unsigned int lineno;

      /* We need to get the canonical symbols in order to call
         bfd_find_nearest_line.  This is inefficient, but, then, you
         don't have to use --line-numbers.  */
      if (abfd != lineno_cache_bfd && syms != NULL)
	{
	  free (syms);
	  syms = NULL;
	}
      if (syms == NULL)
	{
	  long symsize;

	  symsize = bfd_get_symtab_upper_bound (abfd);
	  if (symsize < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	  syms = (asymbol **) xmalloc (symsize);
	  symcount = bfd_canonicalize_symtab (abfd, syms);
	  if (symcount < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	  lineno_cache_bfd = abfd;
	}

      if (bfd_is_und_section (bfd_get_section (sym)))
	{
	  static asection **secs;
	  static arelent ***relocs;
	  static long *relcount;
	  static unsigned int seccount;
	  unsigned int i;
	  const char *symname;

	  /* For an undefined symbol, we try to find a reloc for the
             symbol, and print the line number of the reloc.  */
	  if (abfd != lineno_cache_rel_bfd && relocs != NULL)
	    {
	      for (i = 0; i < seccount; i++)
		if (relocs[i] != NULL)
		  free (relocs[i]);
	      free (secs);
	      free (relocs);
	      free (relcount);
	      secs = NULL;
	      relocs = NULL;
	      relcount = NULL;
	    }

	  if (relocs == NULL)
	    {
	      struct get_relocs_info rinfo;

	      seccount = bfd_count_sections (abfd);

	      secs = (asection **) xmalloc (seccount * sizeof *secs);
	      relocs = (arelent ***) xmalloc (seccount * sizeof *relocs);
	      relcount = (long *) xmalloc (seccount * sizeof *relcount);

	      rinfo.secs = secs;
	      rinfo.relocs = relocs;
	      rinfo.relcount = relcount;
	      rinfo.syms = syms;
	      bfd_map_over_sections (abfd, get_relocs, (void *) &rinfo);
	      lineno_cache_rel_bfd = abfd;
	    }

	  symname = bfd_asymbol_name (sym);
	  for (i = 0; i < seccount; i++)
	    {
	      long j;

	      for (j = 0; j < relcount[i]; j++)
		{
		  arelent *r;

		  r = relocs[i][j];
		  if (r->sym_ptr_ptr != NULL
		      && (*r->sym_ptr_ptr)->section == sym->section
		      && (*r->sym_ptr_ptr)->value == sym->value
		      && strcmp (symname,
				 bfd_asymbol_name (*r->sym_ptr_ptr)) == 0
		      && bfd_find_nearest_line (abfd, secs[i], syms,
						r->address, &filename,
						&functionname, &lineno)
		      && filename != NULL)
		    {
		      /* We only print the first one we find.  */
		      printf ("\t%s:%u", filename, lineno);
		      i = seccount;
		      break;
		    }
		}
	    }
	}
      else if (bfd_get_section (sym)->owner == abfd)
	{
	  if ((bfd_find_line (abfd, syms, sym, &filename, &lineno)
	       || bfd_find_nearest_line (abfd, bfd_get_section (sym),
					 syms, sym->value, &filename,
					 &functionname, &lineno))
	      && filename != NULL
	      && lineno != 0)
	    printf ("\t%s:%u", filename, lineno);
	}
    }

  putchar ('\n');
}
