static bfd_boolean
pe_print_idata (bfd * abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data;
  asection *section;
  bfd_signed_vma adj;

#ifdef POWERPC_LE_PE
  asection *rel_section = bfd_get_section_by_name (abfd, ".reldata");
#endif

  bfd_size_type datasize = 0;
  bfd_size_type dataoff;
  bfd_size_type i;
  int onaline = 20;

  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;

  bfd_vma addr;

  addr = extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress;

  if (addr == 0 && extra->DataDirectory[PE_IMPORT_TABLE].Size == 0)
    {
      /* Maybe the extra header isn't there.  Look for the section.  */
      section = bfd_get_section_by_name (abfd, ".idata");
      if (section == NULL)
	return TRUE;

      addr = section->vma;
      datasize = section->size;
      if (datasize == 0)
	return TRUE;
    }
  else
    {
      addr += extra->ImageBase;
      for (section = abfd->sections; section != NULL; section = section->next)
	{
	  datasize = section->size;
	  if (addr >= section->vma && addr < section->vma + datasize)
	    break;
	}

      if (section == NULL)
	{
	  fprintf (file,
		   _("\nThere is an import table, but the section containing it could not be found\n"));
	  return TRUE;
	}
      else if (!(section->flags & SEC_HAS_CONTENTS))
        {
	  fprintf (file,
		   _("\nThere is an import table in %s, but that section has no contents\n"),
		   section->name);
	  return TRUE;
        }
    }

  /* xgettext:c-format */
  fprintf (file, _("\nThere is an import table in %s at 0x%lx\n"),
	   section->name, (unsigned long) addr);

  dataoff = addr - section->vma;

#ifdef POWERPC_LE_PE
  if (rel_section != 0 && rel_section->size != 0)
    {
      /* The toc address can be found by taking the starting address,
	 which on the PPC locates a function descriptor. The
	 descriptor consists of the function code starting address
	 followed by the address of the toc. The starting address we
	 get from the bfd, and the descriptor is supposed to be in the
	 .reldata section.  */

      bfd_vma loadable_toc_address;
      bfd_vma toc_address;
      bfd_vma start_address;
      bfd_byte *data;
      bfd_vma offset;

      if (!bfd_malloc_and_get_section (abfd, rel_section, &data))
	{
	  if (data != NULL)
	    free (data);
	  return FALSE;
	}

      offset = abfd->start_address - rel_section->vma;

      if (offset >= rel_section->size || offset + 8 > rel_section->size)
        {
          if (data != NULL)
            free (data);
          return FALSE;
        }

      start_address = bfd_get_32 (abfd, data + offset);
      loadable_toc_address = bfd_get_32 (abfd, data + offset + 4);
      toc_address = loadable_toc_address - 32768;

      fprintf (file,
	       _("\nFunction descriptor located at the start address: %04lx\n"),
	       (unsigned long int) (abfd->start_address));
      fprintf (file,
	       /* xgettext:c-format */
	       _("\tcode-base %08lx toc (loadable/actual) %08lx/%08lx\n"),
	       start_address, loadable_toc_address, toc_address);
      if (data != NULL)
	free (data);
    }
  else
    {
      fprintf (file,
	       _("\nNo reldata section! Function descriptor not decoded.\n"));
    }
#endif

  fprintf (file,
	   _("\nThe Import Tables (interpreted %s section contents)\n"),
	   section->name);
  fprintf (file,
	   _("\
 vma:            Hint    Time      Forward  DLL       First\n\
                 Table   Stamp     Chain    Name      Thunk\n"));

  /* Read the whole section.  Some of the fields might be before dataoff.  */
  if (!bfd_malloc_and_get_section (abfd, section, &data))
    {
      if (data != NULL)
	free (data);
      return FALSE;
    }

  adj = section->vma - extra->ImageBase;

  /* Print all image import descriptors.  */
  for (i = dataoff; i + onaline <= datasize; i += onaline)
    {
      bfd_vma hint_addr;
      bfd_vma time_stamp;
      bfd_vma forward_chain;
      bfd_vma dll_name;
      bfd_vma first_thunk;
      int idx = 0;
      bfd_size_type j;
      char *dll;

      /* Print (i + extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress).  */
      fprintf (file, " %08lx\t", (unsigned long) (i + adj));
      hint_addr = bfd_get_32 (abfd, data + i);
      time_stamp = bfd_get_32 (abfd, data + i + 4);
      forward_chain = bfd_get_32 (abfd, data + i + 8);
      dll_name = bfd_get_32 (abfd, data + i + 12);
      first_thunk = bfd_get_32 (abfd, data + i + 16);

      fprintf (file, "%08lx %08lx %08lx %08lx %08lx\n",
	       (unsigned long) hint_addr,
	       (unsigned long) time_stamp,
	       (unsigned long) forward_chain,
	       (unsigned long) dll_name,
	       (unsigned long) first_thunk);

      if (hint_addr == 0 && first_thunk == 0)
	break;

      if (dll_name - adj >= section->size)
        break;

      dll = (char *) data + dll_name - adj;
      /* PR 17512 file: 078-12277-0.004.  */
      bfd_size_type maxlen = (char *)(data + datasize) - dll - 1;
      fprintf (file, _("\n\tDLL Name: %.*s\n"), (int) maxlen, dll);

      /* PR 21546: When the Hint Address is zero,
	 we try the First Thunk instead.  */
      if (hint_addr == 0)
	hint_addr = first_thunk;

      if (hint_addr != 0)
	{
	  bfd_byte *ft_data;
	  asection *ft_section;
	  bfd_vma ft_addr;
	  bfd_size_type ft_datasize;
	  int ft_idx;
	  int ft_allocated;

	  fprintf (file, _("\tvma:  Hint/Ord Member-Name Bound-To\n"));

	  idx = hint_addr - adj;

	  ft_addr = first_thunk + extra->ImageBase;
	  ft_idx = first_thunk - adj;
	  ft_data = data + ft_idx;
	  ft_datasize = datasize - ft_idx;
	  ft_allocated = 0;

	  if (first_thunk != hint_addr)
	    {
	      /* Find the section which contains the first thunk.  */
	      for (ft_section = abfd->sections;
		   ft_section != NULL;
		   ft_section = ft_section->next)
		{
		  if (ft_addr >= ft_section->vma
		      && ft_addr < ft_section->vma + ft_section->size)
		    break;
		}

	      if (ft_section == NULL)
		{
		  fprintf (file,
		       _("\nThere is a first thunk, but the section containing it could not be found\n"));
		  continue;
		}

	      /* Now check to see if this section is the same as our current
		 section.  If it is not then we will have to load its data in.  */
	      if (ft_section != section)
		{
		  ft_idx = first_thunk - (ft_section->vma - extra->ImageBase);
		  ft_datasize = ft_section->size - ft_idx;
		  ft_data = (bfd_byte *) bfd_malloc (ft_datasize);
		  if (ft_data == NULL)
		    continue;

		  /* Read ft_datasize bytes starting at offset ft_idx.  */
		  if (!bfd_get_section_contents (abfd, ft_section, ft_data,
						 (bfd_vma) ft_idx, ft_datasize))
		    {
		      free (ft_data);
		      continue;
		    }
		  ft_allocated = 1;
		}
	    }

	  /* Print HintName vector entries.  */
#ifdef COFF_WITH_pex64
	  for (j = 0; idx + j + 8 <= datasize; j += 8)
	    {
	      bfd_size_type amt;
	      unsigned long member = bfd_get_32 (abfd, data + idx + j);
	      unsigned long member_high = bfd_get_32 (abfd, data + idx + j + 4);

	      if (!member && !member_high)
		break;

	      amt = member - adj;

	      if (HighBitSet (member_high))
		fprintf (file, "\t%lx%08lx\t %4lx%08lx  <none>",
			 member_high, member,
			 WithoutHighBit (member_high), member);
	      /* PR binutils/17512: Handle corrupt PE data.  */
	      else if (amt + 2 >= datasize)
		fprintf (file, _("\t<corrupt: 0x%04lx>"), member);
	      else
		{
		  int ordinal;
		  char *member_name;

		  ordinal = bfd_get_16 (abfd, data + amt);
		  member_name = (char *) data + amt + 2;
		  fprintf (file, "\t%04lx\t %4d  %.*s",member, ordinal,
			   (int) (datasize - (amt + 2)), member_name);
		}

	      /* If the time stamp is not zero, the import address
		 table holds actual addresses.  */
	      if (time_stamp != 0
		  && first_thunk != 0
		  && first_thunk != hint_addr
		  && j + 4 <= ft_datasize)
		fprintf (file, "\t%04lx",
			 (unsigned long) bfd_get_32 (abfd, ft_data + j));
	      fprintf (file, "\n");
	    }
#else
	  for (j = 0; idx + j + 4 <= datasize; j += 4)
	    {
	      bfd_size_type amt;
	      unsigned long member = bfd_get_32 (abfd, data + idx + j);

	      /* Print single IMAGE_IMPORT_BY_NAME vector.  */
	      if (member == 0)
		break;

	      amt = member - adj;
	      if (HighBitSet (member))
		fprintf (file, "\t%04lx\t %4lu  <none>",
			 member, WithoutHighBit (member));
	      /* PR binutils/17512: Handle corrupt PE data.  */
	      else if (amt + 2 >= datasize)
		fprintf (file, _("\t<corrupt: 0x%04lx>"), member);
	      else
		{
		  int ordinal;
		  char *member_name;

		  ordinal = bfd_get_16 (abfd, data + amt);
		  member_name = (char *) data + amt + 2;
		  fprintf (file, "\t%04lx\t %4d  %.*s",
			   member, ordinal,
			   (int) (datasize - (amt + 2)), member_name);
		}

	      /* If the time stamp is not zero, the import address
		 table holds actual addresses.  */
	      if (time_stamp != 0
		  && first_thunk != 0
		  && first_thunk != hint_addr
		  && j + 4 <= ft_datasize)
		fprintf (file, "\t%04lx",
			 (unsigned long) bfd_get_32 (abfd, ft_data + j));

	      fprintf (file, "\n");
	    }
#endif
	  if (ft_allocated)
	    free (ft_data);
	}

      fprintf (file, "\n");
    }

  free (data);

  return TRUE;
}
