static bfd_boolean
read_section (bfd *           abfd,
	      const struct dwarf_debug_section *sec,
	      asymbol **      syms,
	      bfd_uint64_t    offset,
	      bfd_byte **     section_buffer,
	      bfd_size_type * section_size)
{
  asection *msec;
  const char *section_name = sec->uncompressed_name;

  /* The section may have already been read.  */
  if (*section_buffer == NULL)
    {
      msec = bfd_get_section_by_name (abfd, section_name);
      if (! msec)
	{
	  section_name = sec->compressed_name;
	  if (section_name != NULL)
	    msec = bfd_get_section_by_name (abfd, section_name);
	}
      if (! msec)
	{
	  _bfd_error_handler (_("Dwarf Error: Can't find %s section."),
			      sec->uncompressed_name);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      *section_size = msec->rawsize ? msec->rawsize : msec->size;
      if (syms)
	{
	  *section_buffer
	    = bfd_simple_get_relocated_section_contents (abfd, msec, NULL, syms);
	  if (! *section_buffer)
	    return FALSE;
	}
      else
	{
	  *section_buffer = (bfd_byte *) bfd_malloc (*section_size);
	  if (! *section_buffer)
	    return FALSE;
	  if (! bfd_get_section_contents (abfd, msec, *section_buffer,
					  0, *section_size))
	    return FALSE;
	}

      /* Paranoia - if we are reading in a string section, make sure that it
	 is NUL terminated.  This is to prevent string functions from running
	 off the end of the buffer.  Note - knowing the size of the buffer is
	 not enough as some functions, eg strchr, do not have a range limited
	 equivalent.

	 FIXME: We ought to use a flag in the dwarf_debug_sections[] table to
	 determine the nature of a debug section, rather than checking the
	 section name as we do here.  */
      if (*section_size > 0
	  && (*section_buffer)[*section_size - 1] != 0
	  && (strstr (section_name, "_str") || strstr (section_name, "names")))
	{
	  bfd_byte * new_buffer = malloc (*section_size + 1);

	  _bfd_error_handler (_("warning: dwarf string section '%s' is not NUL terminated"),
			      section_name);
	  memcpy (new_buffer, *section_buffer, *section_size);
	  new_buffer[*section_size] = 0;
	  free (*section_buffer);
	  *section_buffer = new_buffer;
	}
    }

  /* It is possible to get a bad value for the offset into the section
     that the client wants.  Validate it here to avoid trouble later.  */
  if (offset != 0 && offset >= *section_size)
    {
      /* xgettext: c-format */
      _bfd_error_handler (_("Dwarf Error: Offset (%llu)"
			    " greater than or equal to %s size (%Lu)."),
			  (long long) offset, section_name, *section_size);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  return TRUE;
}
