static bfd_boolean
pe_print_edata (bfd * abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data;
  asection *section;
  bfd_size_type datasize = 0;
  bfd_size_type dataoff;
  bfd_size_type i;
  bfd_vma       adj;
  struct EDT_type
  {
    long export_flags;		/* Reserved - should be zero.  */
    long time_stamp;
    short major_ver;
    short minor_ver;
    bfd_vma name;		/* RVA - relative to image base.  */
    long base;			/* Ordinal base.  */
    unsigned long num_functions;/* Number in the export address table.  */
    unsigned long num_names;	/* Number in the name pointer table.  */
    bfd_vma eat_addr;		/* RVA to the export address table.  */
    bfd_vma npt_addr;		/* RVA to the Export Name Pointer Table.  */
    bfd_vma ot_addr;		/* RVA to the Ordinal Table.  */
  } edt;

  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;

  bfd_vma addr;

  addr = extra->DataDirectory[PE_EXPORT_TABLE].VirtualAddress;

  if (addr == 0 && extra->DataDirectory[PE_EXPORT_TABLE].Size == 0)
    {
      /* Maybe the extra header isn't there.  Look for the section.  */
      section = bfd_get_section_by_name (abfd, ".edata");
      if (section == NULL)
	return TRUE;

      addr = section->vma;
      dataoff = 0;
      datasize = section->size;
      if (datasize == 0)
	return TRUE;
    }
  else
    {
      addr += extra->ImageBase;

      for (section = abfd->sections; section != NULL; section = section->next)
	if (addr >= section->vma && addr < section->vma + section->size)
	  break;

      if (section == NULL)
	{
	  fprintf (file,
		   _("\nThere is an export table, but the section containing it could not be found\n"));
	  return TRUE;
	}
      else if (!(section->flags & SEC_HAS_CONTENTS))
	{
	  fprintf (file,
		   _("\nThere is an export table in %s, but that section has no contents\n"),
		   section->name);
	  return TRUE;
	}

      dataoff = addr - section->vma;
      datasize = extra->DataDirectory[PE_EXPORT_TABLE].Size;
      if (dataoff > section->size
	  || datasize > section->size - dataoff)
	{
	  fprintf (file,
		   _("\nThere is an export table in %s, but it does not fit into that section\n"),
		   section->name);
	  return TRUE;
	}
    }

  /* PR 17512: Handle corrupt PE binaries.  */
  if (datasize < 40)
    {
      fprintf (file,
	       /* xgettext:c-format */
	       _("\nThere is an export table in %s, but it is too small (%d)\n"),
	       section->name, (int) datasize);
      return TRUE;
    }

  /* xgettext:c-format */
  fprintf (file, _("\nThere is an export table in %s at 0x%lx\n"),
	   section->name, (unsigned long) addr);

  data = (bfd_byte *) bfd_malloc (datasize);
  if (data == NULL)
    return FALSE;

  if (! bfd_get_section_contents (abfd, section, data,
				  (file_ptr) dataoff, datasize))
    return FALSE;

  /* Go get Export Directory Table.  */
  edt.export_flags   = bfd_get_32 (abfd, data +	 0);
  edt.time_stamp     = bfd_get_32 (abfd, data +	 4);
  edt.major_ver	     = bfd_get_16 (abfd, data +	 8);
  edt.minor_ver	     = bfd_get_16 (abfd, data + 10);
  edt.name	     = bfd_get_32 (abfd, data + 12);
  edt.base	     = bfd_get_32 (abfd, data + 16);
  edt.num_functions  = bfd_get_32 (abfd, data + 20);
  edt.num_names	     = bfd_get_32 (abfd, data + 24);
  edt.eat_addr	     = bfd_get_32 (abfd, data + 28);
  edt.npt_addr	     = bfd_get_32 (abfd, data + 32);
  edt.ot_addr	     = bfd_get_32 (abfd, data + 36);

  adj = section->vma - extra->ImageBase + dataoff;

  /* Dump the EDT first.  */
  fprintf (file,
	   _("\nThe Export Tables (interpreted %s section contents)\n\n"),
	   section->name);

  fprintf (file,
	   _("Export Flags \t\t\t%lx\n"), (unsigned long) edt.export_flags);

  fprintf (file,
	   _("Time/Date stamp \t\t%lx\n"), (unsigned long) edt.time_stamp);

  fprintf (file,
	   /* xgettext:c-format */
	   _("Major/Minor \t\t\t%d/%d\n"), edt.major_ver, edt.minor_ver);

  fprintf (file,
	   _("Name \t\t\t\t"));
  bfd_fprintf_vma (abfd, file, edt.name);

  if ((edt.name >= adj) && (edt.name < adj + datasize))
    fprintf (file, " %.*s\n",
	     (int) (datasize - (edt.name - adj)),
	     data + edt.name - adj);
  else
    fprintf (file, "(outside .edata section)\n");

  fprintf (file,
	   _("Ordinal Base \t\t\t%ld\n"), edt.base);

  fprintf (file,
	   _("Number in:\n"));

  fprintf (file,
	   _("\tExport Address Table \t\t%08lx\n"),
	   edt.num_functions);

  fprintf (file,
	   _("\t[Name Pointer/Ordinal] Table\t%08lx\n"), edt.num_names);

  fprintf (file,
	   _("Table Addresses\n"));

  fprintf (file,
	   _("\tExport Address Table \t\t"));
  bfd_fprintf_vma (abfd, file, edt.eat_addr);
  fprintf (file, "\n");

  fprintf (file,
	   _("\tName Pointer Table \t\t"));
  bfd_fprintf_vma (abfd, file, edt.npt_addr);
  fprintf (file, "\n");

  fprintf (file,
	   _("\tOrdinal Table \t\t\t"));
  bfd_fprintf_vma (abfd, file, edt.ot_addr);
  fprintf (file, "\n");

  /* The next table to find is the Export Address Table. It's basically
     a list of pointers that either locate a function in this dll, or
     forward the call to another dll. Something like:
      typedef union
      {
	long export_rva;
	long forwarder_rva;
      } export_address_table_entry;  */

  fprintf (file,
	  _("\nExport Address Table -- Ordinal Base %ld\n"),
	  edt.base);

  /* PR 17512: Handle corrupt PE binaries.  */
  /* PR 17512 file: 140-165018-0.004.  */
  if (edt.eat_addr - adj >= datasize
      /* PR 17512: file: 092b1829 */
      || (edt.num_functions + 1) * 4 < edt.num_functions
      || edt.eat_addr - adj + (edt.num_functions + 1) * 4 > datasize)
    fprintf (file, _("\tInvalid Export Address Table rva (0x%lx) or entry count (0x%lx)\n"),
	     (long) edt.eat_addr,
	     (long) edt.num_functions);
  else for (i = 0; i < edt.num_functions; ++i)
    {
      bfd_vma eat_member = bfd_get_32 (abfd,
				       data + edt.eat_addr + (i * 4) - adj);
      if (eat_member == 0)
	continue;

      if (eat_member - adj <= datasize)
	{
	  /* This rva is to a name (forwarding function) in our section.  */
	  /* Should locate a function descriptor.  */
	  fprintf (file,
		   "\t[%4ld] +base[%4ld] %04lx %s -- %.*s\n",
		   (long) i,
		   (long) (i + edt.base),
		   (unsigned long) eat_member,
		   _("Forwarder RVA"),
		   (int)(datasize - (eat_member - adj)),
		   data + eat_member - adj);
	}
      else
	{
	  /* Should locate a function descriptor in the reldata section.  */
	  fprintf (file,
		   "\t[%4ld] +base[%4ld] %04lx %s\n",
		   (long) i,
		   (long) (i + edt.base),
		   (unsigned long) eat_member,
		   _("Export RVA"));
	}
    }

  /* The Export Name Pointer Table is paired with the Export Ordinal Table.  */
  /* Dump them in parallel for clarity.  */
  fprintf (file,
	   _("\n[Ordinal/Name Pointer] Table\n"));

  /* PR 17512: Handle corrupt PE binaries.  */
  if (edt.npt_addr + (edt.num_names * 4) - adj >= datasize
      /* PR 17512: file: bb68816e.  */
      || edt.num_names * 4 < edt.num_names
      || (data + edt.npt_addr - adj) < data)
    /* xgettext:c-format */
    fprintf (file, _("\tInvalid Name Pointer Table rva (0x%lx) or entry count (0x%lx)\n"),
	     (long) edt.npt_addr,
	     (long) edt.num_names);
  /* PR 17512: file: 140-147171-0.004.  */
  else if (edt.ot_addr + (edt.num_names * 2) - adj >= datasize
	   || data + edt.ot_addr - adj < data)
    /* xgettext:c-format */
    fprintf (file, _("\tInvalid Ordinal Table rva (0x%lx) or entry count (0x%lx)\n"),
	     (long) edt.ot_addr,
	     (long) edt.num_names);
  else for (i = 0; i < edt.num_names; ++i)
    {
      bfd_vma  name_ptr;
      bfd_vma  ord;

      ord = bfd_get_16 (abfd, data + edt.ot_addr + (i * 2) - adj);
      name_ptr = bfd_get_32 (abfd, data + edt.npt_addr + (i * 4) - adj);

      if ((name_ptr - adj) >= datasize)
	{
	  /* xgettext:c-format */
	  fprintf (file, _("\t[%4ld] <corrupt offset: %lx>\n"),
		   (long) ord, (long) name_ptr);
	}
      else
	{
	  char * name = (char *) data + name_ptr - adj;

	  fprintf (file, "\t[%4ld] %.*s\n", (long) ord,
		   (int)((char *)(data + datasize) - name), name);
	}
    }

  free (data);

  return TRUE;
}
