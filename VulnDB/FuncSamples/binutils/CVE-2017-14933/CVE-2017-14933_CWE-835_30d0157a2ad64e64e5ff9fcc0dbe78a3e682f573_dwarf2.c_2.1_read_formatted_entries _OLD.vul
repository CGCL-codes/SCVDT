static bfd_boolean
read_formatted_entries (struct comp_unit *unit, bfd_byte **bufp,
			bfd_byte *buf_end, struct line_info_table *table,
			bfd_boolean (*callback) (struct line_info_table *table,
						 char *cur_file,
						 unsigned int dir,
						 unsigned int time,
						 unsigned int size))
{
  bfd *abfd = unit->abfd;
  bfd_byte format_count, formati;
  bfd_vma data_count, datai;
  bfd_byte *buf = *bufp;
  bfd_byte *format_header_data;
  unsigned int bytes_read;

  format_count = read_1_byte (abfd, buf, buf_end);
  buf += 1;
  format_header_data = buf;
  for (formati = 0; formati < format_count; formati++)
    {
      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);
      buf += bytes_read;
      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);
      buf += bytes_read;
    }

  data_count = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);
  buf += bytes_read;
  if (format_count == 0 && data_count != 0)
    {
      _bfd_error_handler (_("Dwarf Error: Zero format count."));
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  for (datai = 0; datai < data_count; datai++)
    {
      bfd_byte *format = format_header_data;
      struct fileinfo fe;

      memset (&fe, 0, sizeof fe);
      for (formati = 0; formati < format_count; formati++)
	{
	  bfd_vma content_type, form;
	  char *string_trash;
	  char **stringp = &string_trash;
	  unsigned int uint_trash, *uintp = &uint_trash;

	  content_type = _bfd_safe_read_leb128 (abfd, format, &bytes_read,
						FALSE, buf_end);
	  format += bytes_read;
	  switch (content_type)
	    {
	    case DW_LNCT_path:
	      stringp = &fe.name;
	      break;
	    case DW_LNCT_directory_index:
	      uintp = &fe.dir;
	      break;
	    case DW_LNCT_timestamp:
	      uintp = &fe.time;
	      break;
	    case DW_LNCT_size:
	      uintp = &fe.size;
	      break;
	    case DW_LNCT_MD5:
	      break;
	    default:
	      _bfd_error_handler
		(_("Dwarf Error: Unknown format content type %Lu."),
		 content_type);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }

	  form = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE,
					buf_end);
	  format += bytes_read;
	  switch (form)
	    {
	    case DW_FORM_string:
	      *stringp = read_string (abfd, buf, buf_end, &bytes_read);
	      buf += bytes_read;
	      break;

	    case DW_FORM_line_strp:
	      *stringp = read_indirect_line_string (unit, buf, buf_end, &bytes_read);
	      buf += bytes_read;
	      break;

	    case DW_FORM_data1:
	      *uintp = read_1_byte (abfd, buf, buf_end);
	      buf += 1;
	      break;

	    case DW_FORM_data2:
	      *uintp = read_2_bytes (abfd, buf, buf_end);
	      buf += 2;
	      break;

	    case DW_FORM_data4:
	      *uintp = read_4_bytes (abfd, buf, buf_end);
	      buf += 4;
	      break;

	    case DW_FORM_data8:
	      *uintp = read_8_bytes (abfd, buf, buf_end);
	      buf += 8;
	      break;

	    case DW_FORM_udata:
	      *uintp = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE,
					      buf_end);
	      buf += bytes_read;
	      break;

	    case DW_FORM_block:
	      /* It is valid only for DW_LNCT_timestamp which is ignored by
		 current GDB.  */
	      break;
	    }
	}

      if (!callback (table, fe.name, fe.dir, fe.time, fe.size))
	return FALSE;
    }

  *bufp = buf;
  return TRUE;
}
