Document* XSLTProcessor::CreateDocumentFromSource(
    const String& source_string,
    const String& source_encoding,
    const String& source_mime_type,
    Node* source_node,
    LocalFrame* frame) {
  KURL url = NullURL();
  Document* owner_document = &source_node->GetDocument();
  if (owner_document == source_node)
    url = owner_document->Url();

  DocumentInit init = DocumentInit::Create().WithFrame(frame).WithURL(url);

  String document_source = source_string;
  bool force_xhtml = source_mime_type == "text/plain";
  if (force_xhtml)
    TransformTextStringToXHTMLDocumentString(document_source);

  Document* result = nullptr;

  if (frame) {
    Document* old_document = frame->GetDocument();
    // Before parsing, we need to save & detach the old document and get the new
    // document in place. Document::Shutdown() tears down the LocalFrameView, so
    // remember whether or not there was one.
    bool has_view = frame->View();
    old_document->Shutdown();
    // Re-create the LocalFrameView if needed.
    if (has_view)
      frame->Client()->TransitionToCommittedForNewPage();
    result = frame->DomWindow()->InstallNewDocument(source_mime_type, init,
                                                    force_xhtml);

    if (old_document) {
      DocumentXSLT::From(*result).SetTransformSourceDocument(old_document);
      result->UpdateSecurityOrigin(old_document->GetSecurityOrigin());
      result->SetCookieURL(old_document->CookieURL());

      ContentSecurityPolicy* csp = ContentSecurityPolicy::Create();
      csp->CopyStateFrom(old_document->GetContentSecurityPolicy());
      result->InitContentSecurityPolicy(csp);
    }
  } else {
    result =
        LocalDOMWindow::CreateDocument(source_mime_type, init, force_xhtml);
  }

  DocumentEncodingData data;
  data.SetEncoding(source_encoding.IsEmpty()
                       ? UTF8Encoding()
                       : WTF::TextEncoding(source_encoding));
  result->SetEncodingData(data);
  result->SetContent(document_source);

  return result;
}
