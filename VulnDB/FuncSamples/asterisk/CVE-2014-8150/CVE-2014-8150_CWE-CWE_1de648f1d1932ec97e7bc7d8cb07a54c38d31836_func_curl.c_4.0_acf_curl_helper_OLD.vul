static int acf_curl_helper(struct ast_channel *chan, const char *cmd, char *info, char *buf, struct ast_str **input_str, ssize_t len)
{
	struct ast_str *escapebuf = ast_str_thread_get(&thread_escapebuf, 16);
	struct ast_str *str = ast_str_create(16);
	int ret = -1;
	AST_DECLARE_APP_ARGS(args,
		AST_APP_ARG(url);
		AST_APP_ARG(postdata);
	);
	CURL **curl;
	struct curl_settings *cur;
	struct ast_datastore *store = NULL;
	int hashcompat = 0;
	AST_LIST_HEAD(global_curl_info, curl_settings) *list = NULL;
	char curl_errbuf[CURL_ERROR_SIZE + 1]; /* add one to be safe */

	if (buf) {
		*buf = '\0';
	}

	if (!str) {
		return -1;
	}

	if (!escapebuf) {
		ast_free(str);
		return -1;
	}

	if (ast_strlen_zero(info)) {
		ast_log(LOG_WARNING, "CURL requires an argument (URL)\n");
		ast_free(str);
		return -1;
	}

	AST_STANDARD_APP_ARGS(args, info);

	if (chan) {
		ast_autoservice_start(chan);
	}

	if (!(curl = ast_threadstorage_get(&curl_instance, sizeof(*curl)))) {
		ast_log(LOG_ERROR, "Cannot allocate curl structure\n");
		ast_free(str);
		return -1;
	}

	AST_LIST_LOCK(&global_curl_info);
	AST_LIST_TRAVERSE(&global_curl_info, cur, list) {
		if (cur->key == CURLOPT_SPECIAL_HASHCOMPAT) {
			hashcompat = (cur->value != NULL) ? 1 : 0;
		} else {
			curl_easy_setopt(*curl, cur->key, cur->value);
		}
	}

	if (chan && (store = ast_channel_datastore_find(chan, &curl_info, NULL))) {
		list = store->data;
		AST_LIST_LOCK(list);
		AST_LIST_TRAVERSE(list, cur, list) {
			if (cur->key == CURLOPT_SPECIAL_HASHCOMPAT) {
				hashcompat = (cur->value != NULL) ? 1 : 0;
			} else {
				curl_easy_setopt(*curl, cur->key, cur->value);
			}
		}
	}

	curl_easy_setopt(*curl, CURLOPT_URL, args.url);
	curl_easy_setopt(*curl, CURLOPT_FILE, (void *) &str);

	if (args.postdata) {
		curl_easy_setopt(*curl, CURLOPT_POST, 1);
		curl_easy_setopt(*curl, CURLOPT_POSTFIELDS, args.postdata);
	}

	/* Temporarily assign a buffer for curl to write errors to. */
	curl_errbuf[0] = curl_errbuf[CURL_ERROR_SIZE] = '\0';
	curl_easy_setopt(*curl, CURLOPT_ERRORBUFFER, curl_errbuf);

	if (curl_easy_perform(*curl) != 0) {
		ast_log(LOG_WARNING, "%s ('%s')\n", curl_errbuf, args.url);
	}

	/* Reset buffer to NULL so curl doesn't try to write to it when the
	 * buffer is deallocated. Documentation is vague about allowing NULL
	 * here, but the source allows it. See: "typecheck: allow NULL to unset
	 * CURLOPT_ERRORBUFFER" (62bcf005f4678a93158358265ba905bace33b834). */
	curl_easy_setopt(*curl, CURLOPT_ERRORBUFFER, (char*)NULL);

	if (store) {
		AST_LIST_UNLOCK(list);
	}
	AST_LIST_UNLOCK(&global_curl_info);

	if (args.postdata) {
		curl_easy_setopt(*curl, CURLOPT_POST, 0);
	}

	if (ast_str_strlen(str)) {
		ast_str_trim_blanks(str);

		ast_debug(3, "str='%s'\n", ast_str_buffer(str));
		if (hashcompat) {
			char *remainder = ast_str_buffer(str);
			char *piece;
			struct ast_str *fields = ast_str_create(ast_str_strlen(str) / 2);
			struct ast_str *values = ast_str_create(ast_str_strlen(str) / 2);
			int rowcount = 0;
			while (fields && values && (piece = strsep(&remainder, "&"))) {
				char *name = strsep(&piece, "=");
				if (piece) {
					ast_uri_decode(piece);
				}
				ast_uri_decode(name);
				ast_str_append(&fields, 0, "%s%s", rowcount ? "," : "", ast_str_set_escapecommas(&escapebuf, 0, name, INT_MAX));
				ast_str_append(&values, 0, "%s%s", rowcount ? "," : "", ast_str_set_escapecommas(&escapebuf, 0, S_OR(piece, ""), INT_MAX));
				rowcount++;
			}
			pbx_builtin_setvar_helper(chan, "~ODBCFIELDS~", ast_str_buffer(fields));
			if (buf) {
				ast_copy_string(buf, ast_str_buffer(values), len);
			} else {
				ast_str_set(input_str, len, "%s", ast_str_buffer(values));
			}
			ast_free(fields);
			ast_free(values);
		} else {
			if (buf) {
				ast_copy_string(buf, ast_str_buffer(str), len);
			} else {
				ast_str_set(input_str, len, "%s", ast_str_buffer(str));
			}
		}
		ret = 0;
	}
	ast_free(str);

	if (chan)
		ast_autoservice_stop(chan);

	return ret;
}
