static int retrans_pkt(const void *data)
{
	struct sip_pkt *pkt = (struct sip_pkt *)data, *prev, *cur = NULL;
	int reschedule = DEFAULT_RETRANS;
	int xmitres = 0;
	/* how many ms until retrans timeout is reached */
	int64_t diff = pkt->retrans_stop_time - ast_tvdiff_ms(ast_tvnow(), pkt->time_sent);

	/* Do not retransmit if time out is reached. This will be negative if the time between
	 * the first transmission and now is larger than our timeout period. This is a fail safe
	 * check in case the scheduler gets behind or the clock is changed. */
	if ((diff <= 0) || (diff > pkt->retrans_stop_time)) {
		pkt->retrans_stop = 1;
	}

	/* Lock channel PVT */
	sip_pvt_lock(pkt->owner);

	if (!pkt->retrans_stop) {
		pkt->retrans++;
		if (!pkt->timer_t1) {	/* Re-schedule using timer_a and timer_t1 */
			if (sipdebug) {
				ast_debug(4, "SIP TIMER: Not rescheduling id #%d:%s (Method %d) (No timer T1)\n",
					pkt->retransid,
					sip_methods[pkt->method].text,
					pkt->method);
			}
		} else {
			int siptimer_a;

			if (sipdebug) {
				ast_debug(4, "SIP TIMER: Rescheduling retransmission #%d (%d) %s - %d\n",
					pkt->retransid,
					pkt->retrans,
					sip_methods[pkt->method].text,
					pkt->method);
			}
			if (!pkt->timer_a) {
				pkt->timer_a = 2 ;
			} else {
				pkt->timer_a = 2 * pkt->timer_a;
			}

			/* For non-invites, a maximum of 4 secs */
			siptimer_a = pkt->timer_t1 * pkt->timer_a;	/* Double each time */
			if (pkt->method != SIP_INVITE && siptimer_a > 4000) {
				siptimer_a = 4000;
			}

			/* Reschedule re-transmit */
			reschedule = siptimer_a;
			ast_debug(4, "** SIP timers: Rescheduling retransmission %d to %d ms (t1 %d ms (Retrans id #%d)) \n",
				pkt->retrans + 1,
				siptimer_a,
				pkt->timer_t1,
				pkt->retransid);
		}

		if (sip_debug_test_pvt(pkt->owner)) {
			const struct ast_sockaddr *dst = sip_real_dst(pkt->owner);
			ast_verbose("Retransmitting #%d (%s) to %s:\n%s\n---\n",
				pkt->retrans, sip_nat_mode(pkt->owner),
				ast_sockaddr_stringify(dst),
				ast_str_buffer(pkt->data));
		}

		append_history(pkt->owner, "ReTx", "%d %s", reschedule, ast_str_buffer(pkt->data));
		xmitres = __sip_xmit(pkt->owner, pkt->data);

		/* If there was no error during the network transmission, schedule the next retransmission,
		 * but if the next retransmission is going to be beyond our timeout period, mark the packet's
		 * stop_retrans value and set the next retransmit to be the exact time of timeout.  This will
		 * allow any responses to the packet to be processed before the packet is destroyed on the next
		 * call to this function by the scheduler. */
		if (xmitres != XMIT_ERROR) {
			if (reschedule >= diff) {
				pkt->retrans_stop = 1;
				reschedule = diff;
			}
			sip_pvt_unlock(pkt->owner);
			return  reschedule;
		}
	}

	/* At this point, either the packet's retransmission timed out, or there was a
	 * transmission error, either way destroy the scheduler item and this packet. */

	pkt->retransid = -1; /* Kill this scheduler item */

	if (pkt->method != SIP_OPTIONS && xmitres == 0) {
		if (pkt->is_fatal || sipdebug) { /* Tell us if it's critical or if we're debugging */
			ast_log(LOG_WARNING, "Retransmission timeout reached on transmission %s for seqno %u (%s %s) -- See https://wiki.asterisk.org/wiki/display/AST/SIP+Retransmissions\n"
				"Packet timed out after %dms with no response\n",
				pkt->owner->callid,
				pkt->seqno,
				pkt->is_fatal ? "Critical" : "Non-critical",
				pkt->is_resp ? "Response" : "Request",
				(int) ast_tvdiff_ms(ast_tvnow(), pkt->time_sent));
		}
	} else if (pkt->method == SIP_OPTIONS && sipdebug) {
		ast_log(LOG_WARNING, "Cancelling retransmit of OPTIONs (call id %s)  -- See https://wiki.asterisk.org/wiki/display/AST/SIP+Retransmissions\n", pkt->owner->callid);
	}

	if (xmitres == XMIT_ERROR) {
		ast_log(LOG_WARNING, "Transmit error :: Cancelling transmission on Call ID %s\n", pkt->owner->callid);
		append_history(pkt->owner, "XmitErr", "%s", pkt->is_fatal ? "(Critical)" : "(Non-critical)");
	} else {
		append_history(pkt->owner, "MaxRetries", "%s", pkt->is_fatal ? "(Critical)" : "(Non-critical)");
	}

	if (pkt->is_fatal) {
		while(pkt->owner->owner && ast_channel_trylock(pkt->owner->owner)) {
			sip_pvt_unlock(pkt->owner);	/* SIP_PVT, not channel */
			usleep(1);
			sip_pvt_lock(pkt->owner);
		}
		if (pkt->owner->owner && !ast_channel_hangupcause(pkt->owner->owner)) {
			ast_channel_hangupcause_set(pkt->owner->owner, AST_CAUSE_NO_USER_RESPONSE);
		}
		if (pkt->owner->owner) {
			ast_log(LOG_WARNING, "Hanging up call %s - no reply to our critical packet (see https://wiki.asterisk.org/wiki/display/AST/SIP+Retransmissions).\n", pkt->owner->callid);

			if (pkt->is_resp &&
				(pkt->response_code >= 200) &&
				(pkt->response_code < 300) &&
				pkt->owner->pendinginvite &&
				ast_test_flag(&pkt->owner->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED)) {
				/* This is a timeout of the 2XX response to a pending INVITE.  In this case terminate the INVITE
				 * transaction just as if we received the ACK, but immediately hangup with a BYE (sip_hangup
				 * will send the BYE as long as the dialog is not set as "alreadygone")
				 * RFC 3261 section 13.3.1.4.
				 * "If the server retransmits the 2xx response for 64*T1 seconds without receiving
				 * an ACK, the dialog is confirmed, but the session SHOULD be terminated.  This is
				 * accomplished with a BYE, as described in Section 15." */
				pkt->owner->invitestate = INV_TERMINATED;
				pkt->owner->pendinginvite = 0;
			} else {
				/* there is nothing left to do, mark the dialog as gone */
				sip_alreadygone(pkt->owner);
			}
			ast_queue_hangup_with_cause(pkt->owner->owner, AST_CAUSE_NO_USER_RESPONSE);
			ast_channel_unlock(pkt->owner->owner);
		} else {
			/* If no channel owner, destroy now */

			/* Let the peerpoke system expire packets when the timer expires for poke_noanswer */
			if (pkt->method != SIP_OPTIONS && pkt->method != SIP_REGISTER) {
				pvt_set_needdestroy(pkt->owner, "no response to critical packet");
				sip_alreadygone(pkt->owner);
				append_history(pkt->owner, "DialogKill", "Killing this failed dialog immediately");
			}
		}
	} else if (pkt->owner->pendinginvite == pkt->seqno) {
	       ast_log(LOG_WARNING, "Timeout on %s on non-critical invite transaction.\n", pkt->owner->callid);
	       pkt->owner->invitestate = INV_TERMINATED;
	       pkt->owner->pendinginvite = 0;
	       check_pendings(pkt->owner);
	}

	if (pkt->method == SIP_BYE) {
		/* We're not getting answers on SIP BYE's.  Tear down the call anyway. */
		sip_alreadygone(pkt->owner);
		if (pkt->owner->owner) {
			ast_channel_unlock(pkt->owner->owner);
		}
		append_history(pkt->owner, "ByeFailure", "Remote peer doesn't respond to bye. Destroying call anyway.");
		pvt_set_needdestroy(pkt->owner, "no response to BYE");
	}

	/* Remove the packet */
	for (prev = NULL, cur = pkt->owner->packets; cur; prev = cur, cur = cur->next) {
		if (cur == pkt) {
			UNLINK(cur, pkt->owner->packets, prev);
			sip_pvt_unlock(pkt->owner);
			if (pkt->owner) {
				pkt->owner = dialog_unref(pkt->owner,"pkt is being freed, its dialog ref is dead now");
			}
			if (pkt->data) {
				ast_free(pkt->data);
			}
			pkt->data = NULL;
			ast_free(pkt);
			return 0;
		}
	}
	/* error case */
	ast_log(LOG_WARNING, "Weird, couldn't find packet owner!\n");
	sip_pvt_unlock(pkt->owner);
	return 0;
}
