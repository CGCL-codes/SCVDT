static int apply_negotiated_sdp_stream(struct ast_sip_session *session,
	struct ast_sip_session_media *session_media, const struct pjmedia_sdp_session *local,
	const struct pjmedia_sdp_session *remote, int index, struct ast_stream *asterisk_stream)
{
	RAII_VAR(struct ast_sockaddr *, addrs, NULL, ast_free);
	struct pjmedia_sdp_media *remote_stream = remote->media[index];
	enum ast_media_type media_type = session_media->type;
	char host[NI_MAXHOST];
	int res;
	struct ast_sip_session_media *session_media_transport;

	if (!session->channel) {
		return 1;
	}

	/* Ensure incoming transport is compatible with the endpoint's configuration */
	if (!session->endpoint->media.rtp.use_received_transport &&
		check_endpoint_media_transport(session->endpoint, remote_stream) == AST_SIP_MEDIA_TRANSPORT_INVALID) {
		return -1;
	}

	/* Create an RTP instance if need be */
	if (!session_media->rtp && create_rtp(session, session_media, local)) {
		return -1;
	}

	process_ssrc_attributes(session, session_media, remote_stream);
	process_extmap_attributes(session, session_media, remote_stream);

	session_media_transport = ast_sip_session_media_get_transport(session, session_media);

	if (session_media_transport == session_media || !session_media->bundled) {
		session_media->remote_rtcp_mux = (pjmedia_sdp_media_find_attr2(remote_stream, "rtcp-mux", NULL) != NULL);
		set_ice_components(session, session_media);

		enable_rtcp(session, session_media, remote_stream);

		res = setup_media_encryption(session, session_media, remote, remote_stream);
		if (!session->endpoint->media.rtp.encryption_optimistic && res) {
			/* If optimistic encryption is disabled and crypto should have been enabled but was not
			 * this session must fail.
			 */
			return -1;
		}

		if (!remote_stream->conn && !remote->conn) {
			return 1;
		}

		ast_copy_pj_str(host, remote_stream->conn ? &remote_stream->conn->addr : &remote->conn->addr, sizeof(host));

		/* Ensure that the address provided is valid */
		if (ast_sockaddr_resolve(&addrs, host, PARSE_PORT_FORBID, AST_AF_UNSPEC) <= 0) {
			/* The provided host was actually invalid so we error out this negotiation */
			return -1;
		}

		/* Apply connection information to the RTP instance */
		ast_sockaddr_set_port(addrs, remote_stream->desc.port);
		ast_rtp_instance_set_remote_address(session_media->rtp, addrs);

		ast_sip_session_media_set_write_callback(session, session_media, media_session_rtp_write_callback);
		ast_sip_session_media_add_read_callback(session, session_media, ast_rtp_instance_fd(session_media->rtp, 0),
			media_session_rtp_read_callback);
		if (!session->endpoint->media.rtcp_mux || !session_media->remote_rtcp_mux) {
			ast_sip_session_media_add_read_callback(session, session_media, ast_rtp_instance_fd(session_media->rtp, 1),
				media_session_rtcp_read_callback);
		}

		/* If ICE support is enabled find all the needed attributes */
		process_ice_attributes(session, session_media, remote, remote_stream);
	} else {
		/* This is bundled with another session, so mark it as such */
		ast_rtp_instance_bundle(session_media->rtp, session_media_transport->rtp);
		ast_sip_session_media_set_write_callback(session, session_media, media_session_rtp_write_callback);
		enable_rtcp(session, session_media, remote_stream);
	}

	if (set_caps(session, session_media, session_media_transport, remote_stream, 0, asterisk_stream)) {
		return -1;
	}

	/* Set the channel uniqueid on the RTP instance now that it is becoming active */
	ast_channel_lock(session->channel);
	ast_rtp_instance_set_channel_id(session_media->rtp, ast_channel_uniqueid(session->channel));
	ast_channel_unlock(session->channel);

	/* Ensure the RTP instance is active */
	ast_rtp_instance_set_stream_num(session_media->rtp, ast_stream_get_position(asterisk_stream));
	ast_rtp_instance_activate(session_media->rtp);

	/* audio stream handles music on hold */
	if (media_type != AST_MEDIA_TYPE_AUDIO) {
		if ((pjmedia_sdp_neg_was_answer_remote(session->inv_session->neg) == PJ_FALSE)
			&& (session->inv_session->state == PJSIP_INV_STATE_CONFIRMED)) {
			ast_queue_control(session->channel, AST_CONTROL_UPDATE_RTP_PEER);
		}
		return 1;
	}

	if (ast_sockaddr_isnull(addrs) ||
		ast_sockaddr_is_any(addrs) ||
		pjmedia_sdp_media_find_attr2(remote_stream, "sendonly", NULL) ||
		pjmedia_sdp_media_find_attr2(remote_stream, "inactive", NULL)) {
		if (!session_media->remotely_held) {
			/* The remote side has put us on hold */
			ast_queue_hold(session->channel, session->endpoint->mohsuggest);
			ast_rtp_instance_stop(session_media->rtp);
			ast_queue_frame(session->channel, &ast_null_frame);
			session_media->remotely_held = 1;
		}
	} else if (session_media->remotely_held) {
		/* The remote side has taken us off hold */
		ast_queue_unhold(session->channel);
		ast_queue_frame(session->channel, &ast_null_frame);
		session_media->remotely_held = 0;
	} else if ((pjmedia_sdp_neg_was_answer_remote(session->inv_session->neg) == PJ_FALSE)
		&& (session->inv_session->state == PJSIP_INV_STATE_CONFIRMED)) {
		ast_queue_control(session->channel, AST_CONTROL_UPDATE_RTP_PEER);
	}

	/* This purposely resets the encryption to the configured in case it gets added later */
	session_media->encryption = session->endpoint->media.rtp.encryption;

	if (session->endpoint->media.rtp.keepalive > 0 &&
			session_media->type == AST_MEDIA_TYPE_AUDIO) {
		ast_rtp_instance_set_keepalive(session_media->rtp, session->endpoint->media.rtp.keepalive);
		/* Schedule the initial keepalive early in case this is being used to punch holes through
		 * a NAT. This way there won't be an awkward delay before media starts flowing in some
		 * scenarios.
		 */
		AST_SCHED_DEL(sched, session_media->keepalive_sched_id);
		session_media->keepalive_sched_id = ast_sched_add_variable(sched, 500, send_keepalive,
			session_media, 1);
	}

	/* As the channel lock is not held during this process the scheduled item won't block if
	 * it is hanging up the channel at the same point we are applying this negotiated SDP.
	 */
	AST_SCHED_DEL(sched, session_media->timeout_sched_id);

	/* Due to the fact that we only ever have one scheduled timeout item for when we are both
	 * off hold and on hold we don't need to store the two timeouts differently on the RTP
	 * instance itself.
	 */
	ast_rtp_instance_set_timeout(session_media->rtp, 0);
	if (session->endpoint->media.rtp.timeout && !session_media->remotely_held) {
		ast_rtp_instance_set_timeout(session_media->rtp, session->endpoint->media.rtp.timeout);
	} else if (session->endpoint->media.rtp.timeout_hold && session_media->remotely_held) {
		ast_rtp_instance_set_timeout(session_media->rtp, session->endpoint->media.rtp.timeout_hold);
	}

	if (ast_rtp_instance_get_timeout(session_media->rtp)) {
		session_media->timeout_sched_id = ast_sched_add_variable(sched,
			ast_rtp_instance_get_timeout(session_media->rtp) * 1000, rtp_check_timeout,
			session_media, 1);
	}

	return 1;
}
