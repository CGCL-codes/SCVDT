static inline int ws_safe_read(struct ast_websocket *session, char *buf, size_t len, enum ast_websocket_opcode *opcode)
{
	ssize_t rlen;
	int xlen = len;
	char *rbuf = buf;
	int sanity = 10;

	ast_assert(len > 0);

	if (!len) {
		errno = EINVAL;
		return -1;
	}

	ao2_lock(session);
	if (!session->stream) {
		ao2_unlock(session);
		errno = ECONNABORTED;
		return -1;
	}

	for (;;) {
		rlen = ast_iostream_read(session->stream, rbuf, xlen);
		if (rlen != xlen) {
			if (rlen == 0) {
				ast_log(LOG_WARNING, "Web socket closed abruptly\n");
				*opcode = AST_WEBSOCKET_OPCODE_CLOSE;
				session->closing = 1;
				ao2_unlock(session);
				return -1;
			}

			if (rlen < 0 && errno != EAGAIN) {
				ast_log(LOG_ERROR, "Error reading from web socket: %s\n", strerror(errno));
				*opcode = AST_WEBSOCKET_OPCODE_CLOSE;
				session->closing = 1;
				ao2_unlock(session);
				return -1;
			}

			if (!--sanity) {
				ast_log(LOG_WARNING, "Websocket seems unresponsive, disconnecting ...\n");
				*opcode = AST_WEBSOCKET_OPCODE_CLOSE;
				session->closing = 1;
				ao2_unlock(session);
				return -1;
			}
		}
		if (rlen > 0) {
			xlen = xlen - rlen;
			rbuf = rbuf + rlen;
			if (!xlen) {
				break;
			}
		}
		if (ast_wait_for_input(ast_iostream_get_fd(session->stream), 1000) < 0) {
			ast_log(LOG_ERROR, "ast_wait_for_input returned err: %s\n", strerror(errno));
			*opcode = AST_WEBSOCKET_OPCODE_CLOSE;
			session->closing = 1;
			ao2_unlock(session);
			return -1;
		}
	}

	ao2_unlock(session);
	return 0;
}
