static enum check_auth_result check_peer_ok(struct sip_pvt *p, char *of,
	struct sip_request *req, int sipmethod, struct ast_sockaddr *addr,
	struct sip_peer **authpeer,
	enum xmittype reliable, char *calleridname, char *uri2)
{
	enum check_auth_result res;
	int debug = sip_debug_test_addr(addr);
	struct sip_peer *peer;
	struct sip_peer *bogus_peer;

	if (sipmethod == SIP_SUBSCRIBE) {
		/* For subscribes, match on device name only; for other methods,
	 	* match on IP address-port of the incoming request.
	 	*/
		peer = sip_find_peer(of, NULL, TRUE, FINDALLDEVICES, FALSE, 0);
	} else {
		/* First find devices based on username (avoid all type=peer's) */
		peer = sip_find_peer(of, NULL, TRUE, FINDUSERS, FALSE, 0);

		/* Then find devices based on IP */
		if (!peer) {
			char *uri_tmp, *callback = NULL, *dummy;
			uri_tmp = ast_strdupa(uri2);
			parse_uri(uri_tmp, "sip:,sips:,tel:", &callback, &dummy, &dummy, &dummy);
			if (!ast_strlen_zero(callback) && (peer = sip_find_peer_by_ip_and_exten(&p->recv, callback, p->socket.type))) {
				; /* found, fall through */
			} else {
				peer = sip_find_peer(NULL, &p->recv, TRUE, FINDPEERS, FALSE, p->socket.type);
			}
		}
	}

	if (!peer) {
		if (debug) {
			ast_verbose("No matching peer for '%s' from '%s'\n",
				of, ast_sockaddr_stringify(&p->recv));
		}

		/* If you don't mind, we can return 404s for devices that do
		 * not exist: username disclosure. If we allow guests, there
		 * is no way around that. */
		if (sip_cfg.allowguest || !sip_cfg.alwaysauthreject) {
			return AUTH_DONT_KNOW;
		}

		/* If you do mind, we use a peer that will never authenticate.
		 * This ensures that we follow the same code path as regular
		 * auth: less chance for username disclosure. */
		peer = ao2_t_global_obj_ref(g_bogus_peer, "check_peer_ok: Get the bogus peer.");
		if (!peer) {
			return AUTH_DONT_KNOW;
		}
		bogus_peer = peer;
	} else {
		bogus_peer = NULL;
	}

	/*  build_peer, called through sip_find_peer, is not able to check the
	 *  sip_pvt->natdetected flag in order to determine if the peer is behind
	 *  NAT or not when SIP_PAGE3_NAT_AUTO_RPORT or SIP_PAGE3_NAT_AUTO_COMEDIA
	 *  are set on the peer.  So we check for that here and set the peer's
	 *  address accordingly.
	 */
	set_peer_nat(p, peer);

	if (p->natdetected && ast_test_flag(&peer->flags[2], SIP_PAGE3_NAT_AUTO_RPORT)) {
		ast_sockaddr_copy(&peer->addr, &p->recv);
	}

	if (!ast_apply_acl(peer->acl, addr, "SIP Peer ACL: ")) {
		ast_debug(2, "Found peer '%s' for '%s', but fails host access\n", peer->name, of);
		sip_unref_peer(peer, "sip_unref_peer: check_peer_ok: from sip_find_peer call, early return of AUTH_ACL_FAILED");
		return AUTH_ACL_FAILED;
	}
	if (debug && peer != bogus_peer) {
		ast_verbose("Found peer '%s' for '%s' from %s\n",
			peer->name, of, ast_sockaddr_stringify(&p->recv));
	}

	/* Set Frame packetization */
	if (p->rtp) {
		ast_rtp_codecs_set_framing(ast_rtp_instance_get_codecs(p->rtp), ast_format_cap_get_framing(peer->caps));
		p->autoframing = peer->autoframing;
	}

	/* Take the peer */
	ast_copy_flags(&p->flags[0], &peer->flags[0], SIP_FLAGS_TO_COPY);
	ast_copy_flags(&p->flags[1], &peer->flags[1], SIP_PAGE2_FLAGS_TO_COPY);
	ast_copy_flags(&p->flags[2], &peer->flags[2], SIP_PAGE3_FLAGS_TO_COPY);

	if (ast_test_flag(&p->flags[1], SIP_PAGE2_T38SUPPORT) && p->udptl) {
		p->t38_maxdatagram = peer->t38_maxdatagram;
		set_t38_capabilities(p);
	}

	ast_rtp_dtls_cfg_copy(&peer->dtls_cfg, &p->dtls_cfg);

	/* Copy SIP extensions profile to peer */
	/* XXX is this correct before a successful auth ? */
	if (p->sipoptions)
		peer->sipoptions = p->sipoptions;

	do_setnat(p);

	ast_string_field_set(p, peersecret, peer->secret);
	ast_string_field_set(p, peermd5secret, peer->md5secret);
	ast_string_field_set(p, subscribecontext, peer->subscribecontext);
	ast_string_field_set(p, mohinterpret, peer->mohinterpret);
	ast_string_field_set(p, mohsuggest, peer->mohsuggest);
	if (!ast_strlen_zero(peer->parkinglot)) {
		ast_string_field_set(p, parkinglot, peer->parkinglot);
	}
	ast_string_field_set(p, engine, peer->engine);
	p->disallowed_methods = peer->disallowed_methods;
	set_pvt_allowed_methods(p, req);
	ast_cc_copy_config_params(p->cc_params, peer->cc_params);
	if (peer->callingpres)	/* Peer calling pres setting will override RPID */
		p->callingpres = peer->callingpres;
	if (peer->maxms && peer->lastms)
		p->timer_t1 = peer->lastms < global_t1min ? global_t1min : peer->lastms;
 	else
 		p->timer_t1 = peer->timer_t1;

 	/* Set timer B to control transaction timeouts */
 	if (peer->timer_b)
 		p->timer_b = peer->timer_b;
 	else
 		p->timer_b = 64 * p->timer_t1;

	p->allowtransfer = peer->allowtransfer;

	if (ast_test_flag(&peer->flags[0], SIP_INSECURE_INVITE)) {
		/* Pretend there is no required authentication */
		ast_string_field_set(p, peersecret, NULL);
		ast_string_field_set(p, peermd5secret, NULL);
	}
	if (!(res = check_auth(p, req, peer->name, p->peersecret, p->peermd5secret, sipmethod, uri2, reliable))) {
		/* If we have a call limit, set flag */
		if (peer->call_limit)
			ast_set_flag(&p->flags[0], SIP_CALL_LIMIT);
		ast_string_field_set(p, peername, peer->name);
		ast_string_field_set(p, authname, peer->name);

		ast_rtp_dtls_cfg_copy(&peer->dtls_cfg, &p->dtls_cfg);

		if (sipmethod == SIP_INVITE) {
			/* destroy old channel vars and copy in new ones. */
			ast_variables_destroy(p->chanvars);
			p->chanvars = copy_vars(peer->chanvars);
		}

		if (authpeer) {
			ao2_t_ref(peer, 1, "copy pointer into (*authpeer)");
			(*authpeer) = peer;	/* Add a ref to the object here, to keep it in memory a bit longer if it is realtime */
		}

		if (!ast_strlen_zero(peer->username)) {
			ast_string_field_set(p, username, peer->username);
			/* Use the default username for authentication on outbound calls */
			/* XXX this takes the name from the caller... can we override ? */
			ast_string_field_set(p, authname, peer->username);
		}
		if (!get_rpid(p, req)) {
			if (!ast_strlen_zero(peer->cid_num)) {
				char *tmp = ast_strdupa(peer->cid_num);
				if (global_shrinkcallerid && ast_is_shrinkable_phonenumber(tmp))
					ast_shrink_phone_number(tmp);
				ast_string_field_set(p, cid_num, tmp);
			}
			if (!ast_strlen_zero(peer->cid_name))
				ast_string_field_set(p, cid_name, peer->cid_name);
			if (peer->callingpres)
				p->callingpres = peer->callingpres;
		}
		if (!ast_strlen_zero(peer->cid_tag)) {
			ast_string_field_set(p, cid_tag, peer->cid_tag);
		}
		ast_string_field_set(p, fullcontact, peer->fullcontact);
		if (!ast_strlen_zero(peer->context)) {
			ast_string_field_set(p, context, peer->context);
		}
		if (!ast_strlen_zero(peer->messagecontext)) {
			ast_string_field_set(p, messagecontext, peer->messagecontext);
		}
		if (!ast_strlen_zero(peer->mwi_from)) {
			ast_string_field_set(p, mwi_from, peer->mwi_from);
		}
		ast_string_field_set(p, peersecret, peer->secret);
		ast_string_field_set(p, peermd5secret, peer->md5secret);
		ast_string_field_set(p, language, peer->language);
		ast_string_field_set(p, accountcode, peer->accountcode);
		p->amaflags = peer->amaflags;
		p->callgroup = peer->callgroup;
		p->pickupgroup = peer->pickupgroup;
		ast_unref_namedgroups(p->named_callgroups);
		p->named_callgroups = ast_ref_namedgroups(peer->named_callgroups);
		ast_unref_namedgroups(p->named_pickupgroups);
		p->named_pickupgroups = ast_ref_namedgroups(peer->named_pickupgroups);
		ast_format_cap_remove_by_type(p->caps, AST_MEDIA_TYPE_UNKNOWN);
		ast_format_cap_append_from_cap(p->caps, peer->caps, AST_MEDIA_TYPE_UNKNOWN);
		ast_format_cap_remove_by_type(p->jointcaps, AST_MEDIA_TYPE_UNKNOWN);
		ast_format_cap_append_from_cap(p->jointcaps, peer->caps, AST_MEDIA_TYPE_UNKNOWN);
		ast_copy_string(p->zone, peer->zone, sizeof(p->zone));
 		if (peer->maxforwards > 0) {
			p->maxforwards = peer->maxforwards;
		}
		if (ast_format_cap_count(p->peercaps)) {
			struct ast_format_cap *joint;

			joint = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
			if (joint) {
				ast_format_cap_get_compatible(p->jointcaps, p->peercaps, joint);
				ao2_ref(p->jointcaps, -1);
				p->jointcaps = joint;
			}
		}
		p->maxcallbitrate = peer->maxcallbitrate;
		if ((ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_RFC2833) ||
		    (ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_AUTO))
			p->noncodeccapability |= AST_RTP_DTMF;
		else
			p->noncodeccapability &= ~AST_RTP_DTMF;
		p->jointnoncodeccapability = p->noncodeccapability;
		p->rtptimeout = peer->rtptimeout;
		p->rtpholdtimeout = peer->rtpholdtimeout;
		p->rtpkeepalive = peer->rtpkeepalive;
		if (!dialog_initialize_rtp(p)) {
			if (p->rtp) {
				ast_rtp_codecs_set_framing(ast_rtp_instance_get_codecs(p->rtp), ast_format_cap_get_framing(peer->caps));
				p->autoframing = peer->autoframing;
			}
		} else {
			res = AUTH_RTP_FAILED;
		}
	}
	sip_unref_peer(peer, "check_peer_ok: sip_unref_peer: tossing temp ptr to peer from sip_find_peer");
	return res;
}
