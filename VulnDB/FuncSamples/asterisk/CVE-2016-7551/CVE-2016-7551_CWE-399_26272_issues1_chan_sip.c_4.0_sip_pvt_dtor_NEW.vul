static void sip_pvt_dtor(void *vdoomed)
{
	struct sip_pvt *p = vdoomed;
	struct sip_request *req;

	ast_debug(3, "Destroying SIP dialog %s\n", p->callid);

	/* Destroy Session-Timers if allocated */
	ast_free(p->stimer);
	p->stimer = NULL;

	if (sip_debug_test_pvt(p))
		ast_verbose("Really destroying SIP dialog '%s' Method: %s\n", p->callid, sip_methods[p->method].text);

	if (ast_test_flag(&p->flags[0], SIP_INC_COUNT) || ast_test_flag(&p->flags[1], SIP_PAGE2_CALL_ONHOLD)) {
		update_call_counter(p, DEC_CALL_LIMIT);
		ast_debug(2, "This call did not properly clean up call limits. Call ID %s\n", p->callid);
	}

	/* Unlink us from the owner if we have one */
	if (p->owner) {
		ast_channel_lock(p->owner);
		ast_debug(1, "Detaching from %s\n", ast_channel_name(p->owner));
		ast_channel_tech_pvt_set(p->owner, NULL);
		/* Make sure that the channel knows its backend is going away */
		ast_channel_softhangup_internal_flag_add(p->owner, AST_SOFTHANGUP_DEV);
		ast_channel_unlock(p->owner);
		/* Give the channel a chance to react before deallocation */
		usleep(1);
	}

	/* Remove link from peer to subscription of MWI */
	if (p->relatedpeer && p->relatedpeer->mwipvt == p)
		p->relatedpeer->mwipvt = dialog_unref(p->relatedpeer->mwipvt, "delete ->relatedpeer->mwipvt");
	if (p->relatedpeer && p->relatedpeer->call == p)
		p->relatedpeer->call = dialog_unref(p->relatedpeer->call, "unset the relatedpeer->call field in tandem with relatedpeer field itself");

	if (p->relatedpeer)
		p->relatedpeer = sip_unref_peer(p->relatedpeer,"unsetting a dialog relatedpeer field in sip_destroy");

	if (p->registry) {
		if (p->registry->call == p)
			p->registry->call = dialog_unref(p->registry->call, "nulling out the registry's call dialog field in unlink_all");
		ao2_t_replace(p->registry, NULL, "delete p->registry");
	}

	if (p->mwi) {
		p->mwi->call = NULL;
		p->mwi = NULL;
	}

	if (dumphistory)
		sip_dump_history(p);

	if (p->options) {
		if (p->options->outboundproxy) {
			ao2_ref(p->options->outboundproxy, -1);
		}
		ast_free(p->options);
		p->options = NULL;
	}

	if (p->outboundproxy) {
		ref_proxy(p, NULL);
	}

	if (p->notify) {
		ast_variables_destroy(p->notify->headers);
		ast_free(p->notify->content);
		ast_free(p->notify);
		p->notify = NULL;
	}

	/* Free RTP and SRTP instances */
	dialog_clean_rtp(p);

	if (p->udptl) {
		ast_udptl_destroy(p->udptl);
		p->udptl = NULL;
	}
	sip_refer_destroy(p);
	sip_route_clear(&p->route);
	deinit_req(&p->initreq);

	/* Clear history */
	if (p->history) {
		struct sip_history *hist;
		while ( (hist = AST_LIST_REMOVE_HEAD(p->history, list)) ) {
			ast_free(hist);
			p->history_entries--;
		}
		ast_free(p->history);
		p->history = NULL;
	}

	while ((req = AST_LIST_REMOVE_HEAD(&p->request_queue, next))) {
		ast_free(req);
	}

	offered_media_list_destroy(p);

	if (p->chanvars) {
		ast_variables_destroy(p->chanvars);
		p->chanvars = NULL;
	}

	destroy_msg_headers(p);

	if (p->vsrtp) {
		ast_sdp_srtp_destroy(p->vsrtp);
		p->vsrtp = NULL;
	}

	if (p->directmediaacl) {
		p->directmediaacl = ast_free_acl_list(p->directmediaacl);
	}

	ast_string_field_free_memory(p);

	ast_cc_config_params_destroy(p->cc_params);
	p->cc_params = NULL;

	if (p->epa_entry) {
		ao2_ref(p->epa_entry, -1);
		p->epa_entry = NULL;
	}

	if (p->socket.tcptls_session) {
		ao2_ref(p->socket.tcptls_session, -1);
		p->socket.tcptls_session = NULL;
	} else if (p->socket.ws_session) {
		ast_websocket_unref(p->socket.ws_session);
		p->socket.ws_session = NULL;
	}

	if (p->peerauth) {
		ao2_t_ref(p->peerauth, -1, "Removing active peer authentication");
		p->peerauth = NULL;
	}

	p->named_callgroups = ast_unref_namedgroups(p->named_callgroups);
	p->named_pickupgroups = ast_unref_namedgroups(p->named_pickupgroups);

	ao2_cleanup(p->caps);
	ao2_cleanup(p->jointcaps);
	ao2_cleanup(p->peercaps);
	ao2_cleanup(p->redircaps);
	ao2_cleanup(p->prefcaps);

	ast_rtp_dtls_cfg_free(&p->dtls_cfg);

	if (p->last_device_state_info) {
		ao2_ref(p->last_device_state_info, -1);
		p->last_device_state_info = NULL;
	}

	/* Lastly, kill the callid associated with the pvt */
	if (p->logger_callid) {
		ast_callid_unref(p->logger_callid);
	}
}
