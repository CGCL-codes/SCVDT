static void subscription_persistence_update(struct sip_subscription_tree *sub_tree,
	pjsip_rx_data *rdata, enum sip_persistence_update_type type)
{
	pjsip_dialog *dlg;

	if (!sub_tree->persistence) {
		return;
	}

	ast_debug(3, "Updating persistence for '%s->%s'\n", sub_tree->persistence->endpoint,
		sub_tree->root->resource);

	dlg = sub_tree->dlg;
	sub_tree->persistence->cseq = dlg->local.cseq;

	if (rdata) {
		int expires;
		pjsip_expires_hdr *expires_hdr = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_EXPIRES, NULL);
		pjsip_contact_hdr *contact_hdr = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT, NULL);

		expires = expires_hdr ? expires_hdr->ivalue : DEFAULT_PUBLISH_EXPIRES;
		sub_tree->persistence->expires = ast_tvadd(ast_tvnow(), ast_samp2tv(expires, 1));

		pjsip_uri_print(PJSIP_URI_IN_CONTACT_HDR, contact_hdr->uri,
			sub_tree->persistence->contact_uri, sizeof(sub_tree->persistence->contact_uri));

		/* When receiving a packet on an streaming transport, it's possible to receive more than one SIP
		 * message at a time into the rdata->pkt_info.packet buffer. However, the rdata->msg_info.msg_buf
		 * will always point to the proper SIP message that is to be processed. When updating subscription
		 * persistence that is pulled from persistent storage, though, the rdata->pkt_info.packet will
		 * only ever have a single SIP message on it, and so we base persistence on that.
		 */
		if (type == SUBSCRIPTION_PERSISTENCE_CREATED
			|| type == SUBSCRIPTION_PERSISTENCE_RECREATED) {
			if (rdata->msg_info.msg_buf) {
				ast_copy_string(sub_tree->persistence->packet, rdata->msg_info.msg_buf,
						MIN(sizeof(sub_tree->persistence->packet), rdata->msg_info.len));
			} else {
				ast_copy_string(sub_tree->persistence->packet, rdata->pkt_info.packet,
						sizeof(sub_tree->persistence->packet));
			}
		}
		ast_copy_string(sub_tree->persistence->src_name, rdata->pkt_info.src_name,
				sizeof(sub_tree->persistence->src_name));
		sub_tree->persistence->src_port = rdata->pkt_info.src_port;
		ast_copy_string(sub_tree->persistence->transport_key, rdata->tp_info.transport->type_name,
			sizeof(sub_tree->persistence->transport_key));
		ast_copy_pj_str(sub_tree->persistence->local_name, &rdata->tp_info.transport->local_name.host,
			sizeof(sub_tree->persistence->local_name));
		sub_tree->persistence->local_port = rdata->tp_info.transport->local_name.port;
	}

	ast_sorcery_update(ast_sip_get_sorcery(), sub_tree->persistence);
}
