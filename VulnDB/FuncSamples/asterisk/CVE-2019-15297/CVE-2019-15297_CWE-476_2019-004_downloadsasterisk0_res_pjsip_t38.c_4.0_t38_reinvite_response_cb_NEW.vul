static int t38_reinvite_response_cb(struct ast_sip_session *session, pjsip_rx_data *rdata)
{
	struct pjsip_status_line status = rdata->msg_info.msg->line.status;
	struct t38_state *state;
	struct ast_sip_session_media *session_media = NULL;

	if (status.code / 100 <= 1) {
		/* Ignore any non-final responses (1xx) */
		return 0;
	}

	if (session->t38state != T38_LOCAL_REINVITE) {
		/* Do nothing.  We have already processed a final response. */
		ast_debug(3, "Received %d response to T.38 re-invite on '%s' but already had a final response (T.38 state:%d)\n",
			status.code,
			session->channel ? ast_channel_name(session->channel) : "unknown channel",
			session->t38state);
		return 0;
	}

	state = t38_state_get_or_alloc(session);
	if (!session->channel || !state) {
		ast_log(LOG_WARNING, "Received %d response to T.38 re-invite on '%s' but state unavailable\n",
			status.code,
			session->channel ? ast_channel_name(session->channel) : "unknown channel");
		return 0;
	}

	if (status.code / 100 == 2) {
		/* Accept any 2xx response as successfully negotiated */
		int index;

		session_media = session->active_media_state->default_session[AST_MEDIA_TYPE_IMAGE];
		if (!session_media) {
			ast_log(LOG_WARNING, "Received %d response to T.38 re-invite on '%s' but no active session media\n",
					status.code, session->channel ? ast_channel_name(session->channel) : "unknown channel");
		} else {
			t38_change_state(session, session_media, state, T38_ENABLED);

			/* Stop all the streams in the stored away active state, they'll go back to being active once
			 * we reinvite back.
			 */
			for (index = 0; index < AST_VECTOR_SIZE(&state->media_state->sessions); ++index) {
				struct ast_sip_session_media *session_media = AST_VECTOR_GET(&state->media_state->sessions, index);

				if (session_media && session_media->handler && session_media->handler->stream_stop) {
					session_media->handler->stream_stop(session_media);
				}
			}

			return 0;
		}
	} else {
		session_media = session->pending_media_state->default_session[AST_MEDIA_TYPE_IMAGE];
	}

	/* If no session_media then response contained a declined stream, so disable */
	t38_change_state(session, NULL, state, session_media ? T38_REJECTED : T38_DISABLED);

	/* Abort this attempt at switching to T.38 by resetting the pending state and freeing our stored away active state */
	ast_sip_session_media_state_free(state->media_state);
	state->media_state = NULL;
	ast_sip_session_media_state_reset(session->pending_media_state);

	return 0;
}
