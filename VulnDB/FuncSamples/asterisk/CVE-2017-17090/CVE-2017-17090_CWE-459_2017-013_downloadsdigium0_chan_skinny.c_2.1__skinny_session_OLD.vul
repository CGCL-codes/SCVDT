static void *skinny_session(void *data)
{
	int res;
	int bytesread;
	struct skinny_req *req = NULL;
	struct skinnysession *s = data;

	int dlen = 0;
	int eventmessage = 0;
	struct pollfd fds[1];

	if (!s) {
		ast_log(LOG_WARNING, "Bad Skinny Session\n");
		return 0;
	}

	ast_log(LOG_NOTICE, "Starting Skinny session from %s\n", ast_inet_ntoa(s->sin.sin_addr));

	pthread_cleanup_push(skinny_session_cleanup, s);

	s->start = ast_tvnow();
	s->last_keepalive = ast_tvnow();
	s->keepalive_count = 0;
	s->lockstate = 0;

	AST_LIST_LOCK(&sessions);
	AST_LIST_INSERT_HEAD(&sessions, s, list);
	AST_LIST_UNLOCK(&sessions);

	s->auth_timeout_sched = ast_sched_add(sched, auth_timeout*1000, skinny_noauth_cb, s);
	s->keepalive_timeout_sched = ast_sched_add(sched, keep_alive*3000, skinny_nokeepalive_cb, s);

	for (;;) {

		fds[0].fd = s->fd;
		fds[0].events = POLLIN;
		fds[0].revents = 0;
		res = ast_poll(fds, 1, -1); /* block */
		if (res < 0) {
			if (errno != EINTR) {
				ast_log(LOG_WARNING, "Select returned error: %s\n", strerror(errno));
				ast_verb(3, "Ending Skinny session from %s (bad input)\n", ast_inet_ntoa(s->sin.sin_addr));
				break;
			}
		}

		if (!fds[0].revents) {
			continue;
		}
		ast_debug(1, "Reading header\n");

		if (!(req = ast_calloc(1, SKINNY_MAX_PACKET))) {
			ast_log(LOG_WARNING, "Unable to allocated memorey for skinny_req.\n");
			break;
		}

		ast_mutex_lock(&s->lock);
		s->lockstate = 1;

		if ((res = read(s->fd, req, skinny_header_size)) != skinny_header_size) {
			if (res < 0) {
				ast_log(LOG_WARNING, "Header read() returned error: %s\n", strerror(errno));
			} else {
				ast_log(LOG_WARNING, "Unable to read header. Only found %d bytes.\n", res);
			}
			break;
		}

		eventmessage = letohl(req->e);
		if (eventmessage < 0) {
			ast_log(LOG_ERROR, "Event Message is NULL from socket %d, This is bad\n", s->fd);
			break;
		}

		dlen = letohl(req->len) - 4;
		if (dlen < 0) {
			ast_log(LOG_WARNING, "Skinny Client sent invalid data.\n");
			break;
		}
		if (dlen > (SKINNY_MAX_PACKET - skinny_header_size)) {
			ast_log(LOG_WARNING, "Skinny packet too large (%d bytes), max length(%d bytes)\n", dlen+8, SKINNY_MAX_PACKET);
			break;
		}

		ast_debug(1, "Read header: Message ID: 0x%04x,  %d bytes in packet\n", eventmessage, dlen);

		bytesread = 0;
		while (bytesread < dlen) {
			ast_debug(1, "Waiting %dms for %d bytes of %d\n", PACKET_TIMEOUT, dlen - bytesread, dlen);
			fds[0].revents = 0;
			res = ast_poll(fds, 1, PACKET_TIMEOUT);
			if (res <= 0) {
				if (res == 0) {
					ast_debug(1, "Poll timed out waiting for %d bytes\n", dlen - bytesread);
				} else {
					ast_log(LOG_WARNING, "Poll failed waiting for %d bytes: %s\n",
						dlen - bytesread, strerror(errno));
				}
				ast_verb(3, "Ending Skinny session from %s (bad input)\n", ast_inet_ntoa(s->sin.sin_addr));
				res = -1;

				break;
			}
			if (!fds[0].revents) {
				continue;
			}

			res = read(s->fd, ((char*)&req->data)+bytesread, dlen-bytesread);
			if (res < 0) {
				ast_log(LOG_WARNING, "Data read() returned error: %s\n", strerror(errno));
				break;
			}
			bytesread += res;
			ast_debug(1, "Read %d bytes.  %d of %d now read\n", res, bytesread, dlen);
		}

		s->lockstate = 0;
		ast_mutex_unlock(&s->lock);
		if (res < 0) {
			break;
		}

		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
		res = handle_message(req, s);
		pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);

		if (req) {
			ast_free(req);
			req = NULL;
		}
	}

	ast_log(LOG_NOTICE, "Skinny Session returned: %s\n", strerror(errno));
	if (req) {
		ast_free(req);
	}

	pthread_cleanup_pop(1);

	return 0;
}
