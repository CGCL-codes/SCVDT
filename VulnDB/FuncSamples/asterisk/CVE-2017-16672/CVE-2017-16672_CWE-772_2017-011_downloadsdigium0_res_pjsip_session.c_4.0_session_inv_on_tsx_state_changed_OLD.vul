static void session_inv_on_tsx_state_changed(pjsip_inv_session *inv, pjsip_transaction *tsx, pjsip_event *e)
{
	ast_sip_session_response_cb cb;
	int id = session_module.id;
	struct ast_sip_session *session;
	pjsip_tx_data *tdata;

	/*
	 * A race condition exists at shutdown where the res_pjsip_session can be
	 * unloaded but this callback may still get called afterwards. In this case
	 * the id may end up being -1 which is useless to us. To work around this
	 * we store the current value and check/use it.
	 */
	if (id < 0) {
		return;
	}

	session = inv->mod_data[id];

	print_debug_details(inv, tsx, e);
	if (!session) {
		/* The session has ended.  Ignore the transaction change. */
		return;
	}
	switch (e->body.tsx_state.type) {
	case PJSIP_EVENT_TX_MSG:
		/* When we create an outgoing request, we do not have access to the transaction that
		 * is created. Instead, We have to place transaction-specific data in the tdata. Here,
		 * we transfer the data into the transaction. This way, when we receive a response, we
		 * can dig this data out again
		 */
		tsx->mod_data[id] = e->body.tsx_state.src.tdata->mod_data[id];
		break;
	case PJSIP_EVENT_RX_MSG:
		cb = ast_sip_mod_data_get(tsx->mod_data, id, MOD_DATA_ON_RESPONSE);
		/* As the PJSIP invite session implementation responds with a 200 OK before we have a
		 * chance to be invoked session supplements for BYE requests actually end up executing
		 * in the invite session state callback as well. To prevent session supplements from
		 * running on the BYE request again we explicitly squash invocation of them here.
		 */
		if ((e->body.tsx_state.src.rdata->msg_info.msg->type != PJSIP_REQUEST_MSG) ||
			(tsx->method.id != PJSIP_BYE_METHOD)) {
			handle_incoming(session, e->body.tsx_state.src.rdata,
				AST_SIP_SESSION_AFTER_MEDIA);
		}
		if (tsx->method.id == PJSIP_INVITE_METHOD) {
			if (tsx->role == PJSIP_ROLE_UAC) {
				if (tsx->state == PJSIP_TSX_STATE_COMPLETED) {
					/* This means we got a non 2XX final response to our outgoing INVITE */
					if (tsx->status_code == PJSIP_SC_REQUEST_PENDING) {
						reschedule_reinvite(session, cb);
						return;
					}
					if (inv->state == PJSIP_INV_STATE_CONFIRMED) {
						ast_debug(1, "reINVITE received final response code %d\n",
							tsx->status_code);
						if ((tsx->status_code == 401 || tsx->status_code == 407)
							&& !ast_sip_create_request_with_auth(
								&session->endpoint->outbound_auths,
								e->body.tsx_state.src.rdata, tsx, &tdata)) {
							/* Send authed reINVITE */
							ast_sip_session_send_request_with_cb(session, tdata, cb);
							return;
						}
						if (tsx->status_code != 488) {
							/* Other reinvite failures (except 488) result in destroying the session. */
							if (pjsip_inv_end_session(inv, 500, NULL, &tdata) == PJ_SUCCESS
								&& tdata) {
								ast_sip_session_send_request(session, tdata);
							}
						}
					}
				} else if (tsx->state == PJSIP_TSX_STATE_TERMINATED) {
					if (inv->cancelling && tsx->status_code == PJSIP_SC_OK) {
						int sdp_negotiation_done =
							pjmedia_sdp_neg_get_state(inv->neg) == PJMEDIA_SDP_NEG_STATE_DONE;

						/*
						 * We can get here for the following reasons.
						 *
						 * 1) The race condition detailed in RFC5407 section 3.1.2.
						 * We sent a CANCEL at the same time that the UAS sent us a
						 * 200 OK with a valid SDP for the original INVITE.  As a
						 * result, we have now received a 200 OK for a cancelled
						 * call and the SDP negotiation is complete.  We need to
						 * immediately send a BYE to end the dialog.
						 *
						 * 2) We sent a CANCEL and hit the race condition but the
						 * UAS sent us an invalid SDP with the 200 OK.  In this case
						 * the SDP negotiation is incomplete and PJPROJECT has
						 * already sent the BYE for us because of the invalid SDP.
						 *
						 * 3) We didn't send a CANCEL but the UAS sent us an invalid
						 * SDP with the 200 OK.  In this case the SDP negotiation is
						 * incomplete and PJPROJECT has already sent the BYE for us
						 * because of the invalid SDP.
						 */
						ast_test_suite_event_notify("PJSIP_SESSION_CANCELED",
							"Endpoint: %s\r\n"
							"Channel: %s\r\n"
							"Message: %s\r\n"
							"SDP: %s",
							ast_sorcery_object_get_id(session->endpoint),
							session->channel ? ast_channel_name(session->channel) : "",
							pjsip_rx_data_get_info(e->body.tsx_state.src.rdata),
							sdp_negotiation_done ? "complete" : "incomplete");
						if (!sdp_negotiation_done) {
							ast_debug(1, "Endpoint '%s(%s)': Incomplete SDP negotiation cancelled session.  %s\n",
								ast_sorcery_object_get_id(session->endpoint),
								session->channel ? ast_channel_name(session->channel) : "",
								pjsip_rx_data_get_info(e->body.tsx_state.src.rdata));
						} else if (pjsip_inv_end_session(inv, 500, NULL, &tdata) == PJ_SUCCESS
							&& tdata) {
							ast_debug(1, "Endpoint '%s(%s)': Ending session due to RFC5407 race condition.  %s\n",
								ast_sorcery_object_get_id(session->endpoint),
								session->channel ? ast_channel_name(session->channel) : "",
								pjsip_rx_data_get_info(e->body.tsx_state.src.rdata));
							ast_sip_session_send_request(session, tdata);
						}
					}
				}
			}
		} else {
			/* All other methods */
			if (tsx->role == PJSIP_ROLE_UAC) {
				if (tsx->state == PJSIP_TSX_STATE_COMPLETED) {
					/* This means we got a final response to our outgoing method */
					ast_debug(1, "%.*s received final response code %d\n",
						(int) pj_strlen(&tsx->method.name), pj_strbuf(&tsx->method.name),
						tsx->status_code);
					if ((tsx->status_code == 401 || tsx->status_code == 407)
						&& !ast_sip_create_request_with_auth(
							&session->endpoint->outbound_auths,
							e->body.tsx_state.src.rdata, tsx, &tdata)) {
						/* Send authed version of the method */
						ast_sip_session_send_request_with_cb(session, tdata, cb);
						return;
					}
				}
			}
		}
		if (cb) {
			cb(session, e->body.tsx_state.src.rdata);
		}
		break;
	case PJSIP_EVENT_TRANSPORT_ERROR:
		if (inv->state == PJSIP_INV_STATE_DISCONNECTED) {
			/*
			 * Clear the module data now to block session_inv_on_state_changed()
			 * from calling session_end() if it hasn't already done so.
			 */
			inv->mod_data[id] = NULL;

			/*
			 * Pass the session ref held by session->inv_session to
			 * session_end_completion().
			 */
			if (session
				&& ast_sip_push_task(session->serializer, session_end_completion, session)) {
				/* Do it anyway even though this is not the right thread. */
				session_end_completion(session);
			}
			return;
		}
		break;
	case PJSIP_EVENT_TIMER:
		/*
		 * The timer event is run by the pjsip monitor thread and not
		 * by the session serializer.
		 */
		if (inv->state == PJSIP_INV_STATE_DISCONNECTED) {
			/*
			 * We are locking because ast_sip_dialog_get_session() needs
			 * the dialog locked to get the session by other threads.
			 */
			pjsip_dlg_inc_lock(inv->dlg);
			session = inv->mod_data[id];
			inv->mod_data[id] = NULL;
			pjsip_dlg_dec_lock(inv->dlg);

			/*
			 * Pass the session ref held by session->inv_session to
			 * session_end_completion().
			 */
			if (session
				&& ast_sip_push_task(session->serializer, session_end_completion, session)) {
				/* Do it anyway even though this is not the right thread. */
				session_end_completion(session);
			}
			return;
		}
		break;
	case PJSIP_EVENT_USER:
	case PJSIP_EVENT_UNKNOWN:
	case PJSIP_EVENT_TSX_STATE:
		/* Inception? */
		break;
	}

	if (AST_LIST_EMPTY(&session->delayed_requests)) {
		/* No delayed request pending, so just return */
		return;
	}

	if (tsx->method.id == PJSIP_INVITE_METHOD) {
		if (tsx->state == PJSIP_TSX_STATE_PROCEEDING) {
			ast_debug(3, "Endpoint '%s(%s)' INVITE delay check. tsx-state:%s\n",
				ast_sorcery_object_get_id(session->endpoint),
				session->channel ? ast_channel_name(session->channel) : "",
				pjsip_tsx_state_str(tsx->state));
			check_delayed_requests(session, invite_proceeding);
		} else if (tsx->state == PJSIP_TSX_STATE_TERMINATED) {
			/*
			 * Terminated INVITE transactions always should result in
			 * queuing delayed requests, no matter what event caused
			 * the transaction to terminate.
			 */
			ast_debug(3, "Endpoint '%s(%s)' INVITE delay check. tsx-state:%s\n",
				ast_sorcery_object_get_id(session->endpoint),
				session->channel ? ast_channel_name(session->channel) : "",
				pjsip_tsx_state_str(tsx->state));
			check_delayed_requests(session, invite_terminated);
		}
	} else if (tsx->role == PJSIP_ROLE_UAC
		&& tsx->state == PJSIP_TSX_STATE_COMPLETED
		&& !pj_strcmp2(&tsx->method.name, "UPDATE")) {
		ast_debug(3, "Endpoint '%s(%s)' UPDATE delay check. tsx-state:%s\n",
			ast_sorcery_object_get_id(session->endpoint),
			session->channel ? ast_channel_name(session->channel) : "",
			pjsip_tsx_state_str(tsx->state));
		check_delayed_requests(session, update_completed);
	}
}
