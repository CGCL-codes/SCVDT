static void ast_rtp_alt_remote_address_set(struct ast_rtp_instance *instance, struct ast_sockaddr *addr)
{
	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);

	/* No need to futz with rtp->rtcp here because ast_rtcp_read is already able to adjust if receiving
	 * RTCP from an "unexpected" source
	 */
	ast_sockaddr_copy(&rtp->alt_rtp_address, addr);

	if (strictrtp && rtp->strict_rtp_state != STRICT_RTP_OPEN
		&& !ast_sockaddr_isnull(addr) && ast_sockaddr_cmp(addr, &rtp->strict_rtp_address)) {
		/*
		 * We only need to learn a new strict source address if we've been told the
		 * source may be changing to something different.
		 *
		 * XXX NOTE: The alternate source address is only set because of a reINVITE
		 * glare in chan_sip.  A reINVITE glare is supposed to be retried after a
		 * backoff delay so it shouldn't be needed at all.  However, I found this
		 * as the best description of why it was added:
		 * http://lists.digium.com/pipermail/asterisk-dev/2009-May/038348.html
		 * https://reviewboard.asterisk.org/r/252/
		 */
		ast_verb(4, "%p -- Strict RTP learning after alternate remote address set to: %s\n",
			rtp, ast_sockaddr_stringify(addr));
		rtp_learning_start(rtp);
	}
}
