static pj_bool_t session_reinvite_on_rx_request(pjsip_rx_data *rdata)
{
	pjsip_dialog *dlg;
	RAII_VAR(struct ast_sip_session *, session, NULL, ao2_cleanup);
	pjsip_rdata_sdp_info *sdp_info;

	if (rdata->msg_info.msg->line.req.method.id != PJSIP_INVITE_METHOD ||
		!(dlg = pjsip_ua_find_dialog(&rdata->msg_info.cid->id, &rdata->msg_info.to->tag, &rdata->msg_info.from->tag, PJ_FALSE)) ||
		!(session = ast_sip_dialog_get_session(dlg)) ||
		!session->channel) {
		return PJ_FALSE;
	}

	if (session->deferred_reinvite) {
		pj_str_t key, deferred_key;
		pjsip_tx_data *tdata;

		/* We use memory from the new request on purpose so the deferred reinvite pool does not grow uncontrollably */
		pjsip_tsx_create_key(rdata->tp_info.pool, &key, PJSIP_ROLE_UAS, &rdata->msg_info.cseq->method, rdata);
		pjsip_tsx_create_key(rdata->tp_info.pool, &deferred_key, PJSIP_ROLE_UAS, &session->deferred_reinvite->msg_info.cseq->method,
			session->deferred_reinvite);

		/* If this is a retransmission ignore it */
		if (!pj_strcmp(&key, &deferred_key)) {
			return PJ_TRUE;
		}

		/* Otherwise this is a new re-invite, so reject it */
		if (pjsip_dlg_create_response(dlg, rdata, 491, NULL, &tdata) == PJ_SUCCESS) {
			pjsip_endpt_send_response2(ast_sip_get_pjsip_endpoint(), rdata, tdata, NULL, NULL);
		}

		return PJ_TRUE;
	}

	if (!(sdp_info = pjsip_rdata_get_sdp_info(rdata)) ||
		(sdp_info->sdp_err != PJ_SUCCESS)) {
		return PJ_FALSE;
	}

	if (!sdp_info->sdp) {
		const pjmedia_sdp_session *local;
		int i;

		ast_queue_unhold(session->channel);

		pjmedia_sdp_neg_get_active_local(session->inv_session->neg, &local);
		if (!local) {
			return PJ_FALSE;
		}

		/*
		 * Some devices indicate hold with deferred SDP reinvites (i.e. no SDP in the reinvite).
		 * When hold is initially indicated, we
		 * - Receive an INVITE with no SDP
		 * - Send a 200 OK with SDP, indicating sendrecv in the media streams
		 * - Receive an ACK with SDP, indicating sendonly in the media streams
		 *
		 * At this point, the pjmedia negotiator saves the state of the media direction so that
		 * if we are to send any offers, we'll offer recvonly in the media streams. This is
		 * problematic if the device is attempting to unhold, though. If the device unholds
		 * by sending a reinvite with no SDP, then we will respond with a 200 OK with recvonly.
		 * According to RFC 3264, if an offerer offers recvonly, then the answerer MUST respond
		 * with sendonly or inactive. The result of this is that the stream is not off hold.
		 *
		 * Therefore, in this case, when we receive a reinvite while the stream is on hold, we
		 * need to be sure to offer sendrecv. This way, the answerer can respond with sendrecv
		 * in order to get the stream off hold. If this is actually a different purpose reinvite
		 * (like a session timer refresh), then the answerer can respond to our sendrecv with
		 * sendonly, keeping the stream on hold.
		 */
		for (i = 0; i < local->media_count; ++i) {
			pjmedia_sdp_media *m = local->media[i];
			pjmedia_sdp_attr *recvonly;
			pjmedia_sdp_attr *inactive;

			recvonly = pjmedia_sdp_attr_find2(m->attr_count, m->attr, "recvonly", NULL);
			inactive = pjmedia_sdp_attr_find2(m->attr_count, m->attr, "inactive", NULL);
			if (recvonly || inactive) {
				pjmedia_sdp_attr *to_remove = recvonly ?: inactive;
				pjmedia_sdp_attr *sendrecv;

				pjmedia_sdp_attr_remove(&m->attr_count, m->attr, to_remove);

				sendrecv = pjmedia_sdp_attr_create(session->inv_session->pool, "sendrecv", NULL);
				pjmedia_sdp_media_add_attr(m, sendrecv);
			}
		}

		return PJ_FALSE;
	}

	if (!sdp_requires_deferral(session, sdp_info->sdp)) {
		return PJ_FALSE;
	}

	pjsip_rx_data_clone(rdata, 0, &session->deferred_reinvite);

	return PJ_TRUE;
}
