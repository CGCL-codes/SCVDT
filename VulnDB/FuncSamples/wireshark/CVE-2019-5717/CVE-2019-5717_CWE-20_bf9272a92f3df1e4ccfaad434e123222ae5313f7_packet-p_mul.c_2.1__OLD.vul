static p_mul_seq_val *register_p_mul_id (packet_info *pinfo, address *addr, guint32 dstIP,
                                         guint8 pdu_type, guint32 message_id,
                                         guint16 seq_no, gint no_missing)
{
  p_mul_seq_val  *p_mul_data = NULL, *pkg_data = NULL;
  p_mul_id_key   *p_mul_key;
  p_mul_ack_data *ack_data = NULL;
  nstime_t        addr_time, prev_time;
  guint           addr_id = 0, prev_id = 0;
  guint16         last_found_pdu = 0;
  gboolean        missing_pdu = FALSE, need_set_address = FALSE;
  wmem_map_t     *pkg_list;

  if (pinfo->flags.in_error_pkt) {
    /* No analysis of error packets */
    return NULL;
  }

  nstime_set_zero(&addr_time);
  nstime_set_zero(&prev_time);

  p_mul_key = wmem_new(wmem_file_scope(), p_mul_id_key);

  if (!pinfo->fd->flags.visited &&
      (pdu_type == Address_PDU || pdu_type == Data_PDU || pdu_type == Discard_Message_PDU))
  {
    /* Try to match corresponding address PDU */
    p_mul_key->id = message_id;
    p_mul_key->seq = 0;
    copy_address_wmem(wmem_file_scope(), &p_mul_key->addr, addr);
    need_set_address = TRUE;

    p_mul_data = (p_mul_seq_val *) wmem_map_lookup (p_mul_id_hash_table, p_mul_key);

    if (p_mul_data) {
      /* Found address PDU */
      last_found_pdu = p_mul_data->last_found_pdu;
      p_mul_data->last_found_pdu = seq_no;
      addr_id = p_mul_data->pdu_id;
      addr_time = p_mul_data->pdu_time;

      /* Save data for last found PDU */
      p_mul_data->prev_pdu_id = pinfo->num;
      p_mul_data->prev_pdu_time = pinfo->abs_ts;

      if (pdu_type == Data_PDU && p_mul_data->msg_resend_count == 0 && last_found_pdu != seq_no - 1) {
        /* Data_PDU and missing previous PDU */
        missing_pdu = TRUE;
      }

      if (last_found_pdu) {
        /* Try to match previous data PDU */
        p_mul_key->seq = last_found_pdu;
        p_mul_data = (p_mul_seq_val *) wmem_map_lookup (p_mul_id_hash_table, p_mul_key);
      }

      if (p_mul_data) {
        /* Found a previous PDU (Address or Data) */
        if (p_mul_data->prev_msg_id > 0) {
          prev_id = p_mul_data->prev_msg_id;
        } else {
          prev_id = p_mul_data->pdu_id;
        }
        prev_time = p_mul_data->pdu_time;
      }
    } else if (pdu_type == Address_PDU) {
      addr_id = pinfo->num;
      addr_time = pinfo->abs_ts;
    }
  }

  pkg_list = (wmem_map_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_p_mul, 0);
  if (!pkg_list) {
    /* Never saved list for this packet, create a new */
    pkg_list = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);
    p_add_proto_data(wmem_file_scope(), pinfo, proto_p_mul, 0, pkg_list);
  }

  if (!pinfo->fd->flags.visited) {
    p_mul_key->id = message_id;
    p_mul_key->seq = seq_no;
    if (!need_set_address) {
      copy_address_wmem(wmem_file_scope(), &p_mul_key->addr, addr);
    }
    p_mul_data = (p_mul_seq_val *) wmem_map_lookup (p_mul_id_hash_table, p_mul_key);

    if (p_mul_data) {
      if (pdu_type == Ack_PDU) {
        /* Only save this data if positive ack */
        if (no_missing == 0) {
          ack_data = (p_mul_ack_data *)wmem_map_lookup (p_mul_data->ack_data, GUINT_TO_POINTER(dstIP));
          if (!ack_data) {
            /* Only save reference to first ACK */
            ack_data = wmem_new0(wmem_file_scope(), p_mul_ack_data);
            ack_data->ack_id = pinfo->num;
            wmem_map_insert (p_mul_data->ack_data, GUINT_TO_POINTER(dstIP), ack_data);
          } else {
            /* Only count when resending */
            ack_data->ack_resend_count++;
          }
        }
      } else {
        /* Message resent */
        p_mul_data->msg_resend_count++;
        p_mul_data->prev_msg_id = pinfo->num;
        p_mul_data->prev_msg_time = p_mul_data->pdu_time;
        p_mul_data->pdu_time = pinfo->abs_ts;

        if (pdu_type == Data_PDU) {
          p_mul_data->prev_pdu_id = prev_id;
          p_mul_data->prev_pdu_time = prev_time;
        }
      }
    } else {
      /* New message */
      if (pdu_type == Ack_PDU) {
        /* Data is just copied to the structure and never stored,
             so keep a "more temporary" structure */
        p_mul_data = wmem_new0(wmem_packet_scope(), p_mul_seq_val);
      } else {
        p_mul_data = wmem_new0(wmem_file_scope(), p_mul_seq_val);
      }
      p_mul_data->msg_type = pdu_type;
      if (pdu_type == Address_PDU || pdu_type == Ack_PDU) {
        p_mul_data->ack_data = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);
      }

      if (pdu_type == Ack_PDU) {
        /* No matching message for this ack */
        ack_data = wmem_new0(wmem_file_scope(), p_mul_ack_data);
        ack_data->ack_id = pinfo->num;
        wmem_map_insert (p_mul_data->ack_data, GUINT_TO_POINTER(dstIP), ack_data);
      } else {
        p_mul_data->pdu_id = pinfo->num;
        p_mul_data->pdu_time = pinfo->abs_ts;
        p_mul_data->addr_id = addr_id;
        p_mul_data->addr_time = addr_time;
        p_mul_data->first_msg_time = pinfo->abs_ts;

        if (pdu_type == Data_PDU && !missing_pdu) {
          p_mul_data->prev_pdu_id = prev_id;
          p_mul_data->prev_pdu_time = prev_time;
        }

        wmem_map_insert (p_mul_id_hash_table, p_mul_key, p_mul_data);
      }
    }

    /* Copy the current package data to the frame */
    pkg_data = wmem_new(wmem_file_scope(), p_mul_seq_val);
    *pkg_data = *p_mul_data;
    if (p_mul_data->ack_data) {
      /* Copy the hash table for ack data */
      pkg_data->ack_data = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);
      wmem_map_foreach (p_mul_data->ack_data, copy_hashtable_data, pkg_data->ack_data);
    }
    wmem_map_insert(pkg_list, GUINT_TO_POINTER(message_id), pkg_data);
  } else {
    /* Fetch last values from data saved in packet */
    pkg_data = (p_mul_seq_val *)wmem_map_lookup (pkg_list, GUINT_TO_POINTER(message_id));
  }

  DISSECTOR_ASSERT (pkg_data);
  return pkg_data;
}
