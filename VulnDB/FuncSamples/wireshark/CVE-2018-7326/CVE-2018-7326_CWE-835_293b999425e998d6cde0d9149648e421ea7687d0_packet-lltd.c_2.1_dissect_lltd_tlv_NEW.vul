static int
dissect_lltd_tlv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, gboolean* end)
{
    guint8     type, length = 0;
    proto_item *tlv_item, *type_item;
    proto_tree *tlv_tree, *type_tree;
    guint32 i, temp32;

    type = tvb_get_guint8(tvb, offset);
    if (type == 0)
    {
        /* End of Property type doesn't have length */
        tlv_tree = proto_tree_add_subtree(tree, tvb, offset, 1, ett_tlv_item, &tlv_item, "TLV Item (End of Property List)");
        *end = TRUE;
    }
    else
    {
        length = tvb_get_guint8(tvb, offset+1);
        tlv_tree = proto_tree_add_subtree_format(tree, tvb, offset, length+2, ett_tlv_item, &tlv_item,
                    "TLV Item (%s)", val_to_str(type, lltd_tlv_type_vals, "Unknown (0x%02x)"));
        *end = FALSE;
    }

    proto_tree_add_item(tlv_tree, hf_lltd_tlv_type, tvb, offset, 1, ENC_NA);
    if (type != 0)
        proto_tree_add_item(tlv_tree, hf_lltd_tlv_length, tvb, offset+1, 1, ENC_NA);


    if ((type != 0) && (length > tvb_reported_length_remaining(tvb, offset+2)))
    {
        expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "TLV Length field too big");
        *end = TRUE;
        return 2;
    }

    switch(type)
    {
    case 0x00: /* End of Property List */
        /* No data, no length field */
        return 1;
    case 0x01: /* Host ID */
        if (length != 6)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid Host ID length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_host_id, tvb, offset+2, 6, ENC_NA);
        break;
    case 0x02: /* Characteristics */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Characteristics length");
        }
        else
        {
            type_tree = proto_tree_add_subtree(tree, tvb, offset+2, 4, ett_characteristics, &type_item, "Characteristics");
            proto_tree_add_item(type_tree, hf_lltd_char_p, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_char_x, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_char_f, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_char_m, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_char_l, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_char_reserved, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            if (tvb_get_ntohl(tvb, offset+2) & LLTD_CHARACTERISTIC_RESERVE_MASK)
                expert_add_info(pinfo, type_item, &ei_lltd_char_reserved);
        }
        break;
    case 0x03: /* Physical Medium */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid Physical Medium length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_physical_medium, tvb, offset+2, 4, ENC_BIG_ENDIAN);
        break;
    case 0x04: /* Wireless Mode */
        if (length != 1)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid Wireless Mode length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_wireless_mode, tvb, offset+2, 1, ENC_BIG_ENDIAN);
        break;
    case 0x05: /* 802.11 BSSID */
        if (length != 6)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid BSSID length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_bssid, tvb, offset+2, 6, ENC_NA);
        break;
    case 0x06: /* 802.11 SSID */
        if (length > 32)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "SSID length too large");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_ssid, tvb, offset+2, length, ENC_NA|ENC_ASCII);
        break;
    case 0x07: /* IPv4 Address */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid IPv4 Address length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_ipv4_address, tvb, offset+2, 4, ENC_BIG_ENDIAN);
        break;
    case 0x08: /* IPv6 Address */
        if (length != 16)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid IPv6 Address length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_ipv6_address, tvb, offset+2, 16, ENC_NA);
        break;
    case 0x09: /* 802.11 Maximum Operation Rate */
        if (length != 2)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid Maximum Operation Rate length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_max_operation_rate, tvb, offset+2, 2, ENC_BIG_ENDIAN);
        break;
    case 0x0A: /* Performance Counter Frequency */
        if (length != 8)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid Performance Counter Frequency length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_performance_count_freq, tvb, offset+2, 8, ENC_BIG_ENDIAN);
        break;
    case 0x0C: /* Link Speed */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid Link Speed length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_link_speed, tvb, offset+2, 4, ENC_BIG_ENDIAN);
        break;
    case 0x0D: /* 802.11 RSSI */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid RSSI length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_rssi, tvb, offset+2, 4, ENC_BIG_ENDIAN);
        break;
    case 0x0F: /* Machine Name */
        if (length > 32)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Machine Name length too large");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_machine_name, tvb, offset+2, length, ENC_LITTLE_ENDIAN|ENC_UCS_2);
        break;
    case 0x10: /* Support Information */
        if (length > 64)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Support Information length too large");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_support_info, tvb, offset+2, length, ENC_LITTLE_ENDIAN|ENC_UCS_2);
        break;
    case 0x11: /* Friendly Name */
        if (length != 0)
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid Friendly Name length");
        break;
    case 0x12: /* Device UUID */
        if (length != 22)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid Device UUID length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_device_uuid, tvb, offset+2, 22, ENC_NA);
        break;
    case 0x13: /* Hardware ID */
        if (length != 0)
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid Hardware ID length");
        break;
    case 0x14: /* QoS Characteristics */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "QoS Characteristics length");
        }
        else
        {
            type_tree = proto_tree_add_subtree(tlv_tree, tvb, offset+2, 4, ett_qos_characteristics, &type_item, "QoS Characteristics");
            proto_tree_add_item(type_tree, hf_lltd_qos_char_e, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_qos_char_q, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_qos_char_p, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_qos_char_reserved, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            temp32 = tvb_get_ntohl(tvb, offset+2);
            if (temp32 & LLTD_QOS_CHARACTERISTIC_RESERVE_MASK)
                expert_add_info(pinfo, type_item, &ei_lltd_char_reserved);
        }
        break;
    case 0x15: /* 802.11 Physical Medium */
        if (length != 1)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid 802.11 Phyiscal Medium length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_80211_physical_medium, tvb, offset+2, 1, ENC_BIG_ENDIAN);
        break;
    case 0x19: /* Sees-List Working Set */
        if (length != 2)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid Sees-List Working Set length");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_sees_list_working_set, tvb, offset+2, 2, ENC_BIG_ENDIAN);
        break;
    case 0x1B: /* Repeater AP Lineage */
        type_tree = proto_tree_add_subtree(tree, tvb, offset+2, length, ett_repeater_ap_lineage, NULL, "Repeater AP Lineage");
        for (i = 0; i < length; i += 6)
            proto_tree_add_item(type_tree, hf_lltd_repeater_ap_lineage, tvb, offset+2+i, 6, ENC_NA);

        if (length > 36)
            expert_add_info(pinfo, tlv_item, &ei_lltd_too_many_paths);
        break;
    case 0x0E: /* Icon Image */
    case 0x16: /* AP Association Table */
    case 0x18: /* Detailed Icon Image */
    case 0x1A: /* Component Table */
    case 0x1C: /* Repeater AP Table */
        if (length != 0)
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, "Invalid length");
        break;
    default:
        expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_type, "Invalid TLV Type 0x%02x", type);
        break;
    }

    return length+2;
}
