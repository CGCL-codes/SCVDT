int dissect_wassp_sub_tlv(proto_tree *wassp_tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int in_len, int which_tab, int ru_msg_type)
{
	proto_item *tlvi;
	proto_item *ti;
	proto_tree *tmp_tree;
	const char *label;
	guint32 value;
	guint16 tlv_type = EID_PARSE_ERROR;
	guint16 length = 0, org_offset = offset;
	const WASSP_SUBTLV_DECODER_INFO_t *tmp_decr = NULL;
	guint32 i, tableNo;
	int suboffset;

	if (which_tab >= TAB_MAX)
	{
		return offset;
	}

	tmp_decr = &wassp_decr_info[which_tab];

	if (tvb_reported_length_remaining(tvb, offset) > 0)
	{
		ti = proto_tree_add_item(wassp_tree, hf_wassp_sub_tree, tvb, offset, in_len, ENC_NA);
		proto_item_append_text(ti, " : %s", tmp_decr->subtree_name);
		tmp_tree = proto_item_add_subtree(ti, *((int*)(WASSP_SUBTLV_GET_ETTNUM(tmp_decr))));

		while (((value = tvb_reported_length_remaining(tvb, offset)) >= 4) && (offset - org_offset < in_len))
		{
			tlv_type = tvb_get_ntohs(tvb, offset + TLV_TYPE);
			length = tvb_get_ntohs(tvb, offset + TLV_LENGTH);
			if (tlv_type >= WASSP_SUBTLV_GET_MAXENTRY(tmp_decr))
			{
				proto_tree_add_uint_format_value(tmp_tree, hf_wassp_tlv_unknown, tvb, offset, 4, tlv_type, "Unknow Wassp TLV (%d)", tlv_type);
				proto_tree_add_item(tmp_tree, hf_wassp_tlv_length, tvb, offset + TLV_LENGTH, 2, ENC_BIG_ENDIAN);
				proto_tree_add_item(tmp_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);
				offset += length;
				continue;
			}

			label = wassp_match_strval(tmp_decr, tlv_type);
			label = (label == NULL) ? "Unknown Type" : label;

			if (length > value)
			{
				proto_tree_add_item(tmp_tree, hf_wassp_tlv_invalid, tvb, offset, 4, ENC_BIG_ENDIAN);
				tlv_type = EID_PARSE_ERROR;
			}
			else if (length < 4)
			{
				proto_tree_add_item(tmp_tree, hf_wassp_tlv_invalid, tvb, offset, 4, ENC_BIG_ENDIAN);
				tlv_type = EID_PARSE_ERROR;
			}
			else if (length == 4)
			{
				if ((which_tab == TAB_RSS_DATA_ARRAY) && (tlv_type == EID_RSS_DATA_BLOCK))
				{
					proto_tree_add_item(tmp_tree, hf_wassp_tlv_value_octext, tvb, offset, length, ENC_NA);
				}
				else
				{
					tlvi = proto_tree_add_item(tmp_tree, hf_wassp_tlv_value, tvb, offset, length, ENC_NA);
					proto_item_append_text(tlvi, " : %s (%d)", label, tlv_type);
				}
				offset += length;
				continue;
			}
			else
			{
				if ((which_tab == TAB_RSS_DATA_ARRAY) && (tlv_type == EID_RSS_DATA_BLOCK))
				{
					proto_tree_add_item(tmp_tree, hf_wassp_tlv_value_octext, tvb, offset, length, ENC_NA);
				}
				else
				{
					tlvi = proto_tree_add_item(tmp_tree, hf_wassp_tlv_value, tvb, offset, length, ENC_NA);
					proto_item_append_text(tlvi, " : %s (%d)", label, tlv_type);
				}
			}

			tlvi =   proto_tree_add_item(tmp_tree, hf_wassp_tlv_type_sub, tvb, offset + TLV_TYPE, 2, ENC_NA);
			proto_item_append_text(tlvi, " : %s (%d)", label, tlv_type);
			proto_tree_add_item(tmp_tree, hf_wassp_tlv_length, tvb, offset + TLV_LENGTH, 2, ENC_BIG_ENDIAN);

			if (tlv_type == EID_PARSE_ERROR)
			{
				proto_tree_add_item(wassp_tree, hf_wassp_tlv_invalid, tvb, offset, value, ENC_BIG_ENDIAN);
				offset += length;
				break;
			}
			else
			{
				if (WASSP_SUBTLV_GET_ENTRY_IDX_TYPE(tmp_decr, tlv_type) != TLV_TYPE_BLOCK_TLV)
				{
					proto_tree_add_item(tmp_tree, wassp_type_converter(WASSP_SUBTLV_GET_ENTRY_IDX_TYPE(tmp_decr, tlv_type)), tvb, offset + TLV_VALUE, length - 4, FALSE);
					if ((which_tab == TAB_CONFIG_SITE) && (tlv_type == EID_SITE_TOPOLOGY_BLOCK))
					{
						suboffset = offset + 4;
						for (i = 0; i < (guint32)(length / 4 - 1); i++)
						{
							proto_tree_add_item(tmp_tree, hf_wassp_topologykey, tvb, suboffset, 2, ENC_BIG_ENDIAN);
							suboffset += 2;
							proto_tree_add_item(tmp_tree, hf_wassp_topology_mode, tvb, suboffset, 2, ENC_BIG_ENDIAN);
							suboffset += 2;
						}
					}

					if (which_tab == VNS_CONFIG_BLOCK)
					{
						if (tlv_type == EID_V_COS)
						{
							decode_cos_struct(tmp_tree, tvb, offset + 4 );
						}
						else if (tlv_type == EID_V_RATE_LIMIT_RESOURCE_TBL)
						{
							decode_rate_limit_struct(tmp_tree,tvb,  offset + 4,length-4 );
						}
					}

					if (which_tab == TAB_CONFIG_FILTER || which_tab == TAB_FILTER_CONFIG_STRUCT_BLOCK)
					{
						if (tlv_type == EID_V_FILTER_RULES || tlv_type == EID_FILTER_RULES || tlv_type == EID_V_SITE_FILTER_RULES )
						{
							if (length < 20)
								break;
							decode_filter_rule_octext_string(tmp_tree, tvb, offset + 4, length );

						}
					}


					if (which_tab == TAB_SCAN_PROFILE_BLOCK)
					{
						if (tlv_type == EID_CHANNEL_LIST)
						{
							decode_Channel_list(tmp_tree, tvb, offset + 4,  length -4 );
						}
					}

					if (which_tab == TAB_SURVEILLANCE_DATA_BLOCK)
					{
						if (tlv_type == EID_SCAN_RSS_RSSI)
						{
							suboffset = offset + 4;
							proto_tree_add_item(tmp_tree, hf_wassp_rss, tvb, suboffset, 2, ENC_BIG_ENDIAN);
							suboffset += 2;
							proto_tree_add_item(tmp_tree, hf_wassp_rssi, tvb, suboffset, 2, ENC_BIG_ENDIAN);
						}

						if (tlv_type == EID_PARAMS)
						{
							suboffset = offset + 4;
							proto_tree_add_item(tmp_tree, hf_wassp_threatstate, tvb, suboffset, 1, ENC_BIG_ENDIAN);
							suboffset += 1;
							proto_tree_add_item(tmp_tree, hf_wassp_radioparams, tvb, suboffset, 1, ENC_BIG_ENDIAN);
							suboffset += 1;
							proto_tree_add_item(tmp_tree, hf_wassp_channelfreq, tvb, suboffset, 2, ENC_BIG_ENDIAN);
						}

					}


					if (which_tab == CONFIG_GLOBAL_BLOCK)
					{
						if (tlv_type == EID_ON_DEMAND_ARRAY || tlv_type == EID_DYN_ON_DEMAND_ARRAY)
						{
							decode_mac_list_struct(tmp_tree, tvb, offset + 4,  length -4 );
						}
					}

					if (which_tab == TAB_DETECTED_ROGUE_BLOCK)
					{
						if (tlv_type == EID_DNS_IP_ADDR)
						{
							decode_ipv4_list_struct(tmp_tree, tvb, offset + 4,  length -4 );
						}
					}

					offset += length;
				}
				else
				{

					tableNo = WASSP_SUBTLV_GET_ENTRY_IDX_TABIDX(tmp_decr, tlv_type);
					if ((tableNo == RADIO_CONFIG_BLOCK) && (ru_msg_type == WASSP_RU_Ack))
					{
						offset = dissect_wassp_sub_tlv(tmp_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_RU_ACK_RADIO_CONFIG, ru_msg_type);
					}
					else
						offset = dissect_wassp_sub_tlv(tmp_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, tableNo, ru_msg_type);
				}

			}
		}
	}
	return offset;
}
