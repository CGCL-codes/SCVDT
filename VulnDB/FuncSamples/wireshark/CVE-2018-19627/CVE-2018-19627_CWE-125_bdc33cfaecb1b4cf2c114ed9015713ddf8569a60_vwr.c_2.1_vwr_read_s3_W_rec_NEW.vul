static gboolean vwr_read_s3_W_rec(vwr_t *vwr, wtap_rec *record,
                                  Buffer *buf, const guint8 *rec, int rec_size,
                                  int IS_TX, int log_mode, int *err,
                                  gchar **err_info)
{
    guint8           *data_ptr;
    int              bytes_written = 0;                  /* bytes output to buf so far */
    int              i;
    int              stats_offset = 0;
    const guint8     *s_start_ptr = NULL,*s_trail_ptr = NULL, *plcp_ptr, *m_ptr; /* stats & MPDU ptr */
    guint32          msdu_length = 0, actual_octets = 0; /* octets in frame */
    guint8           l1p_1 = 0,l1p_2 = 0, plcp_type, rate_mcs_index, nss;   /* mod (CCK-L/CCK-S/OFDM) */
    guint64          s_time = LL_ZERO, e_time = LL_ZERO; /* start/end */
                                                         /* times, nsec */
    guint64          latency = LL_ZERO;
    guint64          start_time = 0, s_sec = 0, s_usec = LL_ZERO; /* start time, sec + usec */
    guint64          end_time = 0;                                /* end time */
    guint16          info = 0;                           /* INFO/ERRORS fields in stats blk */
    guint32          errors = 0;
    gint8            info_2nd = 0,rssi[] = {0,0,0,0};    /* RSSI, signed 8-bit number */
    int              frame_size;
    guint32          d_time = 0, flow_id = 0;            /* packet duration, Flow Signature ID*/
    int              sig_off, pay_off;                   /* MAC+SNAP header len, signature offset */
    guint64          sig_ts = 0, tsid;                   /* 32 LSBs of timestamp in signature */
    guint64          delta_b;                            /* Used for calculating latency */
    guint8           L1InfoC,port_type,ver_fpga = 0;
    guint8           flow_seq =0,plcp_hdr_flag = 0,rf_id = 0;    /* indicates plcp hdr info */
    const guint8    *rf_ptr = NULL;
    float            rate;
    guint16          phyRate;

    /*
     * The record data must be large enough to hold the statistics header,
     * the PLCP, and the statistics trailer.
     */
    if (IS_TX == 3) {       /*IS_TX =3, i.e., command type is RF Modified*/
        if ((guint)rec_size < OCTO_MODIFIED_RF_LEN) {
            *err_info = g_strdup_printf("vwr: Invalid record length %d (must be at least %u)",
                                        rec_size,
                                        OCTO_MODIFIED_RF_LEN);
            *err = WTAP_ERR_BAD_FILE;
            return FALSE;
        }
        rf_ptr = &(rec[0]);
        rf_id = rf_ptr[0];

        /*
         * Fill up the per-packet header.
         *
         * We include the length of the metadata headers in the packet lengths.
         *
         * OCTO_MODIFIED_RF_LEN + 1 is less than WTAP_MAX_PACKET_SIZE_STANDARD will
         * ever be, so we don't need to check it.
         */
        record->rec_header.packet_header.len = OCTO_MODIFIED_RF_LEN + 1;       /* 1st octet is reserved for detecting type of frame while displaying in wireshark */
        record->rec_header.packet_header.caplen = OCTO_MODIFIED_RF_LEN + 1;

        record->ts.secs   = (time_t)s_sec;
        record->ts.nsecs  = (int)(s_usec * 1000);
        record->rec_header.packet_header.pkt_encap = WTAP_ENCAP_IXVERIWAVE;

        record->rec_type = REC_TYPE_PACKET;
        record->presence_flags = WTAP_HAS_TS;

        ws_buffer_assure_space(buf, record->rec_header.packet_header.caplen);
        data_ptr = ws_buffer_start_ptr(buf);

        port_type = IS_TX << 4;

        nss = 0;
        phyRate = 0;
    }
    else {
        /* Calculate the start of the statistics blocks in the buffer */
        /* Also get a bunch of fields from the stats blocks */
        /* 'stats_offset' variable is use to locate the exact offset.
         * When a RX frame contrains RF,
         * the postion of Stats, Layer 1-4, PLCP parameters are shifted to
         * + OCTO_RF_MOD_ACTUAL_LEN bytes
         */
        if (IS_TX == 4)     /*IS_TX =4, i.e., command type is RF-RX Modified*/
        {
            stats_offset = OCTO_RF_MOD_ACTUAL_LEN;
            if ((guint)rec_size < stats_offset + vwr->MPDU_OFF + vVW510021_W_STATS_TRAILER_LEN) {
                *err_info = g_strdup_printf("vwr: Invalid record length %d (must be at least %u)",
                                            rec_size,
                                            stats_offset + vwr->MPDU_OFF + vVW510021_W_STATS_TRAILER_LEN);
                *err = WTAP_ERR_BAD_FILE;
                return FALSE;
            }
            rf_ptr = &(rec[0]);
            rf_id = rf_ptr[0];
        }
        else
        {
            stats_offset = 0;
            if ((guint)rec_size < vwr->MPDU_OFF + vVW510021_W_STATS_TRAILER_LEN) {
                *err_info = g_strdup_printf("vwr: Invalid record length %d (must be at least %u)",
                                            rec_size,
                                            vwr->MPDU_OFF + vVW510021_W_STATS_TRAILER_LEN);
                *err = WTAP_ERR_BAD_FILE;
                return FALSE;
            }
        }

        s_start_ptr = &(rec[stats_offset]);         /* point to stats header */
        s_trail_ptr = &(rec[rec_size - vVW510021_W_STATS_TRAILER_LEN] );      /* point to stats trailer */

        l1p_1 = s_start_ptr[vVW510021_W_L1P_1_OFF];
        l1p_2 = s_start_ptr[vVW510021_W_L1P_2_OFF];

        plcp_type = vVW510021_W_S3_PLCP_TYPE(l1p_2);
        switch (plcp_type)
        {
        case vVW510021_W_PLCP_LEGACY:
            /* pre-HT */
            rate_mcs_index = vVW510021_W_S3_RATE_INDEX(l1p_1);
            nss = 0;
            break;

        case vVW510021_W_PLCP_MIXED:
        case vVW510021_W_PLCP_GREENFIELD:
            rate_mcs_index = vVW510021_W_S3_MCS_INDEX_HT(l1p_1);
            nss = (rate_mcs_index < MAX_HT_MCS) ? nss_for_mcs[rate_mcs_index] : 0;
            break;

        case vVW510021_W_PLCP_VHT_MIXED:
            rate_mcs_index = vVW510021_W_S3_MCS_INDEX_VHT(l1p_1);
            nss = vVW510021_W_S3_NSS_VHT(l1p_1);
            plcp_hdr_flag = 1;
            break;

        default:
            rate_mcs_index = 0;
            nss = 0;
            plcp_hdr_flag = 0;
            break;
        }

        for (i = 0; i < 4; i++)
        {
            if (IS_TX == 1)
            {
                rssi[i] = (s_start_ptr[4+i] & 0x80) ? -1 * (s_start_ptr[4+i] & 0x7f) : s_start_ptr[4+i] & 0x7f;
            }
            else
            {
                rssi[i] = (s_start_ptr[4+i] >= 128) ? (s_start_ptr[4+i] - 256) : s_start_ptr[4+i];
            }
        }

        if (IS_TX == 0 || IS_TX == 4){
            L1InfoC = s_start_ptr[8];
        }

        msdu_length = pntoh24(&s_start_ptr[9]);

        /*** 16 bytes of PLCP header + 1 byte of L1P for user position ***/
        plcp_ptr = &(rec[stats_offset+16]);

        /*** Add the PLCP length for S3_W_FPGA version VHT frames for Beamforming decode ***/
        if (log_mode == 3) {
            frame_size = rec_size - (stats_offset + vwr->MPDU_OFF + vVW510021_W_STATS_TRAILER_LEN);
            if (frame_size > ((int) msdu_length))
                actual_octets = msdu_length;
            else {
                /*
                 * XXX - does this mean "the packet was cut short during
                 * capture" or "this is a malformed record"?
                 */
                actual_octets = frame_size;
            }
        }
        else
        {
            actual_octets = msdu_length;
        }
        /*
         * Sanity check the octets field to determine if it's greater than
         * the packet data available in the record - i.e., the record size
         * minus the sum of (length of statistics header + PLCP) and
         * (length of statistics trailer).
         *
         * Report an error if it is.
         */
        if (actual_octets > rec_size - (stats_offset + vwr->MPDU_OFF + vVW510021_W_STATS_TRAILER_LEN)) {
            *err_info = g_strdup_printf("vwr: Invalid data length %u (runs past the end of the record)",
                                        actual_octets);
            *err = WTAP_ERR_BAD_FILE;
            return FALSE;
        }

        flow_seq = s_trail_ptr[vVW510021_W_FLOWSEQ_OFF];

        latency = 0x00000000;                        /* clear latency */
        flow_id = pntoh24(&s_trail_ptr[vVW510021_W_FLOWID_OFF]);         /* all 24 bits valid */
        /* For tx latency is duration, for rx latency is timestamp */
        /* Get 48-bit latency value */
        tsid = pcorey48tohll(&s_trail_ptr[vVW510021_W_LATVAL_OFF]);

        errors = pntoh32(&s_trail_ptr[vVW510021_W_ERRORS_OFF]);
        info = pntoh16(&s_trail_ptr[vVW510021_W_INFO_OFF]);

        if (IS_TX == 0 || IS_TX == 4)
            info_2nd = s_trail_ptr[41];

        /*** Calculate Data rate based on
        *  PLCP type, MCS index and number of spatial stream
        *  radioflags is temporarily calculated, which is used in
        *  get_ht_rate() and get_vht_rate().
        **/
        switch (plcp_type)
        {
        case vVW510021_W_PLCP_LEGACY:
            rate = get_legacy_rate(rate_mcs_index);
            break;

        case vVW510021_W_PLCP_MIXED:
            /*
             * According to section 20.3.2 "PPDU format", the HT-mixed
             * PLCP header has a "Non-HT SIGNAL field" (L-SIG), which
             * looks like an 11a SIGNAL field, followed by an HT SIGNAL
             * field (HT-SIG) described in section 20.3.9.4.3 "HT-SIG
             * definition".
             *
             * This means that the first octet of HT-SIG is at
             * plcp_ptr[3], skipping the 3 octets of the L-SIG field.
             *
             * 0x80 is the CBW 20/40 bit of HT-SIG.
             */
            {
                /* set the appropriate flags to indicate HT mode and CB */
                guint16 radioflags = FLAGS_CHAN_HT | ((plcp_ptr[3] & 0x80) ? FLAGS_CHAN_40MHZ : 0) |
                                   ((l1p_1 & vVW510021_W_IS_LONGGI) ? 0 : FLAGS_CHAN_SHORTGI);
                rate = get_ht_rate(rate_mcs_index, radioflags);
            }
            break;

        case vVW510021_W_PLCP_GREENFIELD:
            /*
             * According to section 20.3.2 "PPDU format", the HT-greenfield
             * PLCP header just has the HT SIGNAL field (HT-SIG) above, with
             * no L-SIG field.
             *
             * This means that the first octet of HT-SIG is at
             * plcp_ptr[0], as there's no L-SIG field to skip.
             *
             * 0x80 is the CBW 20/40 bit of HT-SIG.
             */
            {
                /* set the appropriate flags to indicate HT mode and CB */
                guint16 radioflags = FLAGS_CHAN_HT | ((plcp_ptr[0] & 0x80) ? FLAGS_CHAN_40MHZ : 0) |
                                   ((l1p_1 & vVW510021_W_IS_LONGGI) ?  0 : FLAGS_CHAN_SHORTGI);
                rate = get_ht_rate(rate_mcs_index, radioflags);
            }
            break;

        case vVW510021_W_PLCP_VHT_MIXED:
            /*
             * According to section 22.3.2 "VHT PPDU format" of IEEE Std
             * 802.11ac-2013, the VHT PLCP header has a "non-HT SIGNAL field"
             * (L-SIG), which looks like an 11a SIGNAL field, followed by
             * a VHT Signal A field (VHT-SIG-A) described in section
             * 22.3.8.3.3 "VHT-SIG-A definition", with training fields
             * between it and a VHT Signal B field (VHT-SIG-B) described
             * in section 22.3.8.3.6 "VHT-SIG-B definition", followed by
             * the PSDU.
             */
            {
                guint8 SBW = vVW510021_W_BANDWIDTH_VHT(l1p_2);
                guint16 radioflags = FLAGS_CHAN_VHT | ((l1p_1 & vVW510021_W_IS_LONGGI) ?  0 : FLAGS_CHAN_SHORTGI);
                if (SBW == 3)
                    radioflags |= FLAGS_CHAN_40MHZ;
                else if (SBW == 4)
                    radioflags |= FLAGS_CHAN_80MHZ;
                rate = get_vht_rate(rate_mcs_index, radioflags, nss);
            }
            break;

        default:
            rate = 0.0f;
            break;
        }
        phyRate = (guint16)(rate * 10);
        /* Calculation of Data rate ends*/

        /* 'ver_fpga' is the 2nd Octet of each frame.
         * msb/lsb nibble indicates log mode/fpga version respectively.
         * where log mode = 0 is normal capture and 1 is reduced capture,
         * lsb nibble is set to 1 always as this function is applicable for only FPGA version >= 48
         */
        if (log_mode == 3) {
            if (frame_size >= (int) msdu_length) {
                /*
                 * The MSDU length includes the FCS.
                 *
                 * The packet data does *not* include the FCS - it's just 4
                 * bytes of junk - so we have to remove it.
                 *
                 * We'll be stripping off that junk, so make sure we have at
                 * least 4 octets worth of packet data.
                 *
                 * XXX - is the FCS actually present here, as it appears to be
                 * if log_mode isn't 3?
                 *
                 * There seems to be a special case of a length of 0.
                 */
                if (actual_octets < 4) {
                    if (actual_octets != 0) {
                        *err_info = g_strdup_printf("vwr: Invalid data length %u (too short to include 4 bytes of FCS)",
                                                    actual_octets);
                        *err = WTAP_ERR_BAD_FILE;
                        return FALSE;
                    }
                } else {
                    actual_octets -= 4;
                }
            }
            ver_fpga = 0x11;
        } else {
            ver_fpga = 0x01;
        }

        /* Calculate start & end times (in sec/usec), converting 64-bit times to usec. */
        /* 64-bit times are "Corey-endian" */
        s_time = pcoreytohll(&s_trail_ptr[vVW510021_W_STARTT_OFF]);
        e_time = pcoreytohll(&s_trail_ptr[vVW510021_W_ENDT_OFF]);

        /* find the packet duration (difference between start and end times) */
        d_time = (guint32)((e_time - s_time) / NS_IN_US);  /* find diff, converting to usec */

        /* also convert the packet start time to seconds and microseconds */
        start_time = s_time / NS_IN_US;                     /* convert to microseconds first */
        s_sec = (start_time / US_IN_SEC);                   /* get the number of seconds */
        s_usec = start_time - (s_sec * US_IN_SEC);          /* get the number of microseconds */

        /* also convert the packet end time to seconds and microseconds */
        end_time = e_time / NS_IN_US;                       /* convert to microseconds first */

        /* extract the 32 LSBs of the signature timestamp field */
        int m_ptr_offset = stats_offset + 8 + 12;
        m_ptr = rec + m_ptr_offset;
        pay_off = 42;         /* 24 (MAC) + 8 (SNAP) + IP */
        sig_off = find_signature(m_ptr, rec_size - m_ptr_offset, pay_off, flow_id, flow_seq);
        if (m_ptr[sig_off] == 0xdd)
            sig_ts = get_signature_ts(m_ptr, sig_off, rec_size - vVW510021_W_STATS_TRAILER_LEN);
        else
            sig_ts = 0;

        /* Set latency based on rx/tx and signature timestamp */
        if (IS_TX == 0 || IS_TX == 4) {
            if (tsid < s_time) {
                latency = s_time - tsid;
            } else {
                /* Account for the rollover case. Since we cannot use 0x100000000 - l_time + s_time */
                /* we look for a large difference between l_time and s_time. */
                delta_b = tsid - s_time;
                if (delta_b >  0x10000000)
                    latency = 0;
                else
                    latency = delta_b;
            }
        }

        port_type = IS_TX << 4;

        /*
         * Fill up the per-packet header.
         *
         * We include the length of the metadata headers in the packet lengths.
         */
        if (IS_TX == 4) {
            record->rec_header.packet_header.len = OCTO_MODIFIED_RF_LEN + OCTO_TIMESTAMP_FIELDS_LEN + OCTO_LAYER1TO4_LEN + actual_octets;
            record->rec_header.packet_header.caplen = OCTO_MODIFIED_RF_LEN + OCTO_TIMESTAMP_FIELDS_LEN + OCTO_LAYER1TO4_LEN + actual_octets;
        } else {
            record->rec_header.packet_header.len = OCTO_TIMESTAMP_FIELDS_LEN + OCTO_LAYER1TO4_LEN + actual_octets;
            record->rec_header.packet_header.caplen = OCTO_TIMESTAMP_FIELDS_LEN + OCTO_LAYER1TO4_LEN + actual_octets;
        }
        if (record->rec_header.packet_header.caplen > WTAP_MAX_PACKET_SIZE_STANDARD) {
            /*
             * Probably a corrupt capture file; return an error,
             * so that our caller doesn't blow up trying to allocate
             * space for an immensely-large packet.
             */
            *err_info = g_strdup_printf("vwr: File has %u-byte packet, bigger than maximum of %u",
                                        record->rec_header.packet_header.caplen, WTAP_MAX_PACKET_SIZE_STANDARD);
            *err = WTAP_ERR_BAD_FILE;
            return FALSE;
        }

        record->ts.secs   = (time_t)s_sec;
        record->ts.nsecs  = (int)(s_usec * 1000);
        record->rec_header.packet_header.pkt_encap = WTAP_ENCAP_IXVERIWAVE;

        record->rec_type = REC_TYPE_PACKET;
        record->presence_flags = WTAP_HAS_TS;

        ws_buffer_assure_space(buf, record->rec_header.packet_header.caplen);
        data_ptr = ws_buffer_start_ptr(buf);
    }

    /*
     * Generate and copy out the common metadata headers,
     * set the port type to port_type (XXX).
     *
     * All values are copied out in little-endian byte order.
     */
    /*** msdu_length = msdu_length + 16; ***/

    /* 1st octet of record for port_type and other crud */
    phtole8(&data_ptr[bytes_written], port_type);
    bytes_written += 1;

    if (IS_TX != 3) {
        phtole8(&data_ptr[bytes_written], ver_fpga); /* 2nd octet of record for FPGA version*/
        bytes_written += 1;

        phtoles(&data_ptr[bytes_written], OCTO_TIMESTAMP_FIELDS_LEN); /* it_len */
        bytes_written += 2;

    /*** Time Collapsible header started***/
        if (IS_TX == 1 && sig_ts != 0) {
            phtolel(&data_ptr[bytes_written], latency);
        } else {
            phtolel(&data_ptr[bytes_written], 0);
        }
        bytes_written += 4;
        phtolel(&data_ptr[bytes_written], sig_ts); /* 32 LSBs of signature timestamp (nsec) */
        bytes_written += 4;
        phtolell(&data_ptr[bytes_written], start_time); /* record start & end times of frame */
        bytes_written += 8;
        phtolell(&data_ptr[bytes_written], end_time);
        bytes_written += 8;
        phtolel(&data_ptr[bytes_written], d_time);
        bytes_written += 4;
    /*** Time Collapsible header ends ***/
    }

    /*** RF Collapsable header starts***/
    if (IS_TX == 3 || IS_TX == 4) {
        phtole8(&data_ptr[bytes_written], rf_id);
        bytes_written += 1;
        data_ptr[bytes_written] = 0;
        bytes_written += 1;
        data_ptr[bytes_written] = 0;
        bytes_written += 1;
        data_ptr[bytes_written] = 0;
        bytes_written += 1;

        /*** NOISE for all 4 Ports ***/
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[RF_PORT_1_NOISE_OFF+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_NOISE_OFF+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_NOISE_OFF+1+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }

        /*** SNR for all 4 Ports ***/
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[RF_PORT_1_SNR_OFF+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_SNR_OFF+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_SNR_OFF+1+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }

        /*** PFE for all 4 Ports ***/
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[RF_PORT_1_PFE_OFF+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_PFE_OFF+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_PFE_OFF+1+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }

        /*** EVM SIG Data for all 4 Ports ***/
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[RF_PORT_1_EVM_SD_SIG_OFF+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_EVM_SD_SIG_OFF+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_EVM_SD_SIG_OFF+1+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }

        /*** EVM SIG PILOT for all 4 Ports ***/
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[RF_PORT_1_EVM_SP_SIG_OFF+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_EVM_SP_SIG_OFF+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_EVM_SP_SIG_OFF+1+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }

        /*** EVM Data Data for all 4 Ports ***/
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[RF_PORT_1_EVM_SD_DATA_OFF+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_EVM_SD_DATA_OFF+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_EVM_SD_DATA_OFF+1+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }

        /*** EVM Data PILOT for all 4 Ports ***/
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[RF_PORT_1_EVM_SP_DATA_OFF+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_EVM_SP_DATA_OFF+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_EVM_SP_DATA_OFF+1+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }

        /*** EVM WORST SYMBOL for all 4 Ports ***/
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[RF_PORT_1_DSYMBOL_IDX_OFF+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_DSYMBOL_IDX_OFF+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_DSYMBOL_IDX_OFF+1+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }

        /*** CONTEXT_P for all 4 Ports ***/
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[RF_PORT_1_CONTEXT_OFF+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_CONTEXT_OFF+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[RF_PORT_1_CONTEXT_OFF+1+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }

        /*** FOR rest 24 RF data bytes are commented for future use ***/
/***
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[20+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[20+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[21+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[24+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[24+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[25+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }
        for (i = 0; i < RF_NUMBER_OF_PORTS; i++)
        {
            if (pntoh16(&rf_ptr[26+i*RF_INTER_PORT_GAP_OFF]) == 0) {
                phtoles(&data_ptr[bytes_written], 0);
                bytes_written += 2;
            } else {
                data_ptr[bytes_written] = rf_ptr[26+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
                data_ptr[bytes_written] = rf_ptr[27+i*RF_INTER_PORT_GAP_OFF];
                bytes_written += 1;
            }
        }
***/
    }
    /*** RF Collapsable header ends***/

    if (IS_TX != 3) {
        /*
         * Generate and copy out the WLAN metadata headers.
         *
         * All values are copied out in little-endian byte order.
         */
        phtoles(&data_ptr[bytes_written], OCTO_LAYER1TO4_LEN);
        bytes_written += 2;

        /*** Layer-1 Collapsible header started***/
        data_ptr[bytes_written] = l1p_1;
        bytes_written += 1;

        data_ptr[bytes_written] = (nss << 4) | IS_TX;
        bytes_written += 1;

        phtoles(&data_ptr[bytes_written], phyRate);     /* To dosplay Data rate based on the PLCP type & MCS*/
        bytes_written += 2;

        data_ptr[bytes_written] = l1p_2;
        bytes_written += 1;

        data_ptr[bytes_written] = rssi[0];
        bytes_written += 1;
        data_ptr[bytes_written] = rssi[1];
        bytes_written += 1;
        data_ptr[bytes_written] = rssi[2];
        bytes_written += 1;
        data_ptr[bytes_written] = rssi[3];
        bytes_written += 1;

        /* padding may not be required for S3_W*/

        data_ptr[bytes_written] = s_start_ptr[2];    /*** For Signal Bandwidth Mask ***/
        bytes_written += 1;
        data_ptr[bytes_written] = s_start_ptr[3];    /*** For Antenna Port Energy Detect and MU_MASK ***/
        bytes_written += 1;

        if (plcp_hdr_flag == 1 && (IS_TX == 0 || IS_TX == 4)) {
            data_ptr[bytes_written] = L1InfoC;  /*** For Other plcp type = VHT ***/
        } else {
            data_ptr[bytes_written] = 0;    /*** For Other plcp type, this offset is set to 0***/
        }
        bytes_written += 1;

        phtoles(&data_ptr[bytes_written], msdu_length);
        bytes_written += 2;
        /*** Layer-1 Collapsible header Ends ***/

        /*** PLCP Collapsible header Starts ***/
        memcpy(&data_ptr[bytes_written], &rec[stats_offset+16], 16);
        bytes_written += 16;
        /*** PLCP Collapsible header Ends ***/

        /*** Layer 2-4 Collapsible header Starts ***/

        phtolel(&data_ptr[bytes_written], pntoh32(&s_start_ptr[12]));   /*** This 4 bytes includes BM,BV,CV,BSSID and ClientID ***/
        bytes_written += 4;
        phtoles(&data_ptr[bytes_written], pntoh16(&s_trail_ptr[20]));   /*** 2 bytes includes FV,QT,HT,L4V,TID and WLAN type ***/
        bytes_written += 2;
        data_ptr[bytes_written] = flow_seq;
        bytes_written += 1;
        phtole24(&data_ptr[bytes_written], flow_id);
        bytes_written += 3;
        phtoles(&data_ptr[bytes_written], pntoh16(&s_trail_ptr[28]));   /*** 2 bytes for Layer 4 ID ***/
        bytes_written += 2;
        phtolel(&data_ptr[bytes_written], pntoh32(&s_trail_ptr[24]));   /*** 4 bytes for Payload Decode ***/
        bytes_written += 4;

        /*** Incase of RX, Info has 3 bytes of data, whereas for TX, 2 bytes ***/
        if (IS_TX == 0 || IS_TX == 4) {
            phtoles(&data_ptr[bytes_written], info);
            bytes_written += 2;
            data_ptr[bytes_written] = info_2nd;
            bytes_written += 1;
        }
        else {
            phtoles(&data_ptr[bytes_written], info);
            bytes_written += 2;
            data_ptr[bytes_written] = 0;
            bytes_written += 1;
        }

        phtolel(&data_ptr[bytes_written], errors);
        bytes_written += 4;
        /*** Layer 2-4 Collapsible header Ends ***/

        /* Finally, copy the whole MAC frame to the packet buffer as-is.
         * This does not include the stats header or the PLCP.
         * This also does not include the last 4 bytes, as those don't
         * contain an FCS, they just contain junk.
         */
        memcpy(&data_ptr[bytes_written], &rec[stats_offset+(vwr->MPDU_OFF)], actual_octets);
    }

    return TRUE;
}
