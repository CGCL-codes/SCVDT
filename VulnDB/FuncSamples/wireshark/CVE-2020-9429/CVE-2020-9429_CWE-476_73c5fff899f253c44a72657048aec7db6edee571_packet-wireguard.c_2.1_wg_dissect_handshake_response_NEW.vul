static int
wg_dissect_handshake_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *wg_tree, wg_packet_info_t *wg_pinfo)
{
    guint32 sender_id, receiver_id;
    proto_item *ti;
    wg_session_t *session;

#ifdef WG_DECRYPTION_SUPPORTED
    wg_keylog_read();
    const wg_skey_t *skey_i = wg_mac1_key_probe(tvb, FALSE);
#endif /* WG_DECRYPTION_SUPPORTED */

    proto_tree_add_item_ret_uint(wg_tree, hf_wg_sender, tvb, 4, 4, ENC_LITTLE_ENDIAN, &sender_id);
    col_append_fstr(pinfo->cinfo, COL_INFO, ", sender=0x%08X", sender_id);
    proto_tree_add_item_ret_uint(wg_tree, hf_wg_receiver, tvb, 8, 4, ENC_LITTLE_ENDIAN, &receiver_id);
    col_append_fstr(pinfo->cinfo, COL_INFO, ", receiver=0x%08X", receiver_id);

    if (!PINFO_FD_VISITED(pinfo)) {
        session = wg_sessions_lookup_initiation(pinfo, receiver_id);
#ifdef WG_DECRYPTION_SUPPORTED
        if (session && session->hs) {
            wg_prepare_handshake_responder_keys(session->hs, tvb);
            wg_process_response(tvb, session->hs);
        }
#endif /* WG_DECRYPTION_SUPPORTED */
    } else {
        session = wg_pinfo ? wg_pinfo->session : NULL;
    }

    wg_dissect_pubkey(wg_tree, tvb, 12, TRUE);
    proto_tree_add_item(wg_tree, hf_wg_encrypted_empty, tvb, 44, 16, ENC_NA);
#ifdef WG_DECRYPTION_SUPPORTED
    if (session && session->hs) {
        ti = proto_tree_add_boolean(wg_tree, hf_wg_handshake_ok, tvb, 0, 0, !!session->hs->empty_ok);
        proto_item_set_generated(ti);
    }
#endif /* WG_DECRYPTION_SUPPORTED */
    proto_tree_add_item(wg_tree, hf_wg_mac1, tvb, 60, 16, ENC_NA);
#ifdef WG_DECRYPTION_SUPPORTED
    wg_dissect_mac1_pubkey(wg_tree, tvb, skey_i);
#endif /* WG_DECRYPTION_SUPPORTED */
    proto_tree_add_item(wg_tree, hf_wg_mac2, tvb, 76, 16, ENC_NA);

    if (!PINFO_FD_VISITED(pinfo)) {
        /* XXX should probably check whether decryption succeeds before linking
         * and somehow mark that this response is related but not correct. */
        if (session) {
            session->response_frame = pinfo->num;
            wg_session_update_address(session, pinfo, FALSE);
            wg_sessions_insert(sender_id, session);
            wg_pinfo->session = session;
        }
    }
    if (session) {
        ti = proto_tree_add_uint(wg_tree, hf_wg_stream, tvb, 0, 0, session->stream);
        proto_item_set_generated(ti);
        ti = proto_tree_add_uint(wg_tree, hf_wg_response_to, tvb, 0, 0, session->initiator_frame);
        proto_item_set_generated(ti);
    }

    return 92;
}
