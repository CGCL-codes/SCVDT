static void dissect_rbm_object(tvbuff_t* tvb, packet_info* pinfo, proto_tree* ptree, gint* offset, gchar** type, gchar** value)
{
	guint8 subtype = tvb_get_guint8(tvb, *offset);
	proto_tree* tree;
	gchar* type_local = NULL;
	gchar* value_local = NULL;
	gint offset_start = *offset;

	tree = proto_tree_add_subtree(ptree, tvb, *offset, 0, ett_variable, NULL, "");

	proto_tree_add_item(tree, hf_rbm_type, tvb, *offset, 1, ENC_NA);
	*offset += 1;

	switch (subtype) {
		case '0':
		case 'T':
		case 'F':
			dissect_rbm_basic(tvb, pinfo, tree, offset, subtype, &type_local, &value_local);
			break;
		case 'i':
			type_local = "Integer";
			dissect_rbm_integer(tvb, pinfo, tree, offset, &value_local);
			break;
		case ':':
			type_local = "Symbol";
			dissect_rbm_symbol(tvb, pinfo, tree, offset, &value_local);
			break;
		case '"':
			type_local = "String";
			dissect_rbm_string(tvb, pinfo, tree, offset, &value_local);
			break;
		case 'I':
			type_local = "Instance Variable";
			dissect_rbm_variable(tvb, pinfo, tree, offset, &value_local);
			break;
		case '[':
			type_local = "Array";
			dissect_rbm_array(tvb, pinfo, tree, offset, &value_local);
			break;
		case '{':
			type_local = "Hash";
			dissect_rbm_hash(tvb, pinfo, tree, offset, &value_local);
			break;
		case ';':
		case '@':
			dissect_rbm_link(tvb, pinfo, tree, offset, subtype, &type_local, &value_local);
			break;
		case 'f':
			type_local = "Double";
			dissect_rbm_double(tvb, pinfo, tree, offset, &value_local);
			break;
		case 'c':
			type_local = "Class";
			dissect_rbm_class(tvb, pinfo, tree, offset, &value_local);
			break;
		case 'm':
			type_local = "Module";
			dissect_rbm_module(tvb, pinfo, tree, offset, &value_local);
			break;
		case 'S':
			type_local = "Struct";
			dissect_rbm_struct(tvb, pinfo, tree, offset, &value_local);
			break;
		case '/':
			type_local = "Regex";
			dissect_rbm_regex(tvb, pinfo, tree, offset, &value_local);
			break;
		case 'u':
			type_local = "DRb::DRbObject";
			dissect_rbm_drb(tvb, pinfo, tree, offset);
			break;
		case ',':
			dissect_rbm_inline(tvb, pinfo, tree, offset, &type_local, &value_local);
			break;
		case 'o':
			dissect_rbm_rubyobject(tvb, pinfo, tree, offset);
			type_local = "Ruby Object";
			break;
		case 'C':
			type_local = "UserClass";
			dissect_rbm_userclass(tvb, pinfo, tree, offset, &value_local);
			break;
		case 'e':
			type_local = "Extended Object";
			dissect_rbm_extended(tvb, pinfo, tree, offset);
			break;
		default:
			expert_add_info_format(pinfo, tree, &ei_rbm_invalid,
				"Object type 0x%x is invalid", subtype);
	}

	proto_item_set_len(tree, *offset - offset_start);

	proto_item_append_text(tree, "Type: %s", type_local);
	if (value_local && strlen(value_local))
		proto_item_append_text(tree, ", Value: %s", value_local);

	if (type)
		*type = type_local;
	if (value)
		*value = value_local;
}
