static guint
dissect_amqp_1_0_list(tvbuff_t *tvb,
                      packet_info *pinfo,
                      int offset,
                      int bound,
                      proto_item *item,
                      int hf_amqp_type,
                      guint32 hf_amqp_subtype_count,
                      const int **hf_amqp_subtypes,
                      const char *name)
{
    proto_item *list_tree;
    guint8      type;
    guint8      count_len;
    guint32     element_count;
    guint32     element_size;
    guint32     decoded_element_size;
    guint32     orig_offset;
    guint32     decoded_elements;
    int         hf_amqp_item;

    list_tree = 0;
    decoded_elements = 0;
    orig_offset = offset;

    if (proto_registrar_get_ftype(hf_amqp_type) != FT_NONE)
    {
        expert_add_info_format(pinfo, item, &ei_amqp_unknown_amqp_type,
                               "Unexpected list type at frame position %d of field \"%s\"",
                               offset,
                               name ? name : proto_registrar_get_name(hf_amqp_type));
        return bound-orig_offset;
    }

    type = tvb_get_guint8(tvb, offset);
    AMQP_INCREMENT(offset, 1, bound);
    switch (type) {
    case AMQP_1_0_TYPE_LIST0:
        count_len = 0;
        element_size = 0;
        element_count = 0;
        break;
    case AMQP_1_0_TYPE_LIST8:
        count_len = 1;
        element_size = tvb_get_guint8(tvb, offset);
        element_count = tvb_get_guint8(tvb, offset+count_len);
        break;
    case AMQP_1_0_TYPE_LIST32:
        count_len = 4;
        element_size = tvb_get_ntohl(tvb, offset);
        element_count = tvb_get_ntohl(tvb, offset+count_len);
        break;
    default:
        proto_tree_add_none_format(list_tree, hf_amqp_1_0_list, tvb,
                                   offset-1,
                                   1,
                                   "(unknown type %d)",
                                   type);
        expert_add_info_format(pinfo,
                               list_tree,
                               &ei_amqp_unknown_amqp_type,
                               "Unknown AMQP list type %d",
                               type);
        return bound-orig_offset;
    }

    list_tree = proto_tree_add_none_format(item,
                                           hf_amqp_type,
                                           tvb,
                                           offset-1,
                                           element_size+1+count_len,
                                           "%s",
                                           name ? name : proto_registrar_get_name(hf_amqp_type));
    AMQP_INCREMENT(offset, count_len*2, bound);

    if (element_count > 0)
        list_tree = proto_item_add_subtree(list_tree, ett_amqp_1_0_list);
    /* display the item count for custom lists only
     * standard structures contain NULL items, so the real element count is different */
    if (hf_amqp_subtype_count == 0)
        proto_item_append_text(list_tree, " (list of %d element%s)", element_count, element_suffix[element_count!=1]);

    if (element_count > element_size)
    {
        expert_add_info_format(pinfo,
                               list_tree,
                               &ei_amqp_invalid_number_of_params,
                               "Number of list elements (%d) bigger than list size (%d)",
                               element_count, element_size);
        return bound-orig_offset;
    }

    while ((element_count > 0) && (offset < bound)) {
        decoded_element_size = 0;
        if (decoded_elements<hf_amqp_subtype_count)
            hf_amqp_item = *(hf_amqp_subtypes[decoded_elements]);
        else
            hf_amqp_item = hf_amqp_1_0_list; /* dynamic item */
        get_amqp_1_0_type_value_formatter(tvb,
                                          pinfo,
                                          offset,
                                          bound,
                                          hf_amqp_item,
                                          NULL,
                                          &decoded_element_size,
                                          list_tree);
        element_count -= 1;
        decoded_elements += 1;
        AMQP_INCREMENT(offset, decoded_element_size, bound);
    }
    if (element_count > 0)
        expert_add_info_format(pinfo,
                               list_tree,
                               &ei_amqp_invalid_number_of_params,
                               "Number of list elements (%d) not matching number of decoded elements (%d)",
                               element_count+decoded_elements, decoded_elements);
    return offset-orig_offset;
}
