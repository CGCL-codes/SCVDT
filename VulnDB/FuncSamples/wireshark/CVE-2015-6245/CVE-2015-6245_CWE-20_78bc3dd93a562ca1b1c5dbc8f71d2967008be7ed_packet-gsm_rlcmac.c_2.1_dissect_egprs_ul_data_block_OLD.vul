static void
dissect_egprs_ul_data_block(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, RlcMacUplink_t *data, egprs_ul_header_info_t *egprs_ul_header_info)
{
  proto_item         *ti;
  proto_tree         *data_tree;
  guint8              offset   = 0;
  length_indicator_t  li_array[20];
  guint8              li_count = array_length(li_array);
  guint64             e, tlli_i;
  guint16             block_number;

  block_number = (data->flags & GSM_RLC_MAC_EGPRS_BLOCK2)?egprs_ul_header_info->bsn2:egprs_ul_header_info->bsn1;

  col_append_sep_str(pinfo->cinfo, COL_INFO, ":", "DATA BLOCK");
  ti = proto_tree_add_protocol_format(tree, proto_gsm_rlcmac, tvb, offset, -1,
                                      "GSM RLC/MAC: EGPRS UL DATA BLOCK %d (BSN %d)",
                                      (data->flags & GSM_RLC_MAC_EGPRS_BLOCK2)?2:1,
                                      block_number);
  data_tree = proto_item_add_subtree(ti, ett_gsm_rlcmac_data);

  /* we assume that the body of the data block is octet aligned,
     but there are 6 unused bits in the first octet to
     achieve alignment of the following octets */

  /* the data block starts with 2 bit header */
  proto_tree_add_bits_ret_val(data_tree, hf_ti, tvb, 6, 1, &tlli_i, ENC_BIG_ENDIAN);
  proto_tree_add_bits_ret_val(data_tree, hf_e, tvb, 7, 1, &e, ENC_BIG_ENDIAN);
  offset ++;

  /* build the array of Length Indicators */
  offset += construct_egprs_data_segment_li_array(tvb, data_tree, pinfo, offset,
                                                  &li_count,
                                                  li_array,
                                                  &e);

  /* the next fields are present according to earlier flags */
  if (tlli_i)
  {
    proto_tree_add_bits_item(data_tree, hf_tlli, tvb, offset * 8, 32, ENC_BIG_ENDIAN);
    offset += 4;
  }
  if (egprs_ul_header_info->pi)
  {
    proto_tree_add_bits_item(data_tree, hf_pfi, tvb, offset * 8, 7, ENC_BIG_ENDIAN);
    proto_tree_add_bits_ret_val(data_tree, hf_e, tvb, (offset * 8) + 7, 1, &e, ENC_BIG_ENDIAN);
    offset ++;
  }
  if (e)
  {
    /* dissect the data segments */
    dissect_egprs_data_segments(tvb, pinfo, data_tree, offset,
                                tvb_reported_length(tvb), li_count, li_array);
  }
  else
  {
    proto_tree_add_expert(tree, pinfo, &ei_gsm_rlcmac_unexpected_header_extension, tvb, offset, 1);
  }
}
