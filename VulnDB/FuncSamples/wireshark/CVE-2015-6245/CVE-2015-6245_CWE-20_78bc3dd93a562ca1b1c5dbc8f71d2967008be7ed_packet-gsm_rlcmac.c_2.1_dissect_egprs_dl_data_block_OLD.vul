static void
dissect_egprs_dl_data_block(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, RlcMacDownlink_t *data, egprs_dl_header_info_t *egprs_dl_header_info)
{
  proto_item         *ti;
  proto_tree         *data_tree;
  guint16             offset   = 0;
  guint16             block_number;
  length_indicator_t  li_array[20];
  guint8              li_count = array_length(li_array);
  guint64             fbi, e;

  block_number = (data->flags & GSM_RLC_MAC_EGPRS_BLOCK2)?egprs_dl_header_info->bsn2:egprs_dl_header_info->bsn1;

  col_append_sep_str(pinfo->cinfo, COL_INFO, ":", "DATA BLOCK");
  ti = proto_tree_add_protocol_format(tree, proto_gsm_rlcmac, tvb, offset, -1,
                                      "GSM RLC/MAC: EGPRS DL DATA BLOCK %d (BSN %d)",
                                      (data->flags & GSM_RLC_MAC_EGPRS_BLOCK2)?2:1,
                                      block_number);
  data_tree = proto_item_add_subtree(ti, ett_gsm_rlcmac_data);

  /* we assume that there are 6 null bits in the first octet of each data block,
     to give octet alignment of the main body of the block.
     This alignment should be guaranteed by the transport-protocol dissector that called this one */

  /* the data block starts with 2 bit header */
  proto_tree_add_bits_ret_val(data_tree, hf_fbi, tvb, 6, 1, &fbi, ENC_BIG_ENDIAN);
  proto_tree_add_bits_ret_val(data_tree, hf_e, tvb, 7, 1, &e, ENC_BIG_ENDIAN);
  offset ++;

  /* build the array of data segment descriptors */
  offset += construct_egprs_data_segment_li_array(tvb, data_tree, pinfo, 1,
                                                  &li_count,
                                                  li_array,
                                                  &e);
  if (e)
  {
    /* dissect the data segments */
    dissect_egprs_data_segments(tvb, pinfo, data_tree, offset,
                                tvb_reported_length(tvb), li_count, li_array);
  }
  else
  {
    proto_tree_add_expert(tree, pinfo, &ei_gsm_rlcmac_unexpected_header_extension, tvb, offset, 1);
  }
}
