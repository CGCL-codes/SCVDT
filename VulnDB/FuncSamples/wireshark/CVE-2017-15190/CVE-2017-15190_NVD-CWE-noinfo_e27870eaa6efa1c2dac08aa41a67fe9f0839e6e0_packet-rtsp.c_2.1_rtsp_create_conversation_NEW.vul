static void
rtsp_create_conversation(packet_info *pinfo, proto_item *ti,
                         const guchar *line_begin, size_t line_len,
                         gint rdt_feature_level,
                         rtsp_type_t rtsp_type_packet)
{
    conversation_t  *conv;
    guchar    buf[256];
    guchar   *tmp;
    gboolean  rtp_udp_transport = FALSE;
    gboolean  rtp_tcp_transport = FALSE;
    gboolean  rdt_transport = FALSE;
    guint     c_data_port, c_mon_port;
    guint     s_data_port, s_mon_port;
    guint     ipv4_1, ipv4_2, ipv4_3, ipv4_4;
    gboolean  is_video      = FALSE; /* FIX ME - need to indicate video or not */
    address   src_addr;
    address   dst_addr;
    guint32   ip4_addr;

    if (rtsp_type_packet != RTSP_REPLY) {
        return;
    }

    src_addr=pinfo->src;
    dst_addr=pinfo->dst;

    /* Copy line into buf */
    if (line_len > sizeof(buf) - 1)
    {
        /* Don't overflow the buffer. */
        line_len = sizeof(buf) - 1;
    }
    memcpy(buf, line_begin, line_len);
    buf[line_len] = '\0';

    /* Get past "Transport:" and spaces */
    tmp = buf + STRLEN_CONST(rtsp_transport);
    while (*tmp && g_ascii_isspace(*tmp))
        tmp++;

    /* Work out which transport type is here */
    if (g_ascii_strncasecmp(tmp, rtsp_rtp_udp, strlen(rtsp_rtp_udp)) == 0)
    {
        rtp_udp_transport = TRUE;
    }
    else if (g_ascii_strncasecmp(tmp, rtsp_rtp_tcp, strlen(rtsp_rtp_tcp)) == 0)
    {
        rtp_tcp_transport = TRUE;
    }
    else if (g_ascii_strncasecmp(tmp, rtsp_rtp_udp_default, strlen(rtsp_rtp_udp_default)) == 0)
    {
        rtp_udp_transport = TRUE;
    }
    else if (g_ascii_strncasecmp(tmp, rtsp_real_rdt, strlen(rtsp_real_rdt)) == 0 ||
                 g_ascii_strncasecmp(tmp, rtsp_real_tng, strlen(rtsp_real_tng)) == 0)
    {
        rdt_transport = TRUE;
    }
    else
    {
        /* Give up on unknown transport types */
        expert_add_info(pinfo, ti, &ei_rtsp_unknown_transport_type);
        return;
    }

    c_data_port = c_mon_port = 0;
    s_data_port = s_mon_port = 0;

    /* Look for server port */
    if ((tmp = strstr(buf, rtsp_sps_server_port))) {
        tmp += strlen(rtsp_sps_server_port);
        if (sscanf(tmp, "%u-%u", &s_data_port, &s_mon_port) < 1) {
            expert_add_info(pinfo, ti, &ei_rtsp_bad_server_port);
            return;
        }
    }
    else if ((tmp = strstr(buf, rtsp_sps_dest_addr))) {
        tmp += strlen(rtsp_sps_dest_addr);
        if (sscanf(tmp, "\":%u\"", &s_data_port) == 1) {
            /* :9 mean ignore */
            if (s_data_port == 9) {
                s_data_port = 0;
            }
        }
        else if (sscanf(tmp, "\"%u.%u.%u.%u:%u\"", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4, &s_data_port) == 5) {
            guchar *tmp2;
            guchar *tmp3;

            /* Skip leading " */
            tmp++;
            tmp2=strstr(tmp,":");
            tmp3=g_strndup(tmp,tmp2-tmp);
            if (!str_to_ip(tmp3, &ip4_addr)) {
                g_free(tmp3);
                expert_add_info(pinfo, ti, &ei_rtsp_bad_server_ip_address);
                return;
            }
            set_address(&dst_addr, AT_IPv4, 4, &ip4_addr);
            g_free(tmp3);
        }
        else if (sscanf(tmp, "\"%u.%u.%u.%u\"", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4) == 4) {
            guchar *tmp2;
            guchar *tmp3;

            /* Skip leading " */
            tmp++;
            tmp2=strstr(tmp,"\"");
            tmp3=g_strndup(tmp,tmp2-tmp);
            if (!str_to_ip(tmp3, &ip4_addr)) {
                g_free(tmp3);
                expert_add_info(pinfo, ti, &ei_rtsp_bad_server_ip_address);
                return;
            }
            set_address(&dst_addr, AT_IPv4, 4, &ip4_addr);
            g_free(tmp3);
        }
        else
        {
            expert_add_info(pinfo, ti, &ei_rtsp_bad_server_port);
            return;
        }
    }


    /* Look for client port */
    if ((tmp = strstr(buf, rtsp_cps_server_port))) {
        tmp += strlen(rtsp_cps_server_port);
        if (sscanf(tmp, "%u-%u", &c_data_port, &c_mon_port) < 1) {
            expert_add_info(pinfo, ti, &ei_rtsp_bad_client_port);
            return;
        }
    }
    else if ((tmp = strstr(buf, rtsp_cps_src_addr))) {
        tmp += strlen(rtsp_cps_src_addr);
        if (sscanf(tmp, "\"%u.%u.%u.%u:%u\"", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4, &c_data_port) == 5) {
            guchar *tmp2;
            guchar *tmp3;

            /* Skip leading " */
            tmp++;
            tmp2=strstr(tmp,":");
            tmp3=g_strndup(tmp,tmp2-tmp);
            if (!str_to_ip(tmp3, &ip4_addr)) {
                g_free(tmp3);
                expert_add_info(pinfo, ti, &ei_rtsp_bad_client_ip_address);
                return;
            }
            set_address(&src_addr, AT_IPv4, 4, &ip4_addr);
            g_free(tmp3);
        }
    }

    /* Deal with RTSP TCP-interleaved conversations. */
    if (strstr(buf, rtsp_inter) != NULL) {
        rtsp_conversation_data_t    *data;
        guint               s_data_chan, s_mon_chan;
        int             i;

        /* Move tmp to beyone interleaved string */
        tmp = strstr(buf, rtsp_inter);
        tmp += strlen(rtsp_inter);
        /* Look for channel number(s) */
        i = sscanf(tmp, "%u-%u", &s_data_chan, &s_mon_chan);
        if (i < 1)
        {
            expert_add_info(pinfo, ti, &ei_rtsp_bad_interleaved_channel);
            return;
        }

        /* At least data channel present, look for conversation (presumably TCP) */
        conv = find_or_create_conversation(pinfo);

        /* Look for previous data */
        data = (rtsp_conversation_data_t *)conversation_get_proto_data(conv, proto_rtsp);

        /* Create new data if necessary */
        if (!data)
        {
            data = wmem_new0(wmem_file_scope(), rtsp_conversation_data_t);
            conversation_add_proto_data(conv, proto_rtsp, data);
        }

        /* Now set the dissector handle of the interleaved channel
           according to the transport protocol used */
        if (rtp_tcp_transport)
        {
            if (s_data_chan < RTSP_MAX_INTERLEAVED) {
                data->interleaved[s_data_chan].dissector =
                    rtp_handle;
            }
            if (i > 1 && s_mon_chan < RTSP_MAX_INTERLEAVED) {
                data->interleaved[s_mon_chan].dissector =
                    rtcp_handle;
            }
        }
        else if (rdt_transport)
        {
            if (s_data_chan < RTSP_MAX_INTERLEAVED) {
                data->interleaved[s_data_chan].dissector =
                    rdt_handle;
            }
        }
        return;
    }
    /* Noninterleaved options follow */
    /*
     * We only want to match on the destination address, not the
     * source address, because the server might send back a packet
     * from an address other than the address to which its client
     * sent the packet, so we construct a conversation with no
     * second address.
     */
    else if (rtp_udp_transport)
    {
        /* RTP only if indicated */
        if (c_data_port)
        {
            rtp_add_address(pinfo, PT_UDP, &dst_addr, c_data_port, s_data_port,
                            "RTSP", pinfo->num, is_video, NULL);
        }

        /* RTCP only if indicated */
        if (c_mon_port)
        {
            rtcp_add_address(pinfo, &pinfo->dst, c_mon_port, s_mon_port,
                             "RTSP", pinfo->num);
        }
    }
    else if (rtp_tcp_transport)
    {
        /* RTP only if indicated */
        rtp_add_address(pinfo, PT_TCP, &src_addr, c_data_port, s_data_port,
                        "RTSP", pinfo->num, is_video, NULL);
    }
    else if (rdt_transport)
    {
        /* Real Data Transport */
        rdt_add_address(pinfo, &pinfo->dst, c_data_port, s_data_port,
                        "RTSP", rdt_feature_level);
    }
    return;
}
