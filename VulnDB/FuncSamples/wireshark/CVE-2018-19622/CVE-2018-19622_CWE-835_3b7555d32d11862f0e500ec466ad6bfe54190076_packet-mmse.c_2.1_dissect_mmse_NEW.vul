static void
dissect_mmse(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint8 pdut,
        const char *message_type)
{
    guint        offset, old_offset;
    guint8       field = 0;
    const char   *strval;
    guint        length;
    guint        count;
    guint8       version = 0x80; /* Default to MMSE 1.0 */

    /* Set up structures needed to add the protocol subtree and manage it */
    proto_item  *ti = NULL;
    proto_tree  *mmse_tree = NULL;

    DebugLog(("dissect_mmse() - START (Packet %u)\n", pinfo->num));

    ti = proto_tree_add_item(tree, proto_mmse, tvb, 0, -1, ENC_NA);
    proto_item_append_text(ti, ", Type: %s", message_type);
    /* create display subtree for the protocol */
    mmse_tree = proto_item_add_subtree(ti, ett_mmse);

    /* Report PDU-type      */
    proto_tree_add_uint(mmse_tree, hf_mmse_message_type, tvb, 0, 2, pdut);

    offset = 2;                 /* Skip Message-Type    */
    old_offset = 1;

    /*
     * Cycle through MMS-headers
     *
     * NOTE - some PDUs may convey content that can be handed off
     *        to subdissectors.
     */
    if (tree == NULL && !pdu_has_content(pdut)) {
        DebugLog(("tree == NULL and PDU has no potential content\n"));
        return;
    }

    while ((offset < tvb_reported_length(tvb)) &&
            (field = tvb_get_guint8(tvb, offset++)) != MM_CTYPE_HDR)
    {
        DebugLog(("\tField =  0x%02X (offset = %u): %s\n",
                    field, offset,
                    val_to_str(field, vals_mm_header_names,
                        "Unknown MMS header 0x%02X")));
        switch (field)
        {
            case MM_TID_HDR:                /* Text-string  */
                length = get_text_string(tvb, offset, &strval);
                proto_tree_add_string(mmse_tree, hf_mmse_transaction_id,
                        tvb, offset - 1, length + 1,strval);
                offset += length;
                break;
            case MM_VERSION_HDR:            /* nibble-Major/nibble-minor*/
                {
                    guint8   major, minor;
                    char    *vers_string;

                    version = tvb_get_guint8(tvb, offset++);
                    major = (version & 0x70) >> 4;
                    minor = version & 0x0F;
                    if (minor == 0x0F)
                        vers_string = wmem_strdup_printf(wmem_packet_scope(), "%u", major);
                    else
                        vers_string = wmem_strdup_printf(wmem_packet_scope(), "%u.%u", major, minor);
                    proto_tree_add_string(mmse_tree, hf_mmse_mms_version,
                            tvb, offset - 2, 2, vers_string);
                }
                break;
            case MM_BCC_HDR:                /* Encoded-string-value */
                length = get_encoded_strval(tvb, offset, &strval, pinfo);
                proto_tree_add_string(mmse_tree, hf_mmse_bcc, tvb,
                        offset - 1, length + 1, strval);
                offset += length;
                break;
            case MM_CC_HDR:                 /* Encoded-string-value */
                length = get_encoded_strval(tvb, offset, &strval, pinfo);
                proto_tree_add_string(mmse_tree, hf_mmse_cc, tvb,
                        offset - 1, length + 1, strval);
                offset += length;
                break;
            case MM_CLOCATION_HDR:          /* Uri-value            */
                if (pdut == PDU_M_MBOX_DELETE_CONF) {
                    /* General form with length */
                    length = tvb_get_guint8(tvb, offset);
                    if (length == 0x1F) {
                        guint length_len = 0;
                        length = tvb_get_guintvar(tvb, offset + 1,
                                &length_len, pinfo, &ei_mmse_oversized_uintvar);
                        length += 1 + length_len;
                    } else {
                        length += 1;
                    }
                    proto_tree_add_string(mmse_tree,
                            hf_mmse_content_location,
                            tvb, offset - 1, length + 1,
                            "<Undecoded value for m-mbox-delete-conf>");
                } else {
                    length = get_text_string(tvb, offset, &strval);
                    proto_tree_add_string(mmse_tree,
                            hf_mmse_content_location,
                            tvb, offset - 1, length + 1, strval);
                }
                offset += length;
                break;
            case MM_DATE_HDR:               /* Long-integer         */
                {
                    guint            tval;
                    nstime_t         tmptime;

                    tval = get_long_integer(tvb, offset, &count);
                    tmptime.secs = tval;
                    tmptime.nsecs = 0;
                    proto_tree_add_time(mmse_tree, hf_mmse_date, tvb,
                            offset - 1, count + 1, &tmptime);
                }
                offset += count;
                break;
            case MM_DREPORT_HDR:            /* Yes|No               */
                field = tvb_get_guint8(tvb, offset++);
                proto_tree_add_uint(mmse_tree,
                        hf_mmse_delivery_report,
                        tvb, offset - 2, 2, field);
                break;
            case MM_DTIME_HDR:
                {
                    guint            tval;
                    nstime_t         tmptime;
                    guint            cnt;

                    /*
                     * Value-length(Absolute-token Date-value|
                     *              Relative-token Delta-seconds-value)
                     */
                    length = get_value_length(tvb, offset, &count, pinfo);
                    field = tvb_get_guint8(tvb, offset + count);

                    tval =  get_long_integer(tvb, offset + count + 1, &cnt);
                    tmptime.secs = tval;
                    tmptime.nsecs = 0;

                    if (field == 0x80)
                        proto_tree_add_time(mmse_tree,
                                hf_mmse_delivery_time_abs,
                                tvb, offset - 1,
                                length + count + 1, &tmptime);
                    else
                        proto_tree_add_time(mmse_tree,
                                hf_mmse_delivery_time_rel,
                                tvb, offset - 1,
                                length + count + 1, &tmptime);
                }
                offset += length + count;
                break;
            case MM_EXPIRY_HDR:
                {
                    guint            tval;
                    nstime_t         tmptime;
                    guint            cnt;

                    /*
                     * Value-length(Absolute-token Date-value|
                     *              Relative-token Delta-seconds-value)
                     */
                    length = get_value_length(tvb, offset, &count, pinfo);
                    field = tvb_get_guint8(tvb, offset + count);

                    tval = get_long_integer(tvb, offset + count + 1, &cnt);
                    tmptime.secs = tval;
                    tmptime.nsecs = 0;

                    if (field == 0x80)
                        proto_tree_add_time(mmse_tree, hf_mmse_expiry_abs,
                                tvb, offset - 1,
                                length + count + 1, &tmptime);
                    else
                        proto_tree_add_time(mmse_tree, hf_mmse_expiry_rel,
                                tvb, offset - 1,
                                length + count + 1, &tmptime);
                }
                offset += length + count;
                break;
            case MM_FROM_HDR:
                /*
                 * Value-length(Address-present-token Encoded-string-value
                 *              |Insert-address-token)
                 */
                length = get_value_length(tvb, offset, &count, pinfo);
                field = tvb_get_guint8(tvb, offset + count);
                if (field == 0x81) {
                    proto_tree_add_string(mmse_tree, hf_mmse_from, tvb,
                            offset-1, length + count + 1,
                            "<insert address>");
                } else {
                    (void) get_encoded_strval(tvb, offset + count + 1,
                            &strval, pinfo);
                    proto_tree_add_string(mmse_tree, hf_mmse_from, tvb,
                            offset-1, length + count + 1, strval);
                }
                offset += length + count;
                break;
            case MM_MCLASS_HDR:
                /*
                 * Class-identifier|Text-string
                 */
                field = tvb_get_guint8(tvb, offset);
                if (field & 0x80) {
                    offset++;
                    proto_tree_add_uint(mmse_tree,
                            hf_mmse_message_class_id,
                            tvb, offset - 2, 2, field);
                } else {
                    length = get_text_string(tvb, offset, &strval);
                    proto_tree_add_string(mmse_tree,
                            hf_mmse_message_class_str,
                            tvb, offset - 1, length + 1,
                            strval);
                    offset += length;
                }
                break;
            case MM_MID_HDR:                /* Text-string          */
                length = get_text_string(tvb, offset, &strval);
                proto_tree_add_string(mmse_tree, hf_mmse_message_id,
                        tvb, offset - 1, length + 1, strval);
                offset += length;
                break;
            case MM_MSIZE_HDR:              /* Long-integer         */
                length = get_long_integer(tvb, offset, &count);
                proto_tree_add_uint(mmse_tree, hf_mmse_message_size,
                        tvb, offset - 1, count + 1, length);
                offset += count;
                break;
            case MM_PRIORITY_HDR:           /* Low|Normal|High      */
                field = tvb_get_guint8(tvb, offset++);
                proto_tree_add_uint(mmse_tree, hf_mmse_priority, tvb,
                        offset - 2, 2, field);
                break;
            case MM_RREPLY_HDR:             /* Yes|No               */
                field = tvb_get_guint8(tvb, offset++);
                if (version == 0x80) { /* MMSE 1.0 */
                    proto_tree_add_uint(mmse_tree, hf_mmse_read_reply,
                            tvb, offset - 2, 2, field);
                } else {
                    proto_tree_add_uint(mmse_tree, hf_mmse_read_report,
                            tvb, offset - 2, 2, field);
                }
                break;
            case MM_RALLOWED_HDR:           /* Yes|No               */
                field = tvb_get_guint8(tvb, offset++);
                proto_tree_add_uint(mmse_tree, hf_mmse_report_allowed,
                        tvb, offset - 2, 2, field);
                break;
            case MM_RSTATUS_HDR:
                field = tvb_get_guint8(tvb, offset++);
                proto_tree_add_uint(mmse_tree, hf_mmse_response_status,
                        tvb, offset - 2, 2, field);
                break;
            case MM_RTEXT_HDR:              /* Encoded-string-value */
                if (pdut == PDU_M_MBOX_DELETE_CONF) {
                    /* General form with length */
                    length = tvb_get_guint8(tvb, offset);
                    if (length == 0x1F) {
                        guint length_len = 0;
                        length = tvb_get_guintvar(tvb, offset + 1,
                                &length_len, pinfo, &ei_mmse_oversized_uintvar);
                        length += 1 + length_len;
                    } else {
                        length += 1;
                    }
                    proto_tree_add_string(mmse_tree,
                            hf_mmse_content_location,
                            tvb, offset - 1, length + 1,
                            "<Undecoded value for m-mbox-delete-conf>");
                } else {
                    length = get_encoded_strval(tvb, offset, &strval, pinfo);
                    proto_tree_add_string(mmse_tree,
                            hf_mmse_response_text, tvb, offset - 1,
                            length + 1, strval);
                }
                offset += length;
                break;
            case MM_SVISIBILITY_HDR:        /* Hide|Show            */
                field = tvb_get_guint8(tvb, offset++);
                proto_tree_add_uint(mmse_tree,hf_mmse_sender_visibility,
                        tvb, offset - 2, 2, field);
                break;
            case MM_STATUS_HDR:
                field = tvb_get_guint8(tvb, offset++);
                proto_tree_add_uint(mmse_tree, hf_mmse_status, tvb,
                        offset - 2, 2, field);
                break;
            case MM_SUBJECT_HDR:            /* Encoded-string-value */
                length = get_encoded_strval(tvb, offset, &strval, pinfo);
                proto_tree_add_string(mmse_tree, hf_mmse_subject, tvb,
                        offset - 1, length + 1, strval);
                offset += length;
                break;
            case MM_TO_HDR:                 /* Encoded-string-value */
                length = get_encoded_strval(tvb, offset, &strval, pinfo);
                proto_tree_add_string(mmse_tree, hf_mmse_to, tvb,
                        offset - 1, length + 1, strval);
                offset += length;
                break;

                /*
                 * MMS Encapsulation 1.1
                 */
            case MM_RETRIEVE_STATUS_HDR:    /* Well-known-value */
                field = tvb_get_guint8(tvb, offset++);
                proto_tree_add_uint(mmse_tree, hf_mmse_retrieve_status,
                        tvb, offset - 2, 2, field);
                break;
            case MM_RETRIEVE_TEXT_HDR:
                if (pdut == PDU_M_MBOX_DELETE_CONF) {
                    /* General form with length */
                    length = tvb_get_guint8(tvb, offset);
                    if (length == 0x1F) {
                        guint length_len = 0;
                        length = tvb_get_guintvar(tvb, offset + 1,
                                &length_len, pinfo, &ei_mmse_oversized_uintvar);
                        length += 1 + length_len;
                    } else {
                        length += 1;
                    }

                    proto_tree_add_string(mmse_tree,
                            hf_mmse_content_location,
                            tvb, offset - 1, length + 1,
                            "<Undecoded value for m-mbox-delete-conf>");
                } else {
                    /* Encoded-string-value */
                    length = get_encoded_strval(tvb, offset, &strval, pinfo);
                    proto_tree_add_string(mmse_tree,
                            hf_mmse_retrieve_text, tvb, offset - 1,
                            length + 1, strval);
                }
                offset += length;
                break;
            case MM_READ_STATUS_HDR:        /* Well-known-value */
                field = tvb_get_guint8(tvb, offset++);
                proto_tree_add_uint(mmse_tree, hf_mmse_read_status,
                        tvb, offset - 2, 2, field);
                break;
            case MM_REPLY_CHARGING_HDR:     /* Well-known-value */
                field = tvb_get_guint8(tvb, offset++);
                proto_tree_add_uint(mmse_tree, hf_mmse_reply_charging,
                        tvb, offset - 2, 2, field);
                break;
            case MM_REPLY_CHARGING_DEADLINE_HDR:    /* Well-known-value */
                {
                    guint            tval;
                    nstime_t         tmptime;
                    guint            cnt;

                    /*
                     * Value-length(Absolute-token Date-value|
                     *              Relative-token Delta-seconds-value)
                     */

                    length = get_value_length(tvb, offset, &count, pinfo);
                    field = tvb_get_guint8(tvb, offset + count);

                    tval = get_long_integer(tvb, offset + count + 1, &cnt);
                    tmptime.secs = tval;
                    tmptime.nsecs = 0;

                    if (field == 0x80)
                        proto_tree_add_time(mmse_tree, hf_mmse_reply_charging_deadline_abs,
                                tvb, offset - 1,
                                length + count + 1, &tmptime);
                    else
                        proto_tree_add_time(mmse_tree, hf_mmse_reply_charging_deadline_rel,
                                tvb, offset - 1,
                                length + count + 1, &tmptime);
                }
                offset += length + count;
                break;
            case MM_REPLY_CHARGING_ID_HDR:  /* Text-string */
                length = get_text_string(tvb, offset, &strval);
                proto_tree_add_string(mmse_tree,
                        hf_mmse_reply_charging_id,
                        tvb, offset - 1, length + 1, strval);
                offset += length;
                break;
            case MM_REPLY_CHARGING_SIZE_HDR:        /* Long-integer */
                length = get_long_integer(tvb, offset, &count);
                proto_tree_add_uint(mmse_tree,
                        hf_mmse_reply_charging_size,
                        tvb, offset - 1, count + 1, length);
                offset += count;
                break;
            case MM_PREV_SENT_BY_HDR:
                {
                    guint32 fwd_count, count1, count2;
                    proto_tree *subtree = NULL;
                    proto_item *tii = NULL;

                    /* Value-length Integer-value Encoded-string-value */
                    length = get_value_length(tvb, offset, &count, pinfo);

                    /* 1. Forwarded-count-value := Integer-value */
                    fwd_count = get_integer_value(tvb, offset + count,
                            &count1);
                    /* 2. Encoded-string-value */
                    count2 = get_encoded_strval(tvb,
                            offset + count + count1, &strval, pinfo);
                    /* Now render the fields */
                    tii = proto_tree_add_string_format(mmse_tree,
                            hf_mmse_prev_sent_by,
                            tvb, offset - 1, 1 + count + length,
                            strval, "%s (Forwarded-count=%u)",
                            format_text(wmem_packet_scope(), strval, strlen(strval)),
                            fwd_count);
                    subtree = proto_item_add_subtree(tii,
                            ett_mmse_hdr_details);
                    proto_tree_add_uint(subtree,
                            hf_mmse_prev_sent_by_fwd_count,
                            tvb, offset + count, count1, fwd_count);
                    proto_tree_add_string(subtree,
                            hf_mmse_prev_sent_by_address,
                            tvb, offset + count + count1, count2, strval);
                }
                offset += length + count;
                break;
            case MM_PREV_SENT_DATE_HDR:
                {
                    guint32 fwd_count, count1, count2;
                    guint            tval;
                    nstime_t         tmptime;
                    proto_tree *subtree = NULL;
                    proto_item *tii = NULL;

                    /* Value-Length Forwarded-count-value Date-value */
                    length = get_value_length(tvb, offset, &count, pinfo);
                    /* 1. Forwarded-count-value := Integer-value */
                    fwd_count = get_integer_value(tvb, offset + count, &count1);
                    /* 2. Date-value := Long-integer */
                    tval = get_long_integer(tvb, offset + count + count1,
                            &count2);
                    tmptime.secs = tval;
                    tmptime.nsecs = 0;
                    strval = abs_time_to_str(wmem_packet_scope(), &tmptime, ABSOLUTE_TIME_LOCAL,
                            TRUE);
                    /* Now render the fields */
                    tii = proto_tree_add_string_format(mmse_tree,
                            hf_mmse_prev_sent_date,
                            tvb, offset - 1, 1 + count + length,
                            strval, "%s (Forwarded-count=%u)",
                            format_text(wmem_packet_scope(), strval, strlen(strval)),
                            fwd_count);
                    subtree = proto_item_add_subtree(tii,
                            ett_mmse_hdr_details);
                    proto_tree_add_uint(subtree,
                            hf_mmse_prev_sent_date_fwd_count,
                            tvb, offset + count, count1, fwd_count);
                    proto_tree_add_string(subtree,
                            hf_mmse_prev_sent_date_date,
                            tvb, offset + count + count1, count2, strval);
                }
                offset += length + count;
                break;

                /* MMS Encapsulation 1.2 */

            default:
                if (field & 0x80) { /* Well-known WSP header encoding */
                    guint8 peek = tvb_get_guint8(tvb, offset);
                    const char *hdr_name = val_to_str(field, vals_mm_header_names,
                            "Unknown field (0x%02x)");
                    const char *str;
                    DebugLog(("\t\tUndecoded well-known header: %s\n",
                                hdr_name));

                    if (peek & 0x80) { /* Well-known value */
                        length = 1;
                        proto_tree_add_uint_format(mmse_tree, hf_mmse_header_uint, tvb, offset - 1,
                                length + 1, peek,
                                "%s: <Well-known value 0x%02x>"
                                " (not decoded)",
                                hdr_name, peek);
                    } else if ((peek == 0) || (peek >= 0x20)) { /* Text */
                        length = get_text_string(tvb, offset, &strval);
                        str = format_text(wmem_packet_scope(), strval, strlen(strval));
                        proto_tree_add_string_format(mmse_tree, hf_mmse_header_string, tvb, offset - 1,
                                length + 1, str, "%s: %s (Not decoded)", hdr_name, str);
                    } else { /* General form with length */
                        if (peek == 0x1F) { /* Value length in guintvar */
                            guint length_len = 0;
                            length = 1 + tvb_get_guintvar(tvb, offset + 1,
                                    &length_len, pinfo, &ei_mmse_oversized_uintvar);
                            length += length_len;
                        } else { /* Value length in octet */
                            length = 1 + tvb_get_guint8(tvb, offset);
                        }
                        proto_tree_add_bytes_format(mmse_tree, hf_mmse_header_bytes, tvb, offset - 1,
                                length + 1, NULL, "%s: "
                                "<Value in general form> (not decoded)",
                                hdr_name);
                    }
                    offset += length;
                } else { /* Literal WSP header encoding */
                    guint            length2;
                    const char       *strval2;

                    --offset;
                    length = get_text_string(tvb, offset, &strval);
                    DebugLog(("\t\tUndecoded literal header: %s\n",
                                strval));
                    length2= get_text_string(tvb, offset+length, &strval2);

                    proto_tree_add_string_format(mmse_tree,
                            hf_mmse_ffheader, tvb, offset,
                            length + length2,
                            tvb_get_string_enc(wmem_packet_scope(), tvb, offset,
                                length + length2, ENC_ASCII),
                            "%s: %s",
                            format_text(wmem_packet_scope(), strval, strlen(strval)),
                            format_text(wmem_packet_scope(), strval2, strlen(strval2)));

                    offset += length + length2;
                }
                break;
        }
        DebugLog(("\tEnd(case)\n"));

        if (offset <= old_offset) {
            REPORT_DISSECTOR_BUG("Offset isn't increasing");
        }
        old_offset = offset;
    }

    DebugLog(("\tEnd(switch)\n"));
    if (field == MM_CTYPE_HDR) {
        /*
         * Eeehh, we're now actually back to good old WSP content-type
         * encoding. Let's steal that from the WSP-dissector.
         */
        tvbuff_t    *tmp_tvb;
        guint        type;
        const char  *type_str;

        DebugLog(("Content-Type: [from WSP dissector]\n"));
        DebugLog(("Calling add_content_type() in WSP dissector\n"));
        offset = add_content_type(mmse_tree, pinfo, tvb, offset, &type, &type_str);
        DebugLog(("Generating new TVB subset (offset = %u)\n", offset));
        tmp_tvb = tvb_new_subset_remaining(tvb, offset);
        DebugLog(("Add POST data\n"));
        add_post_data(mmse_tree, tmp_tvb, type, type_str, pinfo);
        DebugLog(("Done!\n"));
    }

    /* If this protocol has a sub-dissector call it here, see section 1.8 */
    DebugLog(("dissect_mmse() - END\n"));
}
