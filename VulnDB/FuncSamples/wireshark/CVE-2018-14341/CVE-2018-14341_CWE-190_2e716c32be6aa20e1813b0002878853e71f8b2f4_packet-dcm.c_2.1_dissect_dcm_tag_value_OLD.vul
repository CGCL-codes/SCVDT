static guint32
dissect_dcm_tag_value(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, dcm_state_pdv_t *pdv,
                      guint32 offset, guint16 grp, guint16 elm,
                      guint32 vl, guint32 vl_max, const gchar* vr, gchar **tag_value)
{
    /* Based on the value representation, decode the value of one tag. Returns new offset */

    proto_item *pitem = NULL;

    gboolean is_little_endian;

    if (pdv->syntax == DCM_EBE) is_little_endian = FALSE;
    else                        is_little_endian = TRUE;


    /* ---------------------------------------------------------------------------
       Potentially long types. Obey vl_max
       ---------------------------------------------------------------------------
    */

    if ((strncmp(vr, "AE", 2) == 0) || (strncmp(vr, "AS", 2) == 0) || (strncmp(vr, "CS", 2) == 0) ||
        (strncmp(vr, "DA", 2) == 0) || (strncmp(vr, "DS", 2) == 0) || (strncmp(vr, "DT", 2) == 0) ||
        (strncmp(vr, "IS", 2) == 0) || (strncmp(vr, "LO", 2) == 0) || (strncmp(vr, "LT", 2) == 0) ||
        (strncmp(vr, "PN", 2) == 0) || (strncmp(vr, "SH", 2) == 0) || (strncmp(vr, "ST", 2) == 0) ||
        (strncmp(vr, "TM", 2) == 0) || (strncmp(vr, "UI", 2) == 0) || (strncmp(vr, "UT", 2) == 0) ) {
        /* 15 ways to represent a string ... */

        gchar   *vals;
        dcm_uid_t *uid = NULL;
        guint8 val8;

        val8 = tvb_get_guint8(tvb, offset + vl_max - 1);
        if (val8 == 0x00) {
            /* Last byte of string is 0x00, i.e. padded */
            vals = tvb_format_text(tvb, offset, vl_max - 1);
        }
        else {
            vals = tvb_format_text(tvb, offset, vl_max);
        }

        if ((strncmp(vr, "UI", 2) == 0)) {
            /* This is a UID. Attempt a lookup. Will only return something for classes of course */

            uid = (dcm_uid_t *)g_hash_table_lookup(dcm_uid_table, (gpointer) vals);
            if (uid) {
                g_snprintf(*tag_value, MAX_BUF_LEN, "%s (%s)", vals, uid->name);
            }
            else {
                g_snprintf(*tag_value, MAX_BUF_LEN, "%s", vals);
            }
        }
        else {
            if (strlen(vals) > 50) {
                g_snprintf(*tag_value, MAX_BUF_LEN, "%-50.50s...", vals);
            }
            else {
                g_snprintf(*tag_value, MAX_BUF_LEN, "%s", vals);
            }
        }
        proto_tree_add_string_format(tree, hf_dcm_tag_value_str, tvb, offset, vl_max, *tag_value, "%-8.8s%s", "Value:", *tag_value);

        if (grp == 0x0000 && elm == 0x0902) {
            /* The error comment */
            pdv->comment = wmem_strdup(wmem_file_scope(), g_strstrip(vals));
        }
    }
    else if ((strncmp(vr, "OB", 2) == 0) || (strncmp(vr, "OF", 2) == 0) ||
             (strncmp(vr, "OW", 2) == 0)) {
        /* Array of Bytes, Float or Words. Don't perform any decoding */

        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,
            NULL, "%-8.8s%s", "Value:", "(binary)");

        g_snprintf(*tag_value, MAX_BUF_LEN, "(binary)");
    }
    else if (strncmp(vr, "UN", 2) == 0) {
        /* Usually the case for private tags in implicit syntax, since tag was not found and vr not specified */
        guint8    val8;
        gchar    *vals;
        guint32  i;

        /* String detector, i.e. check if we only have alpha-numeric character */
        gboolean        is_string = TRUE;
        gboolean        is_padded = FALSE;

        for (i = 0; i < vl_max ; i++) {
            val8 = tvb_get_guint8(tvb, offset + i);

            if ((val8 == 0x09) || (val8 == 0x0A) || (val8 == 0x0D)) {
                /* TAB, LF, CR */
            }
            else if ((val8 >= 0x20) && (val8 <= 0x7E)) {
                /* No extended ASCII, 0-9, A-Z, a-z */
            }
            else if ((i == vl_max -1) && (val8 == 0x00)) {
                /* Last Byte can be null*/
                is_padded = TRUE;
            }
            else {
                /* Here's the code */
                is_string = FALSE;
            }
        }

        if (is_string) {
            vals = tvb_format_text(tvb, offset, (is_padded ? vl_max - 1 : vl_max));
            proto_tree_add_string_format(tree, hf_dcm_tag_value_str, tvb, offset, vl_max,
                vals, "%-8.8s%s", "Value:", vals);

            g_snprintf(*tag_value, MAX_BUF_LEN, "%s", vals);
        }
        else {
            proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,
                NULL, "%-8.8s%s", "Value:", "(binary)");

            g_snprintf(*tag_value, MAX_BUF_LEN, "(binary)");
        }
    }
    /* ---------------------------------------------------------------------------
       Smaller types. vl/vl_max are not used. Fixed item length from 2 to 8 bytes
       ---------------------------------------------------------------------------
    */
    else if (strncmp(vr, "AT", 2) == 0)  {      /* Attribute Tag */
        /* 2*2 Bytes */

        guint16 at_grp;
        guint16 at_elm;
        guint32 at_offset = 0;
        const gchar *at_value = "";

        while(at_offset < vl_max-3) {
            if (is_little_endian)   at_grp = tvb_get_letohs(tvb, offset+at_offset);
            else                    at_grp = tvb_get_ntohs(tvb, offset+at_offset);

            if (is_little_endian)   at_elm = tvb_get_letohs(tvb, offset+at_offset+2);
            else                    at_elm = tvb_get_ntohs(tvb, offset+at_offset+2);

            proto_tree_add_uint_format(tree, hf_dcm_tag_value_32u, tvb, offset+at_offset, 4,
                (at_grp << 16) | at_elm, "%-8.8s%04x,%04x", "Value:", at_grp, at_elm);

            at_value = wmem_strdup_printf(wmem_packet_scope(),"%s(%04x,%04x)", at_value, at_grp, at_elm);

            at_offset += 4;
        }
        g_snprintf(*tag_value, MAX_BUF_LEN, "%s", at_value);
    }
    else if (strncmp(vr, "FL", 2) == 0)  {      /* Single Float */

        gfloat valf;

        if (is_little_endian) valf = tvb_get_letohieee_float(tvb, offset);
        else                  valf = tvb_get_ntohieee_float(tvb, offset);

        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, 4,
            NULL, "%-8.8s%f", "Value:", valf);

        g_snprintf(*tag_value, MAX_BUF_LEN, "%f", valf);
    }
    else if (strncmp(vr, "FD", 2) == 0)  {      /* Double Float */

        gdouble vald;

        if (is_little_endian) vald = tvb_get_letohieee_double(tvb, offset);
        else                  vald = tvb_get_ntohieee_double(tvb, offset);

        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, 8,
            NULL, "%-8.8s%f", "Value:", vald);

        g_snprintf(*tag_value, MAX_BUF_LEN, "%f", vald);
    }
    else if (strncmp(vr, "SL", 2) == 0)  {          /* Signed Long */
        gint32  val32;

        if (is_little_endian)   val32 = tvb_get_letohl(tvb, offset);
        else                    val32 = tvb_get_ntohl(tvb, offset);

        proto_tree_add_int_format(tree, hf_dcm_tag_value_32s, tvb, offset, 4,
            val32, "%-8.8s%d", "Value:", val32);

        g_snprintf(*tag_value, MAX_BUF_LEN, "%d", val32);
    }
    else if (strncmp(vr, "SS", 2) == 0)  {          /* Signed Short */
        gint16  val16;

        if (is_little_endian)   val16 = tvb_get_letohs(tvb, offset);
        else                    val16 = tvb_get_ntohs(tvb, offset);

        proto_tree_add_int_format(tree, hf_dcm_tag_value_16s, tvb, offset, 2,
            val16, "%-8.8s%d", "Value:", val16);

        g_snprintf(*tag_value, MAX_BUF_LEN, "%d", val16);
    }
    else if (strncmp(vr, "UL", 2) == 0)  {          /* Unsigned Long */
        guint32  val32;

        if (is_little_endian)   val32 = tvb_get_letohl(tvb, offset);
        else                    val32 = tvb_get_ntohl(tvb, offset);

        proto_tree_add_uint_format(tree, hf_dcm_tag_value_32u, tvb, offset, 4,
            val32, "%-8.8s%u", "Value:", val32);

        g_snprintf(*tag_value, MAX_BUF_LEN, "%u", val32);
    }
    else if (strncmp(vr, "US", 2) == 0)  {          /* Unsigned Short */
        const gchar *status_message = NULL;
        guint16     val16;

        if (is_little_endian)   val16 = tvb_get_letohs(tvb, offset);
        else                    val16 = tvb_get_ntohs(tvb, offset);

        if (grp == 0x0000 && elm == 0x0100) {
            /* This is a command */
            g_snprintf(*tag_value, MAX_BUF_LEN, "%s", dcm_cmd2str(val16));

            pdv->command = wmem_strdup(wmem_file_scope(), *tag_value);
        }
        else if (grp == 0x0000 && elm == 0x0900) {
            /* This is a status message. If value is not 0x0000, add an expert info */

            status_message = dcm_rsp2str(val16);
            g_snprintf(*tag_value, MAX_BUF_LEN, "%s (0x%02x)", status_message, val16);

            if (val16 != 0x0000 && ((val16 & 0xFF00) != 0xFF00)) {
                /* Not 0x0000 0xFFxx */
                pdv->is_warning = TRUE;
            }

            pdv->status = wmem_strdup(wmem_file_scope(), status_message);

        }
        else {
            g_snprintf(*tag_value, MAX_BUF_LEN, "%u", val16);
        }

        if (grp == 0x0000) {
            if (elm == 0x0110) {                /* (0000,0110) Message ID */
                pdv->message_id = val16;
            }
            else if (elm == 0x0120) {           /* (0000,0120) Message ID Being Responded To */
                pdv->message_id_resp = val16;
            }
            else if (elm == 0x1020) {           /* (0000,1020) Number of Remaining Sub-operations */
                pdv->no_remaining = val16;
            }
            else if (elm == 0x1021) {           /* (0000,1021) Number of Completed Sub-operations */
                pdv->no_completed = val16;
            }
            else if (elm == 0x1022) {           /* (0000,1022) Number of Failed Sub-operations  */
                pdv->no_failed = val16;
            }
            else if (elm == 0x1023) {           /* (0000,1023) Number of Warning Sub-operations */
                pdv->no_warning = val16;
            }
        }

        pitem = proto_tree_add_uint_format(tree, hf_dcm_tag_value_16u, tvb, offset, 2,
                    val16, "%-8.8s%s", "Value:", *tag_value);

        if (pdv->is_warning && status_message) {
            expert_add_info(pinfo, pitem, &ei_dcm_status_msg);
        }
    }
    /* Invalid VR, can only occur with Explicit syntax */
    else {
        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,
            NULL, "%-8.8s%s", "Value:", (vl > vl_max ? "" : "(unknown VR)"));

        g_snprintf(*tag_value, MAX_BUF_LEN, "(unknown VR)");
    }
    offset += vl_max;

    return offset;

}
