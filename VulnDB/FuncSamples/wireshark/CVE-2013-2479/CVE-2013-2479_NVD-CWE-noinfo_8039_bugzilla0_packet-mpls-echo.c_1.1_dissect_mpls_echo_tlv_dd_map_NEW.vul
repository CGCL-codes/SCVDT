static void
dissect_mpls_echo_tlv_dd_map(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int rem)
{
    proto_tree *ddti = NULL, *tlv_dd_map_tree, *tlv_ddstlv_map_tree;
    proto_tree *ddsti, *ddsti2;
    guint16     subtlv_length, subtlv_type, multipath_length;
    guint8      addr_type, multipath_type, fec_tlv_length;
    guint16     idx = 1;
    guint32     label;
    guint8      tc, s_bit, proto;

    if (tree) {
        proto_tree_add_item(tree, hf_mpls_echo_tlv_dd_map_mtu, tvb,
                            offset, 2, ENC_BIG_ENDIAN);
        proto_tree_add_item(tree, hf_mpls_echo_tlv_dd_map_addr_type, tvb,
                            offset + 2, 1, ENC_BIG_ENDIAN);
        ddti = proto_tree_add_item(tree, hf_mpls_echo_tlv_dd_map_res, tvb,
                                   offset + 3, 1, ENC_BIG_ENDIAN);
        tlv_dd_map_tree = proto_item_add_subtree(ddti, ett_mpls_echo_tlv_dd_map);

        proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_tlv_dd_map_flag_res, tvb,
                            offset + 3, 1, ENC_BIG_ENDIAN);
        proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_tlv_dd_map_flag_i, tvb,
                            offset + 3, 1, ENC_BIG_ENDIAN);
        ddti = proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_tlv_dd_map_flag_n, tvb,
                                   offset + 3, 1, ENC_BIG_ENDIAN);
    }
    addr_type = tvb_get_guint8(tvb, offset + 2);
    switch (addr_type) {
    case TLV_ADDR_IPv4:
        proto_tree_add_item(tree, hf_mpls_echo_tlv_dd_map_ds_ip, tvb,
                            offset + 4, 4, ENC_BIG_ENDIAN);
        proto_tree_add_item(tree, hf_mpls_echo_tlv_dd_map_int_ip, tvb,
                            offset + 8, 4, ENC_BIG_ENDIAN);
        break;
    case TLV_ADDR_IPv6:
        proto_tree_add_item(tree, hf_mpls_echo_tlv_dd_map_ds_ipv6, tvb,
                            offset + 4, 16, ENC_NA);
        proto_tree_add_item(tree, hf_mpls_echo_tlv_dd_map_int_ipv6, tvb,
                            offset + 20, 16, ENC_NA);
        rem    -= 24;
        offset += 24;
        break;
    case TLV_ADDR_NONIP :
        proto_tree_add_item (tree, hf_mpls_echo_tlv_dd_map_ingress_if_num, tvb,
                             (offset + 4), 4, ENC_BIG_ENDIAN);
        proto_tree_add_item (tree, hf_mpls_echo_tlv_dd_map_egress_if_num, tvb,
                             (offset + 8), 4, ENC_BIG_ENDIAN);
        break;
    default:
        expert_add_info_format(pinfo, ddti, PI_UNDECODED, PI_WARN,
                               "Unknown Address Type (%u)", addr_type);
        break;
    }

    if (tree) {
        proto_tree_add_item(tree, hf_mpls_echo_tlv_dd_map_return_code, tvb,
                            offset + 12, 1, ENC_BIG_ENDIAN);
        proto_tree_add_item(tree, hf_mpls_echo_tlv_dd_map_return_subcode, tvb,
                            offset + 13, 1, ENC_BIG_ENDIAN);
        ddti = proto_tree_add_item(tree, hf_mpls_echo_tlv_dd_map_subtlv_len, tvb,
                                   offset + 14, 2, ENC_BIG_ENDIAN);
    }

    rem    -= 16;
    offset += 16;

    while (rem > 4) {
       /* Get the Sub-tlv Type and Length */
       subtlv_type   = tvb_get_ntohs(tvb, offset);
       subtlv_length = tvb_get_ntohs(tvb, offset+2);
       rem -= 4;
       offset += 4;

       if (rem<subtlv_length){
          expert_add_info_format(pinfo, ddti, PI_MALFORMED, PI_ERROR,
                "Invalid Sub-tlv Length (claimed %u, found %u)",
                subtlv_length, rem);
          return;
       }

        switch (subtlv_type) {
        case TLV_FEC_MULTIPATH_DATA:
            multipath_type   = tvb_get_guint8(tvb, offset);
            multipath_length = tvb_get_ntohs(tvb, offset + 1);
            ddsti = proto_tree_add_text(tree, tvb, offset - 4, multipath_length + 8,
                                        "Multipath sub-TLV");
            tlv_dd_map_tree = proto_item_add_subtree(ddsti, ett_mpls_echo_tlv_dd_map);

            switch (multipath_type) {
            case TLV_MULTIPATH_NO_MULTIPATH:
                if (!tree)
                    break;
                proto_tree_add_item(tlv_dd_map_tree,
                                    hf_mpls_echo_sub_tlv_multipath_type, tvb, offset, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_dd_map_tree,
                                    hf_mpls_echo_sub_tlv_multipath_length, tvb, offset + 1, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_resv, tvb,
                                    offset + 3, 1, ENC_BIG_ENDIAN);
                ddsti2 = proto_tree_add_text(tlv_dd_map_tree, tvb, offset + 4, multipath_length,
                                             "Empty (Multipath Length = 0)");
                tlv_ddstlv_map_tree = proto_item_add_subtree(ddsti2, ett_mpls_echo_tlv_ddstlv_map);
                proto_tree_add_item(tlv_ddstlv_map_tree, hf_mpls_echo_sub_tlv_multipath_info,
                                    tvb, offset + 4, multipath_length, ENC_BIG_ENDIAN);
                break;

            case TLV_MULTIPATH_IP_ADDRESS:
                if (multipath_length != 4) {
                    expert_add_info_format(pinfo, ddsti, PI_MALFORMED, PI_ERROR,
                               "Invalid Sub-tlv Length (claimed %u, should be 4)",
                               multipath_length);
                    break;
                }
                if (!tree)
                    break;
                proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_multipath_type, tvb,
                                    offset, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_dd_map_tree,
                                    hf_mpls_echo_sub_tlv_multipath_length, tvb, offset + 1, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_resv, tvb,
                                    offset + 3, 1, ENC_BIG_ENDIAN);

                ddsti2 = proto_tree_add_text(tlv_dd_map_tree, tvb, offset + 4, multipath_length,
                                             "Multipath Information (IP addresses)");
                tlv_ddstlv_map_tree = proto_item_add_subtree(ddsti2, ett_mpls_echo_tlv_ddstlv_map);

                proto_tree_add_item(tlv_ddstlv_map_tree, hf_mpls_echo_sub_tlv_multipath_ip, tvb,
                                    offset + 4, 4, ENC_BIG_ENDIAN);
                break;

            case TLV_MULTIPATH_IP_ADDRESS_RANGE:
                if (multipath_length != 8) {
                    expert_add_info_format(pinfo, ddsti, PI_MALFORMED, PI_ERROR,
                               "Invalid Sub-tlv Length (claimed %u, should be 8)",
                               multipath_length);
                    break;
                }
                if (!tree)
                    break;
                proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_multipath_type, tvb,
                                    offset, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_dd_map_tree,
                                    hf_mpls_echo_sub_tlv_multipath_length, tvb, offset + 1, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_resv, tvb,
                                    offset + 3, 1, ENC_BIG_ENDIAN);

                ddsti2 = proto_tree_add_text(tlv_dd_map_tree, tvb, offset + 4, multipath_length,
                                             "Multipath Information (low/high address pairs)");
                tlv_ddstlv_map_tree = proto_item_add_subtree(ddsti2, ett_mpls_echo_tlv_ddstlv_map);

                proto_tree_add_item(tlv_ddstlv_map_tree, hf_mpls_echo_sub_tlv_mp_ip_low, tvb,
                                    offset + 4, 4, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_ddstlv_map_tree, hf_mpls_echo_sub_tlv_mp_ip_high, tvb,
                                    offset + 8, 4, ENC_BIG_ENDIAN);
                break;

            case TLV_MULTIPATH_BIT_MASKED_IP:
                if (multipath_length < 4) {
                    expert_add_info_format(pinfo, ddsti, PI_MALFORMED, PI_ERROR,
                               "Invalid Sub-tlv Length (claimed %u, should be >= 4)",
                               multipath_length);
                    break;
                }
                if (!tree)
                    break;
                proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_multipath_type, tvb,
                                    offset, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_dd_map_tree,
                                    hf_mpls_echo_sub_tlv_multipath_length, tvb, offset + 1, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_resv, tvb,
                                    offset + 3, 1, ENC_BIG_ENDIAN);

                ddsti2 = proto_tree_add_text(tlv_dd_map_tree, tvb, offset + 4, multipath_length,
                                             "Multipath Information (IP address prefix and bit mask)");
                tlv_ddstlv_map_tree = proto_item_add_subtree(ddsti2, ett_mpls_echo_tlv_ddstlv_map);

                proto_tree_add_item(tlv_ddstlv_map_tree, hf_mpls_echo_sub_tlv_multipath_ip, tvb,
                                    offset + 4, 4, ENC_BIG_ENDIAN);
                if (multipath_length > 4)
                    proto_tree_add_item(tlv_ddstlv_map_tree, hf_mpls_echo_sub_tlv_mp_mask,
                                        tvb, offset + 8, multipath_length - 4, ENC_NA);
                break;

            case TLV_MULTIPATH_BIT_MASKED_LABEL_SET:
                proto_tree_add_text(tlv_dd_map_tree, tvb, offset, 1,
                                    "Multipath Information (Label prefix and bit mask)");
                break;

            default:
                if (!tree)
                    break;
                proto_tree_add_text(tlv_dd_map_tree, tvb, offset, 1,
                                    "Multipath Type not identified (%u)", multipath_type);
                proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_multipath_type, tvb,
                                    offset, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_dd_map_tree,
                                    hf_mpls_echo_sub_tlv_multipath_length, tvb, offset + 1, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_multipath_value, tvb,
                                    offset + 3, rem, ENC_BIG_ENDIAN);
                break;
            }

            rem -= (multipath_length + 4);
            break;

        case TLV_FEC_LABEL_STACK:
            ddsti = proto_tree_add_text(tree, tvb, offset - 4, subtlv_length + 4, "Label stack sub-TLV");
            tlv_dd_map_tree = proto_item_add_subtree(ddsti, ett_mpls_echo_tlv_dd_map);

            while (rem >= 4) {
                if (tree) {
                    decode_mpls_label(tvb, offset, &label, &tc, &s_bit, &proto);

                    ddsti2 = proto_tree_add_text(tlv_dd_map_tree,
                                                 tvb, offset, 4, "Downstream Label Element %u", idx);
                    tlv_ddstlv_map_tree = proto_item_add_subtree(ddsti2, ett_mpls_echo_tlv_ddstlv_map);
                    proto_item_append_text(ddsti2, ", Label: %u , Protocol: %u", label, proto);
                    proto_tree_add_text(tlv_ddstlv_map_tree, tvb, offset, 3, "Label: %u", label);
                    proto_tree_add_text(tlv_ddstlv_map_tree, tvb, offset + 2, 1, "Traffic Class: %u", tc);
                    proto_tree_add_text(tlv_ddstlv_map_tree, tvb, offset + 2, 1, "S bit: %u", s_bit);
                    proto_tree_add_item(tlv_ddstlv_map_tree, hf_mpls_echo_tlv_ddstlv_map_mp_proto,
                                        tvb, offset + 3, 1, ENC_BIG_ENDIAN);
                }
                rem    -= 4;
                offset += 4;
                idx++;
            }
            break;

        case TLV_FEC_STACK_CHANGE: {
            addr_type       = tvb_get_guint8(tvb, offset + 1);
            fec_tlv_length  = tvb_get_guint8(tvb, offset + 2);
            ddsti           = proto_tree_add_text(tree, tvb, offset - 4, fec_tlv_length + 12, "Stack change sub-TLV");
            tlv_dd_map_tree = proto_item_add_subtree(ddsti, ett_mpls_echo_tlv_dd_map);

            proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_op_type,       tvb, offset,     1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_addr_type,     tvb, offset + 1, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_fec_tlv_value, tvb, offset + 2, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_res,           tvb, offset + 3, 1, ENC_BIG_ENDIAN);
            switch (addr_type) {
            case SUB_TLV_FEC_UNSPECIFIED:
                proto_tree_add_text(tlv_dd_map_tree, tvb, offset + 4, 0, "Unspecified (Address Length = 0)");
                rem    += 4;
                offset -= 4;
                break;
            case SUB_TLV_FEC_IPV4:
                proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_remote_peer_ip, tvb, offset + 4, 4, ENC_BIG_ENDIAN);
                break;
            case SUB_TLV_FEC_IPV6:
                proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_sub_tlv_remore_peer_ipv6, tvb, offset + 4, 16, ENC_NA);
                rem    -= 12;
                offset += 12;
                break;
            }

            offset -= 8;
            dissect_mpls_echo_tlv_fec(tvb, pinfo, offset, tlv_dd_map_tree, fec_tlv_length);

            rem -= (fec_tlv_length + 8);
            break;
        }

        default:
            ddsti = proto_tree_add_text(tree, tvb, offset, subtlv_length, "Error processing sub-TLV");
            tlv_dd_map_tree = proto_item_add_subtree(ddsti, ett_mpls_echo_tlv_dd_map);
            proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_tlv_dd_map_type,   tvb, offset - 4, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_tlv_dd_map_length, tvb, offset - 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_dd_map_tree, hf_mpls_echo_tlv_dd_map_value,  tvb, offset, subtlv_length, ENC_BIG_ENDIAN);
            rem -= subtlv_length;
            break;
        }
    }
}
