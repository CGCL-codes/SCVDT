static int
call_dissector_work(dissector_handle_t handle, tvbuff_t *tvb, packet_info *pinfo_arg,
		    proto_tree *tree, gboolean add_proto_name, void *data)
{
 	packet_info *pinfo = pinfo_arg;
	const char  *saved_proto;
	guint16      saved_can_desegment;
	int          len;
	guint        saved_layers_len = 0;

	if (handle->protocol != NULL &&
	    !proto_is_protocol_enabled(handle->protocol)) {
		/*
		 * The protocol isn't enabled.
		 */
		return 0;
	}

	saved_proto = pinfo->current_proto;
	saved_can_desegment = pinfo->can_desegment;
	saved_layers_len = wmem_list_count(pinfo->layers);

	/*
	 * can_desegment is set to 2 by anyone which offers the
	 * desegmentation api/service.
	 * Then everytime a subdissector is called it is decremented
	 * by one.
	 * Thus only the subdissector immediately on top of whoever
	 * offers this service can use it.
	 * We save the current value of "can_desegment" for the
	 * benefit of TCP proxying dissectors such as SOCKS, so they
	 * can restore it and allow the dissectors they call to use
	 * the desegmentation service.
	 */
	pinfo->saved_can_desegment = saved_can_desegment;
	pinfo->can_desegment = saved_can_desegment-(saved_can_desegment>0);
	if ((handle->protocol != NULL) && (!proto_is_pino(handle->protocol))) {
		pinfo->current_proto =
			proto_get_protocol_short_name(handle->protocol);

		/*
		 * Add the protocol name to the layers
		 * if not told not to. Asn2wrs generated dissectors may be added multiple times otherwise.
		 */
		if (add_proto_name) {
			pinfo->curr_layer_num++;
			wmem_list_append(pinfo->layers, GINT_TO_POINTER(proto_get_id(handle->protocol)));
		}
	}

	if (pinfo->flags.in_error_pkt) {
		len = call_dissector_work_error(handle, tvb, pinfo, tree, data);
	} else {
		/*
 		 * Just call the subdissector.
 		 */
		len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);
	}
	if (len == 0) {
		/*
 		 * That dissector didn't accept the packet, so
 		 * remove its protocol's name from the list
 		 * of protocols.
		 */
		while (wmem_list_count(pinfo->layers) > saved_layers_len) {
			wmem_list_remove_frame(pinfo->layers, wmem_list_tail(pinfo->layers));
		}
 	}
 	pinfo->current_proto = saved_proto;
 	pinfo->can_desegment = saved_can_desegment;
	return len;
}
