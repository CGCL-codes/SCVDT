gboolean
dissector_try_heuristic(heur_dissector_list_t sub_dissectors, tvbuff_t *tvb,
			packet_info *pinfo, proto_tree *tree, heur_dtbl_entry_t **heur_dtbl_entry, void *data)
{
	gboolean           status;
	const char        *saved_curr_proto;
	const char        *saved_heur_list_name;
	GSList            *entry;
	guint16            saved_can_desegment;
	guint              saved_layers_len = 0;
	heur_dtbl_entry_t *hdtbl_entry;
	int                proto_id;

	/* can_desegment is set to 2 by anyone which offers this api/service.
	   then everytime a subdissector is called it is decremented by one.
	   thus only the subdissector immediately ontop of whoever offers this
	   service can use it.
	   We save the current value of "can_desegment" for the
	   benefit of TCP proxying dissectors such as SOCKS, so they
	   can restore it and allow the dissectors they call to use
	   the desegmentation service.
	*/
	saved_can_desegment        = pinfo->can_desegment;
	pinfo->saved_can_desegment = saved_can_desegment;
	pinfo->can_desegment       = saved_can_desegment-(saved_can_desegment>0);

	status      = FALSE;
	saved_curr_proto = pinfo->current_proto;
	saved_heur_list_name = pinfo->heur_list_name;

	saved_layers_len = wmem_list_count(pinfo->layers);
	*heur_dtbl_entry = NULL;

	DISSECTOR_ASSERT(saved_layers_len < PINFO_LAYER_MAX_RECURSION_DEPTH);

	for (entry = sub_dissectors->dissectors; entry != NULL;
	    entry = g_slist_next(entry)) {
		/* XXX - why set this now and above? */
		pinfo->can_desegment = saved_can_desegment-(saved_can_desegment>0);
		hdtbl_entry = (heur_dtbl_entry_t *)entry->data;

		if (hdtbl_entry->protocol != NULL &&
			(!proto_is_protocol_enabled(hdtbl_entry->protocol)||(hdtbl_entry->enabled==FALSE))) {
			/*
			 * No - don't try this dissector.
			 */
			continue;
		}

		if (hdtbl_entry->protocol != NULL) {
			proto_id = proto_get_id(hdtbl_entry->protocol);
			/* do NOT change this behavior - wslua uses the protocol short name set here in order
			   to determine which Lua-based heurisitc dissector to call */
			pinfo->current_proto =
				proto_get_protocol_short_name(hdtbl_entry->protocol);

			/*
			 * Add the protocol name to the layers; we'll remove it
			 * if the dissector fails.
			 */
			wmem_list_append(pinfo->layers, GINT_TO_POINTER(proto_id));
		}

		pinfo->heur_list_name = hdtbl_entry->list_name;

		if ((hdtbl_entry->dissector)(tvb, pinfo, tree, data)) {
			*heur_dtbl_entry = hdtbl_entry;
			status = TRUE;
			break;
		} else {
			/*
			 * That dissector didn't accept the packet, so
			 * remove its protocol's name from the list
			 * of protocols.
			 */
			while (wmem_list_count(pinfo->layers) > saved_layers_len) {
				wmem_list_remove_frame(pinfo->layers, wmem_list_tail(pinfo->layers));
			}
		}
	}

	pinfo->current_proto = saved_curr_proto;
	pinfo->heur_list_name = saved_heur_list_name;
	pinfo->can_desegment = saved_can_desegment;
	return status;
}
