static int
dissect_rtcp_rtpfb( tvbuff_t *tvb, int offset, proto_tree *rtcp_tree, proto_item *top_item, packet_info *pinfo )
{
    unsigned int counter;
    unsigned int rtcp_rtpfb_fmt;
    int          packet_length;
    int          start_offset   = offset;

    /* Transport layer FB message */
    /* Feedback message type (FMT): 5 bits */
    proto_tree_add_item( rtcp_tree, hf_rtcp_rtpfb_fmt, tvb, offset, 1, ENC_BIG_ENDIAN );
    rtcp_rtpfb_fmt = (tvb_get_guint8(tvb, offset) & 0x1f);
    offset++;

    /* Packet type, 8 bits */
    proto_tree_add_item( rtcp_tree, hf_rtcp_pt, tvb, offset, 1, ENC_BIG_ENDIAN );
    offset++;

    /* Packet length in 32 bit words MINUS one, 16 bits */
    packet_length = (tvb_get_ntohs(tvb, offset) + 1) * 4;
    offset = dissect_rtcp_length_field(rtcp_tree, tvb, offset);

    /* SSRC of packet sender, 32 bits */
    proto_tree_add_item( rtcp_tree, hf_rtcp_ssrc_sender, tvb, offset, 4, ENC_BIG_ENDIAN );
    offset += 4;

    /* SSRC of media source, 32 bits */
    proto_tree_add_item( rtcp_tree, hf_rtcp_ssrc_media_source, tvb, offset, 4, ENC_BIG_ENDIAN );
    offset += 4;

    /* Check if we have a type specific dissector,
     * if we do, just return from here
     */
    if (packet_length > 12) {
      tvbuff_t *subtvb = tvb_new_subset_length(tvb, offset, packet_length - 12);

      if (dissector_try_uint (rtcp_rtpfb_dissector_table, rtcp_rtpfb_fmt,
              subtvb, pinfo, rtcp_tree))
        return start_offset + packet_length;
    }

    /* Transport-Layer Feedback Message Elements */
    counter = 0;
    while ((offset - start_offset) < packet_length) {
      counter++;
      if (rtcp_rtpfb_fmt == 1) {
        offset = dissect_rtcp_rtpfb_nack(tvb, offset, rtcp_tree, top_item);
      } else if (rtcp_rtpfb_fmt == 3) {
        offset = dissect_rtcp_rtpfb_tmmbr(tvb, offset, rtcp_tree, top_item, counter, 0);
      } else if (rtcp_rtpfb_fmt == 4) {
        offset = dissect_rtcp_rtpfb_tmmbr(tvb, offset, rtcp_tree, top_item, counter, 1);
      } else if (rtcp_rtpfb_fmt == 15) {
        /* Handle transport-cc (RTP Extensions for Transport-wide Congestion Control) - https://tools.ietf.org/html/draft-holmer-rmcat-transport-wide-cc-extensions-01 */
        offset = dissect_rtcp_rtpfb_transport_cc( tvb, offset, pinfo, rtcp_tree, packet_length);
      } else {
        /* Unknown FMT */
        proto_tree_add_item(rtcp_tree, hf_rtcp_fci, tvb, offset, start_offset + packet_length - offset, ENC_NA );
        offset = start_offset + packet_length;
      }
    }

    return offset;
}
