static int
dissect_rtcp_rtpfb_transport_cc( tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *rtcp_tree, int pkt_len)
{
    proto_tree *fci_tree, *pkt_chunk_tree, *recv_delta_tree;
    proto_item *item       = NULL;
    guint8  *delta_array;
    guint16 *pkt_seq_array;
    guint32 i, pkt_base_seq, pkt_seq_num, pkt_count, delta_index = 0;
    gint fci_length        = pkt_len - RTCP_HEADER_LENGTH;
    int padding_length     = offset;

    fci_tree = proto_tree_add_subtree_format( rtcp_tree, tvb, offset, fci_length, ett_ssrc, NULL, "Transport-cc" );

    /* base sequence number */
    proto_tree_add_item_ret_uint( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_base_seq, tvb, offset, 2, ENC_BIG_ENDIAN, &pkt_base_seq );
    offset += 2;
    pkt_seq_num = pkt_base_seq;

    /* packet status count */
    proto_tree_add_item_ret_uint( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_pkt_stats_cnt, tvb, offset, 2, ENC_BIG_ENDIAN, &pkt_count );
    offset += 2;

    delta_array   = wmem_alloc0_array( wmem_packet_scope(), gint8, pkt_count );
    pkt_seq_array = wmem_alloc0_array( wmem_packet_scope(), gint16, pkt_count );

    /* reference time */
    proto_tree_add_item( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_ref_time, tvb, offset, 3, ENC_BIG_ENDIAN );
    offset += 3;

    /* feedback packet count */
    proto_tree_add_item( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_fb_pkt_cnt, tvb, offset, 1, ENC_BIG_ENDIAN );
    offset += 1;

    /* packet chunk */
    pkt_chunk_tree = proto_tree_add_subtree_format( fci_tree, tvb, offset, 0, ett_ssrc, NULL, "Packet Chunks" );

    for (i = 0; i < pkt_count; )
    {
        guint32 chunk = 0;
        item = proto_tree_add_item_ret_uint( pkt_chunk_tree, hf_rtcp_rtpfb_transport_cc_fci_pkt_chunk, tvb, offset, 2, ENC_BIG_ENDIAN, &chunk );

        /* Packet Status Symbols */
        /**
         * 00 Packet not received
         * 01 Packet received, small delta
         * 10 Packet received, large or negative delta
         * 11 [Reserved]
         */
        if ( !(chunk & 0x8000) )
        {
            /* Run length chunk, first bit is zero */
            guint length = chunk & 0x1FFF;

            if ( length <= 0 || pkt_count - delta_index < length )
            {
                /* Malformed packet (zero or too many packets), stop parsing. */
                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
                offset += 2;
                return offset;
            }

            if ( !(chunk & 0x6000) )
            {
                proto_item_append_text( item, " [Run Length Chunk] Packet not received. Length : %d", length);
                pkt_seq_num += length;
            }
            else if ( chunk & 0x2000 )
            {
                proto_item_append_text( item, " [Run Length Chunk] Small Delta. Length : %d", length);
                for (guint j = 0; j < length; j++)
                {
                    /*1 means 1 byte delta, 2 means 2 bytes delta*/
                    delta_array[delta_index+j] = 1;
                    pkt_seq_array[delta_index+j] = pkt_seq_num++;
                }
                delta_index += length;
            }
            else if ( chunk & 0x4000 )
            {
                proto_item_append_text( item, " [Run Length Chunk] Large or Negative Delta. Length : %d", length);
                for (guint j = 0; j < length; j++)
                {
                    delta_array[delta_index+j] = 2;
                    pkt_seq_array[delta_index+j] = pkt_seq_num++;
                }
                delta_index += length;
            }
            else
            {
                proto_item_append_text( item, " [Run Length Chunk] [Reserved]. Length : %d", length);
                pkt_seq_num += length;
            }

            i += length;

        }
        else
        {
            wmem_strbuf_t* status = wmem_strbuf_new(wmem_packet_scope(), "|");

            /* Status Vector Chunk, first bit is one */
            if ( !(chunk & 0x4000) )
            {
                /* 1 bit symbols */

                int data = chunk & 0x3FFF;
                int chunk_count = 14;

                for (int k = 0; k < chunk_count; k++)
                {
                    if ( (data & (0x2000>>k)) == 0 )
                    {
                        if ( i + k < pkt_count )
                        {
                            wmem_strbuf_append(status, " N |");
                            pkt_seq_num++;
                        }
                        else
                        {
                            /* padding */
                            wmem_strbuf_append(status, " _ |");
                        }
                    }
                    else
                    {
                        if (delta_index >= pkt_count) {
                            /* Malformed packet (too many status packets). */
                            proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
                            offset += 2;
                            return offset;
                        }
                        wmem_strbuf_append(status, " R |");
                        delta_array[delta_index] = 1;
                        pkt_seq_array[delta_index] = pkt_seq_num++;
                        delta_index++;
                    }
                }
                proto_item_append_text( item, " [1 bit Status Vector Chunk]: %s", wmem_strbuf_get_str(status));
                i += chunk_count;
            }
            else
            {
                /* 2 bits symbols */
                int chunk_count = 7;
                int data = chunk & 0x3FFF;

                for (int k = 0; k < chunk_count; k++)
                {
                    switch ( (data & (0x3000 >> (2*k))) >> ( 2 * (6-k) ) )
                    {
                        case 0: /*00 packet not received*/
                            if ( i + k < pkt_count )
                            {
                                wmem_strbuf_append(status, " NR |");
                                pkt_seq_num++;
                            }
                            else
                            {
                                /*padding*/
                                wmem_strbuf_append(status, " __ |");
                            }
                            break;

                        case 1: /*01 Packet received, small delta*/
                            if (delta_index >= pkt_count) {
                                /* Malformed packet (too many status packets). */
                                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
                                offset += 2;
                                return offset;
                            }
                            wmem_strbuf_append(status, " SD |");
                            delta_array[delta_index] = 1;
                            pkt_seq_array[delta_index] = pkt_seq_num++;
                            delta_index++;
                            break;

                        case 2: /*10 Packet received, large or negative delta*/
                            if (delta_index >= pkt_count) {
                                /* Malformed packet (too many status packets). */
                                proto_tree_add_expert(pkt_chunk_tree, pinfo, &ei_rtcp_rtpfb_transportcc_bad, tvb, offset, 2);
                                offset += 2;
                                return offset;
                            }
                            wmem_strbuf_append(status, " LD |");
                            delta_array[delta_index] = 2;
                            pkt_seq_array[delta_index] = pkt_seq_num++;
                            delta_index++;
                            break;

                        case 3: /*11 packet received, w/o(wrong? overflow?) timestamp*/
                        default:
                            /*TODO: process overflow status which is not details on draft.*/
                            wmem_strbuf_append(status, " WO |");
                            pkt_seq_num++;
                            break;

                    }
                }

                proto_item_append_text( item, " [2 bits Status Vector Chunk]: %s", wmem_strbuf_get_str(status));
                i += chunk_count;
            }

        }

        offset += 2;
    }

    /* recv delta */
    recv_delta_tree = proto_tree_add_subtree_format( fci_tree, tvb, offset, 0, ett_ssrc, NULL, "Recv Delta" );
    for (i = 0; i < pkt_count; i++ )
    {
        if ( delta_array[i] == 1 )
        {
            /*1 byte delta*/
            guint32 delta;
            item = proto_tree_add_item_ret_uint( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_1_byte, tvb, offset, 1, ENC_BIG_ENDIAN, &delta );

            proto_item_append_text( item, " Small Delta: [seq: %d] %lf ms", pkt_seq_array[i], delta*250.0/1000);

            offset += 1;
        }
        else if ( delta_array[i] == 2 )
        {
            /*2 bytes delta*/
            gint16 delta;
            item = proto_tree_add_item( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_2_bytes, tvb, offset, 2, ENC_BIG_ENDIAN);
            delta = tvb_get_ntohs(tvb, offset);

            if ( delta < 0 )
            {
                proto_item_append_text( item, " Negative Delta: [seq: %d] %lf ms", pkt_seq_array[i], delta*250.0/1000 );
            }
            else
            {
                proto_item_append_text( item, " Large Delta: [seq: %d] %lf ms", pkt_seq_array[i], delta*250.0/1000 );
            }

            offset += 2;
        }
        else
        {
            /*End with 0*/
            break;
        }
    }

    /* padding */
    padding_length = fci_length - (offset - padding_length);
    if ( padding_length > 0 )
    {
        proto_tree_add_item( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_padding, tvb, offset, padding_length, ENC_BIG_ENDIAN );
        offset += padding_length;
    }

    /* delta_array / pkt_seq_array will be freed out of wmem_packet_scope*/
    delta_array = NULL;
    pkt_seq_array = NULL;

    return offset;
}
