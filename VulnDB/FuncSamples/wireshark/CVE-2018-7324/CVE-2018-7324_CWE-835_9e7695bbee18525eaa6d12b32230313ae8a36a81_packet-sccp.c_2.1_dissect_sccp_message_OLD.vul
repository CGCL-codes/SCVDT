static int
dissect_sccp_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sccp_tree,
                     proto_tree *tree)
{
  guint16   variable_pointer1 = 0, variable_pointer2 = 0, variable_pointer3 = 0;
  guint16   optional_pointer  = 0, orig_opt_ptr = 0;
  guint16   offset = 0;
  gboolean  save_fragmented;
  tvbuff_t *new_tvb = NULL;
  fragment_head *frag_msg = NULL;
  guint32   source_local_ref = 0;
  guint8    more;
  guint     msg_offset = tvb_offset_from_real_beginning(tvb);
  sccp_decode_context_t sccp_info = {0, INVALID_LR, INVALID_LR, NULL, NULL};

/* Macro for getting pointer to mandatory variable parameters */
#define VARIABLE_POINTER(var, hf_var, ptr_size) \
  do {                                          \
    if (ptr_size == POINTER_LENGTH)             \
      var = tvb_get_guint8(tvb, offset);        \
    else                                        \
      var = tvb_get_letohs(tvb, offset);        \
    proto_tree_add_uint(sccp_tree, hf_var, tvb, \
                        offset, ptr_size, var); \
    var += offset;                              \
    if (ptr_size == POINTER_LENGTH_LONG)        \
      var += 1;                                 \
    offset += ptr_size;                         \
  } while (0)

/* Macro for getting pointer to optional parameters */
#define OPTIONAL_POINTER(ptr_size)                                      \
  do {                                                                  \
    if (ptr_size == POINTER_LENGTH)                                     \
      orig_opt_ptr = optional_pointer = tvb_get_guint8(tvb, offset);    \
    else                                                                \
      orig_opt_ptr = optional_pointer = tvb_get_letohs(tvb, offset);    \
    proto_tree_add_uint(sccp_tree, hf_sccp_optional_pointer, tvb,       \
                        offset, ptr_size, optional_pointer);            \
    optional_pointer += offset;                                         \
    if (ptr_size == POINTER_LENGTH_LONG)                                \
      optional_pointer += 1;                                            \
    offset += ptr_size;                                                 \
  } while (0)


  /* Extract the message type;  all other processing is based on this */
  sccp_info.message_type   = tvb_get_guint8(tvb, SCCP_MSG_TYPE_OFFSET);
  offset = SCCP_MSG_TYPE_LENGTH;

  /*  Do not change col_add_fstr() to col_append_fstr() here: we _want_
   *  this call to overwrite whatever's currently in the INFO column (e.g.,
   *  "DATA" from the SCTP dissector).
   *
   *  If there's something there that should not be overwritten, whoever
   *  put that info there should call col_set_fence() to protect it.
   */
  col_add_fstr(pinfo->cinfo, COL_INFO, "%s ",
               val_to_str(sccp_info.message_type, sccp_message_type_acro_values, "Unknown: %d"));

  if (sccp_tree) {
    /* add the message type to the protocol tree */
    proto_tree_add_uint(sccp_tree, hf_sccp_message_type, tvb,
                        SCCP_MSG_TYPE_OFFSET, SCCP_MSG_TYPE_LENGTH, sccp_info.message_type);

  };

  no_assoc.calling_dpc   = 0;
  no_assoc.called_dpc    = 0;
  no_assoc.calling_ssn   = INVALID_SSN;
  no_assoc.called_ssn    = INVALID_SSN;
  no_assoc.has_fw_key    = FALSE;
  no_assoc.has_bw_key    = FALSE;
  no_assoc.payload       = SCCP_PLOAD_NONE;
  no_assoc.called_party  = NULL;
  no_assoc.calling_party = NULL;
  no_assoc.extra_info    = NULL;

  switch (sccp_info.message_type) {
  case SCCP_MSG_TYPE_CR:
    /*  TTC and NTT (Japan) say that the connection-oriented messages are
     *  deleted (not standardized), but they appear to be used anyway, so
     *  we'll dissect it...
     */
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_SOURCE_LOCAL_REFERENCE,
                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_CLASS, offset,
                                     PROTOCOL_CLASS_LENGTH, &sccp_info);
    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);
    OPTIONAL_POINTER(POINTER_LENGTH);

    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLED_PARTY_ADDRESS,
                                    variable_pointer1, &sccp_info);
    break;

  case SCCP_MSG_TYPE_CC:
    /*  TODO: connection has been established;  theoretically we could keep
     *  keep track of the SLR/DLR with the called/calling from the CR and
     *  track the connection (e.g., on subsequent messages regarding this
     *  SLR we could set the global vars "call*_ssn" so data could get
     *  sub-dissected).
     */
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_SOURCE_LOCAL_REFERENCE,
                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_CLASS, offset,
                                     PROTOCOL_CLASS_LENGTH, &sccp_info);
    OPTIONAL_POINTER(POINTER_LENGTH);
    break;

  case SCCP_MSG_TYPE_CREF:
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_REFUSAL_CAUSE, offset,
                                     REFUSAL_CAUSE_LENGTH, &sccp_info);
    OPTIONAL_POINTER(POINTER_LENGTH);
    break;

  case SCCP_MSG_TYPE_RLSD:
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_SOURCE_LOCAL_REFERENCE,
                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_RELEASE_CAUSE, offset,
                                     RELEASE_CAUSE_LENGTH, &sccp_info);

    OPTIONAL_POINTER(POINTER_LENGTH);
    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);
    break;

  case SCCP_MSG_TYPE_RLC:
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_SOURCE_LOCAL_REFERENCE,
                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);
    break;

  case SCCP_MSG_TYPE_DT1:
    source_local_ref = tvb_get_letoh24(tvb, offset);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    more = tvb_get_guint8(tvb, offset) & SEGMENTING_REASSEMBLING_MASK;

    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_SEGMENTING_REASSEMBLING,
                                     offset, SEGMENTING_REASSEMBLING_LENGTH, &sccp_info);
    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);

    /* Reassemble */
    if (!sccp_reassemble) {
      proto_tree_add_item(sccp_tree, hf_sccp_segmented_data, tvb, variable_pointer1,
                          tvb_get_guint8(tvb, variable_pointer1)+1, ENC_NA);
      dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                      PARAMETER_DATA, variable_pointer1, &sccp_info);

    } else {
      save_fragmented = pinfo->fragmented;
      pinfo->fragmented = TRUE;
      frag_msg = fragment_add_seq_next(&sccp_xudt_msg_reassembly_table,
                                       tvb, variable_pointer1 + 1,
                                       pinfo,
                                       source_local_ref,                       /* ID for fragments belonging together */
                                       NULL,
                                       tvb_get_guint8(tvb, variable_pointer1), /* fragment length - to the end */
                                       more);                                  /* More fragments? */

      new_tvb = process_reassembled_data(tvb, variable_pointer1 + 1, pinfo,
                                         "Reassembled SCCP", frag_msg,
                                         &sccp_xudt_msg_frag_items, NULL,
                                         tree);

      if (frag_msg && frag_msg->next) { /* Reassembled */
        col_append_str(pinfo->cinfo, COL_INFO, "(Message reassembled) ");
      } else if (more) { /* Not last packet of reassembled message */
        col_append_str(pinfo->cinfo, COL_INFO, "(Message fragment) ");
      }

      pinfo->fragmented = save_fragmented;

      if (new_tvb)
        dissect_sccp_data_param(new_tvb, pinfo, tree, sccp_info.assoc);
    }

    /* End reassemble */
    break;

  case SCCP_MSG_TYPE_DT2:
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_SEQUENCING_SEGMENTING, offset,
                                     SEQUENCING_SEGMENTING_LENGTH, &sccp_info);
    break;

  case SCCP_MSG_TYPE_AK:
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_RECEIVE_SEQUENCE_NUMBER,
                                     offset, RECEIVE_SEQUENCE_NUMBER_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_CREDIT, offset, CREDIT_LENGTH, &sccp_info);
    break;

  case SCCP_MSG_TYPE_UDT:
    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);

    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_CLASS, offset,
                                     PROTOCOL_CLASS_LENGTH, &sccp_info);
    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);
    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);
    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLED_PARTY_ADDRESS,
                                    variable_pointer1, &sccp_info);
    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLING_PARTY_ADDRESS,
                                    variable_pointer2, &sccp_info);

    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree, PARAMETER_DATA,
                                    variable_pointer3, &sccp_info);
    break;

  case SCCP_MSG_TYPE_UDTS:
  {
    gboolean save_in_error_pkt = pinfo->flags.in_error_pkt;
    pinfo->flags.in_error_pkt = TRUE;

    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);

    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_RETURN_CAUSE, offset,
                                     RETURN_CAUSE_LENGTH, &sccp_info);

    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);
    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);
    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLED_PARTY_ADDRESS,
                                    variable_pointer1, &sccp_info);

    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLING_PARTY_ADDRESS,
                                    variable_pointer2, &sccp_info);

    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree, PARAMETER_DATA,
                                    variable_pointer3, &sccp_info);
    pinfo->flags.in_error_pkt = save_in_error_pkt;
    break;
  }

  case SCCP_MSG_TYPE_ED:
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);

    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree, PARAMETER_DATA,
                                    variable_pointer1, &sccp_info);
    break;

  case SCCP_MSG_TYPE_EA:
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);
    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);
    break;

  case SCCP_MSG_TYPE_RSR:
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_SOURCE_LOCAL_REFERENCE,
                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_RESET_CAUSE, offset,
                                     RESET_CAUSE_LENGTH, &sccp_info);
    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);
    break;

  case SCCP_MSG_TYPE_RSC:
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_SOURCE_LOCAL_REFERENCE,
                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);
    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);
    break;

  case SCCP_MSG_TYPE_ERR:
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_ERROR_CAUSE, offset,
                                     ERROR_CAUSE_LENGTH, &sccp_info);
    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);
    break;

  case SCCP_MSG_TYPE_IT:
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,
                                     offset,
                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_SOURCE_LOCAL_REFERENCE,
                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);
    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_CLASS, offset,
                                     PROTOCOL_CLASS_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_SEQUENCING_SEGMENTING,
                                     offset, SEQUENCING_SEGMENTING_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_CREDIT, offset, CREDIT_LENGTH, &sccp_info);
    break;

  case SCCP_MSG_TYPE_XUDT:
    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_CLASS, offset,
                                     PROTOCOL_CLASS_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_HOP_COUNTER, offset,
                                     HOP_COUNTER_LENGTH, &sccp_info);

    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);
    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);
    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);
    OPTIONAL_POINTER(POINTER_LENGTH);

      /*  Optional parameters are Segmentation and Importance
       *  NOTE 2 - Segmentation Should not be present in case of a single XUDT
       *  message.
       */

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLED_PARTY_ADDRESS,
                                    variable_pointer1, &sccp_info);
    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLING_PARTY_ADDRESS,
                                    variable_pointer2, &sccp_info);

    if (tvb_get_guint8(tvb, optional_pointer) == PARAMETER_SEGMENTATION) {
      if (!sccp_reassemble) {
        proto_tree_add_item(sccp_tree, hf_sccp_segmented_data, tvb, variable_pointer3, tvb_get_guint8(tvb, variable_pointer3)+1, ENC_NA);
      } else {
        guint8 octet;
        gboolean more_frag = TRUE;

        /* Get the first octet of parameter Segmentation, Ch 3.17 in Q.713
         * Bit 8 of octet 1 is used for First segment indication
         * Bit 7 of octet 1 is used to keep in the message in sequence
         *         delivery option required by the SCCP user
         * Bits 6 and 5 in octet 1 are spare bits.
         * Bits 4-1 of octet 1 are used to indicate the number of
         *            remaining segments.
         * The values 0000 to 1111 are possible; the value 0000 indicates
         * the last segment.
         */
        octet = tvb_get_guint8(tvb, optional_pointer+2);
        source_local_ref = tvb_get_letoh24(tvb, optional_pointer+3);

        if ((octet & 0x0f) == 0)
          more_frag = FALSE;

        save_fragmented = pinfo->fragmented;
        pinfo->fragmented = TRUE;
        frag_msg = fragment_add_seq_next(&sccp_xudt_msg_reassembly_table,
                                         tvb, variable_pointer3 + 1,
                                         pinfo,
                                         source_local_ref,                            /* ID for fragments belonging together */
                                         NULL,
                                         tvb_get_guint8(tvb, variable_pointer3),       /* fragment length - to the end */
                                         more_frag);                          /* More fragments? */

        if ((octet & 0x80) == 0x80) /*First segment, set number of segments*/
          fragment_set_tot_len(&sccp_xudt_msg_reassembly_table,
                               pinfo, source_local_ref, NULL, (octet & 0xf));

        new_tvb = process_reassembled_data(tvb, variable_pointer3 + 1,
                                           pinfo, "Reassembled SCCP",
                                           frag_msg,
                                           &sccp_xudt_msg_frag_items,
                                           NULL, tree);

        if (frag_msg) { /* Reassembled */
          col_append_str(pinfo->cinfo, COL_INFO,"(Message reassembled) ");
        } else { /* Not last packet of reassembled message */
          col_append_str(pinfo->cinfo, COL_INFO,"(Message fragment) ");
        }

        pinfo->fragmented = save_fragmented;

        if (new_tvb)
          dissect_sccp_data_param(new_tvb, pinfo, tree, sccp_info.assoc);
      }
    } else {
      dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                      PARAMETER_DATA, variable_pointer3, &sccp_info);
    }
    break;

  case SCCP_MSG_TYPE_XUDTS:
  {
    gboolean save_in_error_pkt = pinfo->flags.in_error_pkt;
    pinfo->flags.in_error_pkt = TRUE;

    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_RETURN_CAUSE, offset,
                                     RETURN_CAUSE_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_HOP_COUNTER, offset,
                                     HOP_COUNTER_LENGTH, &sccp_info);

    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);
    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);
    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);
    OPTIONAL_POINTER(POINTER_LENGTH);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLED_PARTY_ADDRESS,
                                    variable_pointer1, &sccp_info);
    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLING_PARTY_ADDRESS,
                                    variable_pointer2, &sccp_info);

    if (tvb_get_guint8(tvb, optional_pointer) == PARAMETER_SEGMENTATION) {
      if (!sccp_reassemble) {
        proto_tree_add_item(sccp_tree, hf_sccp_segmented_data, tvb, variable_pointer3, tvb_get_guint8(tvb, variable_pointer3)+1, ENC_NA);

      } else {
        guint8 octet;
        gboolean more_frag = TRUE;


        /* Get the first octet of parameter Segmentation, Ch 3.17 in Q.713
         * Bit 8 of octet 1 is used for First segment indication
         * Bit 7 of octet 1 is used to keep in the message in sequence
         *         delivery option required by the SCCP user
         * Bits 6 and 5 in octet 1 are spare bits.
         * Bits 4-1 of octet 1 are used to indicate the number of
         *            remaining segments.
         * The values 0000 to 1111 are possible; the value 0000 indicates
         * the last segment.
         */
        octet = tvb_get_guint8(tvb, optional_pointer+2);
        source_local_ref = tvb_get_letoh24(tvb, optional_pointer+3);

        if ((octet & 0x0f) == 0)
          more_frag = FALSE;

        save_fragmented = pinfo->fragmented;
        pinfo->fragmented = TRUE;
        frag_msg = fragment_add_seq_next(&sccp_xudt_msg_reassembly_table,
                                         tvb, variable_pointer3 + 1,
                                         pinfo,
                                         source_local_ref,                            /* ID for fragments belonging together */
                                         NULL,
                                         tvb_get_guint8(tvb, variable_pointer3),      /* fragment length - to the end */
                                         more_frag);                                  /* More fragments? */

        if ((octet & 0x80) == 0x80) /*First segment, set number of segments*/
          fragment_set_tot_len(&sccp_xudt_msg_reassembly_table,
                               pinfo, source_local_ref, NULL, (octet & 0xf));

        new_tvb = process_reassembled_data(tvb, variable_pointer3 + 1,
                                           pinfo, "Reassembled SCCP",
                                           frag_msg,
                                           &sccp_xudt_msg_frag_items,
                                           NULL, tree);

        if (frag_msg) { /* Reassembled */
          col_append_str(pinfo->cinfo, COL_INFO, "(Message reassembled) ");
        } else { /* Not last packet of reassembled message */
          col_append_str(pinfo->cinfo, COL_INFO, "(Message fragment) ");
        }

        pinfo->fragmented = save_fragmented;

        if (new_tvb)
          dissect_sccp_data_param(new_tvb, pinfo, tree, sccp_info.assoc);
      }
    } else {
      dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                      PARAMETER_DATA, variable_pointer3, &sccp_info);
    }
    pinfo->flags.in_error_pkt = save_in_error_pkt;
    break;
  }
  case SCCP_MSG_TYPE_LUDT:
    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);

    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_CLASS, offset,
                                     PROTOCOL_CLASS_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_HOP_COUNTER, offset,
                                     HOP_COUNTER_LENGTH, &sccp_info);

    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH_LONG);
    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH_LONG);
    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH_LONG);
    OPTIONAL_POINTER(POINTER_LENGTH_LONG);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLED_PARTY_ADDRESS,
                                    variable_pointer1, &sccp_info);
    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLING_PARTY_ADDRESS,
                                    variable_pointer2, &sccp_info);
    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_LONG_DATA, variable_pointer3, &sccp_info);
    break;

  case SCCP_MSG_TYPE_LUDTS:
    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_RETURN_CAUSE, offset,
                                     RETURN_CAUSE_LENGTH, &sccp_info);
    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,
                                     PARAMETER_HOP_COUNTER, offset,
                                     HOP_COUNTER_LENGTH, &sccp_info);

    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH_LONG);
    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH_LONG);
    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH_LONG);
    OPTIONAL_POINTER(POINTER_LENGTH_LONG);

    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);

    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLED_PARTY_ADDRESS,
                                    variable_pointer1, &sccp_info);
    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_CALLING_PARTY_ADDRESS,
                                    variable_pointer2, &sccp_info);
    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,
                                    PARAMETER_LONG_DATA, variable_pointer3, &sccp_info);
    break;

  default:
    dissect_sccp_unknown_message(tvb, sccp_tree);
  }

  if (orig_opt_ptr)
    dissect_sccp_optional_parameters(tvb, pinfo, sccp_tree, tree,
                                     optional_pointer, &sccp_info);

  if (trace_sccp && sccp_info.assoc && (sccp_info.assoc != &no_assoc)) {
    proto_item *pi = proto_tree_add_uint(sccp_tree, hf_sccp_assoc_id, tvb, 0, 0, sccp_info.assoc->id);
    proto_tree *pt = proto_item_add_subtree(pi, ett_sccp_assoc);
    PROTO_ITEM_SET_GENERATED(pi);
    if (sccp_info.assoc->msgs) {
      sccp_msg_info_t *m;
      for(m = sccp_info.assoc->msgs; m ; m = m->data.co.next) {
        pi = proto_tree_add_uint(pt, hf_sccp_assoc_msg, tvb, 0, 0, m->framenum);

        if (sccp_info.assoc->payload != SCCP_PLOAD_NONE)
          proto_item_append_text(pi," %s", val_to_str(sccp_info.assoc->payload, assoc_protos, "Unknown: %d"));

        if (m->data.co.label)
          proto_item_append_text(pi," %s", m->data.co.label);

        if ((m->framenum == pinfo->num) && (m->offset == msg_offset) ) {
          tap_queue_packet(sccp_tap, pinfo, m);
          proto_item_append_text(pi," (current)");
        }
        PROTO_ITEM_SET_GENERATED(pi);
      }
    }
  }

  return offset;
}
