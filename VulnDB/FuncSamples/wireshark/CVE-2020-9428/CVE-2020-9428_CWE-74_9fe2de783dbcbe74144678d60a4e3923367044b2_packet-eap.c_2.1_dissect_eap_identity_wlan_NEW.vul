static gboolean
dissect_eap_identity_wlan(tvbuff_t *tvb, packet_info* pinfo, proto_tree* tree, int offset, gint size)
{
  guint       mnc = 0;
  guint       mcc = 0;
  guint       mcc_mnc = 0;
  proto_tree* eap_identity_tree = NULL;
  guint8      eap_identity_prefix = 0;
  guint8*     identity = NULL;
  gchar**     tokens = NULL;
  guint       ntokens = 0;
  gboolean    ret = TRUE;
  int         hf_eap_identity_wlan_mcc_mnc;
  proto_item* item;

  identity = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, size, ENC_ASCII);

  tokens = g_strsplit_set(identity, "@.", -1);

  while(tokens[ntokens])
    ntokens++;

  /* The WLAN identity must have the form of
     <imsi>@wlan.mnc<mnc>.mcc<mcc>.3gppnetwork.org
     If not, we don't have a wlan identity
  */
  if (ntokens != 6 || g_ascii_strncasecmp(tokens[1], "wlan", 4) ||
      g_ascii_strncasecmp(tokens[4], "3gppnetwork", 11) ||
      g_ascii_strncasecmp(tokens[5], "org", 3)) {
    ret = FALSE;
    goto end;
  }

  /* It is very likely that we have a WLAN identity (EAP-AKA/EAP-SIM) */
  /* Go on with the dissection */
  eap_identity_tree = proto_item_add_subtree(tree, ett_identity);
  eap_identity_prefix = tokens[0][0];
  item = proto_tree_add_uint(eap_identity_tree, hf_eap_identity_wlan_prefix,
    tvb, offset, 1, eap_identity_prefix);

  switch(eap_identity_prefix) {
    case '0':
    case '1':
    case '6':
      dissect_e212_utf8_imsi(tvb, pinfo, eap_identity_tree, offset + 1, (guint)strlen(tokens[0]) - 1);
      break;
    case '2':
    case '3':
    case '7':
      proto_tree_add_item(eap_identity_tree, hf_eap_identity_pseudo, tvb, offset + 1, (guint)strlen(tokens[0]) - 1, ENC_ASCII|ENC_NA);
      break;
    case '4':
    case '5':
    case '8':
      proto_tree_add_item(eap_identity_tree, hf_eap_identity_reauth, tvb, offset + 1, (guint)strlen(tokens[0]) - 1, ENC_ASCII|ENC_NA);
      break;
    default:
      expert_add_info(pinfo, item, &ei_eap_identity_invalid);
  }

  /* guess if we have a 3 bytes mnc by comparing the first bytes with the imsi */
  /* XXX Should we force matches on "mnc" and "mmc"? */
  if (!sscanf(tokens[2], "%*3c%u", &mnc) || !sscanf(tokens[3], "%*3c%u", &mcc)) {
    ret = FALSE;
    goto end;
  }

  if (!g_ascii_strncasecmp(tokens[0], tokens[2] + 3, 3)) {
    mcc_mnc = 1000 * mcc + mnc;
    hf_eap_identity_wlan_mcc_mnc = hf_eap_identity_wlan_mcc_mnc_3digits;
  } else {
    mcc_mnc = 100 * mcc + mnc;
    hf_eap_identity_wlan_mcc_mnc = hf_eap_identity_wlan_mcc_mnc_2digits;
  }

  proto_tree_add_uint(eap_identity_tree, hf_eap_identity_wlan_mcc_mnc,
    tvb, offset + (guint)strlen(tokens[0]) + (guint)strlen("@wlan.") +
    (guint)strlen("mnc"), (guint)strlen(tokens[2]) - (guint)strlen("mnc"),
    mcc_mnc);

  proto_tree_add_uint(eap_identity_tree, hf_eap_identity_wlan_mcc,
    tvb, offset + (guint)(strlen(tokens[0]) + strlen("@wlan.") +
    strlen(tokens[2]) + 1 + strlen("mcc")),
    (guint)(strlen(tokens[3]) - strlen("mcc")), mcc);
end:
  g_strfreev(tokens);
  return ret;
}
