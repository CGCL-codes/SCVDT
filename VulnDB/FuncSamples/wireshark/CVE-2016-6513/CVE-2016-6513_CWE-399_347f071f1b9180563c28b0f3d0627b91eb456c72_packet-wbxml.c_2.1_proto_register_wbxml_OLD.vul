void
proto_register_wbxml(void)
{
	module_t *wbxml_module;	/* WBXML Preferences */

	/* Setup list of header fields. */
	static hf_register_info hf[] = {
		{ &hf_wbxml_version,
		  { "Version",
		    "wbxml.version",
		    FT_UINT8, BASE_HEX|BASE_EXT_STRING,
		    &vals_wbxml_versions_ext, 0x00,
		    "WBXML Version", HFILL }
		},
		{ &hf_wbxml_public_id_known,
		  { "Public Identifier (known)",
		    "wbxml.public_id.known",
		    FT_UINT32, BASE_HEX|BASE_EXT_STRING,
		    &vals_wbxml_public_ids_ext, 0x00,
		    "WBXML Known Public Identifier (integer)", HFILL }
		},
		{ &hf_wbxml_public_id_literal,
		  { "Public Identifier (literal)",
		    "wbxml.public_id.literal",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    "WBXML Literal Public Identifier (text string)", HFILL }
		},
		{ &hf_wbxml_charset,
		  { "Character Set",
		    "wbxml.charset",
		    FT_UINT32, BASE_DEC|BASE_EXT_STRING,
		    &mibenum_vals_character_sets_ext, 0x00,
		    "WBXML Character Set", HFILL }
		},
		{ &hf_wbxml_string_table_item_offset,
		  { "Offset",
		    "wbxml.string_table_item_offset",
		    FT_UINT32, BASE_DEC,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_string_table_item_string,
		  { "String",
		    "wbxml.string_table_item_string",
		    FT_STRINGZ, STR_UNICODE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_switch_page,
		  { "SWITCH_PAGE",
		    "wbxml.switch_page",
		    FT_UINT32, BASE_DEC,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_known_tag,
		  { "Known Tag",
		    "wbxml.known_tag",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_end_known_tag,
		  { "END Known Tag",
		    "wbxml.end_known_tag",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_end_known_tag_uint,
		  { "END Known Tag",
		    "wbxml.end_known_tag.uint",
		    FT_UINT32, BASE_DEC,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_str_i,
		  { "STR_I",
		    "wbxml.str_i",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_str_t,
		  { "STR_T",
		    "wbxml.str_t",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_opaque_data,
		  { "Opaque Data",
		    "wbxml.opaque_data",
		    FT_BYTES, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_entity,
		  { "ENTITY",
		    "wbxml.entity",
		    FT_UINT32, BASE_DEC,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_literal,
		  { "LITERAL",
		    "wbxml.literal",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_ext_i,
		  { "EXT_I",
		    "wbxml.ext_i",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_ext_t,
		  { "EXT_T",
		    "wbxml.ext_t",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_extension_token,
		  { "Extension Token",
		    "wbxml.extension_token",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_reserved_2,
		  { "RESERVED_2",
		    "wbxml.reserved_2",
		    FT_NONE, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_invalid_token,
		  { "Invalid token",
		    "wbxml.invalid_token",
		    FT_UINT32, BASE_DEC,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_known_attrvalue,
		  { "Known attrValue",
		    "wbxml.known_attrvalue",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_known_attrstart,
		  { "Known attrStart",
		    "wbxml.known_attrstart",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_end_literal_tag,
		  { "END (Literal Tag)",
		    "wbxml.end_literal_tag",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_literal_a,
		  { "LITERAL_A",
		    "wbxml.literal_a",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_literal_c,
		  { "LITERAL_C",
		    "wbxml.literal_c",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_literal_ac,
		  { "LITERAL_AC",
		    "wbxml.literal_ac",
		    FT_STRING, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_end_pi,
		  { "END (PI)",
		    "wbxml.end_pi",
		    FT_NONE, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_end_attribute_list,
		  { "END (attribute list)",
		    "wbxml.end_attribute_list",
		    FT_NONE, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
		{ &hf_wbxml_pi_xml,
		  { "PI (XML Processing Instruction)",
		    "wbxml.pi_xml",
		    FT_NONE, BASE_NONE,
		    NULL, 0x00,
		    NULL, HFILL }
		},
	};

	/* Setup protocol subtree array */
	static gint *ett[] = {
		&ett_wbxml,
		&ett_wbxml_str_tbl,
		&ett_wbxml_content,
		&ett_wbxml_tags,
		&ett_wbxml_string_table_item,
	};

	static ei_register_info ei[] = {
		{ &ei_wbxml_data_not_shown, { "wbxml.data_not_shown", PI_PROTOCOL, PI_NOTE, "Data representation not shown (edit WBXML preferences to show)", EXPFILL }},
		{ &ei_wbxml_content_type_not_supported, { "wbxml.content_type.not_supported", PI_UNDECODED, PI_WARN, "Rendering of this content type not (yet) supported", EXPFILL }},
		{ &ei_wbxml_content_type_disabled, { "wbxml.content_type.disabled", PI_PROTOCOL, PI_NOTE, "Rendering of this content type has been disabled (edit WBXML preferences to enable)", EXPFILL }},
		{ &ei_wbxml_oversized_uintvar, { "wbxml.oversized_uintvar", PI_MALFORMED, PI_ERROR, "Uintvar is oversized", EXPFILL }}
	};

	expert_module_t* expert_wbxml;

	/* Register the protocol name and description */
	proto_wbxml = proto_register_protocol(
					      "WAP Binary XML",
					      "WBXML",
					      "wbxml"
					      );

	/* Required function calls to register the header fields
	 * and subtrees used */
	proto_register_field_array(proto_wbxml, hf, array_length(hf));
	proto_register_subtree_array(ett, array_length(ett));
	expert_wbxml = expert_register_protocol(proto_wbxml);
	expert_register_field_array(expert_wbxml, ei, array_length(ei));

	/* Preferences */
	wbxml_module = prefs_register_protocol(proto_wbxml, NULL);
	prefs_register_bool_preference(wbxml_module,
				       "skip_wbxml_token_mapping",
				       "Skip the mapping of WBXML tokens to media type tokens.",
				       "Enable this preference if you want to view the WBXML "
				       "tokens without the representation in a media type "
				       "(e.g., WML). Tokens will show up as Tag_0x12, "
				       "attrStart_0x08 or attrValue_0x0B for example.",
				       &skip_wbxml_token_mapping);
	prefs_register_bool_preference(wbxml_module,
				       "disable_wbxml_token_parsing",
				       "Disable the parsing of the WBXML tokens.",
				       "Enable this preference if you want to skip the "
				       "parsing of the WBXML tokens that constitute the body "
				       "of the WBXML document. Only the WBXML header will be "
				       "dissected (and visualized) then.",
				       &disable_wbxml_token_parsing);

	register_dissector("wbxml", dissect_wbxml, proto_wbxml);
	register_dissector("wbxml-uaprof", dissect_uaprof, proto_wbxml);
}
