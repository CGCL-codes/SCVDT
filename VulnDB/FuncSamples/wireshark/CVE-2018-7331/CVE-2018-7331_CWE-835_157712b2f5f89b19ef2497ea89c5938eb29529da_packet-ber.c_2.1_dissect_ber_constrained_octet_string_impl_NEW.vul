static int
dissect_ber_constrained_octet_string_impl(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb, guint nest_level) {
    gint8       ber_class;
    gboolean    pc, ind;
    gint32      tag;
    guint32     len;
    guint       encoding;
    int         hoffset;
    int         end_offset;
    proto_item *it, *cause;
    guint32     len_remain;

#ifdef DEBUG_BER
{
const char *name;
header_field_info *hfinfo;
if (hf_id >= 0) {
hfinfo = proto_registrar_get_nth(hf_id);
name = hfinfo->name;
} else {
name = "unnamed";
}
if (tvb_reported_length_remaining(tvb, offset) > 3) {
printf("OCTET STRING dissect_ber_octet string(%s) entered implicit_tag:%d offset:%d len:%d %02x:%02x:%02x\n", name, implicit_tag, offset, tvb_reported_length_remaining(tvb, offset), tvb_get_guint8(tvb, offset), tvb_get_guint8(tvb, offset+1), tvb_get_guint8(tvb, offset+2));
} else {
printf("OCTET STRING dissect_ber_octet_string(%s) entered\n", name);
}
}
#endif

    if (out_tvb)
        *out_tvb = NULL;

    if (!implicit_tag) {
        hoffset = offset;
        /* read header and len for the octet string */
        offset = dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &ber_class, &pc, &tag);
        offset = dissect_ber_length(actx->pinfo, tree, tvb, offset, &len, &ind);
        end_offset = offset+len;

        /* sanity check: we only handle Constructed Universal Sequences */
        if ((ber_class != BER_CLASS_APP) && (ber_class != BER_CLASS_PRI)) {
            if ( (ber_class != BER_CLASS_UNI)
              || ((tag < BER_UNI_TAG_NumericString) && (tag != BER_UNI_TAG_OCTETSTRING) && (tag != BER_UNI_TAG_UTF8String)) ) {
                tvb_ensure_bytes_exist(tvb, hoffset, 2);
                cause = proto_tree_add_string_format_value(
                    tree, hf_ber_error, tvb, offset, len, "octetstring_expected",
                    "OctetString expected but class:%s(%d) %s tag:%d was unexpected",
                    val_to_str_const(ber_class, ber_class_codes, "Unknown"),
                    ber_class,
                    pc ? ber_pc_codes_short.true_string : ber_pc_codes_short.false_string,
                    tag);
                expert_add_info(actx->pinfo, cause, &ei_ber_expected_octet_string);
                if (decode_unexpected) {
                    proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);
                    dissect_unknown_ber(actx->pinfo, tvb, hoffset, unknown_tree);
                }
                return end_offset;
            }
        }
    } else {
        /* implicit tag so get from last tag/length */

        get_last_ber_identifier(&ber_class, &pc, &tag);
        get_last_ber_length(&len, &ind);

        end_offset = offset+len;

        /* caller may have created new buffer for indefinite length data Verify via length */
        len_remain = (guint32)tvb_reported_length_remaining(tvb, offset);
        if (ind && (len_remain == (len - 2))) {
            /* new buffer received so adjust length and indefinite flag */
            len -= 2;
            end_offset -= 2;
            ind = FALSE;
        } else if (len_remain < len) {
            /*
             * error - short frame, or this item runs past the
             * end of the item containing it
             */
            ber_add_large_length_error(actx->pinfo, tree, tvb, offset, len);
            return end_offset;
        }

    }

    actx->created_item = NULL;

    if (pc) {
        /* constructed */
        end_offset = reassemble_octet_string(actx, tree, hf_id, tvb, offset, len, ind, out_tvb, nest_level);
    } else {
        /* primitive */
        gint length_remaining;

        length_remaining = tvb_reported_length_remaining(tvb, offset);
#if 0
        if (length_remaining < 1) {
            return end_offset;
        }
#endif

        if (len <= (guint32)length_remaining) {
            length_remaining = len;
        }
        if (hf_id >= 0) {
            /*
             * Strings are special.  See X.680 section 41 "Definition of
             * restricted character string types" and X.690 section 8.20
             * "Encoding for values of the restricted character string
             * types".
             *
             * Some restricted character string types are defined in X.680
             * "by reference to a registration number in the ISO International
             * Register of Character Sets" - or, in Table 8, by multiple
             * registration numbers, or one or more registration numbers
             * plus some characters such as SPACE and/or DELETE, or a
             * reference to "all G sets" or "all G sets and all C sets".
             * Presumably this indicates which characters are allowed
             * in strings of those character types, with "all {G,C} sets"
             * meaning the only restriction is to character sets registered
             * in said registry.
             *
             * The encodings of those types are specified in X.690 as
             * containing "the octets specified in ISO/IEC 2022 for
             * encodings in an 8-bit environment, using the escape sequence
             * and character codings registered in accordance with ISO/IEC
             * 2375".
             *
             * ISO/IEC 2022 is also ECMA-35:
             *
             *    http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-035.pdf
             *
             * ISO/IEC 2375 is the procedure for registering character
             * codings in the ISO International Register of Character Sets.
             * See
             *
             *     http://kikaku.itscj.ipsj.or.jp/ISO-IR/
             *
             * and
             *
             *     http://kikaku.itscj.ipsj.or.jp/ISO-IR/overview.htm
             *
             * for that registry.
             */
            switch (tag) {

            case BER_UNI_TAG_UTF8String:
                /*
                 * UTF-8, obviously.
                 */
                encoding = ENC_UTF_8|ENC_NA;
                break;

            case BER_UNI_TAG_NumericString:
            case BER_UNI_TAG_PrintableString:
            case BER_UNI_TAG_VisibleString:
            case BER_UNI_TAG_IA5String:
                /*
                 * (Subsets of) Boring Old ASCII, with no(?) ISO 2022
                 * escape sequences.
                 */
                encoding = ENC_ASCII|ENC_NA;
                break;

            case BER_UNI_TAG_TeletexString:
                /*
                 * XXX - the G0 part of this starts out as T.61, not ASCII.
                 *
                 * XXX - treat as ASCII for now.
                 */
                encoding = ENC_ASCII|ENC_NA;
                break;

            case BER_UNI_TAG_VideotexString:
                /*
                 * XXX - the G0 part of this starts out as T.61, not ASCII.
                 *
                 * XXX - treat as ASCII for now.
                 */
                encoding = ENC_ASCII|ENC_NA;
                break;

            case BER_UNI_TAG_GraphicString:
            case BER_UNI_TAG_GeneralString:
                /*
                 * One of the types defined in terms of character sets
                 * in the ISO International Register of Character Sets,
                 * with the BER encoding being ISO 2022-based.
                 *
                 * XXX - treat as ASCII for now.
                 */
                encoding = ENC_ASCII|ENC_NA;
                break;

            case BER_UNI_TAG_UniversalString:
                /*
                 * UCS-4.
                 */
                encoding = ENC_UCS_4|ENC_BIG_ENDIAN;
                break;

            case BER_UNI_TAG_CHARACTERSTRING:
                /*
                 * XXX - what's the transfer syntax?
                 * Treat as ASCII for now.
                 */
                encoding = ENC_ASCII|ENC_NA;
                break;

            case BER_UNI_TAG_BMPString:
                /*
                 * UCS-2, not UTF-16; as it says, BMP, as in Basic
                 * Multilingual Plane.
                 */
                encoding = ENC_UCS_2|ENC_BIG_ENDIAN;
                break;

            default:
                 encoding = ENC_BIG_ENDIAN;
                 break;
            }
            it = ber_proto_tree_add_item(actx->pinfo, tree, hf_id, tvb, offset, length_remaining, encoding);
            actx->created_item = it;
            ber_check_length(length_remaining, min_len, max_len, actx, it, FALSE);
        } else {

            proto_tree_add_item(tree, hf_ber_unknown_octetstring, tvb, offset, len, ENC_NA);
        }

        if (out_tvb) {
            *out_tvb = ber_tvb_new_subset_length(tvb, offset, len);
        }
    }
    return end_offset;
}
