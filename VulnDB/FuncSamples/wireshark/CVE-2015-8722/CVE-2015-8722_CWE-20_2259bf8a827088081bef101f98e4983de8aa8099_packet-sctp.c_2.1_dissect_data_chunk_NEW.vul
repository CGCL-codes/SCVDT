static gboolean
dissect_data_chunk(tvbuff_t *chunk_tvb,
                   guint16 chunk_length,
                   packet_info *pinfo,
                   proto_tree *tree,
                   proto_tree *chunk_tree,
                   proto_item *chunk_item,
                   proto_item *flags_item,
                   sctp_half_assoc_t *ha,
                   gboolean is_idata)
{
  guint number_of_ppid;
  volatile guint32 payload_proto_id;
  tvbuff_t *payload_tvb;
  proto_tree *flags_tree;
  guint8 e_bit, b_bit, u_bit;
  guint16 stream_id;
  guint32 tsn, ppid, stream_seq_num = 0;
  proto_item *tsn_item = NULL;
  gboolean call_subdissector = FALSE;
  gboolean is_retransmission;
  guint16 header_length;
  guint16 payload_offset;

  if (is_idata) {
    if (chunk_length < I_DATA_CHUNK_HEADER_LENGTH) {
      proto_item_append_text(chunk_item, ", bogus chunk length %u < %u)", chunk_length, I_DATA_CHUNK_HEADER_LENGTH);
      return TRUE;
    }
    payload_proto_id  = tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET);
  } else {
    if (chunk_length < DATA_CHUNK_HEADER_LENGTH) {
      proto_item_append_text(chunk_item, ", bogus chunk length %u < %u)", chunk_length, DATA_CHUNK_HEADER_LENGTH);
      return TRUE;
    }
    payload_proto_id  = tvb_get_ntohl(chunk_tvb, DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET);
  }

  /* insert the PPID in the pinfo structure if it is not already there and there is still room */
  for(number_of_ppid = 0; number_of_ppid < MAX_NUMBER_OF_PPIDS; number_of_ppid++) {
    void *tmp = p_get_proto_data(pinfo->pool, pinfo, proto_sctp, number_of_ppid);
    ppid = GPOINTER_TO_UINT(tmp);
    if ((ppid == LAST_PPID) || (ppid == payload_proto_id))
      break;
  }
  if ((number_of_ppid < MAX_NUMBER_OF_PPIDS) && (ppid == LAST_PPID))
    p_add_proto_data(pinfo->pool, pinfo, proto_sctp, number_of_ppid, GUINT_TO_POINTER(payload_proto_id));

  e_bit = tvb_get_guint8(chunk_tvb, CHUNK_FLAGS_OFFSET) & SCTP_DATA_CHUNK_E_BIT;
  b_bit = tvb_get_guint8(chunk_tvb, CHUNK_FLAGS_OFFSET) & SCTP_DATA_CHUNK_B_BIT;
  u_bit = tvb_get_guint8(chunk_tvb, CHUNK_FLAGS_OFFSET) & SCTP_DATA_CHUNK_U_BIT;
  tsn = tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET);

  if (chunk_tree) {
    if (is_idata)
      proto_item_set_len(chunk_item, I_DATA_CHUNK_HEADER_LENGTH);
    else
      proto_item_set_len(chunk_item, DATA_CHUNK_HEADER_LENGTH);
    flags_tree  = proto_item_add_subtree(flags_item, ett_sctp_data_chunk_flags);
    proto_tree_add_item(flags_tree, hf_data_chunk_e_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);
    proto_tree_add_item(flags_tree, hf_data_chunk_b_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);
    proto_tree_add_item(flags_tree, hf_data_chunk_u_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);
    proto_tree_add_item(flags_tree, hf_data_chunk_i_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);
    tsn_item = proto_tree_add_item(chunk_tree, hf_data_chunk_tsn,    chunk_tvb, DATA_CHUNK_TSN_OFFSET,                 DATA_CHUNK_TSN_LENGTH,                 ENC_BIG_ENDIAN);
    proto_tree_add_item(chunk_tree, hf_data_chunk_stream_id,         chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET,           DATA_CHUNK_STREAM_ID_LENGTH,           ENC_BIG_ENDIAN);
    if (is_idata) {
      proto_tree_add_item(chunk_tree, hf_idata_chunk_reserved, chunk_tvb, I_DATA_CHUNK_RESERVED_OFFSET, I_DATA_CHUNK_RESERVED_LENGTH, ENC_BIG_ENDIAN);
      proto_tree_add_item(chunk_tree, hf_idata_chunk_mid, chunk_tvb, I_DATA_CHUNK_MID_OFFSET, I_DATA_CHUNK_MID_LENGTH, ENC_BIG_ENDIAN);
      if (b_bit)
        proto_tree_add_item(chunk_tree, hf_data_chunk_payload_proto_id,  chunk_tvb, I_DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET, I_DATA_CHUNK_PAYLOAD_PROTOCOL_ID_LENGTH, ENC_BIG_ENDIAN);
      else
        proto_tree_add_item(chunk_tree, hf_idata_chunk_fsn, chunk_tvb, I_DATA_CHUNK_FSN_OFFSET, I_DATA_CHUNK_FSN_LENGTH, ENC_BIG_ENDIAN);
    } else {
      proto_tree_add_item(chunk_tree, hf_data_chunk_stream_seq_number, chunk_tvb, DATA_CHUNK_STREAM_SEQ_NUMBER_OFFSET,   DATA_CHUNK_STREAM_SEQ_NUMBER_LENGTH,   ENC_BIG_ENDIAN);
      proto_tree_add_item(chunk_tree, hf_data_chunk_payload_proto_id,  chunk_tvb, DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET, DATA_CHUNK_PAYLOAD_PROTOCOL_ID_LENGTH, ENC_BIG_ENDIAN);
    }
    proto_item_append_text(chunk_item, "(%s, ", (u_bit) ? "unordered" : "ordered");
    if (b_bit) {
      if (e_bit)
        proto_item_append_text(chunk_item, "complete");
      else
        proto_item_append_text(chunk_item, "first");
    } else {
      if (e_bit)
        proto_item_append_text(chunk_item, "last");
      else
        proto_item_append_text(chunk_item, "middle");
    }

    if (is_idata) {
      if (b_bit)
        proto_item_append_text(chunk_item, " segment, TSN: %u, SID: %u, MID: %u, payload length: %u byte%s)",
                               tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET),
                               tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET),
                               tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_MID_OFFSET),
                               chunk_length - I_DATA_CHUNK_HEADER_LENGTH, plurality(chunk_length - I_DATA_CHUNK_HEADER_LENGTH, "", "s"));
      else
        proto_item_append_text(chunk_item, " segment, TSN: %u, SID: %u, MID: %u, FSN: %u, payload length: %u byte%s)",
                               tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET),
                               tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET),
                               tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_MID_OFFSET),
                               tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_FSN_OFFSET),
                               chunk_length - I_DATA_CHUNK_HEADER_LENGTH, plurality(chunk_length - I_DATA_CHUNK_HEADER_LENGTH, "", "s"));
    } else
      proto_item_append_text(chunk_item, " segment, TSN: %u, SID: %u, SSN: %u, PPID: %u, payload length: %u byte%s)",
                             tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET),
                             tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET),
                             tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_SEQ_NUMBER_OFFSET),
                             payload_proto_id,
                             chunk_length - DATA_CHUNK_HEADER_LENGTH, plurality(chunk_length - DATA_CHUNK_HEADER_LENGTH, "", "s"));
  }

  is_retransmission = sctp_tsn(pinfo, chunk_tvb, tsn_item, ha, tsn);

  if (is_idata) {
    header_length = I_DATA_CHUNK_HEADER_LENGTH;
    payload_offset = I_DATA_CHUNK_PAYLOAD_OFFSET;
  } else {
    header_length = DATA_CHUNK_HEADER_LENGTH;
    payload_offset = DATA_CHUNK_PAYLOAD_OFFSET;
  }
  payload_tvb = tvb_new_subset(chunk_tvb, payload_offset,
                                 MIN(chunk_length - header_length, tvb_captured_length_remaining(chunk_tvb, payload_offset)),
                                 MIN(chunk_length - header_length, tvb_reported_length_remaining(chunk_tvb, payload_offset)));

  /* Is this a fragment? */
  if (b_bit && e_bit) {
    /* No - just call the subdissector. */
    if (!is_retransmission)
      call_subdissector = TRUE;
  } else {
    /* Yes. */
    pinfo->fragmented = TRUE;

    /* if reassembly is off just mark as fragment for next dissector and proceed */
    if (!use_reassembly)
    {
      /*  Don't pass on non-first fragments since the next dissector will
       *  almost certainly not understand the data.
       */
      if (b_bit) {
        if (!is_retransmission)
          call_subdissector = TRUE;
      } else
        return FALSE;
    }

  }

  if (call_subdissector) {
    /* This isn't a fragment or reassembly is off and it's the first fragment */

    volatile gboolean retval = FALSE;

    TRY {
      wmem_list_frame_t *cur;
      guint proto_id;
      const gchar *proto_name;
      void *tmp;

      cur = wmem_list_tail(pinfo->layers);
      retval = dissect_payload(payload_tvb, pinfo, tree, payload_proto_id);
      cur = wmem_list_frame_next(cur);
      if (cur) {
        tmp = wmem_list_frame_data(cur);
        proto_id = GPOINTER_TO_UINT(tmp);
        proto_name = proto_get_protocol_filter_name(proto_id);
        if (strcmp(proto_name, "data") != 0){
          if (have_tap_listener(exported_pdu_tap)){
            export_sctp_data_chunk(pinfo,payload_tvb, proto_name);
          }
        }
      }
    }
    CATCH_NONFATAL_ERRORS {
      /*
       * Somebody threw an exception that means that there was a problem
       * dissecting the payload; that means that a dissector was found,
       * so we don't need to dissect the payload as data or update the
       * protocol or info columns.
       *
       * Just show the exception and then continue dissecting chunks.
       */
      show_exception(payload_tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);
    }
    ENDTRY;

    return retval;

  } else if (is_retransmission) {
    col_append_str(pinfo->cinfo, COL_INFO, "(retransmission) ");
    return FALSE;
  } else {

    /* The logic above should ensure this... */
    DISSECTOR_ASSERT(use_reassembly);

    stream_id = tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET);
    if (is_idata) {
      /* The stream_seq_num variable is used to hold the MID, the tsn variable holds the FSN*/
      stream_seq_num = tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_MID_OFFSET);
      if (b_bit) {
        tsn = 0;
      } else {
        tsn = tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_FSN_OFFSET);
        payload_proto_id = 0;
      }
    } else {
      /* if unordered set stream_seq_num to 0 for easier handling */
      if (u_bit)
        stream_seq_num = 0;
      else
        stream_seq_num = tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_SEQ_NUMBER_OFFSET);
    }
    /* start reassembly */
    return dissect_fragmented_payload(payload_tvb, pinfo, tree, chunk_tree, tsn, payload_proto_id, stream_id, stream_seq_num, b_bit, e_bit, u_bit, is_idata);
  }

}
