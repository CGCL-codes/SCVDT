static gboolean
dissect_fragmented_payload(tvbuff_t *payload_tvb, packet_info *pinfo, proto_tree *tree,
                           proto_tree *chunk_tree, guint32 tsn, guint32 ppi, guint16 stream_id,
                           guint32 stream_seq_num, guint8 b_bit, guint8 e_bit, guint8 u_bit, gboolean is_idata)
{
  sctp_fragment *fragment;
  tvbuff_t *new_tvb = NULL;

  /*
   * If this is a short frame, then we can't, and don't, do
   * reassembly on it.  We just give up.
   */
  if (tvb_reported_length(payload_tvb) > tvb_captured_length(payload_tvb))
    return TRUE;

  /* add fragment to list of known fragments. returns NULL if segment is a duplicate */
  fragment = add_fragment(payload_tvb, pinfo, chunk_tree, tsn, stream_id, stream_seq_num, b_bit, e_bit, u_bit, ppi, is_idata);

  if (fragment)
    new_tvb = fragment_reassembly(payload_tvb, fragment, pinfo, chunk_tree, stream_id, stream_seq_num, u_bit);

  /* pass reassembled data to next dissector, if possible */
  if (new_tvb){
    wmem_list_frame_t *cur;
    guint proto_id;
    const gchar *proto_name;
    gboolean retval;
    void *tmp;

    cur = wmem_list_tail(pinfo->layers);
    retval = dissect_payload(new_tvb, pinfo, tree, ppi);
    cur = wmem_list_frame_next(cur);
    tmp = wmem_list_frame_data(cur);
    proto_id = GPOINTER_TO_UINT(tmp);
    proto_name = proto_get_protocol_filter_name(proto_id);
    if(strcmp(proto_name, "data") != 0){
      if (have_tap_listener(exported_pdu_tap)){
        export_sctp_data_chunk(pinfo,payload_tvb, proto_name);
      }
    }
    return retval;
  }

  /* no reassembly done, do nothing */
  return TRUE;
}
