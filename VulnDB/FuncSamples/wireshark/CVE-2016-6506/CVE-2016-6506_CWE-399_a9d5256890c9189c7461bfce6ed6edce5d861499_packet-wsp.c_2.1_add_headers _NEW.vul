static void
add_headers (proto_tree *tree, tvbuff_t *tvb, int hf, packet_info *pinfo)
{
    guint8      hdr_id, val_id, codepage = 1;
    gint32      tvb_len                  = tvb_reported_length(tvb);
    gint32      offset                   = 0;
    gint32      save_offset;
    gint32      hdr_len, hdr_start;
    gint32      val_len, val_start;
    gchar      *hdr_str, *val_str;
    proto_tree *wsp_headers;
    proto_item *ti, *hidden_item;
    guint8      ok;
    guint32     val                      = 0;

    if (offset >= tvb_len)
        return; /* No headers! */

    /* XXX: the field pointed to by hf has a type of FT_NONE */
    ti = proto_tree_add_item(tree, hf,
                             tvb, offset, tvb_len, ENC_NA);
    wsp_headers = proto_item_add_subtree(ti, ett_headers);

    while (offset < tvb_len) {
        hdr_start = offset;
        hdr_id = tvb_get_guint8(tvb, offset);
        if (hdr_id & 0x80) { /* Well-known header */
            hdr_len = 1;
            /* Call header value dissector for given header */
            if (codepage == 1) { /* Default header code page */
                save_offset = offset;
                offset = WellKnownHeader[hdr_id & 0x7F](wsp_headers, tvb,
                                                        hdr_start, pinfo);
                /* Make sure we're progressing forward */
                if (save_offset <= offset) {
                    expert_add_info(pinfo, ti, &ei_wsp_header_invalid);
                    break;
                }
            } else { /* Openwave header code page */
                /* Here I'm delibarately assuming that Openwave is the only
                 * company that defines a WSP header code page. */
                save_offset = offset;
                offset = WellKnownOpenwaveHeader[hdr_id & 0x7F](wsp_headers,
                                                                tvb, hdr_start, pinfo);
                /* Make sure we're progressing forward */
                if (save_offset <= offset) {
                    expert_add_info(pinfo, ti, &ei_wsp_header_invalid);
                    break;
                }
            }
        } else if (hdr_id == 0x7F) { /* HCP shift sequence */
            codepage = tvb_get_guint8(tvb, offset+1);
            proto_tree_add_uint(wsp_headers, hf_wsp_header_shift_code,
                                tvb, offset, 2, codepage);
            offset += 2;
        } else if (hdr_id >= 0x20) { /* Textual header */
            /* Header name MUST be NUL-ended string ==> tvb_get_stringz_enc() */
            hdr_str = (gchar *)tvb_get_stringz_enc(wmem_packet_scope(), tvb, hdr_start, (gint *)&hdr_len, ENC_ASCII);
            val_start = hdr_start + hdr_len;
            val_id = tvb_get_guint8(tvb, val_start);
            /* Call header value dissector for given header */
            if (val_id >= 0x20 && val_id <=0x7E) { /* OK! */
                val_str = (gchar *)tvb_get_stringz_enc(wmem_packet_scope(), tvb, val_start, (gint *)&val_len, ENC_ASCII);
                offset = val_start + val_len;
                proto_tree_add_string_format(wsp_headers, hf_wsp_header_text_value, tvb, hdr_start, offset-hdr_start,
                                    val_str, "%s: %s", hdr_str, val_str);
            } else {
                /* Old-style X-WAP-TOD uses a non-textual value
                 * after a textual header. */
                if (g_ascii_strcasecmp(hdr_str, "x-wap.tod") == 0) {
                    get_delta_seconds_value(val, tvb, val_start, val_len, ok);
                    if (ok) {
                        nstime_t t;
                        t.secs = (time_t)val;
                        t.nsecs = 0;
                        if (val == 0) {
                            ti = proto_tree_add_time_format_value(wsp_headers, hf_hdr_x_wap_tod,
                                                        tvb, hdr_start, hdr_len + val_len, &t,
                                                        "Requesting Time Of Day");
                        } else {
                            ti = proto_tree_add_time(wsp_headers, hf_hdr_x_wap_tod,
                                                        tvb, hdr_start, hdr_len + val_len, &t);
                        }
                        expert_add_info(pinfo, ti, &ei_hdr_x_wap_tod);
                    } else {
                        /* I prefer using X-Wap-Tod to the real hdr_str */
                        proto_tree_add_expert_format(wsp_headers, pinfo, &ei_wsp_text_field_invalid,
                                               tvb, hdr_start, hdr_len + val_len,
                                               "Invalid value for the 'X-Wap-Tod' header");

                    }
                } else {
                    proto_tree_add_expert_format(wsp_headers, pinfo, &ei_wsp_text_field_invalid, tvb, hdr_start, hdr_len,
                                         "Invalid value for the textual '%s' header (should be a textual value)",
                                         hdr_str);
                }
                offset = tvb_len;
            }
            hidden_item = proto_tree_add_string(wsp_headers, hf_hdr_name_string,
                                                tvb, hdr_start, offset - hdr_start, hdr_str);
            PROTO_ITEM_SET_HIDDEN(hidden_item);
        } else if (hdr_id > 0) { /* Shorthand HCP switch */
            codepage = hdr_id;
            proto_tree_add_uint (wsp_headers, hf_wsp_header_shift_code,
                                 tvb, offset, 1, codepage);
            offset++;
        } else {
            proto_tree_add_expert_format (wsp_headers, pinfo, &ei_wsp_text_field_invalid, tvb, hdr_start, 1,
                                 "Invalid zero-length textual header");

            offset = tvb_len;
        }
    }
}
