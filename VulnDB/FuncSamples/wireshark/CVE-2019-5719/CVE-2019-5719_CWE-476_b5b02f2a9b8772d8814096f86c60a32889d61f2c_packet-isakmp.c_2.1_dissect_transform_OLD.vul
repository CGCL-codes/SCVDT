static void
dissect_transform(tvbuff_t *tvb, packet_info *pinfo, int offset, int length, proto_tree *tree, int isakmp_version, int protocol_id, void* decr_data)
{
  if (isakmp_version == 1)
  {
    guint8              transform_id;
    guint8              transform_num;
    decrypt_data_t *decr = (decrypt_data_t *)decr_data;
    int offset_end = 0;
    offset_end = offset + length;

    transform_num = tvb_get_guint8(tvb, offset);
    proto_item_append_text(tree," # %d",transform_num);

    proto_tree_add_item(tree, hf_isakmp_trans_number, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;

    transform_id = tvb_get_guint8(tvb, offset);
    switch (protocol_id) {
    case 1:     /* ISAKMP */
      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
                                 transform_id, "%s (%u)",
                                 val_to_str_const(transform_id, vs_v1_trans_isakmp, "UNKNOWN-TRANS-TYPE"), transform_id);
      break;
    case 2:     /* AH */
      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
                                 transform_id, "%s (%u)",
                                 val_to_str_const(transform_id, vs_v1_trans_ah, "UNKNOWN-AH-TRANS-TYPE"), transform_id);
      break;
    case 3:     /* ESP */
      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
                                 transform_id, "%s (%u)",
                                 val_to_str_const(transform_id, vs_v1_trans_esp, "UNKNOWN-ESP-TRANS-TYPE"), transform_id);
      break;
    case 4:     /* IPCOMP */
      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
                                 transform_id, "%s (%u)",
                                 val_to_str_const(transform_id, transform_id_ipcomp, "UNKNOWN-IPCOMP-TRANS-TYPE"), transform_id);
      break;
    default:
      proto_tree_add_item(tree, hf_isakmp_trans_id, tvb, offset, 1, ENC_BIG_ENDIAN);
      break;
    }
    offset += 1;

    proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 2, ENC_NA);
    offset += 2;

    if (protocol_id == 1 && transform_id == 1) {
      /* Allow detection of missing IKE transform attributes:
       * Make sure their values are not carried over from another transform
       * dissected previously. */
      decr->ike_encr_alg = 0;
      decr->ike_encr_keylen = 0;
      decr->ike_hash_alg = 0;
      while (offset < offset_end) {
        offset += dissect_ike_attribute(tvb, pinfo, tree, offset, decr);
      }
    }
    else {
       while (offset < offset_end) {
         offset += dissect_ipsec_attribute(tvb, pinfo, tree, offset);
       }
    }
  }
  else if(isakmp_version == 2)
  {
    guint8 transform_type;
    int offset_end = 0;
    offset_end = offset + length;

    transform_type = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_isakmp_trans_type, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 1, ENC_NA);
    offset += 1;

    switch(transform_type){
    case TF_IKE2_ENCR:
      proto_tree_add_item(tree, hf_isakmp_trans_encr, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    case TF_IKE2_PRF:
      proto_tree_add_item(tree, hf_isakmp_trans_prf, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    case TF_IKE2_INTEG:
      proto_tree_add_item(tree, hf_isakmp_trans_integ, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    case TF_IKE2_DH:
      proto_tree_add_item(tree, hf_isakmp_trans_dh, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    case TF_IKE2_ESN:
      proto_tree_add_item(tree, hf_isakmp_trans_esn, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    default:
      proto_tree_add_item(tree, hf_isakmp_trans_id_v2, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    }
    offset += 2;

    while (offset < offset_end) {
      offset += dissect_ike2_transform_attribute(tvb, pinfo, tree, offset);
    }
  }
}
