static tvbuff_t *wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree, circuit_type ctype, guint32 circuit_id) {

/* do the packet data uncompression and load it into the dst buffer */

	proto_tree	*cd_tree, *sub_tree;
	proto_item	*cd_item, *ti;

	int len, i;
	int cnt = tvb_reported_length( src_tvb)-1;	/* don't include check byte */

	guint8 *dst, *src, *buf_start, *buf_end, comp_flag_bits = 0;
	guint8 src_buf[ MAX_WCP_BUF_LEN];
	tvbuff_t *tvb;
	wcp_window_t *buf_ptr = 0;
	wcp_pdata_t *pdata_ptr;

	buf_ptr = get_wcp_window_ptr(pinfo, ctype, circuit_id);

	buf_start = buf_ptr->buffer;
	buf_end = buf_start + MAX_WIN_BUF_LEN;

	cd_item = proto_tree_add_item(tree, hf_wcp_compressed_data,
	    src_tvb, offset, cnt - offset, ENC_NA);
	cd_tree = proto_item_add_subtree(cd_item, ett_wcp_comp_data);
	if (cnt - offset > MAX_WCP_BUF_LEN) {
		expert_add_info_format(pinfo, cd_item, &ei_wcp_compressed_data_exceeds,
			"Compressed data exceeds maximum buffer length (%d > %d)",
			cnt - offset, MAX_WCP_BUF_LEN);
		return NULL;
	}

	src = (guint8 *)tvb_memcpy(src_tvb, src_buf, offset, cnt - offset);
	dst = buf_ptr->buf_cur;
	len = 0;
	i = -1;

	while( offset < cnt){

		if ( --i >= 0){
			if ( comp_flag_bits & 0x80){	/* if this is a compressed entry */

				if ( !pinfo->fd->flags.visited){	/* if first pass */
					dst = decompressed_entry( src, dst, &len, buf_start, buf_end);
					if (dst == NULL){
						expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,
							"Uncompressed data exceeds maximum buffer length (%d > %d)",
							len, MAX_WCP_BUF_LEN);
						return NULL;
					}
				}
				if ((*src & 0xf0) == 0x10){
					if ( tree) {
						ti = proto_tree_add_item( cd_tree, hf_wcp_long_run, src_tvb,
							 offset, 3, ENC_NA);
						sub_tree = proto_item_add_subtree(ti, ett_wcp_field);
						proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,
							 offset, 2, pntoh16(src));

						proto_tree_add_item( sub_tree, hf_wcp_long_len, src_tvb,
							 offset+2, 1, ENC_BIG_ENDIAN);
					}
					src += 3;
					offset += 3;
				}else{
					if ( tree) {
						ti = proto_tree_add_item( cd_tree, hf_wcp_short_run, src_tvb,
							 offset, 2, ENC_NA);
						sub_tree = proto_item_add_subtree(ti, ett_wcp_field);
						proto_tree_add_uint( sub_tree, hf_wcp_short_len, src_tvb,
							 offset, 1, *src);
						proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,
							 offset, 2, pntoh16(src));
					}
					src += 2;
					offset += 2;
				}
			}else {
				if ( ++len >MAX_WCP_BUF_LEN){
					expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,
						"Uncompressed data exceeds maximum buffer length (%d > %d)",
						len, MAX_WCP_BUF_LEN);
					return NULL;
				}

				if ( !pinfo->fd->flags.visited){	/* if first pass */
					*dst = *src;
					if ( dst++ == buf_end)
						dst = buf_start;
				}
				++src;
				++offset;
			}

			comp_flag_bits <<= 1;

		}else {	/* compressed data flag */

			comp_flag_bits = *src++;
			if (cd_tree)
				proto_tree_add_uint(cd_tree, hf_wcp_comp_bits,  src_tvb, offset, 1,
					comp_flag_bits);
			offset++;

			i = 8;
		}
	}

	if ( pinfo->fd->flags.visited){	/* if not first pass */
					/* get uncompressed data */
		pdata_ptr = (wcp_pdata_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_wcp, 0);

		if ( !pdata_ptr) {	/* exit if no data */
			REPORT_DISSECTOR_BUG("Can't find uncompressed data");
			return NULL;
		}
		len = pdata_ptr->len;
	} else {

	/* save the new data as per packet data */
		pdata_ptr = wmem_new(wmem_file_scope(), wcp_pdata_t);
		memcpy( &pdata_ptr->buffer, buf_ptr->buf_cur,  len);
		pdata_ptr->len = len;

		p_add_proto_data(wmem_file_scope(), pinfo, proto_wcp, 0, (void*)pdata_ptr);

		buf_ptr->buf_cur = dst;
	}

	tvb = tvb_new_child_real_data(src_tvb,  pdata_ptr->buffer, pdata_ptr->len, pdata_ptr->len);

	/* Add new data to the data source list */
	add_new_data_source( pinfo, tvb, "Uncompressed WCP");
	return tvb;

}
