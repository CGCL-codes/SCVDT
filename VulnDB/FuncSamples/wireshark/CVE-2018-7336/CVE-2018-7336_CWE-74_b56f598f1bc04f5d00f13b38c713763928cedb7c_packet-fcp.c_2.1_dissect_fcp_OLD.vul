static int
dissect_fcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
    proto_item      *ti            = NULL;
    proto_tree      *fcp_tree      = NULL;
    fc_hdr          *fchdr;
    guint8           r_ctl;
    conversation_t  *fc_conv;
    fcp_conv_data_t *fcp_conv_data = NULL;
    fcp_request_data_t *request_data = NULL;
    gboolean         els;
    fcp_proto_data_t *proto_data;

    /* Reject the packet if data is NULL */
    if (data == NULL)
        return 0;
    fchdr = (fc_hdr *)data;

    /* Make entries in Protocol column and Info column on summary display */
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "FCP");

    r_ctl = fchdr->r_ctl;
    els = (r_ctl & 0xf0) == FC_RCTL_LINK_DATA;
    r_ctl &= 0xF;

    col_add_str(pinfo->cinfo, COL_INFO,
                     val_to_str(r_ctl, els ? fcp_els_iu_val : fcp_iu_val,
                                 "0x%x"));

    ti = proto_tree_add_protocol_format(tree, proto_fcp, tvb, 0, -1,
                                            "FCP: %s",
                                            val_to_str(r_ctl,
                                            els ? fcp_els_iu_val :
                                            fcp_iu_val, "Unknown 0x%02x"));
    fcp_tree = proto_item_add_subtree(ti, ett_fcp);

    fc_conv = find_conversation(pinfo->num, &pinfo->src, &pinfo->dst,
                     pinfo->ptype, pinfo->srcport,
                     pinfo->destport, 0);
    if (fc_conv != NULL) {
        fcp_conv_data = (fcp_conv_data_t *)conversation_get_proto_data(fc_conv, proto_fcp);
    }
    if (!fcp_conv_data) {
        fcp_conv_data = wmem_new(wmem_file_scope(), fcp_conv_data_t);
        fcp_conv_data->luns = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);
        conversation_add_proto_data(fc_conv, proto_fcp, fcp_conv_data);
    }

    /* Lun is only populated by FCP_IU_CMD, and subsequent packets assume the same lun.
       The only way that consistently works is to save the lun on the first pass when packets
       are guaranteed to be parsed consecutively */
    if (!pinfo->fd->flags.visited) {
        proto_data = wmem_new(wmem_file_scope(), fcp_proto_data_t);
        proto_data->lun = fchdr->lun;
        p_add_proto_data(wmem_file_scope(), pinfo, proto_fcp, 0, proto_data);
    } else {
        proto_data = (fcp_proto_data_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fcp, 0);
    }

    if ((r_ctl != FCP_IU_CMD) && (r_ctl != FCP_IU_UNSOL_CTL)) {
        request_data = (fcp_request_data_t *)wmem_map_lookup(fcp_conv_data->luns, GUINT_TO_POINTER((guint)(proto_data->lun)));
    }

    /* put a request_in in all frames except the command frame */
    if ((r_ctl != FCP_IU_CMD) && (r_ctl != FCP_IU_UNSOL_CTL) &&
        (request_data != NULL) && (request_data->itlq->first_exchange_frame)) {
        proto_item *it;
        it = proto_tree_add_uint(fcp_tree, hf_fcp_singlelun, tvb, 0, 0, proto_data->lun);
        PROTO_ITEM_SET_GENERATED(it);
        if (request_data != NULL) {
            it = proto_tree_add_uint(fcp_tree, hf_fcp_request_in, tvb, 0, 0, request_data->request_frame);
            PROTO_ITEM_SET_GENERATED(it);
            /* only put the response time in the actual response frame */
            if (r_ctl == FCP_IU_RSP) {
                nstime_t delta_ts;
                nstime_delta(&delta_ts, &pinfo->abs_ts, &request_data->request_time);
                it = proto_tree_add_time(ti, hf_fcp_time, tvb, 0, 0, &delta_ts);
                PROTO_ITEM_SET_GENERATED(it);
            }
        }
    }
    /* put a response_in in all frames except the response frame */
    if ((r_ctl != FCP_IU_RSP) && (r_ctl != FCP_IU_SOL_CTL) &&
        (request_data != NULL) && (request_data->response_frame)) {
        proto_item *it;
        it = proto_tree_add_uint(fcp_tree, hf_fcp_response_in, tvb, 0, 0, request_data->response_frame);
        PROTO_ITEM_SET_GENERATED(it);
    }

    if (els) {
        dissect_fcp_els(tvb, pinfo, fcp_tree, fchdr);
        return tvb_captured_length(tvb);
    }

    switch (r_ctl) {
    case FCP_IU_DATA:
        dissect_fcp_data(tvb, pinfo, tree, fc_conv, (request_data != NULL) ? request_data->itlq : NULL, fchdr->relative_offset);
        break;
    case FCP_IU_CONFIRM:
        /* Nothing to be done here */
        break;
    case FCP_IU_XFER_RDY:
        dissect_fcp_xfer_rdy(tvb, fcp_tree);
        break;
    case FCP_IU_CMD:
        dissect_fcp_cmnd(tvb, pinfo, tree, fcp_tree, fc_conv, fchdr, fcp_conv_data);
        break;
    case FCP_IU_RSP:
        dissect_fcp_rsp(tvb, pinfo, tree, fcp_tree, fc_conv, fchdr, request_data);
        break;
    default:
        call_data_dissector(tvb, pinfo, tree);
        break;
    }
/*xxx once the subdissectors return bytes consumed:  proto_item_set_end(ti, tvb, offset);*/
    return tvb_captured_length(tvb);
}
