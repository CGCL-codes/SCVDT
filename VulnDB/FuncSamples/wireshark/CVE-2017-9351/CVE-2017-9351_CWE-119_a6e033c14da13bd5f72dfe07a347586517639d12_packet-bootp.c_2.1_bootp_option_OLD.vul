static int
bootp_option(tvbuff_t *tvb, packet_info *pinfo, proto_tree *bp_tree, proto_item *bp_item, int voff,
	     int eoff, gboolean first_pass, gboolean *at_end, const char **dhcp_type_p,
	     const guint8 **vendor_class_id_p, guint8 *overload_p)
{
	struct opt_info *opt;
	enum field_type	 ftype;
	guchar		 code = tvb_get_guint8(tvb, voff);
	int		 optlen;
	guchar		 byte;
	int		 i, consumed, basictype_consumed;
	int		 optoff, optleft, optend;
	proto_tree	*v_tree;
	proto_item	*vti, *ti;
	guint8		 protocol;
	guint8		 algorithm;
	guint8		 rdm;
	guint8		 fqdn_flags;
	int		 o52voff, o52eoff;
	gboolean	 o52at_end;
	guint8		 s_option;
	guint8		 s_len;
	const guchar	*dns_name;
	gboolean	 option_handled = TRUE;

	struct basic_types_hfs default_hfs = {
		&hf_bootp_option_value,
		&hf_bootp_option_value_ip_address,
		&hf_bootp_option_value_ip_address,
		&hf_bootp_option_value_stringz,
		&hf_bootp_option_value_boolean,
		&hf_bootp_option_value_8,
		&hf_bootp_option_value_16,
		&hf_bootp_option_value_16,
		&hf_bootp_option_value_u32,
		&hf_bootp_option_value_i32,
		&hf_bootp_option_value_u32
	};

	/* Options whose length isn't "optlen + 2". */
	switch (code) {

	case 0:		/* Padding */
		/* check how much padding we have */
		for (i = voff + 1; i < eoff; i++ ) {
			if (tvb_get_guint8(tvb, i) != 0) {
				break;
			}
		}
		i = i - voff;
		if (!first_pass) {
			if (bp_tree != NULL) {
				vti = proto_tree_add_uint_format_value(bp_tree, hf_bootp_option_type,
						tvb, voff, 1, 0, "(0) Padding");
				v_tree = proto_item_add_subtree(vti, ett_bootp_option);
				proto_tree_add_item(v_tree, hf_bootp_option_padding, tvb, voff, i, ENC_NA);
			}
		}
		consumed = i;
		return consumed;

	case 255:	/* End Option */
		if (!first_pass) {
			if (bp_tree != NULL) {
				vti = proto_tree_add_uint_format_value(bp_tree, hf_bootp_option_type,
						tvb, voff, 1, 0, "(255) End");
				v_tree = proto_item_add_subtree(vti, ett_bootp_option);
				if (*overload_p)
					proto_tree_add_item(v_tree, hf_bootp_option_end_overload, tvb, voff, 1, ENC_BIG_ENDIAN);
				else
					proto_tree_add_item(v_tree, hf_bootp_option_end, tvb, voff, 1, ENC_BIG_ENDIAN);
			}
		}
		*at_end = TRUE;
		consumed = 1;
		return consumed;
	}

	/*
	 * Get the length of the option, and the number of bytes it
	 * consumes (the length doesn't include the option code or
	 * length bytes).
	 *
	 * On the first pass, check first whether we have the length
	 * byte, so that we don't throw an exception; if we throw an
	 * exception in the first pass, which is only checking for options
	 * whose values we need in order to properly dissect the packet
	 * on the second pass, we won't actually dissect the options, so
	 * you won't be able to see which option had the problem.
	 */
	if (first_pass) {
		if (!tvb_bytes_exist(tvb, voff+1, 1)) {
			/*
			 * We don't have the length byte; just return 1
			 * as the number of bytes we consumed, to count
			 * the code byte.
			 */
			return 1;
		}
	}
	optlen = tvb_get_guint8(tvb, voff+1);
	consumed = optlen + 2;

	/*
	 * In the first pass, we don't put anything into the protocol
	 * tree; we just check for some options we have to look at
	 * in order to properly process the packet:
	 *
	 *	52 (Overload) - we need this to properly dissect the
	 *	   file and sname fields
	 *
	 *	53 (DHCP message type) - if this is present, this is DHCP
	 *
	 *	60 (Vendor class identifier) - we need this in order to
	 *	   interpret the vendor-specific info
	 *
	 * We also check, before fetching anything, to make sure we
	 * have the entire item we're fetching, so that we don't throw
	 * an exception.
	 */
	if (first_pass) {
		if (tvb_bytes_exist(tvb, voff+2, consumed-2)) {
			switch (code) {

			case 52:
				*overload_p = tvb_get_guint8(tvb, voff+2);
				break;

			case 53:
				*dhcp_type_p =
				    val_to_str(tvb_get_guint8(tvb, voff+2),
					opt53_text,
					"Unknown Message Type (0x%02x)");
				break;

			case 60:
				*vendor_class_id_p =
				    tvb_get_ptr(tvb, voff+2, consumed-2);
				break;
			case 119:
				rfc3396_dns_domain_search_list.total_number_of_block++;
				break;
			case 120:
				rfc3396_sip_server.total_number_of_block++;
				break;
			}
		}

		/*
		 * We don't do anything else here.
		 */
		return consumed;
	}

	/* Normal cases */
	opt = bootp_get_opt(code);
	if (opt == NULL)
	{
		/* THIS SHOULD NEVER HAPPEN!!! */
		return consumed;
	}

	/* function type may be overridden and that shouldn't be a 'saved' change */
	ftype = opt->ftype;

	optoff = voff+2;

	vti = proto_tree_add_uint_format_value(bp_tree, hf_bootp_option_type,
		tvb, voff, consumed, code, "(%d) %s", code, opt->text);
	v_tree = proto_item_add_subtree(vti, ett_bootp_option);
	proto_tree_add_item(v_tree, hf_bootp_option_length, tvb, voff+1, 1, ENC_BIG_ENDIAN);

	ti = proto_tree_add_item(v_tree, hf_bootp_option_value, tvb, voff+2, optlen, ENC_NA);
	PROTO_ITEM_SET_HIDDEN(ti);

	/* Special cases */
	switch (code) {

	case 21:	/* Policy Filter */
		for (i = optoff, optleft = optlen;
			optleft > 0; i += 8, optleft -= 8) {
			if (optleft < 8) {
				expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "Option length isn't a multiple of 8");
				break;
			}

			proto_tree_add_item(v_tree, hf_bootp_option_policy_filter_ip, tvb, i, 4, ENC_BIG_ENDIAN);
			proto_tree_add_item(v_tree, hf_bootp_option_policy_filter_subnet_mask, tvb, i+4, 4, ENC_BIG_ENDIAN);
		}
		break;

	case 33:	/* Static Route */
		for (i = optoff, optleft = optlen;
			optleft > 0; i += 8, optleft -= 8) {
			if (optleft < 8) {
				expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "Option length isn't a multiple of 8");
				break;
			}

			proto_tree_add_item(v_tree, hf_bootp_option_static_route_ip, tvb, i, 4, ENC_BIG_ENDIAN);
			proto_tree_add_item(v_tree, hf_bootp_option_static_route_router, tvb, i+4, 4, ENC_BIG_ENDIAN);
		}
		break;

	case 43:	/* Vendor-Specific Info */
		s_option = tvb_get_guint8(tvb, optoff);

		/* PXE protocol 2.1 as described in the Intel specs */
		if (*vendor_class_id_p != NULL &&
		    strncmp((const gchar*)*vendor_class_id_p, "PXEClient", strlen("PXEClient")) == 0) {
			proto_item_append_text(vti, " (PXEClient)");
			v_tree = proto_item_add_subtree(vti, ett_bootp_option);

			optend = optoff + optlen;
			while (optoff < optend) {
				optoff = dissect_vendor_pxeclient_suboption(pinfo, vti, v_tree,
					tvb, optoff, optend);
			}
		} else if (*vendor_class_id_p != NULL &&
			   ((strncmp((const gchar*)*vendor_class_id_p, "pktc", strlen("pktc")) == 0) ||
			    (strncmp((const gchar*)*vendor_class_id_p, "docsis", strlen("docsis")) == 0) ||
			    (strncmp((const gchar*)*vendor_class_id_p, "OpenCable2.0", strlen("OpenCable2.0")) == 0) ||
			    (strncmp((const gchar*)*vendor_class_id_p, "CableHome", strlen("CableHome")) == 0))) {
			/* CableLabs standard - see www.cablelabs.com/projects */
			proto_item_append_text(vti, " (CableLabs)");

			optend = optoff + optlen;
			while (optoff < optend) {
				optoff = dissect_vendor_cablelabs_suboption(pinfo, vti, v_tree,
					tvb, optoff, optend);
			}
		} else if (*vendor_class_id_p != NULL &&
			   ((strncmp((const gchar*)*vendor_class_id_p, "ArubaAP", strlen("ArubaAP")) == 0) )) {
			/* Aruba AP */
			proto_item_append_text(vti, " (Aruba AP)");
			proto_tree_add_item(v_tree, hf_bootp_option43_arubaap_controllerip, tvb, optoff, optlen, ENC_ASCII|ENC_NA);
		} else if (*vendor_class_id_p != NULL &&
			   ((strncmp((const gchar*)*vendor_class_id_p, "ArubaInstantAP", strlen("ArubaInstantAP")) == 0) )) {
			gint32 nameorglen, ampiplen;
			/* Aruba  Instant AP */
			proto_item_append_text(vti, " (Aruba Instant AP)");
			vti = proto_tree_add_item(v_tree, hf_bootp_option43_arubaiap, tvb, optoff, optlen, ENC_ASCII|ENC_NA);
			v_tree = proto_item_add_subtree(vti, ett_bootp_option43_suboption);
			nameorglen = tvb_find_guint8(tvb, optoff, optlen, ',') - optoff;
			proto_tree_add_item(v_tree, hf_bootp_option43_arubaiap_nameorg, tvb, optoff, nameorglen, ENC_ASCII|ENC_NA);
			ampiplen = tvb_find_guint8(tvb, optoff+nameorglen+1, optlen-nameorglen-1, ',') - (optoff+nameorglen+1);
			proto_tree_add_item(v_tree, hf_bootp_option43_arubaiap_ampip, tvb, optoff+nameorglen+1, ampiplen, ENC_ASCII|ENC_NA);
			proto_tree_add_item(v_tree, hf_bootp_option43_arubaiap_password, tvb, optoff+nameorglen+1+ampiplen+1, optlen-(nameorglen+1+ampiplen+1), ENC_ASCII|ENC_NA);
		} else if ((s_option==58 || s_option==64 || s_option==65
			|| s_option==66 || s_option==67)
			&& test_encapsulated_vendor_options(tvb, optoff, optoff+optlen)) {
			/* Note that this is a rather weak (permissive) heuristic, */
			/* but since it comes last, I guess this is OK. */
			/* Add any stronger (less permissive) heuristics before this! */
			/* Alcatel-Lucent DHCP Extensions */
			proto_item_append_text(vti, " (Alcatel-Lucent)");
			optend = optoff + optlen;
			while (optoff < optend) {
				optoff = dissect_vendor_alcatel_suboption(pinfo, vti, v_tree,
					tvb, optoff, optend);
			}
		} else {
			/* Default Vendor-Specific Info.. display in bytes */
			proto_tree_add_item(v_tree, hf_bootp_option43_value, tvb, optoff, optlen, ENC_NA);
		}
		break;

	case 52:	/* Option Overload */
		if (optlen < 1) {
			expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length isn't >= 1");
			break;
		}

		byte = tvb_get_guint8(tvb, optoff);
		proto_tree_add_item(v_tree, *opt->phf, tvb, optoff, 1, ENC_BIG_ENDIAN);

		/* Just in case we find an option 52 in sname or file */
		if (voff > VENDOR_INFO_OFFSET && byte >= 1 && byte <= 3) {
			if (byte & OPT_OVERLOAD_FILE) {
				proto_item *oti;
				proto_tree_add_subtree(bp_tree, tvb,
					FILE_NAME_OFFSET, FILE_NAME_LEN, ett_bootp_filename_option, &oti,
					"Boot file name option overload");
				o52voff = FILE_NAME_OFFSET;
				o52eoff = FILE_NAME_OFFSET + FILE_NAME_LEN;
				o52at_end = FALSE;
				rfc3396_dns_domain_search_list.index_current_block = 0;
				rfc3396_sip_server.index_current_block = 0;
				while (o52voff < o52eoff && !o52at_end) {
					o52voff += bootp_option(tvb, pinfo, bp_tree, bp_item, o52voff,
						o52eoff, FALSE, &o52at_end,
						dhcp_type_p, vendor_class_id_p,
						overload_p);
				}
				if (!o52at_end)
				{
					expert_add_info(pinfo, oti, &hf_bootp_opt_overload_file_end_missing);
				}
			}
			if (byte & OPT_OVERLOAD_SNAME) {
				proto_item *oti;
				proto_tree_add_subtree(bp_tree, tvb,
					SERVER_NAME_OFFSET, SERVER_NAME_LEN, ett_bootp_server_hostname, &oti,
					"Server host name option overload");
				o52voff = SERVER_NAME_OFFSET;
				o52eoff = SERVER_NAME_OFFSET + SERVER_NAME_LEN;
				o52at_end = FALSE;
				rfc3396_dns_domain_search_list.index_current_block = 0;
				rfc3396_sip_server.index_current_block = 0;
				while (o52voff < o52eoff && !o52at_end) {
					o52voff += bootp_option(tvb, pinfo, bp_tree, bp_item, o52voff,
						o52eoff, FALSE, &o52at_end,
						dhcp_type_p, vendor_class_id_p,
						overload_p);
				}
				if (!o52at_end)
				{
					expert_add_info(pinfo, oti, &hf_bootp_opt_overload_sname_end_missing);
				}
			}
			/* The final end option is not in overload */
			*overload_p = 0;
		}
		break;

	case 53:
		/* Show the message type name on the Message Type option, and in the protocol root */
		proto_item_append_text(vti, " (%s)", val_to_str(tvb_get_guint8(tvb, voff+2),
				       opt53_text,
				       "Unknown Message Type (0x%02x)"));
		proto_item_append_text(bp_item, " (%s)", val_to_str(tvb_get_guint8(tvb, voff+2),
				       opt53_text,
				       "Unknown Message Type (0x%02x)"));
		break;

	case 55:	/* Parameter Request List */
		for (i = 0; i < optlen; i++) {
			byte = tvb_get_guint8(tvb, optoff+i);
			proto_tree_add_uint_format_value(v_tree, hf_bootp_option_parameter_request_list_item,
					tvb, optoff+i, 1, byte, "(%d) %s", byte, bootp_get_opt_text(byte));
		}
		break;

	case 60:	/* Vendor class identifier */
		/*
		 * XXX - RFC 2132 says this is a string of octets;
		 * should we check for non-printables?
		 */

		proto_tree_add_item(v_tree, hf_bootp_option_vendor_class_id, tvb, optoff, consumed-2, ENC_ASCII|ENC_NA);
		if ((tvb_memeql(tvb, optoff, (const guint8*)PACKETCABLE_MTA_CAP10,
				      (int)strlen(PACKETCABLE_MTA_CAP10)) == 0)
		    ||
		    (tvb_memeql(tvb, optoff, (const guint8*)PACKETCABLE_MTA_CAP15,
				      (int)strlen(PACKETCABLE_MTA_CAP15)) == 0)
			||
			(tvb_memeql(tvb, optoff, (const guint8*)PACKETCABLE_MTA_CAP20,
				      (int)strlen(PACKETCABLE_MTA_CAP20)) == 0))
		{
			dissect_packetcable_mta_cap(v_tree, pinfo, tvb, optoff, optlen);
		} else
			if ((tvb_memeql(tvb, optoff, (const guint8*)PACKETCABLE_CM_CAP11,
				(int)strlen(PACKETCABLE_CM_CAP11)) == 0)
			||
			(tvb_memeql(tvb, optoff, (const guint8*)PACKETCABLE_CM_CAP20,
				(int)strlen(PACKETCABLE_CM_CAP20)) == 0 ))
		{
			dissect_docsis_cm_cap(v_tree, tvb, optoff, optlen, FALSE);
		} else
			if (tvb_memeql(tvb, optoff, (const guint8*)PACKETCABLE_CM_CAP30,
				(int)strlen(PACKETCABLE_CM_CAP30)) == 0 )
		{
			proto_tree_add_item(v_tree, hf_bootp_option_vendor_class_data, tvb, optoff, optlen, ENC_ASCII|ENC_NA);
		}
		break;

	case 61:	/* Client Identifier */
		if (optlen > 0)
			byte = tvb_get_guint8(tvb, optoff);
		else
			byte = 0;

		/* We *MAY* use hwtype/hwaddr. If we have 7 bytes, I'll
		   guess that the first is the hwtype, and the last 6
		   are the hw addr */
		/* See http://www.iana.org/assignments/arp-parameters */
		/* RFC2132 9.14 Client-identifier has the following to say:
		   A hardware type of 0 (zero) should be used when the value
		   field contains an identifier other than a hardware address
		   (e.g. a fully qualified domain name). */

		if (optlen == 7 && byte > 0 && byte < 48) {
			proto_tree_add_item(v_tree,
					hf_bootp_hw_type, tvb, optoff, 1,
					ENC_NA);

			if (byte == ARPHRD_ETHER || byte == ARPHRD_IEEE802)
				proto_tree_add_item(v_tree,
					hf_bootp_hw_ether_addr, tvb, optoff+1, 6,
					ENC_NA);
			else
				proto_tree_add_string(v_tree, hf_bootp_client_hardware_address, tvb, optoff+1, 6,
					tvb_arphrdaddr_to_str(tvb, optoff+1, 6, byte));
		} else if (optlen == 17 && byte == 0) {
			/* Identifier is a UUID */
			proto_tree_add_item(v_tree, hf_bootp_client_identifier_uuid,
					    tvb, optoff + 1, 16, ENC_LITTLE_ENDIAN);
		/* From RFC 4361 paragraph 6.1 DHCPv4 Client Behavior:
			To send an RFC 3315-style binding identifier in a DHCPv4 'client
			identifier' option, the type of the 'client identifier' option is set
			to 255.	*/
		} else if (byte == 255) {
			guint16	duidtype;
			guint16	hwtype;

			/*	The type field is immediately followed by the IAID, which is
				an opaque 32-bit quantity	*/
			proto_tree_add_string(v_tree, hf_bootp_client_id_iaid, tvb, optoff+1, 4,
				tvb_arphrdaddr_to_str(tvb, optoff+1, 4, byte));
			optoff = optoff + 5;
			duidtype = tvb_get_ntohs(tvb, optoff);
			proto_tree_add_item(v_tree, hf_bootp_client_id_duid_type, tvb, optoff, 2, ENC_BIG_ENDIAN);
			switch (duidtype) {
			case DUID_LLT:
				if (optlen < 8) {
					expert_add_info(pinfo, vti, &ei_bootp_mal_duid);
					break;
				}
				hwtype=tvb_get_ntohs(tvb, optoff + 2);
				proto_tree_add_item(v_tree, hf_bootp_client_identifier_duid_llt_hw_type,
						tvb, optoff + 2, 2, ENC_BIG_ENDIAN);

				/* XXX seconds since Jan 1 2000 */
				proto_tree_add_item(v_tree, hf_bootp_client_identifier_time, tvb, optoff + 4, 4, ENC_BIG_ENDIAN);
				if (optlen > 8) {
					proto_tree_add_string(v_tree, hf_bootp_client_identifier_link_layer_address, tvb, optoff + 8,
						optlen - 13, tvb_arphrdaddr_to_str(tvb, optoff+8, optlen-13, hwtype));
				}
				break;
			case DUID_EN:
				if (optlen < 6) {
					expert_add_info(pinfo, vti, &ei_bootp_mal_duid);
					break;
				}
				proto_tree_add_item(v_tree, hf_bootp_client_identifier_enterprise_num, tvb, optoff + 2, 4, ENC_BIG_ENDIAN);
				if (optlen > 6) {
					proto_tree_add_item(v_tree, hf_bootp_client_identifier, tvb, optoff + 6, optlen - 11, ENC_NA);
				}
				break;
			case DUID_LL:
				if (optlen < 4) {
					expert_add_info(pinfo, vti, &ei_bootp_mal_duid);
					break;
				}
				hwtype=tvb_get_ntohs(tvb, optoff + 2);
				proto_tree_add_item(v_tree, hf_bootp_client_identifier_duid_ll_hw_type,
						tvb, optoff + 2, 2, ENC_BIG_ENDIAN);

				if (optlen > 4) {
					proto_tree_add_string(v_tree, hf_bootp_client_identifier_link_layer_address, tvb, optoff + 4,
						optlen - 9, tvb_arphrdaddr_to_str(tvb, optoff+4, optlen-9, hwtype));
				}
				break;
			}
		} else {
			/* otherwise, it's opaque data */
		}
		break;
	case 77: {	/* User Class Information RFC 3004 */
		guchar user_class_instance_index;
		proto_item *vtix;
		proto_tree *o77_v_tree;
		if (optlen < 2) {
			expert_add_info_format(pinfo, v_tree, &ei_bootp_bad_length, "length isn't >= 2");
			break;
		}
		optleft = optlen;
		for (user_class_instance_index = 0, i = 0, byte = tvb_get_guint8(tvb, optoff); i < optlen; byte = tvb_get_guint8(tvb, optoff + i), user_class_instance_index++) {
			/* Create subtree for instance of User Class. */
			vtix = proto_tree_add_uint_format_value(v_tree, hf_bootp_option77_user_class,
					tvb, optoff + i, byte + 1, user_class_instance_index, "[%d]", user_class_instance_index);
			o77_v_tree = proto_item_add_subtree(vtix, ett_bootp_option77_instance);

			/* Add length for instance of User Class. */
			proto_tree_add_item(o77_v_tree, hf_bootp_option77_user_class_length,
					tvb, optoff + i, 1, ENC_BIG_ENDIAN);

			if (byte == 0) {
				expert_add_info_format(pinfo, vtix, &ei_bootp_bad_length, "UC_Len_%u isn't >= 1 (UC_Len_%u = 0)", user_class_instance_index, user_class_instance_index);
				break;
			}
			optleft -= byte + 1;
			if (optleft < 0) {
				expert_add_info(pinfo, vtix, &ei_bootp_option77_user_class_malformed);
				break;
			}

			/* Add data for instance of User Class. */
			proto_tree_add_item(o77_v_tree, hf_bootp_option77_user_class_data,
					tvb, optoff + i + 1, byte, ENC_NA);

			/* Slide to next instance of User Class if any. */
			i += byte + 1;
		}
		break;
	}
	case 97:	/* Client Identifier (UUID) */
		if (optlen > 0)
			byte = tvb_get_guint8(tvb, optoff);
		else
			byte = 0;

		/* We *MAY* use hwtype/hwaddr. If we have 7 bytes, I'll
		   guess that the first is the hwtype, and the last 6
		   are the hw addr */
		/* See http://www.iana.org/assignments/arp-parameters */
		/* RFC2132 9.14 Client-identifier has the following to say:
		   A hardware type of 0 (zero) should be used when the value
		   field contains an identifier other than a hardware address
		   (e.g. a fully qualified domain name). */

		if (optlen == 7 && byte > 0 && byte < 48) {
			proto_tree_add_item(v_tree,
					hf_bootp_hw_type, tvb, optoff, 1,
					ENC_NA);
			if (byte == ARPHRD_ETHER || byte == ARPHRD_IEEE802)
				proto_tree_add_item(v_tree,
					hf_bootp_hw_ether_addr, tvb, optoff+1, 6,
					ENC_NA);
			else
				proto_tree_add_string(v_tree, hf_bootp_client_hardware_address, tvb, optoff+1, 6,
					tvb_arphrdaddr_to_str(tvb, optoff+1, 6, byte));
		} else if (optlen == 17 && byte == 0) {
			/* Identifier is a UUID */
			proto_tree_add_item(v_tree, hf_bootp_client_identifier_uuid,
					    tvb, optoff + 1, 16, ENC_LITTLE_ENDIAN);
		} else {
			/* otherwise, it's opaque data */
		}
		break;

	case 63:	/* NetWare/IP options (RFC 2242) */

		optend = optoff + optlen;
		while (optoff < optend)
			optoff = dissect_netware_ip_suboption(pinfo, vti, v_tree, tvb, optoff, optend);
		break;

	case 78:	/* SLP Directory Agent Option RFC2610 Added by Greg Morris (gmorris@novell.com)*/
		if (optlen < 1) {
			expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length isn't >= 1");
			break;
		}
		optleft = optlen;
		byte = tvb_get_guint8(tvb, optoff);
		proto_tree_add_item(v_tree, hf_bootp_option_slp_directory_agent_value, tvb, optoff, 1, ENC_BIG_ENDIAN);

		optoff++;
		optleft--;
		if (byte == 0x80) {
			if (optleft == 0)
				break;
			optoff++;
			optleft--;
		}
		for (i = optoff; optleft > 0; i += 4, optleft -= 4) {
			if (optleft < 4) {
				expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "Option length isn't a multiple of 4");
				break;
			}

			proto_tree_add_item(v_tree, hf_bootp_option_slp_directory_agent_slpda_address, tvb, i, 4, ENC_BIG_ENDIAN);
		}
		break;

	case 79:	/* SLP Service Scope Option RFC2610 Added by Greg Morris (gmorris@novell.com)*/
		proto_tree_add_item(v_tree, hf_bootp_option_slp_service_scope_value, tvb, optoff, 1, ENC_BIG_ENDIAN);

		optoff++;
		optleft = optlen - 1;
		proto_tree_add_item(v_tree, hf_bootp_option_slp_service_scope_string, tvb, optoff, optleft, ENC_ASCII|ENC_NA);
		break;

	case 81:	/* Client Fully Qualified Domain Name */
		{
		static const int * fqdn_hf_flags[] = {
			&hf_bootp_fqdn_mbz,
			&hf_bootp_fqdn_n,
			&hf_bootp_fqdn_e,
			&hf_bootp_fqdn_o,
			&hf_bootp_fqdn_s,
			NULL
		};

		if (optlen < 3) {
			expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length isn't >= 3");
			break;
		}

		fqdn_flags = tvb_get_guint8(tvb, optoff);
		proto_tree_add_bitmask(v_tree, tvb, optoff, hf_bootp_fqdn_flags,
					ett_bootp_fqdn_flags, fqdn_hf_flags, ENC_BIG_ENDIAN);

		/* XXX: use code from packet-dns for return code decoding */
		proto_tree_add_item(v_tree, hf_bootp_fqdn_rcode1, tvb, optoff+1, 1, ENC_BIG_ENDIAN);
		/* XXX: use code from packet-dns for return code decoding */
		proto_tree_add_item(v_tree, hf_bootp_fqdn_rcode2, tvb, optoff+2, 1, ENC_BIG_ENDIAN);
		if (optlen > 3) {
			if (fqdn_flags & F_FQDN_E) {
				get_dns_name(tvb, optoff+3, optlen-3, optoff+3, &dns_name);
				proto_tree_add_string(v_tree, hf_bootp_fqdn_name,
				    tvb, optoff+3, optlen-3, dns_name);
			} else {
				proto_tree_add_item(v_tree, hf_bootp_fqdn_asciiname,
				    tvb, optoff+3, optlen-3, ENC_ASCII|ENC_NA);
			}
		}
		}
		break;

	case 82:	/* Relay Agent Information Option */
		optend = optoff + optlen;
		while (optoff < optend)
			optoff = bootp_dhcp_decode_agent_info(pinfo, vti, v_tree, tvb, optoff, optend);
		break;

	case 85:	/* Novell Servers (RFC 2241) */
		/* Option 85 can be sent as a string */
		/* Added by Greg Morris (gmorris[AT]novell.com) */
		if (novell_string) {
			proto_tree_add_item(v_tree, hf_bootp_option_novell_dss_string, tvb, optoff, optlen, ENC_ASCII|ENC_NA);
		} else{
			/* IP addresses */
			for (i = optoff, optleft = optlen; optleft > 0;
				i += 4, optleft -= 4) {
				if (optleft < 4) {
					expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "Option length isn't a multiple of 4");
					break;
				}

				proto_tree_add_item(v_tree, hf_bootp_option_novell_dss_ip, tvb, i, 4, ENC_BIG_ENDIAN);
			}
		}
		break;

	case 94: {	/* Client network interface identifier */
		guint8 id_type;

		id_type = tvb_get_guint8(tvb, optoff);

		if (id_type == 0x01) {
			proto_tree_add_item(v_tree, hf_bootp_option_client_network_id_major_ver,
								tvb, optoff + 1, 1, ENC_LITTLE_ENDIAN);
			proto_tree_add_item(v_tree, hf_bootp_option_client_network_id_minor_ver,
								tvb, optoff + 2, 1, ENC_LITTLE_ENDIAN);
		}

		break;
	}

	case 90:	/* DHCP Authentication */
	case 210:	/* Was this used for authentication at one time? */
		if (optlen < 11) {
			expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length isn't >= 11");
			break;
		}
		optleft = optlen;
		protocol = tvb_get_guint8(tvb, optoff);

		proto_tree_add_item(v_tree, hf_bootp_option_dhcp_authentication_protocol, tvb, optoff, 1, ENC_BIG_ENDIAN);
		optoff++;
		optleft--;

		algorithm = tvb_get_guint8(tvb, optoff);
		switch (protocol) {

		case AUTHEN_PROTO_DELAYED_AUTHEN:
			proto_tree_add_item(v_tree, hf_bootp_option_dhcp_authentication_alg_delay, tvb, optoff, 1, ENC_BIG_ENDIAN);
			break;

		default:
			proto_tree_add_item(v_tree, hf_bootp_option_dhcp_authentication_algorithm, tvb, optoff, 1, ENC_BIG_ENDIAN);
			break;
		}
		optoff++;
		optleft--;

		rdm = tvb_get_guint8(tvb, optoff);
		proto_tree_add_item(v_tree, hf_bootp_option_dhcp_authentication_rdm, tvb, optoff, 1, ENC_BIG_ENDIAN);
		optoff++;
		optleft--;

		switch (rdm) {

		case AUTHEN_RDM_MONOTONIC_COUNTER:
			proto_tree_add_item(v_tree, hf_bootp_option_dhcp_authentication_rdm_replay_detection, tvb, optoff, 8, ENC_BIG_ENDIAN);
			break;

		default:
			proto_tree_add_item(v_tree, hf_bootp_option_dhcp_authentication_rdm_rdv, tvb, optoff, 8, ENC_ASCII|ENC_NA);
			break;
		}
		optoff += 8;
		optleft -= 8;

		switch (protocol) {

		case AUTHEN_PROTO_DELAYED_AUTHEN:
			switch (algorithm) {

			case AUTHEN_DELAYED_ALGO_HMAC_MD5:
				if (*dhcp_type_p && !strcmp(*dhcp_type_p, OPT53_DISCOVER)) {
					/* Discover has no Secret ID nor HMAC MD5 Hash */
					break;
				} else {
					if (optlen < 31) {
						expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length isn't >= 31");
						break;
					}

					proto_tree_add_item(v_tree, hf_bootp_option_dhcp_authentication_secret_id, tvb, optoff, 4, ENC_BIG_ENDIAN);
					optoff += 4;
					/*optleft -= 4;*/
					proto_tree_add_item(v_tree, hf_bootp_option_dhcp_authentication_hmac_md5_hash, tvb, optoff, 16, ENC_ASCII|ENC_NA);
					break;
				}

			default:
				if (optleft == 0)
					break;

				proto_tree_add_item(v_tree, hf_bootp_option_dhcp_authentication_information, tvb, optoff, optleft, ENC_ASCII|ENC_NA);
				break;
			}
			break;

		default:
			if (optleft == 0)
				break;

			proto_tree_add_item(v_tree, hf_bootp_option_dhcp_authentication_information, tvb, optoff, optleft, ENC_ASCII|ENC_NA);
			break;
		}
		break;

	case 99: /* civic location (RFC 4776) */

		optleft = optlen;
		if (optleft >= 3)
		{
			proto_tree_add_item(v_tree, hf_bootp_option_civic_location_what, tvb, optoff, 1, ENC_BIG_ENDIAN);
			proto_tree_add_item(v_tree, hf_bootp_option_civic_location_country, tvb, optoff+1, 2, ENC_ASCII|ENC_NA);
			optleft = optleft - 3;
			optoff = optoff + 3;

			while (optleft >= 2)
			{
				int calength = tvb_get_guint8(tvb, optoff+1);
				proto_tree_add_item(v_tree, hf_bootp_option_civic_location_ca_type, tvb, optoff, 1, ENC_BIG_ENDIAN);
				proto_tree_add_item(v_tree, hf_bootp_option_civic_location_ca_length, tvb, optoff+1, 1, ENC_BIG_ENDIAN);

				optoff += 2;
				optleft -= 2;

				if (calength == 0)
					continue;

				if (optleft >= calength)
				{
					proto_tree_add_item(v_tree, hf_bootp_option_civic_location_ca_value, tvb, optoff, calength, ENC_ASCII|ENC_NA);

					optoff = optoff + calength;
					optleft = optleft - calength;
				}
				else
				{
					optleft = 0;
					expert_add_info(pinfo, vti, &ei_bootp_option_civic_location_bad_cattype);
				}
			}
		}
		break;

	case 117:   /* The Name Service Search Option for DHCP (RFC 2937) */
		if (optlen < 2) {
			expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length isn't >= 2");
		} else if (optlen & 1) {
			expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length (%u) isn't even number", optlen);
		} else {
			guint16 ns;
			for (i = 0, ns = tvb_get_ntohs(tvb, optoff); i < optlen; i += 2, ns = tvb_get_ntohs(tvb, optoff + i)) {
				switch (ns) {
				case RFC2937_LOCAL_NAMING_INFORMATION:
					proto_tree_add_string(v_tree, hf_bootp_option_dhcp_name_service_search_option, tvb, optoff + i, 2, "Local naming information (e.g., an /etc/hosts file on a UNIX machine) (0)");
					break;
				case RFC2937_DOMAIN_NAME_SERVER_OPTION:
					proto_tree_add_string(v_tree, hf_bootp_option_dhcp_name_service_search_option, tvb, optoff + i, 2, "Domain Name Server Option (6)");
					break;
				case RFC2937_NETWORK_INFORMATION_SERVERS_OPTION:
					proto_tree_add_string(v_tree, hf_bootp_option_dhcp_name_service_search_option, tvb, optoff + i, 2, "Network Information Servers Option (41)");
					break;
				case RFC2937_NETBIOS_OVER_TCP_IP_NAME_SERVER_OPTION:
					proto_tree_add_string(v_tree, hf_bootp_option_dhcp_name_service_search_option, tvb, optoff + i, 2, "NetBIOS over TCP/IP Name Server Option (44)");
					break;
				case RFC2937_NETWORK_INFORMATION_SERVICE_PLUS_SERVERS_OPTION:
					proto_tree_add_string(v_tree, hf_bootp_option_dhcp_name_service_search_option, tvb, optoff + i, 2, "Network Information Service+ Servers Option (65)");
					break;
				default:
					expert_add_info_format(pinfo, vti, &ei_bootp_option_dhcp_name_service_invalid,
								"Invalid Name Service (%u). RFC 2937 defines only 0, 6, 41, 44, and 65 as possible values.", ns);
					break;
				}
			}
		}
		break;

	case 119: { /* Dynamic Host Configuration Protocol (DHCP) Domain Search Option (RFC 3397) */
		    /* Encoding Long Options in the Dynamic Host Configuration Protocol (DHCPv4) (RFC 3396) */
		    /* Domain Names - Implementation And Specification (RFC 1035) */
		char tmpChar[BOOTP_MAX_NO_CHAR];
		rfc3396_dns_domain_search_list.index_current_block++;
		if (rfc3396_dns_domain_search_list.total_number_of_block > 1) {
			g_snprintf(tmpChar, BOOTP_MAX_NO_CHAR, "%u/%u", rfc3396_dns_domain_search_list.index_current_block, rfc3396_dns_domain_search_list.total_number_of_block);
			proto_tree_add_string(v_tree, hf_bootp_option_dhcp_dns_domain_search_list_rfc_3396_detected, tvb, optoff, optlen, tmpChar);
			if (rfc3396_dns_domain_search_list.index_current_block != rfc3396_dns_domain_search_list.total_number_of_block) {
				g_snprintf(tmpChar, BOOTP_MAX_NO_CHAR, "%u/%u", rfc3396_dns_domain_search_list.total_number_of_block, rfc3396_dns_domain_search_list.total_number_of_block);
				proto_tree_add_string(v_tree, hf_bootp_option_dhcp_dns_domain_search_list_refer_last_option, tvb, optoff, optlen, tmpChar);
			}
		}

		if (rfc3396_dns_domain_search_list.tvb_composite == NULL && optlen) {
			/* We use composite tvb for managing RFC 3396 */
			rfc3396_dns_domain_search_list.tvb_composite = tvb_new_composite();
		}

		/* Concatenate the block before being interpreted for managing RFC 3396 */
		if (optlen)
			tvb_composite_append(rfc3396_dns_domain_search_list.tvb_composite, tvb_new_subset_length(tvb, optoff, optlen));

		if (rfc3396_dns_domain_search_list.index_current_block == rfc3396_dns_domain_search_list.total_number_of_block
		    && rfc3396_dns_domain_search_list.tvb_composite) {
			/* Here, we are into the last (or unique) option 119. */
			/* We will display the information about fqdn */
			unsigned int consumedx = 0;
			unsigned int offset = 0;
			tvb_composite_finalize(rfc3396_dns_domain_search_list.tvb_composite);

			while (offset < tvb_reported_length(rfc3396_dns_domain_search_list.tvb_composite)) {
				/* use the get_dns_name method that manages all techniques of RFC 1035 (compression pointer and so on) */
				consumedx = get_dns_name(rfc3396_dns_domain_search_list.tvb_composite, offset, tvb_reported_length(rfc3396_dns_domain_search_list.tvb_composite), 0, &dns_name);
				if (rfc3396_dns_domain_search_list.total_number_of_block == 1) {
					/* RFC 3396 is not used, so we can easily link the fqdn with v_tree. */
					proto_tree_add_string(v_tree, hf_bootp_option_dhcp_dns_domain_search_list_fqdn, tvb, optoff + offset, consumedx, dns_name);
				} else {
					/* RFC 3396 is used, so the option is split into several option 119. We don't link fqdn with v_tree. */
					proto_tree_add_string(v_tree, hf_bootp_option_dhcp_dns_domain_search_list_fqdn, tvb, 0, 0, dns_name);
				}
				offset += consumedx;
			}
			rfc3396_dns_domain_search_list.tvb_composite = NULL;
		}
		break;
	}
	case 120: { /* SIP Servers (RFC 3361) */
		    /* Encoding Long Options in the Dynamic Host Configuration Protocol (DHCPv4) (RFC 3396) */
		    /* Domain Names - Implementation And Specification (RFC 1035) */
		char tmpChar[BOOTP_MAX_NO_CHAR];
		rfc3396_sip_server.index_current_block++;
		if (rfc3396_sip_server.total_number_of_block > 1) {
			g_snprintf(tmpChar, BOOTP_MAX_NO_CHAR, "%u/%u", rfc3396_sip_server.index_current_block, rfc3396_sip_server.total_number_of_block);
			proto_tree_add_string(v_tree, hf_bootp_option_sip_server_rfc_3396_detected, tvb, optoff, optlen, tmpChar);
			if (rfc3396_sip_server.index_current_block != rfc3396_sip_server.total_number_of_block) {
				g_snprintf(tmpChar, BOOTP_MAX_NO_CHAR, "%u/%u", rfc3396_sip_server.total_number_of_block, rfc3396_sip_server.total_number_of_block);
				proto_tree_add_string(v_tree, hf_bootp_option_sip_server_refer_last_option, tvb, optoff, optlen, tmpChar);
			}
		}

		if (rfc3396_sip_server.tvb_composite == NULL && optlen) {
			/* We use composite tvb for managing RFC 3396 */
			rfc3396_sip_server.tvb_composite = tvb_new_composite();
		}

		/* Concatenate the block before being interpreted for managing RFC 3396 */
		if (optlen)
			tvb_composite_append(rfc3396_sip_server.tvb_composite, tvb_new_subset_length(tvb, optoff, optlen));

		if (rfc3396_sip_server.index_current_block == rfc3396_sip_server.total_number_of_block
		    && rfc3396_sip_server.tvb_composite) {
			/* Here, we are into the last (or unique) option 120. */
			/* We will display the information about SIP server */
			guint8 enc;
			unsigned int offset = 1; /* ignore enc */
			tvb_composite_finalize(rfc3396_sip_server.tvb_composite);

			enc = tvb_get_guint8(rfc3396_sip_server.tvb_composite, 0);
			if (rfc3396_sip_server.total_number_of_block == 1) {
				/* RFC 3396 is not used, so we can easily link the fqdn with v_tree. */
				proto_tree_add_uint(v_tree, hf_bootp_option_sip_server_enc, tvb, optoff, 1, enc);
			} else {
				/* RFC 3396 is used, so the option is split into several option 120. We don't link fqdn with v_tree. */
				proto_tree_add_uint(v_tree, hf_bootp_option_sip_server_enc, tvb, 0, 0, enc);
			}

			switch (enc) {
			case RFC_3361_ENC_FQDN: {
				unsigned int consumedx = 0;
				if (tvb_reported_length(rfc3396_sip_server.tvb_composite) < 3) {
					expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length isn't >= 3 (len = %u)", tvb_reported_length(rfc3396_sip_server.tvb_composite));
					break;
				}

				while (offset < tvb_reported_length(rfc3396_sip_server.tvb_composite)) {
					/* use the get_dns_name method that manages all techniques of RFC 1035 (compression pointer and so on) */
					consumedx = get_dns_name(rfc3396_sip_server.tvb_composite, offset, tvb_reported_length(rfc3396_sip_server.tvb_composite), 1 /* ignore enc */, &dns_name);

					if (rfc3396_sip_server.total_number_of_block == 1) {
						/* RFC 3396 is not used, so we can easily link the fqdn with v_tree. */
						proto_tree_add_string(v_tree, hf_bootp_option_sip_server_name, tvb, optoff + offset, consumedx, dns_name);
					} else {
						/* RFC 3396 is used, so the option is split into several option 120. We don't link fqdn with v_tree. */
						proto_tree_add_string(v_tree, hf_bootp_option_sip_server_name, tvb, 0, 0, dns_name);
					}
					offset += consumedx;
				}
				rfc3396_sip_server.tvb_composite = NULL;
				break;
			}
			case RFC_3361_ENC_IPADDR:
				if (tvb_reported_length(rfc3396_sip_server.tvb_composite) < 5) {
					expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length isn't >= 5 (len = %u)", tvb_reported_length(rfc3396_sip_server.tvb_composite));
					break;
				}
				/* x % 2^n == x & (2^n - 1) note : (assuming x is a positive integer) */
				if ((tvb_reported_length(rfc3396_sip_server.tvb_composite) - 1) & 3) {
					if (rfc3396_sip_server.total_number_of_block == 1)
						expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length isn't a multiple of 4 plus 1 (len = %u).", tvb_reported_length(rfc3396_sip_server.tvb_composite));
					else
						expert_add_info_format(pinfo, vti, &ei_bootp_bad_length,
							"length isn't a multiple of 4 plus 1 (len = %u). For your information with RFC 3396, the length is the length sum of all options 120 into this BOOTP packet.",
							tvb_reported_length(rfc3396_sip_server.tvb_composite));
					break;
				}
				while (offset < tvb_reported_length(rfc3396_sip_server.tvb_composite)) {
					if (rfc3396_sip_server.total_number_of_block == 1) {
						/* RFC 3396 is not used, so we can easily link the fqdn with v_tree. */
						proto_tree_add_item(v_tree, hf_bootp_option_sip_server_address, rfc3396_sip_server.tvb_composite, offset, 4, ENC_BIG_ENDIAN);
					} else {
						/* RFC 3396 is used, so the option is split into several option 120. We don't link fqdn with v_tree. */
						/* Since we don't use the "numbered argument" as described by README.developer, we have to repeat the arguments :( */
						g_snprintf(tmpChar, BOOTP_MAX_NO_CHAR, "%u.%u.%u.%u (%u.%u.%u.%u)",
							   tvb_get_guint8(rfc3396_sip_server.tvb_composite, offset),
							   tvb_get_guint8(rfc3396_sip_server.tvb_composite, offset + 1),
							   tvb_get_guint8(rfc3396_sip_server.tvb_composite, offset + 2),
							   tvb_get_guint8(rfc3396_sip_server.tvb_composite, offset + 3),
							   tvb_get_guint8(rfc3396_sip_server.tvb_composite, offset),
							   tvb_get_guint8(rfc3396_sip_server.tvb_composite, offset + 1),
							   tvb_get_guint8(rfc3396_sip_server.tvb_composite, offset + 2),
							   tvb_get_guint8(rfc3396_sip_server.tvb_composite, offset + 3)
							   );
						proto_tree_add_string(v_tree, hf_bootp_option_sip_server_address_stringz, tvb, 0, 0, tmpChar);
					}
					offset += 4;
				}
				break;
			default:
				expert_add_info_format(pinfo, vti, &ei_bootp_option_sip_server_address_encoding, "RFC 3361 defines only 0 and 1 for Encoding byte (Encoding = %u).", enc);
				break;
			}
		}
		break;
	}
	case 121:	/* Classless Static Route */
	case 249: {	/* Classless Static Route (Microsoft) */
		int mask_width, significant_octets;
		optend = optoff + optlen;
		/* minimum length is 5 bytes */
		if (optlen < 5) {
			expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length isn't >= 5");
			break;
		}
		while (optoff < optend) {
			mask_width = tvb_get_guint8(tvb, optoff);
			/* mask_width <= 32 */
			if (mask_width > 32) {
				expert_add_info_format(pinfo, vti, &ei_bootp_option_classless_static_route, "Mask width (%d) > 32", mask_width);
				break;
			}
			significant_octets = (mask_width + 7) / 8;
			vti = proto_tree_add_bytes_format(v_tree, hf_bootp_option_classless_static_route, tvb, optoff,
				1 + significant_octets + 4, NULL,
				" ");
			optoff++;
			/* significant octets + router(4) */
			if (optend < optoff + significant_octets + 4) {
				expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "Remaining length (%d) < %d bytes", optend - optoff, significant_octets + 4);
				break;
			}
			if(mask_width == 0)
				proto_item_append_text(vti, "default");
			else {
				for(i = 0 ; i < significant_octets ; i++) {
					if (i > 0)
						proto_item_append_text(vti, ".");
					byte = tvb_get_guint8(tvb, optoff++);
					proto_item_append_text(vti, "%d", byte);
				}
				for(i = significant_octets ; i < 4 ; i++)
					proto_item_append_text(vti, ".0");
				proto_item_append_text(vti, "/%d", mask_width);
			}
			proto_item_append_text(vti, "-%s", tvb_ip_to_str(tvb, optoff));
			optoff += 4;
		}
		break;
	}

	case 123: /* coordinate based location RFC 3825 or CableLabs DSS_ID  */
		if (optlen == 16) {
			int c;
			unsigned char lci[16];
			struct rfc3825_location_fixpoint_t location_fp;
			struct rfc3825_location_decimal_t location;

			for (c=0; c < 16;c++)
				lci[c] = (unsigned char) tvb_get_guint8(tvb, optoff + c);

			/* convert lci encoding into fixpoint location */
			rfc3825_lci_to_fixpoint(lci, &location_fp);

			/* convert location from decimal to fixpoint */
			i = rfc3825_fixpoint_to_decimal(&location_fp, &location);

			if (i != RFC3825_NOERROR) {
				ti = proto_tree_add_uint(v_tree, hf_bootp_option_rfc3825_error, tvb, optoff, 1, i);
			proto_item_set_len(ti, optlen);
			} else {
				proto_tree_add_double_format_value(v_tree, hf_bootp_option_rfc3825_latitude, tvb, optoff, 5, location.latitude, "%15.10f", location.latitude);
				proto_tree_add_double_format_value(v_tree, hf_bootp_option_rfc3825_longitude, tvb, optoff+5, 5, location.longitude, "%15.10f", location.longitude);
				proto_tree_add_double_format_value(v_tree, hf_bootp_option_rfc3825_latitude_res, tvb, optoff, 1, location.latitude_res, "%15.10f", location.latitude_res);
				proto_tree_add_double_format_value(v_tree, hf_bootp_option_rfc3825_longitude_res, tvb, optoff+5, 1, location.longitude_res, "%15.10f", location.longitude_res);
				proto_tree_add_double_format_value(v_tree, hf_bootp_option_rfc3825_altitude, tvb, optoff+12, 4, location.altitude, "%15.10f", location.altitude);
				proto_tree_add_double_format_value(v_tree, hf_bootp_option_rfc3825_altitide_res, tvb, optoff+10, 2, location.altitude_res, "%15.10f", location.altitude_res);
				proto_tree_add_uint(v_tree, hf_bootp_option_rfc3825_altitude_type, tvb, optoff+10, 1, location.altitude_type);
				proto_tree_add_uint(v_tree, hf_bootp_option_rfc3825_map_datum, tvb, optoff+15, 1, location.datum_type);
			}
		} else if (optlen < 69) { /* CableLabs DSS_ID */

			proto_tree_add_item(v_tree, hf_bootp_option_cl_dss_id_option, tvb, optoff, 1, ENC_BIG_ENDIAN);
			proto_tree_add_item(v_tree, hf_bootp_option_cl_dss_id_len, tvb, optoff+1, 1, ENC_BIG_ENDIAN);
			s_len = tvb_get_guint8(tvb, optoff+1);
			proto_tree_add_item(v_tree, hf_bootp_option_cl_dss_id, tvb, optoff+2, s_len, ENC_ASCII|ENC_NA);

			if (optlen > s_len+2) { /* Second DSS_ID*/

				proto_tree_add_item(v_tree, hf_bootp_option_cl_dss_id_option, tvb, optoff+2+s_len, 1, ENC_BIG_ENDIAN);
				proto_tree_add_item(v_tree, hf_bootp_option_cl_dss_id_len, tvb, optoff+1+2+s_len, 1, ENC_BIG_ENDIAN);
				s_len = tvb_get_guint8(tvb, optoff+1+2+s_len);
				proto_tree_add_item(v_tree, hf_bootp_option_cl_dss_id, tvb, optoff+2+2+s_len, s_len, ENC_ASCII|ENC_NA);
			}
		} else {
			expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "Invalid length of DHCP option!");
		}
		break;

	case 124: {	/* V-I Vendor Class */
		int data_len;

		if (optlen == 1) {
			/* CableLab specific */
			proto_tree_add_item(v_tree, hf_bootp_option_vi_class_cl_address_mode, tvb, optoff, optlen, ENC_BIG_ENDIAN);
			break;
		}

		optleft = optlen;

		while (optleft > 0) {

			if (optleft < 5) {
				expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length < 5");
				break;
			}

			proto_tree_add_item(v_tree, hf_bootp_option_vi_class_enterprise, tvb, optoff, 4, ENC_BIG_ENDIAN);
			proto_tree_add_item(v_tree, hf_bootp_option_vi_class_data_length, tvb, optoff, 1, ENC_BIG_ENDIAN);
			data_len = tvb_get_guint8(tvb, optoff + 4);

			optoff += 5;
			optleft -= 5;

			proto_tree_add_item(v_tree, hf_bootp_option_vi_class_data, tvb, optoff, data_len, ENC_ASCII|ENC_NA);

			/* look for next enterprise number */
			optoff += data_len;
			optleft -= data_len;
		}
		break;
	}

	case 125: {	/* V-I Vendor-specific Information */
		int enterprise = 0;
		int s_end = 0;
		int s_option_len = 0;
		proto_tree *e_tree = 0;

		optend = optoff + optlen;
		optleft = optlen;

		while (optleft > 0) {

			if (optleft < 5) {
				expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "length < 5");
				break;
			}

			enterprise = tvb_get_ntohl(tvb, optoff);
			vti = proto_tree_add_item(v_tree, hf_bootp_option125_enterprise, tvb, optoff, 4, ENC_BIG_ENDIAN);

			s_option_len = tvb_get_guint8(tvb, optoff + 4);

			optoff += 5;
			optleft -= 5;

			/* Handle DSL Forum TR-111 Option 125 */
			switch (enterprise) {

			case 3561: /* ADSL Forum */
				s_end = optoff + s_option_len;
				if ( s_end > optend ) {
					expert_add_info_format(pinfo, vti, &ei_bootp_option125_enterprise_malformed, "no room left in option for enterprise %u data", enterprise);
					break;
				}

				e_tree = proto_item_add_subtree(vti, ett_bootp_option);
				while (optoff < s_end) {

				optoff = dissect_vendor_tr111_suboption(pinfo, vti, e_tree, tvb, optoff, s_end);
			}
			break;

			case 4491: /* CableLab */
				s_end = optoff + s_option_len;
				if ( s_end > optend ) {
					expert_add_info_format(pinfo, vti, &ei_bootp_option125_enterprise_malformed, "no room left in option for enterprise %u data", enterprise);
					break;
				}

				e_tree = proto_item_add_subtree(vti, ett_bootp_option);
				while (optoff < s_end) {
					optoff = dissect_vendor_cl_suboption(pinfo, vti, e_tree, tvb, optoff, s_end);
			}
			break;

			default:
				s_end = optoff + s_option_len;
				if ( s_end > optend ) {
					expert_add_info_format(pinfo, vti, &ei_bootp_option125_enterprise_malformed, "no room left in option for enterprise %u data", enterprise);
					break;
				}

				e_tree = proto_item_add_subtree(vti, ett_bootp_option);
				while (optoff < s_end) {

				optoff = dissect_vendor_generic_suboption(pinfo, vti, e_tree, tvb, optoff, s_end);
			}
			break;
			}

			optleft -= s_option_len;
		}
		break;
	}

	case 212: {	/* 6RD option (RFC 5969) */
		if (optlen < 22) {
			expert_add_info(pinfo, vti, &ei_bootp_option_6RD_malformed);
			break;
		}

		proto_tree_add_item(v_tree, hf_bootp_option_6RD_ipv4_mask_len, tvb, optoff, 1, ENC_BIG_ENDIAN);
		proto_tree_add_item(v_tree, hf_bootp_option_6RD_prefix_len, tvb, optoff+1, 1, ENC_BIG_ENDIAN);
		proto_tree_add_item(v_tree, hf_bootp_option_6RD_prefix, tvb, optoff+2, 16, ENC_NA);
		proto_tree_add_item(v_tree, hf_bootp_option_6RD_border_relay_ip, tvb, optoff+18, 4, ENC_BIG_ENDIAN);

		/* More Border Relay IPv4 addresses included */
		if (optlen > 22) {
			optoff += 22;
			for (i = optoff, optleft = optlen - 22; optleft > 0; i += 4, optleft -= 4) {
				if (optleft < 4) {
					expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "Option length isn't a multiple of 4");
					break;
				}

				proto_tree_add_item(v_tree, hf_bootp_option_6RD_border_relay_ip, tvb, i, 4, ENC_BIG_ENDIAN);
			}
		}
		break;
	}

	case 242: {	/* Avaya IP Telephone */
		proto_tree *o242avaya_v_tree;
		proto_item *avaya_ti;
		gchar *avaya_option = NULL;
		gchar *field = NULL;
		wmem_strbuf_t *avaya_param_buf = NULL;

		/* minimum length is 5 bytes */
		if (optlen < 5) {
			expert_add_info_format(pinfo, vti, &ei_bootp_bad_length, "Avaya IP Telephone option length isn't >= 5");
			optoff += optlen;
			break;
		}
		avaya_option = (gchar*)tvb_get_string_enc(wmem_packet_scope(), tvb, optoff, optlen, ENC_ASCII);
		avaya_ti = proto_tree_add_string(v_tree, hf_bootp_option242_avaya, tvb, optoff, optlen, avaya_option);
		o242avaya_v_tree = proto_item_add_subtree(avaya_ti, ett_bootp_option242_suboption);
		avaya_param_buf = wmem_strbuf_new(wmem_packet_scope(), "");
		for ( field = strtok(avaya_option, ","); field; field = strtok(NULL, ",") ) {
			if (!strchr(field, '=')) {
				if (wmem_strbuf_get_len(avaya_param_buf) == 0) {
					expert_add_info_format(pinfo, vti, &hf_bootp_subopt_unknown_type, "ERROR, Unknown parameter %s", field);
					optoff += (int)strlen(field);
					break;
				}
				wmem_strbuf_append_printf(avaya_param_buf,",%s", field);
			}
			else {
				if (wmem_strbuf_get_len(avaya_param_buf) > 0) {
					dissect_vendor_avaya_param(o242avaya_v_tree, pinfo, vti, tvb, optoff, avaya_param_buf);
					optoff += (int)wmem_strbuf_get_len(avaya_param_buf) + 1;
					wmem_strbuf_truncate(avaya_param_buf, 0);
				}
				wmem_strbuf_append(avaya_param_buf, field);
			}
		}
		if (wmem_strbuf_get_len(avaya_param_buf) > 0) {
			dissect_vendor_avaya_param(o242avaya_v_tree, pinfo, vti, tvb, optoff, avaya_param_buf);
		}
		break;
	}

	default:	/* not special */
		/* The PacketCable CCC option number can vary.	If this is a CCC option,
		   handle it as a special.
		 */
		if (code == pkt_ccc_option) {
			ftype = special;
			proto_item_append_text(vti,
				"CableLabs Client Configuration (%d bytes)",
				optlen);
			optend = optoff + optlen;
			while (optoff < optend) {
				switch (pkt_ccc_protocol_version) {

				case PACKETCABLE_CCC_I05:
					optoff = dissect_packetcable_i05_ccc(pinfo, vti, v_tree, tvb, optoff, optend);
					break;
				case PACKETCABLE_CCC_DRAFT5:
				case PACKETCABLE_CCC_RFC_3495:
					optoff = dissect_packetcable_ietf_ccc(pinfo, vti, v_tree, tvb, optoff, optend, pkt_ccc_protocol_version);
					break;
				default: /* XXX Should we do something here? */
					break;
				}
			}
		} else {
			option_handled = FALSE;
		}

		break;
	}

	basictype_consumed = bootp_handle_basic_types(pinfo, v_tree, vti, tvb, ftype,
						      optoff, optlen, opt->phf, &default_hfs);

	if ((basictype_consumed == 0) && (option_handled == FALSE) &&
	    (opt->phf == NULL) && (optlen > 0)) {
		proto_tree_add_item(v_tree, hf_bootp_option_value, tvb, voff+2, optlen, ENC_NA);
	}

	return consumed;
}
