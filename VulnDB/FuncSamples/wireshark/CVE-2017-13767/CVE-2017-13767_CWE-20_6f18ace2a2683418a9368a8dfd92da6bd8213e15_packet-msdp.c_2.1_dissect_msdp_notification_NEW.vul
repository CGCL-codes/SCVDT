static void dissect_msdp_notification(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset, guint16 tlv_len)
{
        guint8              error, error_sub;
        const value_string *vals;
        gint reported_length;
        tvbuff_t *next_tvb;

        if (tlv_len < 1)
                return;
        proto_tree_add_item(tree, hf_msdp_not_o, tvb, *offset, 1, ENC_BIG_ENDIAN);
        proto_tree_add_item(tree, hf_msdp_not_error, tvb, *offset, 1, ENC_BIG_ENDIAN);
        error = tvb_get_guint8(tvb, *offset);
        error &= 0x7F;             /* Error is 7-bit field. O-bit is bit 8 */
        *offset += 1;
        tlv_len -= 1;

        /* Depending on the Error Code, we collect the correct
         * value_strings for the Error subcode
         */
        switch (error) {
        case MESSAGE_HEADER_ERROR:
                vals = hdr_error_vals;
                break;
        case SA_REQUEST_ERROR:
                vals = sa_req_error_vals;
                break;
        case SA_MESSAGE_SA_RESPONSE_ERROR:
                vals = sa_msg_error_vals;
                break;
        case FSM_ERROR:
                vals = fsm_error_vals;
                break;
        case HOLD_TIMER_EXPIRED:
        case NOTIFICATION:
        case CEASE:
                vals = sa_unspec_error_vals;
                break;
        default:
                vals = sa_unspec_error_vals;
                break;
        }

        if (tlv_len < 1)
                return;
        error_sub = tvb_get_guint8(tvb, *offset);
        proto_tree_add_uint_format_value(tree, hf_msdp_not_error_sub, tvb, *offset, 1,
                                   error_sub, "%s (%u)",
                                   val_to_str_const(error_sub, vals, "<Unknown Error subcode>"),
                                   error_sub);
        *offset += 1;
        tlv_len -= 1;

        /* Do switch again, this time to dissect the data portion
         * correctly. Ugly.
         */
        switch (error) {
        case SA_REQUEST_ERROR:
                if (tlv_len < 7) {
                        *offset += tlv_len;
                        return;
                }
                add_notification_data_ipv4addr(tvb, tree, offset, hf_msdp_not_group_address);
                tlv_len -= 7;
                break;
        case SA_MESSAGE_SA_RESPONSE_ERROR:
                if (error_sub == 0) {
                        break;
                } else if (error_sub == 1) {
                        if (tlv_len < 1)
                                return;
                        proto_tree_add_item(tree, hf_msdp_not_entry_count, tvb, *offset, 1, ENC_BIG_ENDIAN);
                        *offset += 1;
                        tlv_len -= 1;
                        break;
                } else if (error_sub == 2) {
                        if (tlv_len < 7) {
                                *offset += tlv_len;
                                return;
                        }
                        add_notification_data_ipv4addr(tvb, tree, offset, hf_msdp_not_rp_address);
                        tlv_len -= 7;
                        break;
                } else if (error_sub == 3 || error_sub == 8) {
                        if (tlv_len < 7) {
                                *offset += tlv_len;
                                return;
                        }
                        add_notification_data_ipv4addr(tvb, tree, offset, hf_msdp_not_group_address);
                        tlv_len -= 7;
                        break;
                } else if (error_sub == 4) {
                        if (tlv_len < 7) {
                                *offset += tlv_len;
                                return;
                        }
                        add_notification_data_ipv4addr(tvb, tree, offset, hf_msdp_not_source_address);
                        tlv_len -= 7;
                        break;
                } else if (error_sub == 5) {
                        if (tlv_len < 1)
                                return;
                        proto_tree_add_item(tree, hf_msdp_not_sprefix_len, tvb, *offset, 1, ENC_BIG_ENDIAN);
                        *offset += 1;
                        tlv_len -= 1;
                        break;
                } else if (error_sub == 6) {
                        if (tlv_len > 0) {
                                reported_length = tvb_reported_length_remaining(tvb, *offset);
                                DISSECTOR_ASSERT(reported_length >= 0);
                                if (reported_length > tlv_len)
                                        reported_length = tlv_len;
                                next_tvb = tvb_new_subset_length(tvb, *offset, tlv_len);
                                dissect_msdp(next_tvb, pinfo, tree, NULL);
                        }
                        *offset += tlv_len;
                        tlv_len = 0;
                } else if (error_sub == 7) {
                        if (tlv_len > 0) {
                                reported_length = tvb_reported_length_remaining(tvb, *offset);
                                DISSECTOR_ASSERT(reported_length >= 0);
                                if (reported_length > tlv_len)
                                        reported_length = tlv_len;
                                next_tvb = tvb_new_subset_length(tvb, *offset, tlv_len);
                                dissect_msdp(next_tvb, pinfo, tree, NULL);
                        }
                        *offset += tlv_len;
                        tlv_len = 0;
                        break;
                } else {
                        if (tlv_len > 0)
                                proto_tree_add_item(tree, hf_msdp_unknown_data, tvb, *offset, tlv_len, ENC_NA);
                        *offset += tlv_len;
                        tlv_len = 0;
                        break;
                }
                break;
        case MESSAGE_HEADER_ERROR:
        case NOTIFICATION:
                /* Data contains the message that had an error. Even a
                 * broken Notification message causes a Notification
                 * message with Error Code set to Notification to be
                 * sent back.
                 */
                if (tlv_len > 0) {
                        reported_length = tvb_reported_length_remaining(tvb, *offset);
                        DISSECTOR_ASSERT(reported_length >= 0);
                        if (reported_length > tlv_len)
                                reported_length = tlv_len;
                        next_tvb = tvb_new_subset_length(tvb, *offset, tlv_len);
                        dissect_msdp(next_tvb, pinfo, tree);
                }
                *offset += tlv_len;
                tlv_len = 0;
                break;
        case FSM_ERROR:
        case HOLD_TIMER_EXPIRED:
        case CEASE:
                /* Do nothing. These contain no data */
                break;
        default:
                if (tlv_len > 0)
                        proto_tree_add_item(tree, hf_msdp_unknown_data, tvb, *offset, tlv_len, ENC_NA);
                *offset += tlv_len;
                tlv_len = 0;
                break;
        }
        if (tlv_len != 0) {
                proto_tree_add_item(tree, hf_msdp_trailing_junk, tvb, *offset, tlv_len, ENC_NA);
                *offset += tlv_len;
        }

        return;
}
