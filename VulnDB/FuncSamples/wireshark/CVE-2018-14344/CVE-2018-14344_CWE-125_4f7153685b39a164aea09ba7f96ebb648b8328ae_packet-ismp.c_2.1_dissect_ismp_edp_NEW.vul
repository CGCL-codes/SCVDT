static void
dissect_ismp_edp(tvbuff_t *tvb, packet_info *pinfo, int offset, proto_tree *ismp_tree)
{
	/* local variables used for EDP dissection */
	int neighbors_count = 0;
	int tuples_count = 0;
	guint16 device_type = 0;
	guint16 num_neighbors = 0;
	guint16 num_tuples = 0;
	guint16 tuple_type = 0;
	guint32 tuple_length = 0;

	/* Set up structures needed to add the protocol subtree and manage it */
	proto_item *edp_ti;
	proto_tree *edp_tree;

	proto_item *edp_neighbors_ti;
	proto_tree *edp_neighbors_tree;

	proto_tree *edp_neighbors_leaf_tree;

	proto_item *edp_tuples_ti;
	proto_tree *edp_tuples_tree;

	proto_tree *edp_tuples_leaf_tree;

	/* add column information marking this as EDP (Enterasys Discover Protocol */
	col_set_str(pinfo->cinfo, COL_PROTOCOL, "ISMP.EDP");
	col_clear(pinfo->cinfo, COL_INFO);

	/* create display subtree for EDP */
		edp_ti  = proto_tree_add_item(ismp_tree, hf_ismp_edp, tvb, offset, -1, ENC_NA);
		edp_tree = proto_item_add_subtree(edp_ti, ett_ismp_edp);

		col_add_fstr(pinfo->cinfo, COL_INFO, "MIP %s, MMAC %s, ifIdx %d",
			tvb_ip_to_str(tvb, offset+2),
			tvb_ether_to_str(tvb, offset+6),
			tvb_get_ntohl(tvb, offset+12));

		proto_tree_add_item(edp_tree, hf_ismp_edp_version, tvb, offset, 2, ENC_BIG_ENDIAN);
		offset += 2;
		proto_tree_add_item(edp_tree, hf_ismp_edp_module_ip, tvb, offset, 4, ENC_BIG_ENDIAN);
		offset += 4;
		proto_tree_add_item(edp_tree, hf_ismp_edp_module_mac, tvb, offset, 6, ENC_NA);
		offset += 6;
		proto_tree_add_item(edp_tree, hf_ismp_edp_module_port, tvb, offset, 4, ENC_BIG_ENDIAN);
		offset += 4;
		proto_tree_add_item(edp_tree, hf_ismp_edp_chassis_mac, tvb, offset, 6, ENC_NA);
		offset += 6;
		proto_tree_add_item(edp_tree, hf_ismp_edp_chassis_ip, tvb, offset, 4, ENC_BIG_ENDIAN);
		offset += 4;
		device_type = tvb_get_ntohs(tvb, offset);
		proto_tree_add_item(edp_tree, hf_ismp_edp_device_type, tvb, offset, 2, ENC_BIG_ENDIAN);
		offset += 2;
		proto_tree_add_uint_format_value(edp_tree, hf_ismp_edp_module_rev, tvb, offset, 4, tvb_get_ntohl(tvb, offset),
			"%02x.%02x.%02x.%02x", tvb_get_guint8(tvb, offset),
			tvb_get_guint8(tvb, offset+1), tvb_get_guint8(tvb, offset+2), tvb_get_guint8(tvb, offset+3));
		offset += 4;

		/* depending on device_type, show the appropriate options */
		switch (device_type) {
			case EDP_DEVICE_TYPE_SFS17:
			case EDP_DEVICE_TYPE_SFS18:
                {
		        static const gint *options[] = {
			        &hf_ismp_edp_sfs_option_uplink_flood,
			        &hf_ismp_edp_sfs_option_uplink_port,
			        &hf_ismp_edp_sfs_option_uplink_core,
			        &hf_ismp_edp_sfs_option_uplink_switch,
			        &hf_ismp_edp_sfs_option_isolated,
			        &hf_ismp_edp_sfs_option_redun,
			        &hf_ismp_edp_sfs_option_conmsg,
			        &hf_ismp_edp_sfs_option_calltap,
			        &hf_ismp_edp_sfs_option_tagflood,
			        &hf_ismp_edp_sfs_option_unused2,
			        &hf_ismp_edp_sfs_option_resolve,
			        &hf_ismp_edp_sfs_option_flood,
			        &hf_ismp_edp_sfs_option_lsp,
			        &hf_ismp_edp_sfs_option_sfssup,
			        &hf_ismp_edp_sfs_option_unused1,
		            NULL
		        };
		        proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
                }
				break;
			case EDP_DEVICE_TYPE_ROUTER:
                {
		        static const gint *options[] = {
			        &hf_ismp_edp_rtr_option_level1,
			        &hf_ismp_edp_rtr_option_trans,
			        &hf_ismp_edp_rtr_option_route,
			        &hf_ismp_edp_rtr_option_igmp_snoop,
			        &hf_ismp_edp_rtr_option_gmrp,
			        &hf_ismp_edp_rtr_option_gvrp,
			        &hf_ismp_edp_rtr_option_8021q,
			        &hf_ismp_edp_rtr_option_dvmrp,
			        &hf_ismp_edp_rtr_option_ospf,
			        &hf_ismp_edp_rtr_option_bgp,
			        &hf_ismp_edp_rtr_option_rip,
			        &hf_ismp_edp_rtr_option_igmp,
			        &hf_ismp_edp_rtr_option_ssr,
		            NULL
		        };

		        proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
                }
				break;
			case EDP_DEVICE_TYPE_BRIDGE:
                {
		        static const gint *options[] = {
			        &hf_ismp_edp_switch_option_level1,
			        &hf_ismp_edp_switch_option_trans,
			        &hf_ismp_edp_switch_option_route,
			        &hf_ismp_edp_switch_option_igmp,
			        &hf_ismp_edp_switch_option_gmrp,
			        &hf_ismp_edp_switch_option_gvrp,
			        &hf_ismp_edp_switch_option_8021q,
		            NULL
		        };

		        proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
                }
				break;
			case EDP_DEVICE_TYPE_NTSERVER:
			case EDP_DEVICE_TYPE_NTCLIENT:
			case EDP_DEVICE_TYPE_WIN95:
			case EDP_DEVICE_TYPE_WIN98:
			case EDP_DEVICE_TYPE_UNIXSERVER:
			case EDP_DEVICE_TYPE_UNIXCLIENT:
                {
		        static const gint *options[] = {
			        &hf_ismp_edp_end_station_option_ad,
			        &hf_ismp_edp_end_station_option_dns,
			        &hf_ismp_edp_end_station_option_dhcp,
		            NULL
		        };

		        proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
                }
				break;
			case EDP_DEVICE_TYPE_VLANMAN:
			case EDP_DEVICE_TYPE_ACCESSPOINT:
			default:
		        proto_tree_add_item(edp_tree, hf_ismp_edp_options, tvb, offset, 4, ENC_BIG_ENDIAN);
				break;
		}
		offset += 4;

		/* determine the number of neighbors and create EDP neighbors subtree */
		num_neighbors = tvb_get_ntohs(tvb, offset);
		proto_tree_add_item(edp_tree, hf_ismp_edp_num_neighbors, tvb, offset, 2, ENC_BIG_ENDIAN);
		offset += 2;
		if (num_neighbors > 0)
		{
			edp_neighbors_ti = proto_tree_add_item(edp_tree, hf_ismp_edp_neighbors, tvb,
										offset, num_neighbors*10, ENC_NA);
			edp_neighbors_tree = proto_item_add_subtree(edp_neighbors_ti, ett_ismp_edp_neighbors);
			while ( neighbors_count < num_neighbors && tvb_reported_length_remaining(tvb, offset) >= 10)
			{
				edp_neighbors_leaf_tree = proto_tree_add_subtree_format(edp_neighbors_tree, tvb, offset, 10,
										ett_ismp_edp_neighbors_leaf, NULL, "Neighbor%d", (neighbors_count+1));

				proto_tree_add_item(edp_neighbors_leaf_tree, hf_ismp_neighborhood_mac_address, tvb, offset, 6, ENC_NA);
				proto_tree_add_item(edp_neighbors_leaf_tree, hf_ismp_assigned_neighbor_state, tvb, offset, 4, ENC_BIG_ENDIAN);
				offset += 10;
				neighbors_count++;
			}
			if (neighbors_count != num_neighbors)
			{
				proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);
				return;
			}
		}

		/* determine data remains, if so, count tuples
		   and create EDP tuples subtree */
		if (tvb_reported_length_remaining(tvb, offset) != 0 &&
			tvb_reported_length_remaining(tvb, offset) >= 2)
		{
			num_tuples = tvb_get_ntohs(tvb, offset);
			proto_tree_add_item(edp_tree, hf_ismp_edp_num_tuples, tvb, offset, 2, ENC_BIG_ENDIAN);
			offset += 2;
		}
		else if (tvb_reported_length_remaining(tvb, offset) > 0) {
			proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);
			return;
		}
		else
		{
			return;
		}

		/* start populating tuple information */
		if (num_tuples && tvb_reported_length_remaining(tvb, offset) >= 4)
		{
			edp_tuples_ti = proto_tree_add_bytes_format(edp_tree, hf_ismp_edp_tuples, tvb,
				offset, -1, NULL, "Tuples");
			edp_tuples_tree = proto_item_add_subtree(edp_tuples_ti, ett_ismp_edp_tuples);

			while ( (tuples_count < num_tuples) && (tvb_reported_length_remaining(tvb, offset) >= 4) )
			{

				edp_tuples_leaf_tree = proto_tree_add_subtree_format(edp_tuples_tree, tvb, offset, 4,
					ett_ismp_edp_tuples_leaf, NULL, "Tuple%d", tuples_count+1);

				tuple_type = tvb_get_ntohs(tvb, offset);
				proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_tuple_type, tvb, offset, 2, ENC_BIG_ENDIAN);
				offset += 2;
				proto_tree_add_item_ret_uint(edp_tuples_leaf_tree, hf_ismp_tuple_length, tvb, offset, 2, ENC_BIG_ENDIAN, &tuple_length);
				if (tuple_length < 4) {
					proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, 2);
					return;
				}
				offset += 2;
				proto_item_set_len(edp_tuples_leaf_tree, tuple_length);
				tuple_length -= 4;

				if ((guint)tvb_reported_length_remaining(tvb, offset) >= tuple_length)
				{
					switch (tuple_type)
					{
						case EDP_TUPLE_HOLD:
							proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_hold_time, tvb, offset, tuple_length, ENC_BIG_ENDIAN);
							break;
						case EDP_TUPLE_INT_NAME:
							proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_interface_name, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);
							col_append_fstr(pinfo->cinfo, COL_INFO, ", ifName %s",
								tvb_format_text(tvb, offset, tuple_length));
							break;
						case EDP_TUPLE_SYS_DESCRIPT:
							proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_system_description, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);
							break;
						case EDP_TUPLE_IPX_ADDR:
							if (tuple_length != 4+6) {
								proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, tuple_length);
								return;
							}
							proto_tree_add_string(edp_tuples_leaf_tree, hf_ismp_interface_ipx_address ,tvb, offset, tuple_length,
								ipx_addr_to_str(tvb_get_ntohl(tvb, offset),
								tvb_get_ptr(tvb, offset+4, tuple_length-4)));
							break;
						case EDP_TUPLE_UNKNOWN:
						default:
							proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_unknown_tuple_data, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);
							break;
					}
				}
				offset += tuple_length;

				tuples_count++;
			}
			if (tuples_count != num_tuples)
				proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);

			return;
		}
}
