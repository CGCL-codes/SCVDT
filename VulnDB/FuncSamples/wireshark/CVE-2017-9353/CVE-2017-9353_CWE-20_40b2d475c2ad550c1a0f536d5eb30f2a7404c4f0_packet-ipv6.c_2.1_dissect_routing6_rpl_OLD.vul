static void
dissect_routing6_rpl(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *rthdr_tree,
                        struct rthdr_proto_item *rthdr_ti, struct ip6_rthdr rt)
{
    proto_item *pi = proto_tree_get_parent(rthdr_tree);
    proto_item *ti;
    guint8 cmprI, cmprE, cmprX, pad;
    guint32 reserved;
    gint idx;
    gint rpl_addr_count;
    struct e_in6_addr rpl_fulladdr;
    const struct e_in6_addr *ip6_dst_addr, *ip6_src_addr;
    wmem_array_t *rpl_addr_vector = NULL;
    guint i;

    /* IPv6 destination address used for elided bytes */
    ip6_dst_addr = (const struct e_in6_addr *)pinfo->dst.data;
    /* IPv6 source address used for strict checking */
    ip6_src_addr = (const struct e_in6_addr *)pinfo->src.data;

    /* from RFC6554: Multicast addresses MUST NOT appear in the IPv6 Destination Address field */
    if (in6_is_addr_multicast(ip6_dst_addr)) {
        expert_add_info(pinfo, pi, &ei_ipv6_dst_addr_not_multicast);
    }

    proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_cmprI, tvb, offset, 4, ENC_BIG_ENDIAN);
    proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_cmprE, tvb, offset, 4, ENC_BIG_ENDIAN);
    ti = proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_pad, tvb, offset, 4, ENC_BIG_ENDIAN);

    cmprI = tvb_get_guint8(tvb, offset) & 0xF0;
    cmprE = tvb_get_guint8(tvb, offset) & 0x0F;
    pad   = tvb_get_guint8(tvb, offset + 1) & 0xF0;

    /* Shift bytes over */
    cmprI >>= 4;
    pad >>= 4;

    /* from RFC6554: when CmprI and CmprE are both 0, Pad MUST carry a value of 0 */
    if (cmprI == 0 && cmprE == 0 && pad != 0) {
        expert_add_info_format(pinfo, ti, &ei_ipv6_routing_rpl_cmpri_cmpre_pad, "When cmprI equals 0 and cmprE equals 0, pad MUST equal 0 but instead was %d", pad);
    }

    ti = proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_reserved, tvb, offset, 4, ENC_BIG_ENDIAN);
    reserved = tvb_get_bits32(tvb, ((offset + 1) * 8) + 4, 20, ENC_BIG_ENDIAN);

    if (reserved != 0) {
        expert_add_info_format(pinfo, ti, &ei_ipv6_routing_rpl_reserved, "Reserved field must equal 0 but instead was %d", reserved);
    }

    /* From RFC6554:
     *   n = (((Hdr Ext Len * 8) - Pad - (16 - CmprE)) / (16 - CmprI)) + 1
     */
    rpl_addr_count = 0;
    if (rt.ip6r_len > 0) {
        rpl_addr_count = (((rt.ip6r_len * 8) - pad - (16 - cmprE)) / (16 - cmprI)) + 1;
    }
    ti = proto_tree_add_int(rthdr_tree, hf_ipv6_routing_rpl_addr_count, tvb, offset, 2, rpl_addr_count);
    PROTO_ITEM_SET_GENERATED(ti);
    if (rpl_addr_count < 0) {
        /* This error should always be reported */
        expert_add_info_format(pinfo, ti, &ei_ipv6_routing_rpl_addr_count_ge0, "Calculated total address count must be greater than or equal to 0, instead was %d", rpl_addr_count);
    }
    else if (rt.ip6r_segleft > (guint)rpl_addr_count) {
        expert_add_info_format(pinfo, rthdr_ti->segs, &ei_ipv6_routing_invalid_segleft,
            "IPv6 RPL Routing Header segments left field must not exceed address count (%d)", rpl_addr_count);
    }

    if (rpl_addr_count > 0) {
        offset += 4;

        if (g_ipv6_rpl_srh_strict_rfc_checking)
            rpl_addr_vector = wmem_array_sized_new(wmem_packet_scope(), IPv6_ADDR_SIZE, rpl_addr_count);

        /* We use cmprI for internal (e.g.: not last) address for how many bytes to elide, so actual bytes present = 16-CmprI */
        for (idx = 1; idx <= rpl_addr_count; idx++) {
            if (idx == rpl_addr_count)
                cmprX = 16 - cmprE;
            else
                cmprX = 16 - cmprI;
            proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_addr, tvb, offset, cmprX, ENC_NA);
            /* Display Full Address */
            memcpy(&rpl_fulladdr, ip6_dst_addr, IPv6_ADDR_SIZE);
            tvb_memcpy(tvb, &rpl_fulladdr.bytes[16-cmprX], offset, cmprX);
            ti = _proto_tree_add_ipv6_vector_address(rthdr_tree, hf_ipv6_routing_rpl_fulladdr, tvb,
                                offset, cmprX, &rpl_fulladdr, idx);
            PROTO_ITEM_SET_GENERATED(ti);
            offset += cmprX;

            /* IPv6 Source and Destination addresses of the encapsulating datagram (MUST) not appear in the SRH*/
            if (memcmp(&rpl_fulladdr, ip6_src_addr, IPv6_ADDR_SIZE) == 0) {
                expert_add_info(pinfo, ti, &ei_ipv6_src_route_list_src_addr);
            }
            if (memcmp(&rpl_fulladdr, ip6_dst_addr, IPv6_ADDR_SIZE) == 0) {
                expert_add_info(pinfo, ti, &ei_ipv6_src_route_list_dst_addr);
            }

            /* Multicast addresses MUST NOT appear in the in SRH */
            if (in6_is_addr_multicast(&rpl_fulladdr)) {
                expert_add_info(pinfo, ti, &ei_ipv6_src_route_list_multicast_addr);
            }

            if (g_ipv6_rpl_srh_strict_rfc_checking) {
                /* from RFC6554: */
                /* The SRH MUST NOT specify a path that visits a node more than once. */
                /* To do this, we will just check the current 'addr' against the previous addresses */
                for (i = 0; i < wmem_array_get_count(rpl_addr_vector); i++) {
                    /* Compare the addresses */
                    if (memcmp(&rpl_fulladdr, wmem_array_index(rpl_addr_vector, i), IPv6_ADDR_SIZE) == 0) {
                        /* Found a previous that is the same */
                        expert_add_info(pinfo, ti, &ei_ipv6_src_route_list_mult_inst_same_addr);
                        break;
                    }
                }
                wmem_array_append(rpl_addr_vector, &rpl_fulladdr, 1);
            }

            if (rt.ip6r_segleft > 0) {
                alloc_address_wmem(pinfo->pool, &pinfo->dst, AT_IPv6, IPv6_ADDR_SIZE, &rpl_fulladdr);
            }
        }
    }
}
