wtap_open_return_val nstrace_open(wtap *wth, int *err, gchar **err_info)
{
    gchar *nstrace_buf;
    gint64 file_size;
    gint32 page_size;
    nstrace_t *nstrace;


    if ((file_size = wtap_file_size(wth, err)) == -1)
        return WTAP_OPEN_NOT_MINE;

    nstrace_buf = (gchar *)g_malloc(NSPR_PAGESIZE);
    page_size = GET_READ_PAGE_SIZE(file_size);

    switch ((wth->file_type_subtype = nspm_signature_version(wth, nstrace_buf, page_size)))
    {
    case WTAP_FILE_TYPE_SUBTYPE_NETSCALER_1_0:
        wth->file_encap = WTAP_ENCAP_NSTRACE_1_0;
        break;

    case WTAP_FILE_TYPE_SUBTYPE_NETSCALER_2_0:
        wth->file_encap = WTAP_ENCAP_NSTRACE_2_0;
        break;

    case WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_0:
        wth->file_encap = WTAP_ENCAP_NSTRACE_3_0;
        g_free(nstrace_buf);
        nstrace_buf = (gchar *)g_malloc(NSPR_PAGESIZE_TRACE);
        page_size = GET_READ_PAGE_SIZEV3(file_size);
        break;

    default:
        /* No known signature found, assume it's not NetScaler */
        g_free(nstrace_buf);
        return WTAP_OPEN_NOT_MINE;
    }

    if ((file_seek(wth->fh, 0, SEEK_SET, err)) == -1)
    {
        g_free(nstrace_buf);
        return WTAP_OPEN_ERROR;
    }

    if (!wtap_read_bytes(wth->fh, nstrace_buf, page_size, err, err_info))
    {
        g_free(nstrace_buf);
        if (*err != WTAP_ERR_SHORT_READ)
            return WTAP_OPEN_ERROR;
        return WTAP_OPEN_NOT_MINE;
    }

    switch (wth->file_type_subtype)
    {
    case WTAP_FILE_TYPE_SUBTYPE_NETSCALER_1_0:
        wth->subtype_read = nstrace_read_v10;
        wth->subtype_seek_read = nstrace_seek_read_v10;
        break;

    case WTAP_FILE_TYPE_SUBTYPE_NETSCALER_2_0:
        wth->subtype_read = nstrace_read_v20;
        wth->subtype_seek_read = nstrace_seek_read_v20;
        break;

    case WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_0:
        wth->subtype_read = nstrace_read_v30;
        wth->subtype_seek_read = nstrace_seek_read_v30;
        break;
    }
    wth->subtype_close = nstrace_close;

    nstrace = (nstrace_t *)g_malloc(sizeof(nstrace_t));
    wth->priv = (void *)nstrace;
    nstrace->pnstrace_buf = nstrace_buf;
    nstrace->xxx_offset = 0;
    nstrace->nstrace_buflen = page_size;
    nstrace->nstrace_buf_offset = 0;
    nstrace->nspm_curtime = 0;
    nstrace->nspm_curtimemsec = 0;
    nstrace->nspm_curtimelastmsec = 0;
    nstrace->nsg_creltime = 0;
    nstrace->file_size = file_size;


    /* Set the start time by looking for the abstime record */
    if ((nstrace_set_start_time(wth)) == FALSE)
    {
        /* Reset the read pointer to start of the file. */
        if ((file_seek(wth->fh, 0, SEEK_SET, err)) == -1)
        {
            g_free(nstrace->pnstrace_buf);
            g_free(nstrace);
            return WTAP_OPEN_ERROR;
        }

        /* Read the first page of data */
        if (!wtap_read_bytes(wth->fh, nstrace_buf, page_size, err, err_info))
        {
            g_free(nstrace->pnstrace_buf);
            g_free(nstrace);
            return WTAP_OPEN_ERROR;
        }

        /* reset the buffer offset */
        nstrace->nstrace_buf_offset = 0;
    }

    wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
    wth->phdr.ts.secs = nstrace->nspm_curtime;
    wth->phdr.ts.nsecs = 0;

    *err = 0;
    return WTAP_OPEN_MINE;
}
