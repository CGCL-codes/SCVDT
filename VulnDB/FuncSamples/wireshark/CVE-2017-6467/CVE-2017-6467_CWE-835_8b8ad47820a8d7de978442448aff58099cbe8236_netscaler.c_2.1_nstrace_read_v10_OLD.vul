static gboolean nstrace_read_v10(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
{
    nstrace_t *nstrace = (nstrace_t *)wth->priv;
    guint64 nsg_creltime = nstrace->nsg_creltime;
    gchar *nstrace_buf = nstrace->pnstrace_buf;
    gint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;
    gint32 nstrace_buflen = nstrace->nstrace_buflen;
    nspr_pktracefull_v10_t *fp;
    nspr_pktracepart_v10_t *pp;
    int bytes_read;

    *err = 0;
    *err_info = NULL;
    do
    {
        while ((nstrace_buf_offset < nstrace_buflen) &&
            ((nstrace_buflen - nstrace_buf_offset) >= ((gint32)sizeof(fp->nsprRecordType))))
        {

#define GENERATE_CASE_FULL(phdr,type,acttype) \
        case NSPR_PDPKTRACEFULLTX_V##type:\
        case NSPR_PDPKTRACEFULLTXB_V##type:\
        case NSPR_PDPKTRACEFULLRX_V##type:\
            fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];\
            /*\
             * XXX - we can't do this in the seek-read routine,\
             * as the time stamps in the records are relative to\
             * the previous packet.\
             */\
            (phdr)->rec_type = REC_TYPE_PACKET;\
            (phdr)->presence_flags = WTAP_HAS_TS;\
            nsg_creltime += ns_hrtime2nsec(pletoh32(&fp->fp_RelTimeHr));\
            (phdr)->ts.secs = nstrace->nspm_curtime + (guint32) (nsg_creltime / 1000000000);\
            (phdr)->ts.nsecs = (guint32) (nsg_creltime % 1000000000);\
            TRACE_FULL_V##type##_REC_LEN_OFF(phdr,v##type##_full,fp,pktracefull_v##type);\
            buffer_assure_space(wth->frame_buffer, (phdr)->caplen);\
            memcpy(buffer_start_ptr(wth->frame_buffer), fp, (phdr)->caplen);\
            *data_offset = nstrace->xxx_offset + nstrace_buf_offset;\
            nstrace->nstrace_buf_offset = nstrace_buf_offset + (phdr)->len;\
            nstrace->nstrace_buflen = nstrace_buflen;\
            nstrace->nsg_creltime = nsg_creltime;\
            return TRUE;

#define GENERATE_CASE_PART(phdr,type,acttype) \
        case NSPR_PDPKTRACEPARTTX_V##type:\
        case NSPR_PDPKTRACEPARTTXB_V##type:\
        case NSPR_PDPKTRACEPARTRX_V##type:\
            pp = (nspr_pktracepart_v10_t *) &nstrace_buf[nstrace_buf_offset];\
            /*\
             * XXX - we can't do this in the seek-read routine,\
             * as the time stamps in the records are relative to\
             * the previous packet.\
             */\
            (phdr)->rec_type = REC_TYPE_PACKET;\
            (phdr)->presence_flags = WTAP_HAS_TS;\
            nsg_creltime += ns_hrtime2nsec(pletoh32(&pp->pp_RelTimeHr));\
            (phdr)->ts.secs = nstrace->nspm_curtime + (guint32) (nsg_creltime / 1000000000);\
            (phdr)->ts.nsecs = (guint32) (nsg_creltime % 1000000000);\
            TRACE_PART_V##type##_REC_LEN_OFF(phdr,v##type##_part,pp,pktracepart_v##type);\
            buffer_assure_space(wth->frame_buffer, (phdr)->caplen);\
            memcpy(buffer_start_ptr(wth->frame_buffer), pp, (phdr)->caplen);\
            *data_offset = nstrace->xxx_offset + nstrace_buf_offset;\
            nstrace->nstrace_buf_offset = nstrace_buf_offset + (phdr)->caplen;\
            nstrace->nsg_creltime = nsg_creltime;\
            nstrace->nstrace_buflen = nstrace_buflen;\
            return TRUE;\

            switch (pletoh16(&(( nspr_header_v10_t*)&nstrace_buf[nstrace_buf_offset])->ph_RecordType))
            {
                GENERATE_CASE_FULL(&wth->phdr,10,100)
                GENERATE_CASE_PART(&wth->phdr,10,100)

#undef GENERATE_CASE_FULL
#undef GENERATE_CASE_PART

            case NSPR_ABSTIME_V10:

                fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];
                ns_setabstime(nstrace, pletoh32(((nspr_abstime_v10_t *) fp)->abs_Time), pletoh32(&((nspr_abstime_v10_t *) fp)->abs_RelTime));
                nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);
                break;

            case NSPR_RELTIME_V10:

                fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];
                ns_setrelativetime(nstrace, pletoh32(((nspr_abstime_v10_t *) fp)->abs_RelTime));
                nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);
                break;

            case NSPR_UNUSEDSPACE_V10:

                nstrace_buf_offset = nstrace_buflen;
                break;

            default:

                fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];
                nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);
                break;
            }
        }

        nstrace_buf_offset = 0;
        nstrace->xxx_offset += nstrace_buflen;
        nstrace_buflen = GET_READ_PAGE_SIZE((nstrace->file_size - nstrace->xxx_offset));
    }while((nstrace_buflen > 0) && (bytes_read = file_read(nstrace_buf, nstrace_buflen, wth->fh)) && (bytes_read == nstrace_buflen));

    return FALSE;
}
