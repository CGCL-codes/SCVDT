static int
dissect_modbus(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    proto_tree          *modbus_tree;
    proto_item          *mi;
    int                 offset = 0;
    int*                packet_type = (int*)data;
    gint                payload_start, payload_len, len;
    guint8              function_code, exception_code;
    modbus_pkt_info_t   *pkt_info;

    /* Reject the packet if data passed from the mbrtu or mbtcp dissector is NULL */
    if (packet_type == NULL)
        return 0;

    len = tvb_captured_length(tvb);

    /* If the packet is zero-length, we should not attempt to dissect any further */
    if (len == 0)
        return 0;

    /* Add items to protocol tree specific to Modbus */
    mi = proto_tree_add_protocol_format(tree, proto_modbus, tvb, offset, len, "Modbus");
    modbus_tree = proto_item_add_subtree(mi, ett_modbus_hdr);

    function_code = tvb_get_guint8(tvb, offset) & 0x7F;
    proto_tree_add_item(modbus_tree, hf_modbus_functioncode, tvb, offset, 1, ENC_BIG_ENDIAN);

    /* Conversation support */
    if (!pinfo->fd->flags.visited) {
        conversation_t       *conversation = NULL;
        modbus_conversation  *modbus_conv_data = NULL;

        /* Find a conversation, create a new if no one exists */
        conversation = find_or_create_conversation(pinfo);
        modbus_conv_data = (modbus_conversation *)conversation_get_proto_data(conversation, proto_modbus);
        pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t);

        if (modbus_conv_data == NULL){
           modbus_conv_data = wmem_new(wmem_file_scope(), modbus_conversation);
           modbus_conv_data->modbus_request_frame_data = wmem_list_new(wmem_file_scope());
           modbus_conv_data->register_format = global_mbus_register_format;
           conversation_add_proto_data(conversation, proto_modbus, (void *)modbus_conv_data);
        }

        pkt_info->register_format = modbus_conv_data->register_format;

        if (*packet_type == QUERY_PACKET) {
            /*create the modbus_request frame. It holds the request information.*/
            modbus_request_info_t    *frame_ptr = wmem_new(wmem_file_scope(), modbus_request_info_t);

            /* load information into the modbus request frame */
            frame_ptr->fnum = pinfo->num;
            frame_ptr->function_code = function_code;
            pkt_info->reg_base = frame_ptr->base_address = tvb_get_ntohs(tvb, 1);
            pkt_info->num_reg = frame_ptr->num_reg = tvb_get_ntohs(tvb, 3);

            wmem_list_prepend(modbus_conv_data->modbus_request_frame_data, frame_ptr);
        }
        else if (*packet_type == RESPONSE_PACKET) {
            guint8                req_function_code;
            guint32               req_frame_num;
            modbus_request_info_t *request_data;

            wmem_list_frame_t *frame = wmem_list_head(modbus_conv_data->modbus_request_frame_data);
            /* Step backward through all logged instances of request frames, looking for a request frame number that
            occurred immediately prior to current frame number that has a matching function code */
            while (frame && !pkt_info->request_found) {
                request_data = (modbus_request_info_t *)wmem_list_frame_data(frame);
                req_frame_num = request_data->fnum;
                req_function_code = request_data->function_code;
                if ((pinfo->num > req_frame_num) && (req_function_code == function_code)) {
                    pkt_info->reg_base = request_data->base_address;
                    pkt_info->num_reg = request_data->num_reg;
                    pkt_info->request_found = TRUE;
                    pkt_info->req_frame_num = req_frame_num;
                }
                frame = wmem_list_frame_next(frame);
            }


        }
        p_add_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0, pkt_info);

    }
    else { /* !visited */
        pkt_info = (modbus_pkt_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0);
    }


    /* Find exception - last bit set in function code */
    if (tvb_get_guint8(tvb, offset) & 0x80 ) {
        exception_code = tvb_get_guint8(tvb, offset+1);
    }
    else {
        exception_code = 0;
    }

    payload_start = offset + 1;
    payload_len = len - 1;

    if (exception_code != 0) {
        proto_item_set_text(mi, "Function %u:  %s.  Exception: %s",
                            function_code,
                            val_to_str_const(function_code, function_code_vals, "Unknown Function"),
                            val_to_str(exception_code,
                                       exception_code_vals,
                                       "Unknown Exception Code (%u)"));
        proto_tree_add_uint(modbus_tree, hf_modbus_exceptioncode, tvb, payload_start, 1,
                            exception_code);
    }
    else {

        /* Follow different dissection path depending on whether packet is query or response */
        if (*packet_type == QUERY_PACKET) {
            dissect_modbus_request(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info);
        }
        else if (*packet_type == RESPONSE_PACKET) {
            dissect_modbus_response(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info);
        }

    }

    return tvb_captured_length(tvb);
}
