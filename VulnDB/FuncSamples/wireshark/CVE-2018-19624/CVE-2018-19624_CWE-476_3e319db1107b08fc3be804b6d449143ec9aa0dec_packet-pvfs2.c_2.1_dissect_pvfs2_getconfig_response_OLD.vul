static int
dissect_pvfs2_getconfig_response(tvbuff_t *tvb, proto_tree *parent_tree,
		int offset, packet_info *pinfo)
{
	guint32 i;
	guint32 total_bytes = 0, total_config_bytes = 0, total_lines = 0;
	guint32 bytes_processed = 0;
	guint32 length_remaining = 0;
	const char *ptr = NULL;
	proto_tree *tree, *config_tree = NULL;
	/*guint8 truncated = 0;*/

	tree = proto_tree_add_subtree(parent_tree, tvb, offset, 12,
				ett_pvfs_server_config, NULL, "Server Config");

	/* Total number of bytes in server config (incl. entry count) */
	total_bytes = tvb_get_letohl(tvb, offset);
	proto_tree_add_item(tree, hf_pvfs_getconfig_response_total_bytes, tvb, offset, 4, ENC_LITTLE_ENDIAN);
	offset += 4;

	/* There must be at least 4 bytes of data returned to determine the
	 * size of the server config data
	 */
	if (total_bytes < 4)
	{
		/* Server config not returned, bail out */
		return offset;
	}

	/* Number of entries in server config */
	total_lines = tvb_get_letohl(tvb, offset);
	proto_tree_add_item(tree, hf_pvfs_getconfig_response_lines, tvb, offset, 4, ENC_LITTLE_ENDIAN);
	offset += 4;

	/* Number of bytes in server config */
	total_config_bytes = tvb_get_letohl(tvb, offset);
	proto_tree_add_item(tree, hf_pvfs_getconfig_response_config_bytes, tvb, offset, 4, ENC_LITTLE_ENDIAN);
	offset += 4;

	/* Get pointer to server config data */
	ptr = tvb_get_ptr(tvb, offset, total_config_bytes);

	/* Check if all data is available */
	length_remaining = tvb_captured_length_remaining(tvb, offset);

	if (length_remaining < total_config_bytes)
	{
		total_config_bytes = length_remaining;

		/*truncated = 1;*/
	}

	bytes_processed = 0;

	for (i = 0; i < total_lines; i++)
	{
		guint8 entry[256], *pentry = entry, *tmp_entry = NULL;
		guint32 entry_length = 0, tmp_entry_length = 0;
		guint32 bufsiz = sizeof(entry);

		while ((*ptr != '\n') && (*ptr != '\0') &&
				(bytes_processed < total_config_bytes) &&
				(entry_length < bufsiz))
		{
			*pentry++ = *ptr++;

			bytes_processed++;
			entry_length++;
		}

		if ((entry_length == bufsiz) &&
				((entry[entry_length - 1] != '\n') &&
				 (entry[entry_length - 1] != '\0')))
		{
			/*
			 * Single line of config data doesn't fit into provided buffer,
			 * config data is malformed.
			 */

			break;
		}

		if (bytes_processed == total_config_bytes)
		{
			/* Oops...  ran out of data before we could complete the entry */
			break;
		}

		*pentry= '\0';

		tmp_entry = entry;
		tmp_entry_length = entry_length;

		/* Remove all whitespace from front of entry */
		while ((tmp_entry_length > 0) && (!g_ascii_isalnum(*tmp_entry)) &&
				(*tmp_entry != '<'))
		{
			tmp_entry++;
			tmp_entry_length--;
		}

		if (tmp_entry[0] == '<')
		{
 			if (tmp_entry[tmp_entry_length - 1] == '>')
			{
				/* Token */
				if (tmp_entry[1] != '/')
				{
					/* Opening token, create new tree root */
					config_tree = proto_tree_add_subtree(tree, tvb, offset,
							tmp_entry_length, ett_pvfs_server_config_branch, NULL, tmp_entry);
				}
				else
				{
					/* Closing token */
					config_tree = NULL;
				}
			}
			else
			{
				/* Malformed token */
				break;
			}
		}
		else
		{
			/* Insert items into the root config tree if there's no subtree
			 * defined.
			 */
			if (config_tree == NULL)
				config_tree = tree;

			if (tmp_entry_length > 0)
			{
				proto_tree_add_string_format(config_tree, hf_pvfs_getconfig_response_entry, tvb, offset, tmp_entry_length,
						tmp_entry, "%s", tmp_entry);
			}
		}

		offset += entry_length + 1;

		ptr++;
		bytes_processed++;
	}

	if (bytes_processed < total_config_bytes)
	{
		/* We ran out of server config data */
		proto_tree_add_expert(config_tree, pinfo, &ei_pvfs_malformed, tvb, offset, -1);
	}

	return offset;
}
