static void llc_gprs_dissect_xid(tvbuff_t *tvb,
								 packet_info *pinfo,
								 proto_item *llcgprs_tree)

{
	guint8 xid_param_len = 0, byte1 = 0, byte2 = 0, item_len = 0, tmp = 0;
	guint16 location = 0;
	guint16 loop_counter = 0;
	proto_tree *uinfo_tree = NULL;
	proto_tree *xid_tree = NULL;
	guint16 info_len;

	info_len = tvb_reported_length(tvb);

	xid_tree = proto_tree_add_subtree_format(llcgprs_tree, tvb, 0, info_len,
				ett_ui, NULL, "Information Field: Length = %u", info_len);

	while (location < info_len)
	{
		/* parse the XID parameters */
		byte1 = tvb_get_guint8(tvb, location);

		if (byte1 & 0x80)
		{
			guint8 xid_param_len_high = 0;
			guint8 xid_param_len_low = 0;
			byte2 = tvb_get_guint8(tvb, location + 1);

			/* XL bit is set - length is continued in second byte */
			xid_param_len_high = byte1 & 0x03;
			xid_param_len_low = byte2 & 0xFC;

			/* bit shift the rest of the length */
			xid_param_len_low = xid_param_len_low >> 2;
			xid_param_len_low = xid_param_len_low & 0x3F;

			xid_param_len_high = xid_param_len_high << 6;
			xid_param_len_high = xid_param_len_high & 0xC0;

			/* combine the two */
			xid_param_len = xid_param_len_high | xid_param_len_low;
			item_len = xid_param_len + 2;

		}
		else
		{
			xid_param_len = byte1 & 0x3;
			item_len = xid_param_len + 1;
		}

		tmp =  byte1 & 0x7C;
		tmp = tmp >> 2;

		if (tmp == 0xB) /* L3 XID parameters, call the SNDCP-XID dissector */
		{
			tvbuff_t	*sndcp_xid_tvb;
			guint8 sndcp_xid_offset;

			uinfo_tree = proto_tree_add_subtree(xid_tree, tvb, location, item_len,
				ett_ui, NULL, "XID parameter Type: L3 parameters");
			proto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location, 1, byte1);
			proto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location, 1, byte1);
			proto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location, 1, byte1);
			if (byte1 & 0x80) {
				proto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location+1, 1, byte2);
				proto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location+1, 1, byte2);
				sndcp_xid_offset = 2;
			}
			else
			{
				sndcp_xid_offset = 1;
			}

			if (xid_param_len) {

				sndcp_xid_tvb = tvb_new_subset_length (tvb, location+sndcp_xid_offset, xid_param_len);

				if(sndcp_xid_handle)
				{
					call_dissector(sndcp_xid_handle, sndcp_xid_tvb, pinfo, uinfo_tree);
				}
			}

			location += item_len;
		}
		else
		{
			if (( xid_param_len > 0 ) && ( xid_param_len <=4 ))
			{
				guint32 value = 0;
				guint8 i;
				for (i=1;i<=xid_param_len;i++)
				{
					value <<= 8;
					value |= (guint32)tvb_get_guint8(tvb, location+i );
				}
				uinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,
					ett_ui, NULL, "XID Parameter Type: %s - Value: %u",
					val_to_str_ext_const(tmp, &xid_param_type_str_ext, "Reserved Type:%X"), value);
			}
			else
			{
				uinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,
					ett_ui, NULL, "XID Parameter Type: %s",
					val_to_str_ext_const(tmp, &xid_param_type_str_ext, "Reserved Type:%X"));
			}
			proto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location,
				1, byte1);
			proto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location,
				1, byte1);
			proto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location,
				1, byte1);

			if (byte1 & 0x80) {
				/* length continued into byte 2 */
				proto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location,
					1, byte2);
				proto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location,
					1, byte2);

				/* be sure to account for the second byte of length */
				location++;
			}

			location++;
			for (loop_counter = 0; loop_counter < xid_param_len; loop_counter++)
			{
				/* grab the information in the XID param */
				byte2 = tvb_get_guint8(tvb, location);
				proto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_byte, tvb, location,
					1, byte2);
				location++;
			}
		}
	}
}
