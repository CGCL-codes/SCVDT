gint wimax_decode_dlmapc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *base_tree)
{
	/* 8.4.5.6.1 [2] Compressed DL-MAP */
	/* decode a compressed dl-map and return the length in bytes; */
	/* if there is a compressed ul-map, also decode that and include in the length */
	guint offset = 0;
	proto_item *ti = NULL;
	proto_item *ti_phy = NULL;
	proto_item *ti_dlmap_ies = NULL;
	proto_tree *tree = NULL;
	proto_tree *ie_tree = NULL;
	proto_tree *phy_tree = NULL;
	gint ulmap_appended;
	guint length, lennib, pad;
	guint mac_len, dl_ie_count;
	guint tvb_len = tvb_reported_length(tvb);
	guint nib = 0;
	guint32 mac_crc, calculated_crc;

	/* update the info column */
	col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Compressed DL-MAP");

	INC_CID = 0;

	length = tvb_get_ntohs(tvb, offset) & 0x07FF; /* compressed map length is 11 bits */
	mac_len = length;
	lennib = BYTE_TO_NIB(length);

	ulmap_appended = (tvb_get_guint8(tvb, offset) >> 4) & 1; /* UL MAP appended? */

	/* display MAC Compressed DL-MAP and create subtree */
	ti = proto_tree_add_protocol_format(base_tree, proto_mac_mgmt_msg_dlmap_decoder, tvb, offset, length, "Compressed DL-MAP (%u bytes)", length);
	tree = proto_item_add_subtree(ti, ett_305);

	/* decode dlmap fields */
	proto_tree_add_item(tree, hf_dlmapc_compr, tvb, offset, 2, ENC_BIG_ENDIAN);
	proto_tree_add_item(tree, hf_dlmapc_ulmap, tvb, offset, 2, ENC_BIG_ENDIAN);
	proto_tree_add_item(tree, hf_dlmapc_rsv, tvb, offset, 2, ENC_BIG_ENDIAN);
	proto_tree_add_item(tree, hf_dlmapc_len, tvb, offset, 2, ENC_BIG_ENDIAN);
	/* PHY Synchronization Field 8.4.5.1 */
	{
		phy_tree = proto_tree_add_subtree(tree, tvb, offset+2, 4, ett_275_phy, &ti_phy, "Phy Synchronization Field");
		proto_tree_add_item(phy_tree, hf_dlmap_phy_fdur_ms, tvb, offset+2, 1, ENC_BIG_ENDIAN);
		proto_tree_add_item(phy_tree, hf_dlmap_phy_fdur_per_sec, tvb, offset+2, 1, ENC_BIG_ENDIAN);
		proto_tree_add_item(phy_tree, hf_dlmap_phy_fnum, tvb, offset+3, 3, ENC_BIG_ENDIAN);
	}
	proto_tree_add_item(tree, hf_dlmap_dcd,	   tvb, offset+6, 1, ENC_BIG_ENDIAN);
	proto_tree_add_item(tree, hf_dlmapc_opid,	 tvb, offset+7, 1, ENC_BIG_ENDIAN);
	proto_tree_add_item(tree, hf_dlmapc_secid,	tvb, offset+8, 1, ENC_BIG_ENDIAN);
	proto_tree_add_item(tree, hf_dlmap_ofdma_sym, tvb, offset+9, 1, ENC_BIG_ENDIAN); /* 2005 */
	proto_tree_add_item(tree, hf_dlmapc_count,	tvb, offset+10,1, ENC_BIG_ENDIAN);
	dl_ie_count = tvb_get_guint8(tvb, offset + 10);
	offset += 11;
	nib = BYTE_TO_NIB(offset);

	/* DL-MAP IEs */
	length -= 15; /* remaining length in bytes (11 bytes above + CRC at end) */
	if (dl_ie_count) {
		ie_tree = proto_tree_add_subtree_format(tree, tvb, offset, length, ett_dlmap_ie, &ti_dlmap_ies, "DL-MAP IEs (%d bytes)", length);

		/* length = BYTE_TO_NIB(mac_len - (int)sizeof(mac_crc) - 1); */ /* convert length to nibbles */

		while (dl_ie_count--) {
			nib += dissect_dlmap_ie(ie_tree, pinfo, nib, tvb_len * 2, tvb);
		}
		pad = NIB_PADDING(nib);
		if (pad) {
			proto_tree_add_bytes_format(tree, hf_padding, tvb, NIBHI(nib,1), NULL, "Padding nibble");
			nib++;
		}
	}

	if (ulmap_appended) {
		/* Replace the text of items to set the correct length in bytes.*/
		proto_item_set_text(ti, "Compressed DL-MAP (%u bytes)", NIB_ADDR(nib));
		proto_item_set_text(ti_dlmap_ies, "DL-MAP IEs (%u bytes)",NIB_ADDR(nib)- offset);

		/* set the length of items */
		proto_item_set_end(ti_dlmap_ies, tvb, NIB_ADDR(nib));
		proto_item_set_end(ti, tvb, NIB_ADDR(nib));

		/* update the info column */
		col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Compressed UL-MAP");

		/* subtract 8 from lennib (CRC) */
		wimax_decode_ulmapc(base_tree, pinfo, nib, lennib - 8, tvb);
	}

	/* CRC is always appended */
	/* check the length */
	if (mac_len <= sizeof(mac_crc))
	{
		expert_add_info_format(pinfo, ti, &ei_mac_header_invalid_length,
		"Invalid length: %d.", mac_len);
		return sizeof(mac_crc);
	}
	else if (MIN(tvb_len, tvb_reported_length(tvb)) >= mac_len)
	{
		/* calculate the CRC */
		calculated_crc = wimax_mac_calc_crc32(tvb_get_ptr(tvb, 0, mac_len - (int)sizeof(mac_crc)), mac_len - (int)sizeof(mac_crc));
		proto_tree_add_checksum(base_tree, tvb, mac_len - (int)sizeof(mac_crc), hf_mac_header_compress_dlmap_crc, hf_mac_header_compress_dlmap_crc_status, &ei_mac_header_compress_dlmap_crc,
								pinfo, calculated_crc, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY);
	}
	else
	{   /* display error message */
		proto_tree_add_protocol_format(base_tree, proto_mac_mgmt_msg_dlmap_decoder, tvb, 0, tvb_len, "CRC missing - the frame is too short (%u bytes)", tvb_len);
	}

	return mac_len;
}
