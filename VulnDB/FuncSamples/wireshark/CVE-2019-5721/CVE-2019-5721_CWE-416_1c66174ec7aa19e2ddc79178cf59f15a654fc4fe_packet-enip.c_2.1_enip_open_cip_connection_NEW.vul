static void
enip_open_cip_connection( packet_info *pinfo, cip_conn_info_t* connInfo)
{
   enip_conn_key_t  *conn_key;
   enip_conn_val_t  *conn_val;
   conversation_t   *conversation, *conversationTO;
   enip_conv_info_t *enip_info;
   address           dest_address;
   struct e_in6_addr ipv6_zero;

   if (pinfo->fd->flags.visited)
      return;

   conn_key = wmem_new(wmem_file_scope(), enip_conn_key_t);
   conn_key->ConnSerialNumber = connInfo->ConnSerialNumber;
   conn_key->VendorID = connInfo->VendorID;
   conn_key->DeviceSerialNumber = connInfo->DeviceSerialNumber;
   conn_key->O2TConnID = connInfo->O2T.connID;
   conn_key->T2OConnID = connInfo->T2O.connID;

   conn_val = (enip_conn_val_t *)wmem_map_lookup( enip_conn_hashtable, conn_key );
   if ( conn_val == NULL )
   {
      conn_val = wmem_new(wmem_file_scope(), enip_conn_val_t);

      conn_val->ConnSerialNumber       = connInfo->ConnSerialNumber;
      conn_val->VendorID               = connInfo->VendorID;
      conn_val->DeviceSerialNumber     = connInfo->DeviceSerialNumber;
      conn_val->O2TConnID              = connInfo->O2T.connID;
      conn_val->T2OConnID              = connInfo->T2O.connID;
      conn_val->TransportClass_trigger = connInfo->TransportClass_trigger;
      conn_val->safety                 = connInfo->safety;
      conn_val->motion                 = connInfo->motion;
      conn_val->ClassID                = connInfo->ClassID;
      conn_val->open_frame             = connInfo->forward_open_frame;
      conn_val->open_reply_frame       = pinfo->num;
      conn_val->close_frame            = 0;
      conn_val->connid                 = enip_unique_connid++;

      wmem_map_insert(enip_conn_hashtable, conn_key, conn_val );

      /* I/O connection */
      if (((connInfo->TransportClass_trigger & CI_TRANSPORT_CLASS_MASK) == 0) ||
          ((connInfo->TransportClass_trigger & CI_TRANSPORT_CLASS_MASK) == 1))
      {
          /* zero out the ipv6 structure for comparison */
          memset(&ipv6_zero, 0, sizeof(ipv6_zero));

         /* default some information if not included */
         if ((connInfo->O2T.port == 0) || (connInfo->O2T.type == CONN_TYPE_MULTICAST))
            connInfo->O2T.port = ENIP_IO_PORT;
         if ((connInfo->O2T.ipaddress.type == AT_NONE) ||
             ((connInfo->O2T.ipaddress.type == AT_IPv4) && ((*(const guint32*)connInfo->O2T.ipaddress.data)) == 0) ||
             ((connInfo->O2T.ipaddress.type == AT_IPv6) && (memcmp(connInfo->O2T.ipaddress.data, &ipv6_zero, sizeof(ipv6_zero)) == 0)) ||
             (connInfo->O2T.type != CONN_TYPE_MULTICAST))
            copy_address_wmem(wmem_file_scope(), &connInfo->O2T.ipaddress, &pinfo->src);
         if ((connInfo->T2O.port == 0) || (connInfo->T2O.type == CONN_TYPE_MULTICAST))
            connInfo->T2O.port = ENIP_IO_PORT;
         if ((connInfo->T2O.ipaddress.type == AT_NONE) ||
             ((connInfo->T2O.ipaddress.type == AT_IPv4) && ((*(const guint32*)connInfo->T2O.ipaddress.data)) == 0) ||
             ((connInfo->T2O.ipaddress.type == AT_IPv6) && (memcmp(connInfo->T2O.ipaddress.data, &ipv6_zero, sizeof(ipv6_zero)) == 0)) ||
             (connInfo->T2O.type != CONN_TYPE_MULTICAST))
            copy_address_wmem(wmem_file_scope(), &connInfo->T2O.ipaddress, &pinfo->dst);

         if (connInfo->O2T.ipaddress.type == AT_IPv6)
         {
             dest_address.type = AT_IPv6;
             dest_address.len  = 16;
         }
         else
         {
             dest_address.type = AT_IPv4;
             dest_address.len  = 4;
         }
         dest_address.data = connInfo->O2T.ipaddress.data;

         /* check for O->T conversation */
         /* similar logic to find_or_create_conversation(), but since I/O traffic
         is on UDP, the pinfo parameter doesn't have the correct information */
         if ((conversation = find_conversation(pinfo->num, &pinfo->dst, &dest_address,
                                              PT_UDP, connInfo->O2T.port, 0, NO_PORT_B)) == NULL) {

            conversation = conversation_new(pinfo->num, &pinfo->dst, &dest_address,
                                            PT_UDP, connInfo->O2T.port, 0, NO_PORT2);
         }

         enip_info = (enip_conv_info_t *)conversation_get_proto_data(conversation, proto_enip);
         if (enip_info == NULL)
         {
            enip_info = wmem_new(wmem_file_scope(), enip_conv_info_t);
            enip_info->O2TConnIDs = wmem_tree_new(wmem_file_scope());
            enip_info->T2OConnIDs = wmem_tree_new(wmem_file_scope());

            conversation_add_proto_data(conversation, proto_enip, enip_info);
         }
         wmem_tree_insert32(enip_info->O2TConnIDs, connInfo->O2T.connID, (void *)conn_val);

         /* Check if separate T->O conversation is necessary.  If either side is multicast
            or ports aren't equal, a separate conversation must be generated */
         dest_address.data = connInfo->T2O.ipaddress.data;
         if ((conversationTO = find_conversation(pinfo->num, &pinfo->src, &dest_address,
                                                PT_UDP, connInfo->T2O.port, 0, NO_PORT_B)) == NULL) {

             conversationTO = conversation_new(pinfo->num, &pinfo->src,
                                               &dest_address, PT_UDP,
                                               connInfo->T2O.port, 0, NO_PORT2);
         }

         enip_info = (enip_conv_info_t *)conversation_get_proto_data(conversationTO, proto_enip);
         if (enip_info == NULL)
         {
            enip_info = wmem_new(wmem_file_scope(), enip_conv_info_t);
            enip_info->O2TConnIDs = wmem_tree_new(wmem_file_scope());
            enip_info->T2OConnIDs = wmem_tree_new(wmem_file_scope());
            conversation_add_proto_data(conversationTO, proto_enip, enip_info);
         }
         wmem_tree_insert32(enip_info->T2OConnIDs, connInfo->T2O.connID, (void *)conn_val);
      }
      else
      {
         /* explicit message connection */
         conversation = find_or_create_conversation(pinfo);

         /* Do we already have a state structure for this conv */
         enip_info = (enip_conv_info_t *)conversation_get_proto_data(conversation, proto_enip);
         if (!enip_info)
         {
            /*
             * No.  Attach that information to the conversation, and add
             * it to the list of information structures.
             */
            enip_info = wmem_new(wmem_file_scope(), enip_conv_info_t);
            enip_info->O2TConnIDs = wmem_tree_new(wmem_file_scope());
            enip_info->T2OConnIDs = wmem_tree_new(wmem_file_scope());

            conversation_add_proto_data(conversation, proto_enip, enip_info);
         }
         wmem_tree_insert32(enip_info->O2TConnIDs, connInfo->O2T.connID, (void *)conn_val);
         wmem_tree_insert32(enip_info->T2OConnIDs, connInfo->T2O.connID, (void *)conn_val);
      }
   }

   /* Save the connection info for the conversation filter */
   if (!pinfo->fd->flags.visited)
      p_add_proto_data(wmem_file_scope(), pinfo, proto_enip, ENIP_CONNECTION_INFO, conn_val);
}
