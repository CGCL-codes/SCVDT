void
setup_sdp_transport(tvbuff_t *tvb, packet_info *pinfo, enum sdp_exchange_type exchange_type,
    int request_frame, const gboolean delay)
{
    gint        offset = 0, next_offset, n;
    int         linelen;
    gboolean    in_media_description = FALSE;
    guchar      type, delim;
    const int   tokenoffset = 2;
    int         hf     = -1;
    gint        start_transport_info_count = 0;
    transport_info_t* transport_info = NULL;
    disposable_media_info_t media_info;

    struct srtp_info *srtp_info = NULL;

    DPRINT2(("-------------------- setup_sdp_transport -------------------"));

    /* Only do this once during first pass */
    if (pinfo->fd->flags.visited) {
        DPRINT(("already visited"));
        return;
    }

    memset(&media_info, 0, sizeof(media_info));

    if (request_frame != 0)
        transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_reqs, request_frame );
    if (transport_info == NULL) {
        transport_info = wmem_new0(wmem_file_scope(), transport_info_t);
        transport_info->media_count = -1;

        for (n = 0; n < SDP_NO_OF_PT; n++) {
            transport_info->encoding_name[n] = (char*)UNKNOWN_ENCODING;
        }
        for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {
            transport_info->media[n].rtp_dyn_payload =
                g_hash_table_new(g_int_hash, g_int_equal);
            transport_info->media[n].set_rtp = FALSE;
        }

        if (request_frame != 0)
            wmem_tree_insert32(sdp_transport_reqs, request_frame, (void *)transport_info);
    }
#ifdef DEBUG_CONVERSATION
    else {
        DPRINT(("found previous transport_info:"));
        sdp_dump_transport_info(transport_info);
    }
#endif

    if (exchange_type != SDP_EXCHANGE_OFFER)
        wmem_tree_insert32(sdp_transport_rsps, pinfo->fd->num, (void *)transport_info);

    /* Offer has already been answered or rejected and hash tables freed, so
     * don't try to add to it
     * XXX - Need to support "modified offers" */
    if ((transport_info->sdp_status == SDP_EXCHANGE_ANSWER_REJECT) ||
        (transport_info->sdp_status == SDP_EXCHANGE_ANSWER_ACCEPT))
        return;

    if (transport_info->media_count > 0)
        start_transport_info_count = transport_info->media_count;

    DPRINT(("start_transport_info_count=%d", start_transport_info_count));

    /* if we don't delay, and this is an answer after a previous offer, then
       we free'd the unused media rtp_dyn_payload last time while processing
       the offer, so we need to re-create them this time in case we need them.
       If they don't get used they'll get free'd again later */
    if (!delay && (exchange_type == SDP_EXCHANGE_ANSWER_ACCEPT) &&
        (transport_info->sdp_status == SDP_EXCHANGE_OFFER)) {
        for (n = start_transport_info_count; n < SDP_MAX_RTP_CHANNELS; n++) {
            if (!transport_info->media[n].rtp_dyn_payload)
                transport_info->media[n].rtp_dyn_payload = g_hash_table_new(g_int_hash, g_int_equal);
        }
    }

    /*
     * Show the SDP message a line at a time.
     */
    while (tvb_reported_length_remaining(tvb, offset) > 0) {
        /*
         * Find the end of the line.
         */
        linelen = tvb_find_line_end_unquoted(tvb, offset, -1, &next_offset);

        /*
         * Line must contain at least e.g. "v=".
         */
        if (linelen < 2)
            break;

        type  = tvb_get_guint8(tvb, offset);
        delim = tvb_get_guint8(tvb, offset + 1);
        if (delim != '=') {
            offset = next_offset;
            continue;
        }

        /*
         * Attributes.  Only care about ones that affect the transport.  Ignore others.
         */
        switch (type) {
            case 'c':
                hf = hf_connection_info;
                break;
            case 'm':
                hf = hf_media;

                /* Increase the count of media channels, but don't walk off the end of the arrays. */
                if (((transport_info->media_count < 0) && (in_media_description == FALSE)) || (transport_info->media_count < (SDP_MAX_RTP_CHANNELS-1)))
                    transport_info->media_count++;

                if (in_media_description && (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1)))
                    media_info.media_count++;

                in_media_description = TRUE;
                DPRINT(("in media description, transport_info->media_count=%d, "
                        "media_info.media_count=%d",
                        transport_info->media_count, media_info.media_count));
                break;
            case 'a':
                if (in_media_description) {
                    hf = hf_media_attribute;
                } else {
                    hf = hf_session_attribute;
                }
                break;
            default:
                hf = hf_unknown;
                break;
        }

        if (hf != hf_unknown)
        {
            DINDENT();
            call_sdp_subdissector(tvb_new_subset(tvb, offset + tokenoffset,
                                                   linelen - tokenoffset,
                                                   linelen - tokenoffset),
                                    pinfo,
                                    hf, NULL, linelen-tokenoffset, transport_info, &media_info);
            DENDENT();
        }

        offset = next_offset;
    }

    if (in_media_description) {
        /* Increase the count of media channels, but don't walk off the end of the arrays. */
        /* XXX: I don't know why this was done here - I'm keeping it here in case
         * removing it causes problems, but it's wrong. transport_info->media_count
         * is already incremented in the while() loop above. Incrementing it
         * again here will cause bugs. The name of this is misleading, because
         * 'transport_info->media_count' is actually an index, not count.
         * In other words, it's a 0-based number, of the current rtp channel.
         * So debug printing shows bogus rtp channels get created and then later
         * removed because luckily it knows they were bogus. But it will cause bugs
         * because if we're not delaying, then for the SDP_EXCHANGE_ANSWER_ACCEPT
         * run through this function, it will add new RTP channels at a +1 index,
         * which will likely cause problems.
         */
        if (transport_info->media_count < (SDP_MAX_RTP_CHANNELS-1))
            transport_info->media_count++;
        if (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1))
            media_info.media_count++;
    }

#ifdef DEBUG_CONVERSATION
    sdp_dump_disposable_media_info(&media_info);
#endif

    DPRINT(("calling convert_disposable_media(), transport_info->media_count=%d, "
            "media_info.media_count=%d, start_transport_info_count=%d",
            transport_info->media_count, media_info.media_count, start_transport_info_count));
    DINDENT();
    /* Take all of the collected strings and convert them into something permanent
     * for the life of the capture
     */
    convert_disposable_media(transport_info, &media_info, start_transport_info_count);
    DENDENT();

#ifdef DEBUG_CONVERSATION
    sdp_dump_transport_info(transport_info);
#endif

    /* We have a successful negotiation, apply data to their respective protocols */
    if (!delay || ((exchange_type == SDP_EXCHANGE_ANSWER_ACCEPT) &&
        (transport_info->sdp_status == SDP_EXCHANGE_OFFER))) {

        for (n = 0; n <= transport_info->media_count; n++) {
          guint32 current_rtp_port = 0;

            /* Add (s)rtp and (s)rtcp conversation, if available (overrides t38 if conversation already set) */
            if ((transport_info->media_port[n] != 0) &&
                (transport_info->proto_bitmask[n] & (SDP_RTP_PROTO|SDP_SRTP_PROTO)) &&
                (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6))) {

                if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {
                    srtp_info = wmem_new0(wmem_file_scope(), struct srtp_info);
                    if (transport_info->encryption_algorithm != SRTP_ENC_ALG_NOT_SET) {
                        srtp_info->encryption_algorithm = transport_info->encryption_algorithm;
                        srtp_info->auth_algorithm       = transport_info->auth_algorithm;
                        srtp_info->mki_len              = transport_info->mki_len;
                        srtp_info->auth_tag_len         = transport_info->auth_tag_len;

                    }
                    DPRINT(("calling srtp_add_address, channel=%d, media_port=%d",
                            n, transport_info->media_port[n]));
                    DINDENT();
                    /* srtp_add_address and rtp_add_address are given the request_frame's not this frame's number,
                       because that's where the RTP flow started, and thus conversation needs to check against */
                    srtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, "SDP", request_frame,
                                    (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,
                                     transport_info->media[n].rtp_dyn_payload, srtp_info);
                    DENDENT();
                } else {
                    DPRINT(("calling rtp_add_address, channel=%d, media_port=%d",
                            n, transport_info->media_port[n]));
                    DINDENT();
                    rtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, "SDP", request_frame,
                                    (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,
                                    transport_info->media[n].rtp_dyn_payload);
                    DENDENT();
                 }
                transport_info->media[n].set_rtp = TRUE;
                /* SPRT might use the same port... */
                current_rtp_port = transport_info->media_port[n];

                if (rtcp_handle) {
                    if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {
                        DPRINT(("calling rtcp_add_address, channel=%d, media_port=%d",
                                n, transport_info->media_port[n]+1));
                        DINDENT();
                        srtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, "SDP", request_frame, srtp_info);
                        DENDENT();
                     } else {
                        DPRINT(("calling rtcp_add_address, channel=%d, media_port=%d",
                                n, transport_info->media_port[n]+1));
                        DINDENT();
                        rtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, "SDP", request_frame);
                        DENDENT();
                     }
                }
            }

            /* add SPRT conversation */
            if ((transport_info->proto_bitmask[n] & SDP_SPRT_PROTO) &&
                (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6)) &&
                (sprt_handle)) {

                if (transport_info->media_port[n] == 0 && current_rtp_port) {
                    sprt_add_address(pinfo, &transport_info->src_addr[n], current_rtp_port,
                                     0, "SDP", pinfo->fd->num); /* will use same port as RTP */
                } else {
                    sprt_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, "SDP", pinfo->fd->num);
                }
            }

            /* Add t38 conversation, if available and only if no rtp */
            if ((transport_info->media_port[n] != 0) &&
                !transport_info->media[n].set_rtp &&
                (transport_info->proto_bitmask[n] & SDP_T38_PROTO) &&
                (transport_info->proto_bitmask[n] & SDP_IPv4)) {
                t38_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, "SDP", pinfo->fd->num);
            }

            /* Add MSRP conversation.  Uses addresses discovered in attribute
               rather than connection information of media session line
               (already handled in media conversion) */
            if ((transport_info->proto_bitmask[n] & SDP_MSRP_PROTO) &&
                (transport_info->proto_bitmask[n] & SDP_MSRP_IPv4) &&
                msrp_handle) {
                msrp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], "SDP", pinfo->fd->num);
            }

            /* Free the hash table if we did't assigned it to a conv use it */
            if (!transport_info->media[n].set_rtp)
            {
                DPRINT(("set_rtp is not set, calling rtp_free_hash_dyn_payload, "
                        "channel=%d, media_port=%d",
                        n, transport_info->media_port[n]));
                rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);
                transport_info->media[n].rtp_dyn_payload = NULL;
            }

        } /* end for (n = 0; n <= transport_info->media_count; n++) */

        /* Free the remaining hash tables not used */
        if (transport_info->media_count == -1)
        {
            for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++)
            {
                if (!transport_info->media[n].set_rtp)
                {
                    DPRINT(("media_count == -1, calling rtp_free_hash_dyn_payload, "
                            "channel=%d, media_port=%d",
                            n, transport_info->media_port[n]));
                    rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);
                    transport_info->media[n].rtp_dyn_payload = NULL;
                }
            }
        }
        else
        {
            for (n = transport_info->media_count; n < SDP_MAX_RTP_CHANNELS; n++)
            {
                if (!transport_info->media[n].set_rtp)
                {
                    DPRINT(("media_count != -1, calling rtp_free_hash_dyn_payload, "
                            "channel=%d, media_port=%d",
                            n, transport_info->media_port[n]));
                    rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);
                    transport_info->media[n].rtp_dyn_payload = NULL;
                }
            }
        }
        transport_info->sdp_status = exchange_type;

    } else if ((exchange_type == SDP_EXCHANGE_ANSWER_REJECT) &&
               (transport_info->sdp_status != SDP_EXCHANGE_ANSWER_REJECT)) {

        /* Free the hash tables, since they won't be put to use */
        for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++)
        {
            if (!transport_info->media[n].set_rtp)
            {
                rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);
                transport_info->media[n].rtp_dyn_payload = NULL;
            }
        }

        transport_info->sdp_status = SDP_EXCHANGE_ANSWER_REJECT;
    }
}
