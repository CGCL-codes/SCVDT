static guint8
elem_a2p_bearer_format(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, guint len, ansi_a_shared_data_t *data_p)
{
    guint8                              oct;
    proto_item                          *item;
    proto_tree                          *subtree;
    guint8                              num_bearers;
    guint32                             curr_offset, orig_offset;
    guint8                              ip_addr_type;
    gboolean                            ext;
    guint8                              ext_len;
    const gchar                         *mime_type;
    int                                 sample_rate;
    gboolean                            format_assigned;
    gboolean                            in_band_format_assigned;
    gboolean                            first_assigned_found;
    gboolean                            rtp_dyn_payload_used;
    guint8                              rtp_payload_type;
    rtp_dyn_payload_t                  *rtp_dyn_payload;

    rtp_dyn_payload = rtp_dyn_payload_new();
    rtp_dyn_payload_used = FALSE;

    first_assigned_found = FALSE;

    curr_offset = offset;

    proto_tree_add_item(tree, hf_ansi_a_a2p_bearer_form_num_formats, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
    proto_tree_add_item(tree, hf_ansi_a_a2p_bearer_form_ip_addr_type, tvb, curr_offset, 1, ENC_BIG_ENDIAN);

    ip_addr_type = tvb_get_guint8(tvb, curr_offset) & 0x03;

    curr_offset++;

    num_bearers = 0;

    while ((len - (curr_offset - offset)) > 0)
    {
        orig_offset = curr_offset;

        item = proto_tree_add_text(tree, tvb, curr_offset, -1,
                "Bearer Format [%u]", num_bearers + 1);

        subtree = proto_item_add_subtree(item, ett_bearer_list);

        proto_tree_add_item(subtree, hf_ansi_a_a2p_bearer_form_format_len, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
        curr_offset++;

        NO_MORE_DATA_CHECK(len);

        proto_tree_add_item(subtree, hf_ansi_a_extension_8_80, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
        proto_tree_add_item(subtree, hf_ansi_a_a2p_bearer_form_format_tag_type, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
        proto_tree_add_item(subtree, hf_ansi_a_a2p_bearer_form_format_format_id, tvb, curr_offset, 1, ENC_BIG_ENDIAN);

        oct = tvb_get_guint8(tvb, curr_offset);

        ext = (oct & 0x80) ? TRUE : FALSE;

        format_assigned = FALSE;
        in_band_format_assigned = FALSE;

        switch ((oct & 0x70) >> 4)
        {
        case 1:
            in_band_format_assigned = TRUE;
            break;
        case 2:
            format_assigned = TRUE;
            break;
        }

        /*
         * sampling rates are based on the specific vocoder RFCs
         * (example subset RFC4788, RFC5188, RFC6884)
         */
        if (((oct & 0x0f) >= 10) &&
            ((oct & 0x0f) <= 15))
        {
            sample_rate = 16000;
        }
        else
        {
            sample_rate = 8000;
        }

        mime_type = val_to_str_const(oct & 0xf, ansi_a_a2p_bearer_form_format_format_id_vals, "Reserved");
        proto_item_append_text(item, " - (%s)", mime_type);
        curr_offset++;

        NO_MORE_DATA_CHECK(len);

        proto_tree_add_item(subtree, hf_ansi_a_a2p_bearer_form_format_rtp_payload_type, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
        proto_tree_add_item(subtree, hf_ansi_a_a2p_bearer_form_format_bearer_addr_flag, tvb, curr_offset, 1, ENC_BIG_ENDIAN);

        oct = tvb_get_guint8(tvb, curr_offset);

        rtp_payload_type = (oct & 0xfe) >> 1;

        curr_offset++;

        if (oct & 0x01)
        {
            /* bearer address included */

            if (ip_addr_type != 0)
            {
                SHORT_DATA_CHECK(len - (curr_offset - offset), 18);

                proto_tree_add_item(subtree, hf_ansi_a_a2p_bearer_form_format_ipv6_addr, tvb, curr_offset, 16, ENC_NA);

                if (format_assigned)
                {
                    data_p->rtp_src_addr.type = AT_IPv6;
                    data_p->rtp_src_addr.len = 16;
                    data_p->rtp_src_addr.data = (guint8 *) &data_p->rtp_ipv6_addr;

                    tvb_get_ipv6(tvb, curr_offset, &data_p->rtp_ipv6_addr);
                }

                curr_offset += 16;
            }
            else
            {
                SHORT_DATA_CHECK(len - (curr_offset - offset), 6);

                proto_tree_add_item(subtree, hf_ansi_a_a2p_bearer_form_format_ipv4_addr, tvb, curr_offset, 4, ENC_BIG_ENDIAN);

                if (format_assigned)
                {
                    data_p->rtp_src_addr.type = AT_IPv4;
                    data_p->rtp_src_addr.len = 4;
                    data_p->rtp_src_addr.data = (guint8 *) &data_p->rtp_ipv4_addr;

                    data_p->rtp_ipv4_addr = tvb_get_ipv4(tvb, curr_offset);
                }

                curr_offset += 4;
            }

            proto_tree_add_item(subtree, hf_ansi_a_a2p_bearer_form_format_udp_port, tvb, curr_offset, 2, ENC_BIG_ENDIAN);

            if (format_assigned)
            {
                data_p->rtp_port = tvb_get_ntohs(tvb, curr_offset);
            }

            curr_offset += 2;
        }

        if (ext)
        {
            SHORT_DATA_CHECK(len - (curr_offset - offset), 1);

            proto_tree_add_item(subtree, hf_ansi_a_a2p_bearer_form_format_ext_len, tvb, curr_offset, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(subtree, hf_ansi_a_a2p_bearer_form_format_ext_id, tvb, curr_offset, 1, ENC_BIG_ENDIAN);

            oct = tvb_get_guint8(tvb, curr_offset);

            ext_len = (oct & 0xf0) >> 4;

            curr_offset++;

            if (ext_len > 0)
            {
                SHORT_DATA_CHECK(len - (curr_offset - offset), ext_len);

                proto_tree_add_text(subtree, tvb, curr_offset, ext_len, "Extension Parameter value");

                curr_offset += ext_len;
            }
        }

        proto_item_set_len(item, curr_offset - orig_offset);

        if (format_assigned &&
            (first_assigned_found == FALSE))
        {
            rtp_dyn_payload_insert(rtp_dyn_payload, rtp_payload_type, mime_type, sample_rate);
            rtp_dyn_payload_used = TRUE;

            first_assigned_found = TRUE;
            rtp_add_address(pinfo, &data_p->rtp_src_addr, data_p->rtp_port, 0, "IOS5",
                pinfo->fd->num, FALSE, rtp_dyn_payload);
        }

        if (in_band_format_assigned)
        {
            rtp_dyn_payload_insert(rtp_dyn_payload, rtp_payload_type, "telephone-event", sample_rate);
            rtp_dyn_payload_used = TRUE;
        }

        num_bearers++;
    }

    if (rtp_dyn_payload_used == FALSE)
    {
        rtp_dyn_payload_free(rtp_dyn_payload);
    }

    EXTRANEOUS_DATA_CHECK(len, curr_offset - offset);

    return(curr_offset - offset);
}
