static int dissect_dof_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    conversation_t *conversation;
    tcp_session_data *session;
    tcp_packet_data *packet;
    struct tcpinfo *tcpinfo = (struct tcpinfo *)data;
    guint8 header;

    /* Get the TCP conversation. TCP creates a new conversation for each TCP connection,12
     * so we can "mirror" that by attaching our own data to that conversation. If our
     * data cannot be found, then it is a new connection (to us).
     */
    conversation = find_conversation(pinfo->fd->num, &pinfo->src, &pinfo->dst, pinfo->ptype, pinfo->srcport, pinfo->destport, 0);
    {
        /* This should be impossible - the TCP dissector requires this conversation.
         * Bail...
         */
        DISSECTOR_ASSERT(conversation != NULL);
    }


    /* This requires explanation. TCP will call this dissector, and we know
     * that the first byte (offset 0 of this tvb) is the first byte of an
     * DPS packet. The TCP dissector ensures this.
     *
     * We do *not* know that this is the only packet, and
     * so the dissector that we call below must handle framing. All of
     * this state must be stored, and so we store it in a transport
     * data structure. DPS packet data is created later and associated
     * differently.
     *
     * Further, this routine MAY be called MULTIPLE times for the SAME
     * frame with DIFFERENT sequence numbers. This makes handling
     * retransmissions very difficult - we must track each call to this
     * routine with its associated offset and ignore flag. However, due
     * to the way that Wireshark handles asking for more data we cannot
     * mark an offset as "duplicate" until after it has been processed.
     */

    /* TCP packet data is only associated with TCP frames that hold DPS packets. */
    session = (tcp_session_data *)conversation_get_proto_data(conversation, proto_2008_1_dof_tcp);
    if (session == NULL)
    {
        session = create_tcp_session_data(pinfo, conversation);
        if (!session)
        {
            fprintf(stderr, "! session");
            return 0;
        }

        conversation_add_proto_data(conversation, proto_2008_1_dof_tcp, session);
    }

    if (session->not_dps)
        return 0;

    packet = (tcp_packet_data *)p_get_proto_data(NULL, pinfo, proto_2008_1_dof_tcp, 0);
    if (packet == NULL)
    {
        packet = (tcp_packet_data *)wmem_alloc0(wmem_file_scope(), sizeof(tcp_packet_data));
        if (!packet)
        {
            fprintf(stderr, "! packet");
            return 0;
        }

        p_add_proto_data(NULL, pinfo, proto_2008_1_dof_tcp, 0, packet);
    }

    if (is_retransmission(pinfo, session, packet, tcpinfo))
        return 0;

    /* Loop, checking all the packets in this frame and communicating with the TCP
     * desegmenter. The framing dissector entry is used to determine the size
     * of the current frame.
     */
    {
        /* Note that we must handle fragmentation on TCP... */
        gint offset = 0;

        while (offset < (gint)tvb_reported_length(tvb))
        {
            gint available = tvb_ensure_captured_length_remaining(tvb, offset);
            int packet_length;

            header = tvb_get_guint8(tvb, offset);

            /* If we are negotiating, then we do not need the framing dissector
             * as we know the packet length is two. Note that for the first byte
             * of a TCP session there are only two cases, both handled here. An error
             * of not understanding the first byte will trigger that this is not
             * a DPS session.
             */
            if (((header & 0x80) == 0) && session->common.negotiation_required && ((pinfo->fd->num < session->common.negotiation_complete_at) || (session->common.negotiation_complete_at == 0)))
            {
                packet_length = 2;
                if (header > DNP_MAX_VERSION)
                {
                    session->not_dps = TRUE;
                    return 0;
                }
            }
            else
            {
                packet_length = dof_dissect_dnp_length(tvb, pinfo, header & 0x7F, &offset);
                if (packet_length < 0)
                {
                    session->not_dps = TRUE;
                    return offset;
                }
            }

            if (packet_length == 0)
            {
                pinfo->desegment_offset = offset;
                pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;
                return offset + available;
            }

            if (available < packet_length)
            {
                pinfo->desegment_offset = offset;
                pinfo->desegment_len = packet_length - available;
                return offset + available;
            }

            remember_offset(pinfo, session, packet, tcpinfo);
            if (is_retransmission(pinfo, session, packet, tcpinfo))
                return 0;

            /* We have a packet. We have to store the dof_packet_data in a list, as there may be
             * multiple DPS packets in a single Wireshark frame.
             */
            {
                tvbuff_t *next_tvb = tvb_new_subset(tvb, offset, packet_length, packet_length);
                tcp_dof_packet_ref *ref;
                gint raw_offset = tvb_raw_offset(tvb) + offset;
                gboolean ref_is_new = FALSE;

                /* Get the packet data. This is a list in increasing sequence order. */
                if (packet->dof_packets == NULL)
                {
                    ref_is_new = TRUE;
                    ref = (tcp_dof_packet_ref *)wmem_alloc0(wmem_file_scope(), sizeof(tcp_dof_packet_ref));
                    ref->transport_packet.sender_id = assign_addr_port_id(&pinfo->src, pinfo->srcport);
                    ref->transport_packet.receiver_id = assign_addr_port_id(&pinfo->dst, pinfo->destport);
                    packet->dof_packets = ref;
                    ref->start_offset = raw_offset;
                }
                else
                    ref = packet->dof_packets;

                /* Find the entry for our offset. */
                while (ref->start_offset != raw_offset)
                {
                    if (ref->next)
                    {
                        ref = ref->next;
                        continue;
                    }

                    {
                        tcp_dof_packet_ref *last = ref;

                        /* This is the default state, NULL and 0. */
                        ref_is_new = TRUE;
                        ref = wmem_new0(wmem_file_scope(), tcp_dof_packet_ref);
                        if (!ref)
                        {
                            fprintf(stderr, "! ref");
                            return offset;
                        }

                        ref->transport_packet.sender_id = last->transport_packet.sender_id;
                        ref->transport_packet.receiver_id = last->transport_packet.receiver_id;
                        ref->start_offset = raw_offset;
                        last->next = ref;
                    }
                }

                if (ref_is_new)
                {
                    dof_transport_packet *tp = &(ref->transport_packet);

                    tp->is_sent_by_client = FALSE;
                    if (addresses_equal(&session->client.addr, &pinfo->src) &&
                        (session->client.port == pinfo->srcport))
                        tp->is_sent_by_client = TRUE;

                    ref->api_data.transport_session = (dof_transport_session *)&(session->common);
                    ref->api_data.transport_packet = tp;
                }


                dissect_dof_common(next_tvb, pinfo, tree, &ref->api_data);
            }

            offset += packet_length;
        }

        return offset;
    }
}
