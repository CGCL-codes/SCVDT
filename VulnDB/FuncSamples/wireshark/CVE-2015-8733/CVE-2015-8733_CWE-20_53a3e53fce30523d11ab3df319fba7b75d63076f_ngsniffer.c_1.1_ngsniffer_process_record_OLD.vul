static int
ngsniffer_process_record(wtap *wth, gboolean is_random, guint *padding,
    struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)
{
	ngsniffer_t *ngsniffer;
	char	record_type[2];
	char	record_length[4]; /* only 1st 2 bytes are length */
	guint16	type, length;
	struct frame2_rec frame2;
	struct frame4_rec frame4;
	struct frame6_rec frame6;
	guint16	time_low, time_med, true_size, size;
	guint8	time_high, time_day;
	guint64 t, tsecs, tpsecs;

	/*
	 * Read the record header.
	 */
	if (!ng_read_bytes_or_eof(wth, record_type, 2, is_random, err, err_info)) {
		if (*err != 0)
			return -1;
		return REC_EOF;
	}
	if (!ng_read_bytes(wth, record_length, 4, is_random, err, err_info))
		return -1;

	type = pletoh16(record_type);
	length = pletoh16(record_length);

	ngsniffer = (ngsniffer_t *)wth->priv;
	switch (type) {

	case REC_FRAME2:
		if (ngsniffer->network == NETWORK_ATM) {
			/*
			 * We shouldn't get a frame2 record in
			 * an ATM capture.
			 */
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup("ngsniffer: REC_FRAME2 record in an ATM Sniffer file");
			return -1;
		}

		/* Read the f_frame2_struct */
		if (!ng_read_bytes(wth, &frame2, (unsigned int)sizeof frame2,
		   is_random, err, err_info))
			return -1;
		time_low = pletoh16(&frame2.time_low);
		time_med = pletoh16(&frame2.time_med);
		time_high = frame2.time_high;
		time_day = frame2.time_day;
		size = pletoh16(&frame2.size);
		true_size = pletoh16(&frame2.true_size);

		length -= sizeof frame2;	/* we already read that much */

		set_pseudo_header_frame2(wth, &phdr->pseudo_header, &frame2);
		break;

	case REC_FRAME4:
		if (ngsniffer->network != NETWORK_ATM) {
			/*
			 * We shouldn't get a frame2 record in
			 * a non-ATM capture.
			 */
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup("ngsniffer: REC_FRAME4 record in a non-ATM Sniffer file");
			return -1;
		}

		/* Read the f_frame4_struct */
		if (!ng_read_bytes(wth, &frame4, (unsigned int)sizeof frame4,
		    is_random, err, err_info))
			return -1;
		time_low = pletoh16(&frame4.time_low);
		time_med = pletoh16(&frame4.time_med);
		time_high = frame4.time_high;
		time_day = frame4.time_day;
		size = pletoh16(&frame4.size);
		true_size = pletoh16(&frame4.true_size);

		/*
		 * XXX - it looks as if some version 4 captures have
		 * a bogus record length, based on the assumption
		 * that the record is a frame2 record.
		 */
		if (ngsniffer->maj_vers >= 5)
			length -= sizeof frame4;	/* we already read that much */
		else {
			if (ngsniffer->min_vers >= 95)
				length -= sizeof frame2;
			else
				length -= sizeof frame4;
		}

		set_pseudo_header_frame4(&phdr->pseudo_header, &frame4);
		break;

	case REC_FRAME6:
		/* Read the f_frame6_struct */
		if (!ng_read_bytes(wth, &frame6, (unsigned int)sizeof frame6,
		    is_random, err, err_info))
			return -1;
		time_low = pletoh16(&frame6.time_low);
		time_med = pletoh16(&frame6.time_med);
		time_high = frame6.time_high;
		time_day = frame6.time_day;
		size = pletoh16(&frame6.size);
		true_size = pletoh16(&frame6.true_size);

		length -= sizeof frame6;	/* we already read that much */

		set_pseudo_header_frame6(wth, &phdr->pseudo_header, &frame6);
		break;

	case REC_EOF:
		/*
		 * End of file.  Return an EOF indication.
		 */
		*err = 0;	/* EOF, not error */
		return REC_EOF;

	default:
		/*
		 * Unknown record type, or type that's not an EOF or
		 * a packet record.
		 */
		if (padding != NULL) {
			/*
			 * Treat the entire record as padding, so we
			 * skip it.
			 */
			*padding = length;
		}
		return type;	/* unknown type */
	}

	/*
	 * This is a packet record.
	 *
	 * Is the frame data size greater than than what's left of the
	 * record?
	 */
	if (size > length) {
		/*
		 * Yes - treat this as an error.
		 */
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup("ngsniffer: Record length is less than packet size");
		return -1;
	}

	if (padding != NULL) {
		/*
		 * Padding, if the frame data size is less than what's
		 * left of the record.
		 */
		*padding = length - size;
	}

	phdr->rec_type = REC_TYPE_PACKET;
	phdr->presence_flags = true_size ? WTAP_HAS_TS|WTAP_HAS_CAP_LEN : WTAP_HAS_TS;
	phdr->len = true_size ? true_size : size;
	phdr->caplen = size;

	/*
	 * Read the packet data.
	 */
	ws_buffer_assure_space(buf, size);
	if (!ng_read_bytes(wth, ws_buffer_start_ptr(buf), size, is_random,
	    err, err_info))
		return -1;

	phdr->pkt_encap = fix_pseudo_header(wth->file_encap,
	    buf, length, &phdr->pseudo_header);

	/*
	 * 40-bit time stamp, in units of timeunit picoseconds.
	 */
	t = (((guint64)time_high)<<32) | (((guint64)time_med) << 16) | time_low;

	/*
	 * timeunit is always < 2^(64-40), so t * timeunit fits in 64
	 * bits.  That gives a 64-bit time stamp, in units of
	 * picoseconds.
	 */
	t *= ngsniffer->timeunit;

	/*
	 * Convert to seconds and picoseconds.
	 */
	tsecs = t/G_GUINT64_CONSTANT(1000000000000);
	tpsecs = t - tsecs*G_GUINT64_CONSTANT(1000000000000);

	/*
	 * Add in the time_day value (86400 seconds/day).
	 */
	tsecs += time_day*86400;

	/*
	 * Add in the capture start time.
	 */
	tsecs += ngsniffer->start;

	phdr->ts.secs = (time_t)tsecs;
	phdr->ts.nsecs = (int)(tpsecs/1000);	/* psecs to nsecs */

	return type;	/* success */
}
