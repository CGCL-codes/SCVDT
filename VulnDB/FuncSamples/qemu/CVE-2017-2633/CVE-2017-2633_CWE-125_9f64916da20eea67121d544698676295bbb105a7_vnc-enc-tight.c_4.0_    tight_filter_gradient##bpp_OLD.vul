    static void                                                         \
    tight_filter_gradient##bpp(VncState *vs, uint##bpp##_t *buf,        \
                               int w, int h) {                          \
        uint##bpp##_t pix, diff;                                        \
        bool endian;                                                    \
        int *prev;                                                      \
        int max[3], shift[3];                                           \
        int here[3], upper[3], left[3], upperleft[3];                   \
        int prediction;                                                 \
        int x, y, c;                                                    \
                                                                        \
        memset (vs->tight.gradient.buffer, 0, w * 3 * sizeof(int));     \
                                                                        \
        endian = ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) !=        \
                  (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG));     \
                                                                        \
        max[0] = vs->clientds.pf.rmax;                                  \
        max[1] = vs->clientds.pf.gmax;                                  \
        max[2] = vs->clientds.pf.bmax;                                  \
        shift[0] = vs->clientds.pf.rshift;                              \
        shift[1] = vs->clientds.pf.gshift;                              \
        shift[2] = vs->clientds.pf.bshift;                              \
                                                                        \
        for (y = 0; y < h; y++) {                                       \
            for (c = 0; c < 3; c++) {                                   \
                upper[c] = 0;                                           \
                here[c] = 0;                                            \
            }                                                           \
            prev = (int *)vs->tight.gradient.buffer;                    \
            for (x = 0; x < w; x++) {                                   \
                pix = *buf;                                             \
                if (endian) {                                           \
                    pix = bswap##bpp(pix);                              \
                }                                                       \
                diff = 0;                                               \
                for (c = 0; c < 3; c++) {                               \
                    upperleft[c] = upper[c];                            \
                    left[c] = here[c];                                  \
                    upper[c] = *prev;                                   \
                    here[c] = (int)(pix >> shift[c] & max[c]);          \
                    *prev++ = here[c];                                  \
                                                                        \
                    prediction = left[c] + upper[c] - upperleft[c];     \
                    if (prediction < 0) {                               \
                        prediction = 0;                                 \
                    } else if (prediction > max[c]) {                   \
                        prediction = max[c];                            \
                    }                                                   \
                    diff |= ((here[c] - prediction) & max[c])           \
                        << shift[c];                                    \
                }                                                       \
                if (endian) {                                           \
                    diff = bswap##bpp(diff);                            \
                }                                                       \
                *buf++ = diff;                                          \
            }                                                           \
        }                                                               \
    }
