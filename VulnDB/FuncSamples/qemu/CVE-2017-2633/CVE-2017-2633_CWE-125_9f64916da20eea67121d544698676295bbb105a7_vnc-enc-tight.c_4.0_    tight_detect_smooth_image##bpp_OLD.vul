    static unsigned int                                                 \
    tight_detect_smooth_image##bpp(VncState *vs, int w, int h) {        \
        bool endian;                                                    \
        uint##bpp##_t pix;                                              \
        int max[3], shift[3];                                           \
        int x, y, d, dx;                                                \
        unsigned int c;                                                 \
        unsigned int stats[256];                                        \
        int pixels = 0;                                                 \
        int sample, sum, left[3];                                       \
        unsigned int errors;                                            \
        unsigned char *buf = vs->tight.tight.buffer;                    \
                                                                        \
        endian = ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) !=        \
                  (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG));     \
                                                                        \
                                                                        \
        max[0] = vs->clientds.pf.rmax;                                  \
        max[1] = vs->clientds.pf.gmax;                                  \
        max[2] = vs->clientds.pf.bmax;                                  \
        shift[0] = vs->clientds.pf.rshift;                              \
        shift[1] = vs->clientds.pf.gshift;                              \
        shift[2] = vs->clientds.pf.bshift;                              \
                                                                        \
        memset(stats, 0, sizeof(stats));                                \
                                                                        \
        y = 0, x = 0;                                                   \
        while (y < h && x < w) {                                        \
            for (d = 0; d < h - y &&                                    \
                     d < w - x - VNC_TIGHT_DETECT_SUBROW_WIDTH; d++) {  \
                pix = ((uint##bpp##_t *)buf)[(y+d)*w+x+d];              \
                if (endian) {                                           \
                    pix = bswap##bpp(pix);                              \
                }                                                       \
                for (c = 0; c < 3; c++) {                               \
                    left[c] = (int)(pix >> shift[c] & max[c]);          \
                }                                                       \
                for (dx = 1; dx <= VNC_TIGHT_DETECT_SUBROW_WIDTH;       \
                     dx++) {                                            \
                    pix = ((uint##bpp##_t *)buf)[(y+d)*w+x+d+dx];       \
                    if (endian) {                                       \
                        pix = bswap##bpp(pix);                          \
                    }                                                   \
                    sum = 0;                                            \
                    for (c = 0; c < 3; c++) {                           \
                        sample = (int)(pix >> shift[c] & max[c]);       \
                        sum += abs(sample - left[c]);                   \
                        left[c] = sample;                               \
                    }                                                   \
                    if (sum > 255) {                                    \
                        sum = 255;                                      \
                    }                                                   \
                    stats[sum]++;                                       \
                    pixels++;                                           \
                }                                                       \
            }                                                           \
            if (w > h) {                                                \
                x += h;                                                 \
                y = 0;                                                  \
            } else {                                                    \
                x = 0;                                                  \
                y += w;                                                 \
            }                                                           \
        }                                                               \
                                                                        \
        if ((stats[0] + stats[1]) * 100 / pixels >= 90) {               \
            return 0;                                                   \
        }                                                               \
                                                                        \
        errors = 0;                                                     \
        for (c = 1; c < 8; c++) {                                       \
            errors += stats[c] * (c * c);                               \
            if (stats[c] == 0 || stats[c] > stats[c-1] * 2) {           \
                return 0;                                               \
            }                                                           \
        }                                                               \
        for (; c < 256; c++) {                                          \
            errors += stats[c] * (c * c);                               \
        }                                                               \
        errors /= (pixels - stats[0]);                                  \
                                                                        \
        return errors;                                                  \
    }
