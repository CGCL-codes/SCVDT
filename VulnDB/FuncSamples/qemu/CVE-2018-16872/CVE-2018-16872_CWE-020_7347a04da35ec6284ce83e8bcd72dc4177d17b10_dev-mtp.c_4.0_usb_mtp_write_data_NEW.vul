static void usb_mtp_write_data(MTPState *s)
{
    MTPData *d = s->data_out;
    MTPObject *parent =
        usb_mtp_object_lookup(s, s->dataset.parent_handle);
    char *path = NULL;
    int rc = -1;
    mode_t mask = 0644;

    assert(d != NULL);

    if (parent == NULL || !s->write_pending) {
        usb_mtp_queue_result(s, RES_INVALID_OBJECTINFO, d->trans,
                             0, 0, 0, 0);
        return;
    }

    if (s->dataset.filename) {
        path = g_strdup_printf("%s/%s", parent->path, s->dataset.filename);
        if (s->dataset.format == FMT_ASSOCIATION) {
            d->fd = mkdir(path, mask);
            goto free;
        }
        if (s->dataset.size < d->length) {
            usb_mtp_queue_result(s, RES_STORE_FULL, d->trans,
                                 0, 0, 0, 0);
            goto done;
        }
        d->fd = open(path, O_CREAT | O_WRONLY | O_CLOEXEC | O_NOFOLLOW, mask);
        if (d->fd == -1) {
            usb_mtp_queue_result(s, RES_STORE_FULL, d->trans,
                                 0, 0, 0, 0);
            goto done;
        }

        /*
         * Return success if initiator sent 0 sized data
         */
        if (!s->dataset.size) {
            goto success;
        }

        rc = write(d->fd, d->data, s->dataset.size);
        if (rc == -1) {
            usb_mtp_queue_result(s, RES_STORE_FULL, d->trans,
                                 0, 0, 0, 0);
            goto done;
            }
        if (rc != s->dataset.size) {
            usb_mtp_queue_result(s, RES_INCOMPLETE_TRANSFER, d->trans,
                                 0, 0, 0, 0);
            goto done;
        }
    }

success:
    usb_mtp_queue_result(s, RES_OK, d->trans,
                         0, 0, 0, 0);

done:
    /*
     * The write dataset is kept around and freed only
     * on success or if another write request comes in
     */
    if (d->fd != -1) {
        close(d->fd);
    }
free:
    g_free(s->dataset.filename);
    g_free(path);
    s->write_pending = false;
}
