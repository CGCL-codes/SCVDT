static void char2_field_tests(void)
{
    BN_CTX *ctx = NULL;
    BIGNUM *p, *a, *b;
    EC_GROUP *group;
    EC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 =
        NULL, *C2_K571 = NULL;
    EC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 =
        NULL, *C2_B571 = NULL;
    EC_POINT *P, *Q, *R;
    BIGNUM *x, *y, *z, *cof;
    unsigned char buf[100];
    size_t i, len;
    int k;

#  if 1                         /* optional */
    ctx = BN_CTX_new();
    if (!ctx)
        ABORT;
#  endif

    p = BN_new();
    a = BN_new();
    b = BN_new();
    if (!p || !a || !b)
        ABORT;

    if (!BN_hex2bn(&p, "13"))
        ABORT;
    if (!BN_hex2bn(&a, "3"))
        ABORT;
    if (!BN_hex2bn(&b, "1"))
        ABORT;

    group = EC_GROUP_new(EC_GF2m_simple_method()); /* applications should use
                                                    * EC_GROUP_new_curve_GF2m
                                                    * so that the library gets
                                                    * to choose the EC_METHOD */
    if (!group)
        ABORT;
    if (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx))
        ABORT;

    {
        EC_GROUP *tmp;
        tmp = EC_GROUP_new(EC_GROUP_method_of(group));
        if (!tmp)
            ABORT;
        if (!EC_GROUP_copy(tmp, group))
            ABORT;
        EC_GROUP_free(group);
        group = tmp;
    }

    if (!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx))
        ABORT;

    fprintf(stdout,
            "Curve defined by Weierstrass equation\n     y^2 + x*y = x^3 + a*x^2 + b  (mod 0x");
    BN_print_fp(stdout, p);
    fprintf(stdout, ")\n     a = 0x");
    BN_print_fp(stdout, a);
    fprintf(stdout, "\n     b = 0x");
    BN_print_fp(stdout, b);
    fprintf(stdout, "\n(0x... means binary polynomial)\n");

    P = EC_POINT_new(group);
    Q = EC_POINT_new(group);
    R = EC_POINT_new(group);
    if (!P || !Q || !R)
        ABORT;

    if (!EC_POINT_set_to_infinity(group, P))
        ABORT;
    if (!EC_POINT_is_at_infinity(group, P))
        ABORT;

    buf[0] = 0;
    if (!EC_POINT_oct2point(group, Q, buf, 1, ctx))
        ABORT;

    if (!EC_POINT_add(group, P, P, Q, ctx))
        ABORT;
    if (!EC_POINT_is_at_infinity(group, P))
        ABORT;

    x = BN_new();
    y = BN_new();
    z = BN_new();
    cof = BN_new();
    if (!x || !y || !z || !cof)
        ABORT;

    if (!BN_hex2bn(&x, "6"))
        ABORT;
/* Change test based on whether binary point compression is enabled or not. */
#  ifdef OPENSSL_EC_BIN_PT_COMP
    if (!EC_POINT_set_compressed_coordinates_GF2m(group, Q, x, 1, ctx))
        ABORT;
#  else
    if (!BN_hex2bn(&y, "8"))
        ABORT;
    if (!EC_POINT_set_affine_coordinates_GF2m(group, Q, x, y, ctx))
        ABORT;
#  endif
    if (EC_POINT_is_on_curve(group, Q, ctx) <= 0) {
/* Change test based on whether binary point compression is enabled or not. */
#  ifdef OPENSSL_EC_BIN_PT_COMP
        if (!EC_POINT_get_affine_coordinates_GF2m(group, Q, x, y, ctx))
            ABORT;
#  endif
        fprintf(stderr, "Point is not on curve: x = 0x");
        BN_print_fp(stderr, x);
        fprintf(stderr, ", y = 0x");
        BN_print_fp(stderr, y);
        fprintf(stderr, "\n");
        ABORT;
    }

    fprintf(stdout, "A cyclic subgroup:\n");
    k = 100;
    do {
        if (k-- == 0)
            ABORT;

        if (EC_POINT_is_at_infinity(group, P))
            fprintf(stdout, "     point at infinity\n");
        else {
            if (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx))
                ABORT;

            fprintf(stdout, "     x = 0x");
            BN_print_fp(stdout, x);
            fprintf(stdout, ", y = 0x");
            BN_print_fp(stdout, y);
            fprintf(stdout, "\n");
        }

        if (!EC_POINT_copy(R, P))
            ABORT;
        if (!EC_POINT_add(group, P, P, Q, ctx))
            ABORT;
    }
    while (!EC_POINT_is_at_infinity(group, P));

    if (!EC_POINT_add(group, P, Q, R, ctx))
        ABORT;
    if (!EC_POINT_is_at_infinity(group, P))
        ABORT;

/* Change test based on whether binary point compression is enabled or not. */
#  ifdef OPENSSL_EC_BIN_PT_COMP
    len =
        EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf,
                           sizeof(buf), ctx);
    if (len == 0)
        ABORT;
    if (!EC_POINT_oct2point(group, P, buf, len, ctx))
        ABORT;
    if (0 != EC_POINT_cmp(group, P, Q, ctx))
        ABORT;
    fprintf(stdout, "Generator as octet string, compressed form:\n     ");
    for (i = 0; i < len; i++)
        fprintf(stdout, "%02X", buf[i]);
#  endif

    len =
        EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf,
                           sizeof(buf), ctx);
    if (len == 0)
        ABORT;
    if (!EC_POINT_oct2point(group, P, buf, len, ctx))
        ABORT;
    if (0 != EC_POINT_cmp(group, P, Q, ctx))
        ABORT;
    fprintf(stdout, "\nGenerator as octet string, uncompressed form:\n     ");
    for (i = 0; i < len; i++)
        fprintf(stdout, "%02X", buf[i]);

/* Change test based on whether binary point compression is enabled or not. */
#  ifdef OPENSSL_EC_BIN_PT_COMP
    len =
        EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof(buf),
                           ctx);
    if (len == 0)
        ABORT;
    if (!EC_POINT_oct2point(group, P, buf, len, ctx))
        ABORT;
    if (0 != EC_POINT_cmp(group, P, Q, ctx))
        ABORT;
    fprintf(stdout, "\nGenerator as octet string, hybrid form:\n     ");
    for (i = 0; i < len; i++)
        fprintf(stdout, "%02X", buf[i]);
#  endif

    fprintf(stdout, "\n");

    if (!EC_POINT_invert(group, P, ctx))
        ABORT;
    if (0 != EC_POINT_cmp(group, P, R, ctx))
        ABORT;

    /* Curve K-163 (FIPS PUB 186-2, App. 6) */
    CHAR2_CURVE_TEST
        ("NIST curve K-163",
         "0800000000000000000000000000000000000000C9",
         "1",
         "1",
         "02FE13C0537BBC11ACAA07D793DE4E6D5E5C94EEE8",
         "0289070FB05D38FF58321F2E800536D538CCDAA3D9",
         1, "04000000000000000000020108A2E0CC0D99F8A5EF", "2", 163, C2_K163);

    /* Curve B-163 (FIPS PUB 186-2, App. 6) */
    CHAR2_CURVE_TEST
        ("NIST curve B-163",
         "0800000000000000000000000000000000000000C9",
         "1",
         "020A601907B8C953CA1481EB10512F78744A3205FD",
         "03F0EBA16286A2D57EA0991168D4994637E8343E36",
         "00D51FBC6C71A0094FA2CDD545B11C5C0C797324F1",
         1, "040000000000000000000292FE77E70C12A4234C33", "2", 163, C2_B163);

    /* Curve K-233 (FIPS PUB 186-2, App. 6) */
    CHAR2_CURVE_TEST
        ("NIST curve K-233",
         "020000000000000000000000000000000000000004000000000000000001",
         "0",
         "1",
         "017232BA853A7E731AF129F22FF4149563A419C26BF50A4C9D6EEFAD6126",
         "01DB537DECE819B7F70F555A67C427A8CD9BF18AEB9B56E0C11056FAE6A3",
         0,
         "008000000000000000000000000000069D5BB915BCD46EFB1AD5F173ABDF",
         "4", 233, C2_K233);

    /* Curve B-233 (FIPS PUB 186-2, App. 6) */
    CHAR2_CURVE_TEST
        ("NIST curve B-233",
         "020000000000000000000000000000000000000004000000000000000001",
         "000000000000000000000000000000000000000000000000000000000001",
         "0066647EDE6C332C7F8C0923BB58213B333B20E9CE4281FE115F7D8F90AD",
         "00FAC9DFCBAC8313BB2139F1BB755FEF65BC391F8B36F8F8EB7371FD558B",
         "01006A08A41903350678E58528BEBF8A0BEFF867A7CA36716F7E01F81052",
         1,
         "01000000000000000000000000000013E974E72F8A6922031D2603CFE0D7",
         "2", 233, C2_B233);

    /* Curve K-283 (FIPS PUB 186-2, App. 6) */
    CHAR2_CURVE_TEST
        ("NIST curve K-283",
         "0800000000000000000000000000000000000000000000000000000000000000000010A1",
         "0",
         "1",
         "0503213F78CA44883F1A3B8162F188E553CD265F23C1567A16876913B0C2AC2458492836",
         "01CCDA380F1C9E318D90F95D07E5426FE87E45C0E8184698E45962364E34116177DD2259",
         0,
         "01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE9AE2ED07577265DFF7F94451E061E163C61",
         "4", 283, C2_K283);

    /* Curve B-283 (FIPS PUB 186-2, App. 6) */
    CHAR2_CURVE_TEST
        ("NIST curve B-283",
         "0800000000000000000000000000000000000000000000000000000000000000000010A1",
         "000000000000000000000000000000000000000000000000000000000000000000000001",
         "027B680AC8B8596DA5A4AF8A19A0303FCA97FD7645309FA2A581485AF6263E313B79A2F5",
         "05F939258DB7DD90E1934F8C70B0DFEC2EED25B8557EAC9C80E2E198F8CDBECD86B12053",
         "03676854FE24141CB98FE6D4B20D02B4516FF702350EDDB0826779C813F0DF45BE8112F4",
         1,
         "03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEF90399660FC938A90165B042A7CEFADB307",
         "2", 283, C2_B283);

    /* Curve K-409 (FIPS PUB 186-2, App. 6) */
    CHAR2_CURVE_TEST
        ("NIST curve K-409",
         "02000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000001",
         "0",
         "1",
         "0060F05F658F49C1AD3AB1890F7184210EFD0987E307C84C27ACCFB8F9F67CC2C460189EB5AAAA62EE222EB1B35540CFE9023746",
         "01E369050B7C4E42ACBA1DACBF04299C3460782F918EA427E6325165E9EA10E3DA5F6C42E9C55215AA9CA27A5863EC48D8E0286B",
         1,
         "007FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE5F83B2D4EA20400EC4557D5ED3E3E7CA5B4B5C83B8E01E5FCF",
         "4", 409, C2_K409);

    /* Curve B-409 (FIPS PUB 186-2, App. 6) */
    CHAR2_CURVE_TEST
        ("NIST curve B-409",
         "02000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000001",
         "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001",
         "0021A5C2C8EE9FEB5C4B9A753B7B476B7FD6422EF1F3DD674761FA99D6AC27C8A9A197B272822F6CD57A55AA4F50AE317B13545F",
         "015D4860D088DDB3496B0C6064756260441CDE4AF1771D4DB01FFE5B34E59703DC255A868A1180515603AEAB60794E54BB7996A7",
         "0061B1CFAB6BE5F32BBFA78324ED106A7636B9C5A7BD198D0158AA4F5488D08F38514F1FDF4B4F40D2181B3681C364BA0273C706",
         1,
         "010000000000000000000000000000000000000000000000000001E2AAD6A612F33307BE5FA47C3C9E052F838164CD37D9A21173",
         "2", 409, C2_B409);

    /* Curve K-571 (FIPS PUB 186-2, App. 6) */
    CHAR2_CURVE_TEST
        ("NIST curve K-571",
         "80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000425",
         "0",
         "1",
         "026EB7A859923FBC82189631F8103FE4AC9CA2970012D5D46024804801841CA44370958493B205E647DA304DB4CEB08CBBD1BA39494776FB988B47174DCA88C7E2945283A01C8972",
         "0349DC807F4FBF374F4AEADE3BCA95314DD58CEC9F307A54FFC61EFC006D8A2C9D4979C0AC44AEA74FBEBBB9F772AEDCB620B01A7BA7AF1B320430C8591984F601CD4C143EF1C7A3",
         0,
         "020000000000000000000000000000000000000000000000000000000000000000000000131850E1F19A63E4B391A8DB917F4138B630D84BE5D639381E91DEB45CFE778F637C1001",
         "4", 571, C2_K571);

    /* Curve B-571 (FIPS PUB 186-2, App. 6) */
    CHAR2_CURVE_TEST
        ("NIST curve B-571",
         "80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000425",
         "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001",
         "02F40E7E2221F295DE297117B7F3D62F5C6A97FFCB8CEFF1CD6BA8CE4A9A18AD84FFABBD8EFA59332BE7AD6756A66E294AFD185A78FF12AA520E4DE739BACA0C7FFEFF7F2955727A",
         "0303001D34B856296C16C0D40D3CD7750A93D1D2955FA80AA5F40FC8DB7B2ABDBDE53950F4C0D293CDD711A35B67FB1499AE60038614F1394ABFA3B4C850D927E1E7769C8EEC2D19",
         "037BF27342DA639B6DCCFFFEB73D69D78C6C27A6009CBBCA1980F8533921E8A684423E43BAB08A576291AF8F461BB2A8B3531D2F0485C19B16E2F1516E23DD3C1A4827AF1B8AC15B",
         1,
         "03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE661CE18FF55987308059B186823851EC7DD9CA1161DE93D5174D66E8382E9BB2FE84E47",
         "2", 571, C2_B571);

    /* more tests using the last curve */

    if (!EC_POINT_copy(Q, P))
        ABORT;
    if (EC_POINT_is_at_infinity(group, Q))
        ABORT;
    if (!EC_POINT_dbl(group, P, P, ctx))
        ABORT;
    if (EC_POINT_is_on_curve(group, P, ctx) <= 0)
        ABORT;
    if (!EC_POINT_invert(group, Q, ctx))
        ABORT;                  /* P = -2Q */

    if (!EC_POINT_add(group, R, P, Q, ctx))
        ABORT;
    if (!EC_POINT_add(group, R, R, Q, ctx))
        ABORT;
    if (!EC_POINT_is_at_infinity(group, R))
        ABORT;                  /* R = P + 2Q */

    {
        const EC_POINT *points[3];
        const BIGNUM *scalars[3];

        if (EC_POINT_is_at_infinity(group, Q))
            ABORT;
        points[0] = Q;
        points[1] = Q;
        points[2] = Q;

        if (!BN_add(y, z, BN_value_one()))
            ABORT;
        if (BN_is_odd(y))
            ABORT;
        if (!BN_rshift1(y, y))
            ABORT;
        scalars[0] = y;         /* (group order + 1)/2, so y*Q + y*Q = Q */
        scalars[1] = y;

        fprintf(stdout, "combined multiplication ...");
        fflush(stdout);

        /* z is still the group order */
        if (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx))
            ABORT;
        if (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx))
            ABORT;
        if (0 != EC_POINT_cmp(group, P, R, ctx))
            ABORT;
        if (0 != EC_POINT_cmp(group, R, Q, ctx))
            ABORT;

        fprintf(stdout, ".");
        fflush(stdout);

        if (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0))
            ABORT;
        if (!BN_add(z, z, y))
            ABORT;
        BN_set_negative(z, 1);
        scalars[0] = y;
        scalars[1] = z;         /* z = -(order + y) */

        if (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx))
            ABORT;
        if (!EC_POINT_is_at_infinity(group, P))
            ABORT;

        fprintf(stdout, ".");
        fflush(stdout);

        if (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0))
            ABORT;
        if (!BN_add(z, x, y))
            ABORT;
        BN_set_negative(z, 1);
        scalars[0] = x;
        scalars[1] = y;
        scalars[2] = z;         /* z = -(x+y) */

        if (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx))
            ABORT;
        if (!EC_POINT_is_at_infinity(group, P))
            ABORT;

        fprintf(stdout, " ok\n\n");
    }

#  if 0
    timings(C2_K163, TIMING_BASE_PT, ctx);
    timings(C2_K163, TIMING_RAND_PT, ctx);
    timings(C2_K163, TIMING_SIMUL, ctx);
    timings(C2_B163, TIMING_BASE_PT, ctx);
    timings(C2_B163, TIMING_RAND_PT, ctx);
    timings(C2_B163, TIMING_SIMUL, ctx);
    timings(C2_K233, TIMING_BASE_PT, ctx);
    timings(C2_K233, TIMING_RAND_PT, ctx);
    timings(C2_K233, TIMING_SIMUL, ctx);
    timings(C2_B233, TIMING_BASE_PT, ctx);
    timings(C2_B233, TIMING_RAND_PT, ctx);
    timings(C2_B233, TIMING_SIMUL, ctx);
    timings(C2_K283, TIMING_BASE_PT, ctx);
    timings(C2_K283, TIMING_RAND_PT, ctx);
    timings(C2_K283, TIMING_SIMUL, ctx);
    timings(C2_B283, TIMING_BASE_PT, ctx);
    timings(C2_B283, TIMING_RAND_PT, ctx);
    timings(C2_B283, TIMING_SIMUL, ctx);
    timings(C2_K409, TIMING_BASE_PT, ctx);
    timings(C2_K409, TIMING_RAND_PT, ctx);
    timings(C2_K409, TIMING_SIMUL, ctx);
    timings(C2_B409, TIMING_BASE_PT, ctx);
    timings(C2_B409, TIMING_RAND_PT, ctx);
    timings(C2_B409, TIMING_SIMUL, ctx);
    timings(C2_K571, TIMING_BASE_PT, ctx);
    timings(C2_K571, TIMING_RAND_PT, ctx);
    timings(C2_K571, TIMING_SIMUL, ctx);
    timings(C2_B571, TIMING_BASE_PT, ctx);
    timings(C2_B571, TIMING_RAND_PT, ctx);
    timings(C2_B571, TIMING_SIMUL, ctx);
#  endif

    if (ctx)
        BN_CTX_free(ctx);
    BN_free(p);
    BN_free(a);
    BN_free(b);
    EC_GROUP_free(group);
    EC_POINT_free(P);
    EC_POINT_free(Q);
    EC_POINT_free(R);
    BN_free(x);
    BN_free(y);
    BN_free(z);
    BN_free(cof);

    if (C2_K163)
        EC_GROUP_free(C2_K163);
    if (C2_B163)
        EC_GROUP_free(C2_B163);
    if (C2_K233)
        EC_GROUP_free(C2_K233);
    if (C2_B233)
        EC_GROUP_free(C2_B233);
    if (C2_K283)
        EC_GROUP_free(C2_K283);
    if (C2_B283)
        EC_GROUP_free(C2_B283);
    if (C2_K409)
        EC_GROUP_free(C2_K409);
    if (C2_B409)
        EC_GROUP_free(C2_B409);
    if (C2_K571)
        EC_GROUP_free(C2_K571);
    if (C2_B571)
        EC_GROUP_free(C2_B571);

}
