static int MS_CALLBACK app_verify_callback(X509_STORE_CTX *ctx, void *arg)
	{
	int ok=1;
	struct app_verify_arg *cb_arg = arg;
	unsigned int letters[26]; /* only used with proxy_auth */

	if (cb_arg->app_verify)
		{
		char *s = NULL,buf[256];

		fprintf(stderr, "In app_verify_callback, allowing cert. ");
		fprintf(stderr, "Arg is: %s\n", cb_arg->string);
		fprintf(stderr, "Finished printing do we have a context? 0x%p a cert? 0x%p\n",
			(void *)ctx, (void *)ctx->cert);
		if (ctx->cert)
			s=X509_NAME_oneline(X509_get_subject_name(ctx->cert),buf,256);
		if (s != NULL)
			{
			fprintf(stderr,"cert depth=%d %s\n",ctx->error_depth,buf);
			}
		return(1);
		}
	if (cb_arg->proxy_auth)
		{
		int found_any = 0, i;
		char *sp;

		for(i = 0; i < 26; i++)
			letters[i] = 0;
		for(sp = cb_arg->proxy_auth; *sp; sp++)
			{
			int c = *sp;
			if (isascii(c) && isalpha(c))
				{
				if (islower(c))
					c = toupper(c);
				letters[c - 'A'] = 1;
				}
			}

		fprintf(stderr,
			"  Initial proxy rights = ");
		for(i = 0; i < 26; i++)
			if (letters[i])
				{
				fprintf(stderr, "%c", i + 'A');
				found_any = 1;
				}
		if (!found_any)
			fprintf(stderr, "none");
		fprintf(stderr, "\n");

		X509_STORE_CTX_set_ex_data(ctx,
			get_proxy_auth_ex_data_idx(),letters);
		}
	if (cb_arg->allow_proxy_certs)
		{
		X509_STORE_CTX_set_flags(ctx, X509_V_FLAG_ALLOW_PROXY_CERTS);
		}

#ifndef OPENSSL_NO_X509_VERIFY
	ok = X509_verify_cert(ctx);
#endif

	if (cb_arg->proxy_auth)
		{
		if (ok)
			{
			const char *cond_end = NULL;

			ok = process_proxy_cond(letters,
				cb_arg->proxy_cond, &cond_end);

			if (ok < 0)
				EXIT(3);
			if (*cond_end)
				{
				fprintf(stderr, "Stopped processing condition before it's end.\n");
				ok = 0;
				}
			if (!ok)
				fprintf(stderr, "Proxy rights check with condition '%s' proved invalid\n",
					cb_arg->proxy_cond);
			else
				fprintf(stderr, "Proxy rights check with condition '%s' proved valid\n",
					cb_arg->proxy_cond);
			}
		}
	return(ok);
	}
