static int replace_grant_va_mapping(
    unsigned long addr, unsigned long frame, unsigned int grant_pte_flags,
    l1_pgentry_t nl1e, struct vcpu *v)
{
    l1_pgentry_t *pl1e, ol1e;
    unsigned long gl1mfn;
    struct page_info *l1pg;
    int rc = 0;

    pl1e = guest_map_l1e(addr, &gl1mfn);
    if ( !pl1e )
    {
        gdprintk(XENLOG_WARNING, "Could not find L1 PTE for address %lx\n", addr);
        return GNTST_general_error;
    }

    if ( !get_page_from_mfn(_mfn(gl1mfn), current->domain) )
    {
        rc = GNTST_general_error;
        goto out;
    }

    l1pg = mfn_to_page(_mfn(gl1mfn));
    if ( !page_lock(l1pg) )
    {
        rc = GNTST_general_error;
        put_page(l1pg);
        goto out;
    }

    if ( (l1pg->u.inuse.type_info & PGT_type_mask) != PGT_l1_page_table )
    {
        rc = GNTST_general_error;
        goto unlock_and_out;
    }

    ol1e = *pl1e;

    /*
     * Check that the virtual address supplied is actually mapped to frame
     * (with appropriate permissions).
     */
    if ( unlikely(l1e_get_pfn(ol1e) != frame) ||
         unlikely((l1e_get_flags(ol1e) ^ grant_pte_flags) &
                  (_PAGE_PRESENT | _PAGE_RW)) )
    {
        gdprintk(XENLOG_ERR,
                 "PTE %"PRIpte" for %lx doesn't match grant (%"PRIpte")\n",
                 l1e_get_intpte(ol1e), addr,
                 l1e_get_intpte(l1e_from_pfn(frame, grant_pte_flags)));
        rc = GNTST_general_error;
        goto unlock_and_out;
    }

    if ( unlikely((l1e_get_flags(ol1e) ^ grant_pte_flags) &
                  ~(_PAGE_AVAIL | PAGE_CACHE_ATTRS)) )
        gdprintk(XENLOG_WARNING,
                 "PTE flags %x for %"PRIx64" don't match grant (%x)\n",
                 l1e_get_flags(ol1e), addr, grant_pte_flags);

    /* Delete pagetable entry. */
    if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, v, 0)) )
    {
        gdprintk(XENLOG_WARNING, "Cannot delete PTE entry for %"PRIx64"\n",
                 addr);
        rc = GNTST_general_error;
        goto unlock_and_out;
    }

 unlock_and_out:
    page_unlock(l1pg);
    put_page(l1pg);
 out:
    guest_unmap_l1e(pl1e);
    return rc;
}
