static bool_t
__gnttab_copy(
    struct gnttab_copy *op)
{
    struct domain *sd = NULL, *dd = NULL;
    unsigned long s_frame, d_frame;
    struct page_info *s_pg = NULL, *d_pg = NULL;
    char *sp, *dp;
    s16 rc = GNTST_okay;
    int have_d_grant = 0, have_s_grant = 0;
    int src_is_gref, dest_is_gref;

    if ( ((op->source.offset + op->len) > PAGE_SIZE) ||
         ((op->dest.offset + op->len) > PAGE_SIZE) )
        PIN_FAIL(error_out, GNTST_bad_copy_arg, "copy beyond page area.\n");

    src_is_gref = op->flags & GNTCOPY_source_gref;
    dest_is_gref = op->flags & GNTCOPY_dest_gref;

    if ( (op->source.domid != DOMID_SELF && !src_is_gref ) ||
         (op->dest.domid   != DOMID_SELF && !dest_is_gref)   )
        PIN_FAIL(error_out, GNTST_permission_denied,
                 "only allow copy-by-mfn for DOMID_SELF.\n");

    if ( op->source.domid == DOMID_SELF )
        sd = rcu_lock_current_domain();
    else if ( (sd = rcu_lock_domain_by_id(op->source.domid)) == NULL )
        PIN_FAIL(error_out, GNTST_bad_domain,
                 "couldn't find %d\n", op->source.domid);

    if ( op->dest.domid == DOMID_SELF )
        dd = rcu_lock_current_domain();
    else if ( (dd = rcu_lock_domain_by_id(op->dest.domid)) == NULL )
        PIN_FAIL(error_out, GNTST_bad_domain,
                 "couldn't find %d\n", op->dest.domid);

    rc = xsm_grant_copy(XSM_HOOK, sd, dd);
    if ( rc )
    {
        rc = GNTST_permission_denied;
        goto error_out;
    }

    if ( src_is_gref )
    {
        unsigned source_off, source_len;
        rc = __acquire_grant_for_copy(sd, op->source.u.ref,
                                      current->domain->domain_id, 1,
                                      &s_frame, &s_pg,
                                      &source_off, &source_len, 1);
        if ( rc != GNTST_okay )
            goto error_out;
        have_s_grant = 1;
        if ( op->source.offset < source_off ||
             op->len > source_len )
            PIN_FAIL(error_out, GNTST_general_error,
                     "copy source out of bounds: %d < %d || %d > %d\n",
                     op->source.offset, source_off,
                     op->len, source_len);
    }
    else
    {
        rc = __get_paged_frame(op->source.u.gmfn, &s_frame, &s_pg, 1, sd);
        if ( rc != GNTST_okay )
            PIN_FAIL(error_out, rc,
                     "source frame %lx invalid.\n", s_frame);
    }

    if ( dest_is_gref )
    {
        unsigned dest_off, dest_len;
        rc = __acquire_grant_for_copy(dd, op->dest.u.ref,
                                      current->domain->domain_id, 0,
                                      &d_frame, &d_pg, &dest_off, &dest_len, 1);
        if ( rc != GNTST_okay )
            goto error_out;
        have_d_grant = 1;
        if ( op->dest.offset < dest_off ||
             op->len > dest_len )
            PIN_FAIL(error_out, GNTST_general_error,
                     "copy dest out of bounds: %d < %d || %d > %d\n",
                     op->dest.offset, dest_off,
                     op->len, dest_len);
    }
    else
    {
        rc = __get_paged_frame(op->dest.u.gmfn, &d_frame, &d_pg, 0, dd);
        if ( rc != GNTST_okay )
            PIN_FAIL(error_out, rc,
                     "destination frame %lx invalid.\n", d_frame);
    }

    if ( !get_page_type(d_pg, PGT_writable_page) )
    {
        if ( !dd->is_dying )
            gdprintk(XENLOG_WARNING, "Could not get dst frame %lx\n", d_frame);
        rc = GNTST_general_error;
        goto error_out;
    }

    sp = map_domain_page(s_frame);
    dp = map_domain_page(d_frame);

    memcpy(dp + op->dest.offset, sp + op->source.offset, op->len);

    unmap_domain_page(dp);
    unmap_domain_page(sp);

    gnttab_mark_dirty(dd, d_frame);

    put_page_type(d_pg);
 error_out:
    if ( d_pg )
        put_page(d_pg);
    if ( s_pg )
        put_page(s_pg);
    if ( have_s_grant )
        __release_grant_for_copy(sd, op->source.u.ref, 1);
    if ( have_d_grant )
        __release_grant_for_copy(dd, op->dest.u.ref, 0);
    if ( sd )
        rcu_unlock_domain(sd);
    if ( dd )
        rcu_unlock_domain(dd);
    if ( rc > 0 )
        return 0;
    op->status = rc;
    return 1;
}
