const struct hvm_function_table * __init start_vmx(void)
{
    set_in_cr4(X86_CR4_VMXE);

    if ( vmx_cpu_up() )
    {
        printk("VMX: failed to initialise.\n");
        return NULL;
    }

    /*
     * Do not enable EPT when (!cpu_has_vmx_pat), to prevent security hole
     * (refer to http://xenbits.xen.org/xsa/advisory-60.html).
     */
    if ( cpu_has_vmx_ept && (cpu_has_vmx_pat || opt_force_ept) )
    {
        bool cpu_has_bug_pschange_mc = has_if_pschange_mc();

        if ( opt_ept_exec_sp == -1 )
        {
            /* Default to non-executable superpages on vulnerable hardware. */
            opt_ept_exec_sp = !cpu_has_bug_pschange_mc;

            if ( cpu_has_bug_pschange_mc )
                printk("VMX: Disabling executable EPT superpages due to CVE-2018-12207\n");
        }

        vmx_function_table.hap_supported = 1;
        vmx_function_table.altp2m_supported = 1;

        vmx_function_table.hap_capabilities = 0;

        if ( cpu_has_vmx_ept_2mb )
            vmx_function_table.hap_capabilities |= HVM_HAP_SUPERPAGE_2MB;
        if ( cpu_has_vmx_ept_1gb )
            vmx_function_table.hap_capabilities |= HVM_HAP_SUPERPAGE_1GB;

        setup_ept_dump();
    }

    if ( !cpu_has_vmx_virtual_intr_delivery )
    {
        vmx_function_table.update_eoi_exit_bitmap = NULL;
        vmx_function_table.process_isr = NULL;
        vmx_function_table.handle_eoi = NULL;
    }

    if ( cpu_has_vmx_posted_intr_processing )
    {
        alloc_direct_apic_vector(&posted_intr_vector, pi_notification_interrupt);
        if ( iommu_intpost )
            alloc_direct_apic_vector(&pi_wakeup_vector, pi_wakeup_interrupt);
    }
    else
    {
        vmx_function_table.deliver_posted_intr = NULL;
        vmx_function_table.sync_pir_to_irr = NULL;
    }

    if ( cpu_has_vmx_ept
         && cpu_has_vmx_pat
         && cpu_has_vmx_msr_bitmap
         && cpu_has_vmx_secondary_exec_control )
        vmx_function_table.pvh_supported = 1;

    if ( cpu_has_vmx_tsc_scaling )
        vmx_function_table.tsc_scaling.ratio_frac_bits = 48;

    if ( cpu_has_mpx && cpu_has_vmx_mpx )
    {
        vmx_function_table.set_guest_bndcfgs = vmx_set_guest_bndcfgs;
        vmx_function_table.get_guest_bndcfgs = vmx_get_guest_bndcfgs;
    }

    setup_vmcs_dump();

    return &vmx_function_table;
}
