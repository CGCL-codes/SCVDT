int new_guest_cr3(unsigned long mfn)
{
    struct vcpu *curr = current;
    struct domain *d = curr->domain;
    int okay;
    unsigned long old_base_mfn;

    if ( is_pv_32on64_domain(d) )
    {
        unsigned long gt_mfn = pagetable_get_pfn(curr->arch.guest_table);
        l4_pgentry_t *pl4e = map_domain_page(gt_mfn);

        okay = paging_mode_refcounts(d)
            ? 0 /* Old code was broken, but what should it be? */
            : mod_l4_entry(
                    pl4e,
                    l4e_from_pfn(
                        mfn,
                        (_PAGE_PRESENT|_PAGE_RW|_PAGE_USER|_PAGE_ACCESSED)),
                    gt_mfn, 0, 0, curr) == 0;
        unmap_domain_page(pl4e);
        if ( unlikely(!okay) )
        {
            MEM_LOG("Error while installing new compat baseptr %lx", mfn);
            return 0;
        }

        invalidate_shadow_ldt(curr, 0);
        write_ptbase(curr);

        return 1;
    }

    okay = paging_mode_refcounts(d)
        ? get_page_from_pagenr(mfn, d)
        : !get_page_and_type_from_pagenr(mfn, PGT_root_page_table, d, 0, 0);
    if ( unlikely(!okay) )
    {
        MEM_LOG("Error while installing new baseptr %lx", mfn);
        return 0;
    }

    invalidate_shadow_ldt(curr, 0);

    old_base_mfn = pagetable_get_pfn(curr->arch.guest_table);

    curr->arch.guest_table = pagetable_from_pfn(mfn);
    update_cr3(curr);

    write_ptbase(curr);

    if ( likely(old_base_mfn != 0) )
    {
        if ( paging_mode_refcounts(d) )
            put_page(mfn_to_page(old_base_mfn));
        else
            put_page_and_type(mfn_to_page(old_base_mfn));
    }

    return 1;
}
