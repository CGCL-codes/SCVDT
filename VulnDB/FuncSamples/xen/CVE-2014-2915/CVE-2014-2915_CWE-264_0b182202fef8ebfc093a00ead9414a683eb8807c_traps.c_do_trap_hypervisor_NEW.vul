asmlinkage void do_trap_hypervisor(struct cpu_user_regs *regs)
{
    union hsr hsr = { .bits = READ_SYSREG32(ESR_EL2) };

    switch (hsr.ec) {
    case HSR_EC_WFI_WFE:
        if ( !check_conditional_instr(regs, hsr) )
        {
            advance_pc(regs, hsr);
            return;
        }
        /* at the moment we only trap WFI */
        vcpu_block();
        /* The ARM spec declares that even if local irqs are masked in
         * the CPSR register, an irq should wake up a cpu from WFI anyway.
         * For this reason we need to check for irqs that need delivery,
         * ignoring the CPSR register, *after* calling SCHEDOP_block to
         * avoid races with vgic_vcpu_inject_irq.
         */
        if ( local_events_need_delivery_nomask() )
            vcpu_unblock(current);
        advance_pc(regs, hsr);
        break;
    case HSR_EC_CP15_32:
        if ( !is_32bit_domain(current->domain) )
            goto bad_trap;
        do_cp15_32(regs, hsr);
        break;
    case HSR_EC_CP15_64:
        if ( !is_32bit_domain(current->domain) )
            goto bad_trap;
        do_cp15_64(regs, hsr);
        break;
    case HSR_EC_CP14_32:
    case HSR_EC_CP14_DBG:
        if ( !is_32bit_domain(current->domain) )
            goto bad_trap;
        do_cp14(regs, hsr);
        break;
    case HSR_EC_CP:
        if ( !is_32bit_domain(current->domain) )
            goto bad_trap;
        do_cp(regs, hsr);
        break;
    case HSR_EC_SMC32:
        inject_undef32_exception(regs);
        break;
    case HSR_EC_HVC32:
#ifndef NDEBUG
        if ( (hsr.iss & 0xff00) == 0xff00 )
            return do_debug_trap(regs, hsr.iss & 0x00ff);
#endif
        if ( hsr.iss == 0 )
            return do_trap_psci(regs);
        do_trap_hypercall(regs, (register_t *)&regs->r12, hsr.iss);
        break;
#ifdef CONFIG_ARM_64
    case HSR_EC_HVC64:
#ifndef NDEBUG
        if ( (hsr.iss & 0xff00) == 0xff00 )
            return do_debug_trap(regs, hsr.iss & 0x00ff);
#endif
        if ( hsr.iss == 0 )
            return do_trap_psci(regs);
        do_trap_hypercall(regs, &regs->x16, hsr.iss);
        break;
    case HSR_EC_SMC64:
        inject_undef64_exception(regs, hsr.len);
        break;
    case HSR_EC_SYSREG:
        if ( is_32bit_domain(current->domain) )
            goto bad_trap;
        do_sysreg(regs, hsr);
        break;
#endif

    case HSR_EC_INSTR_ABORT_LOWER_EL:
        do_trap_instr_abort_guest(regs, hsr);
        break;
    case HSR_EC_DATA_ABORT_LOWER_EL:
        do_trap_data_abort_guest(regs, hsr);
        break;
    default:
 bad_trap:
        printk("Hypervisor Trap. HSR=0x%x EC=0x%x IL=%x Syndrome=%"PRIx32"\n",
               hsr.bits, hsr.ec, hsr.len, hsr.iss);
        do_unexpected_trap("Hypervisor", regs);
    }
}
