static int msixtbl_write(struct vcpu *v, unsigned long address,
                         unsigned long len, unsigned long val)
{
    unsigned long offset;
    struct msixtbl_entry *entry;
    const struct msi_desc *msi_desc;
    void *virt;
    unsigned int nr_entry, index;
    int r = X86EMUL_UNHANDLEABLE;
    unsigned long flags, orig;
    struct irq_desc *desc;

    if ( len != 4 || (address & 3) )
        return r;

    rcu_read_lock(&msixtbl_rcu_lock);

    entry = msixtbl_find_entry(v, address);
    nr_entry = (address - entry->gtable) / PCI_MSIX_ENTRY_SIZE;

    offset = address & (PCI_MSIX_ENTRY_SIZE - 1);
    if ( offset != PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET)
    {
        if ( nr_entry < MAX_MSIX_ACC_ENTRIES ) 
        {
            index = offset / sizeof(uint32_t);
            entry->gentries[nr_entry].msi_ad[index] = val;
        }
        set_bit(nr_entry, &entry->table_flags);
        goto out;
    }

    /* exit to device model if address/data has been modified */
    if ( test_and_clear_bit(nr_entry, &entry->table_flags) )
    {
        if ( !(val & PCI_MSIX_VECTOR_BITMASK) )
            v->arch.hvm_vcpu.hvm_io.msix_unmask_address = address;
        goto out;
    }

    virt = msixtbl_addr_to_virt(entry, address);
    if ( !virt )
        goto out;

    msi_desc = virt_to_msi_desc(entry->pdev, virt);
    if ( !msi_desc || msi_desc->irq < 0 )
        goto out;
    
    desc = irq_to_desc(msi_desc->irq);
    if ( !desc )
        goto out;

    spin_lock_irqsave(&desc->lock, flags);

    if ( !desc->msi_desc )
        goto unlock;

    ASSERT(msi_desc == desc->msi_desc);
   
    orig = readl(virt);

    /*
     * Do not allow guest to modify MSI-X control bit if it is masked 
     * by Xen. We'll only handle the case where Xen thinks that
     * bit is unmasked, but hardware has silently masked the bit
     * (in case of SR-IOV VF reset, etc). On the other hand, if Xen 
     * thinks that the bit is masked, but it's really not, 
     * we log a warning.
     */
    if ( msi_desc->msi_attrib.masked )
    {
        if ( !(orig & PCI_MSIX_VECTOR_BITMASK) )
            printk(XENLOG_WARNING "MSI-X control bit is unmasked when"
                   " it is expected to be masked [%04x:%02x:%02x.%u]\n", 
                   entry->pdev->seg, entry->pdev->bus,
                   PCI_SLOT(entry->pdev->devfn), 
                   PCI_FUNC(entry->pdev->devfn));

        goto unlock;
    }

    /*
     * The mask bit is the only defined bit in the word. But we 
     * ought to preserve the reserved bits. Clearing the reserved 
     * bits can result in undefined behaviour (see PCI Local Bus
     * Specification revision 2.3).
     */
    val &= PCI_MSIX_VECTOR_BITMASK;
    val |= (orig & ~PCI_MSIX_VECTOR_BITMASK);
    writel(val, virt);

unlock:
    spin_unlock_irqrestore(&desc->lock, flags);
    r = X86EMUL_OKAY;

out:
    rcu_read_unlock(&msixtbl_rcu_lock);
    return r;
}
