static void xc_cpuid_hvm_policy(
    xc_interface *xch, domid_t domid,
    const unsigned int *input, unsigned int *regs)
{
    DECLARE_DOMCTL;
    char brand[13];
    uint64_t val;
    int is_pae, is_nestedhvm;
    uint64_t xfeature_mask;

    xc_hvm_param_get(xch, domid, HVM_PARAM_PAE_ENABLED, &val);
    is_pae = !!val;

    /* Detecting Xen's atitude towards XSAVE */
    memset(&domctl, 0, sizeof(domctl));
    domctl.cmd = XEN_DOMCTL_getvcpuextstate;
    domctl.domain = domid;
    do_domctl(xch, &domctl);
    xfeature_mask = domctl.u.vcpuextstate.xfeature_mask;

    xc_hvm_param_get(xch, domid, HVM_PARAM_NESTEDHVM, &val);
    is_nestedhvm = !!val;

    switch ( input[0] )
    {
    case 0x00000000:
        if ( regs[0] > DEF_MAX_BASE )
            regs[0] = DEF_MAX_BASE;
        break;

    case 0x00000001:
        /*
         * EBX[23:16] is Maximum Logical Processors Per Package.
         * Update to reflect vLAPIC_ID = vCPU_ID * 2.
         */
        regs[1] = (regs[1] & 0x0000ffffu) | ((regs[1] & 0x007f0000u) << 1);

        regs[2] &= (bitmaskof(X86_FEATURE_XMM3) |
                    bitmaskof(X86_FEATURE_PCLMULQDQ) |
                    bitmaskof(X86_FEATURE_SSSE3) |
                    bitmaskof(X86_FEATURE_FMA) |
                    bitmaskof(X86_FEATURE_CX16) |
                    bitmaskof(X86_FEATURE_PCID) |
                    bitmaskof(X86_FEATURE_SSE4_1) |
                    bitmaskof(X86_FEATURE_SSE4_2) |
                    bitmaskof(X86_FEATURE_MOVBE)  |
                    bitmaskof(X86_FEATURE_POPCNT) |
                    bitmaskof(X86_FEATURE_AES) |
                    bitmaskof(X86_FEATURE_F16C) |
                    bitmaskof(X86_FEATURE_RDRAND) |
                    ((xfeature_mask != 0) ?
                     (bitmaskof(X86_FEATURE_AVX) |
                      bitmaskof(X86_FEATURE_XSAVE)) : 0));

        regs[2] |= (bitmaskof(X86_FEATURE_HYPERVISOR) |
                    bitmaskof(X86_FEATURE_TSC_DEADLINE) |
                    bitmaskof(X86_FEATURE_X2APIC));

        regs[3] &= (bitmaskof(X86_FEATURE_FPU) |
                    bitmaskof(X86_FEATURE_VME) |
                    bitmaskof(X86_FEATURE_DE) |
                    bitmaskof(X86_FEATURE_PSE) |
                    bitmaskof(X86_FEATURE_TSC) |
                    bitmaskof(X86_FEATURE_MSR) |
                    bitmaskof(X86_FEATURE_PAE) |
                    bitmaskof(X86_FEATURE_MCE) |
                    bitmaskof(X86_FEATURE_CX8) |
                    bitmaskof(X86_FEATURE_APIC) |
                    bitmaskof(X86_FEATURE_SEP) |
                    bitmaskof(X86_FEATURE_MTRR) |
                    bitmaskof(X86_FEATURE_PGE) |
                    bitmaskof(X86_FEATURE_MCA) |
                    bitmaskof(X86_FEATURE_CMOV) |
                    bitmaskof(X86_FEATURE_PAT) |
                    bitmaskof(X86_FEATURE_CLFLSH) |
                    bitmaskof(X86_FEATURE_PSE36) |
                    bitmaskof(X86_FEATURE_MMX) |
                    bitmaskof(X86_FEATURE_FXSR) |
                    bitmaskof(X86_FEATURE_XMM) |
                    bitmaskof(X86_FEATURE_XMM2) |
                    bitmaskof(X86_FEATURE_HT));
            
        /* We always support MTRR MSRs. */
        regs[3] |= bitmaskof(X86_FEATURE_MTRR);

        if ( !is_pae ) {
            clear_bit(X86_FEATURE_PAE, regs[3]);
            clear_bit(X86_FEATURE_PSE36, regs[3]);
        }
        break;

    case 0x00000007: /* Intel-defined CPU features */
        if ( input[1] == 0 ) {
            regs[1] &= (bitmaskof(X86_FEATURE_TSC_ADJUST) |
                        bitmaskof(X86_FEATURE_BMI1) |
                        bitmaskof(X86_FEATURE_HLE)  |
                        bitmaskof(X86_FEATURE_AVX2) |
                        bitmaskof(X86_FEATURE_SMEP) |
                        bitmaskof(X86_FEATURE_BMI2) |
                        bitmaskof(X86_FEATURE_ERMS) |
                        bitmaskof(X86_FEATURE_INVPCID) |
                        bitmaskof(X86_FEATURE_RTM)  |
                        bitmaskof(X86_FEATURE_RDSEED)  |
                        bitmaskof(X86_FEATURE_ADX)  |
                        bitmaskof(X86_FEATURE_SMAP) |
                        bitmaskof(X86_FEATURE_FSGSBASE));
            regs[3] &= (bitmaskof(X86_FEATURE_IBRSB) |
                        bitmaskof(X86_FEATURE_STIBP) |
                        bitmaskof(X86_FEATURE_SSBD));
        } else
            regs[1] = regs[3] = 0;
        regs[0] = regs[2] = 0;
        break;

    case 0x0000000d:
        xc_cpuid_config_xsave(xch, domid, xfeature_mask, input, regs);
        break;

    case 0x80000000:
        /* Passthrough to cpu vendor specific functions */
        break;

    case 0x80000001:
        if ( !is_pae )
        {
            clear_bit(X86_FEATURE_LAHF_LM, regs[2]);
            clear_bit(X86_FEATURE_LM, regs[3]);
            clear_bit(X86_FEATURE_NX, regs[3]);
            clear_bit(X86_FEATURE_PSE36, regs[3]);
            clear_bit(X86_FEATURE_PAGE1GB, regs[3]);
        }
        break;

    case 0x80000007:
        /*
         * Keep only TSCInvariant. This may be cleared by the hypervisor
         * depending on guest TSC and migration settings.
         */
        regs[0] = regs[1] = regs[2] = 0;
        regs[3] &= 1u<<8;
        break;

    case 0x80000008:
        regs[0] &= 0x0000ffffu;
        regs[3] &= bitmaskof(X86_FEATURE_IBPB);
        regs[1] = 0;
        break;

    case 0x00000002: /* Intel cache info (dumped by AMD policy) */
    case 0x00000004: /* Intel cache info (dumped by AMD policy) */
    case 0x0000000a: /* Architectural Performance Monitor Features */
    case 0x80000002: /* Processor name string */
    case 0x80000003: /* ... continued         */
    case 0x80000004: /* ... continued         */
    case 0x80000005: /* AMD L1 cache/TLB info (dumped by Intel policy) */
    case 0x80000006: /* AMD L2/3 cache/TLB info ; Intel L2 cache features */
    case 0x8000000a: /* AMD SVM feature bits */
    case 0x8000001c: /* AMD lightweight profiling */
        break;

    default:
        regs[0] = regs[1] = regs[2] = regs[3] = 0;
        break;
    }

    xc_cpuid_brand_get(brand);
    if ( strstr(brand, "AMD") )
        amd_xc_cpuid_policy(xch, domid, input, regs, is_pae, is_nestedhvm);
    else
        intel_xc_cpuid_policy(xch, domid, input, regs, is_pae, is_nestedhvm);

}
