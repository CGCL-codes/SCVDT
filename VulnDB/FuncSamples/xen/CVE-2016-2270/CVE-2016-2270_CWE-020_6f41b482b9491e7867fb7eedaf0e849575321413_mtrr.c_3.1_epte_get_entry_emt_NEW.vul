uint8_t epte_get_entry_emt(struct domain *d, unsigned long gfn, mfn_t mfn,
                           uint8_t *ipat, bool_t direct_mmio)
{
    uint8_t gmtrr_mtype, hmtrr_mtype;
    uint32_t type;
    struct vcpu *v = current;

    *ipat = 0;

    if ( v->domain != d )
        v = d->vcpu ? d->vcpu[0] : NULL;

    if ( !mfn_valid(mfn_x(mfn)) ||
         rangeset_contains_singleton(mmio_ro_ranges, mfn_x(mfn)) )
    {
        *ipat = 1;
        return MTRR_TYPE_UNCACHABLE;
    }

    if ( hvm_get_mem_pinned_cacheattr(d, gfn, &type) )
        return type;

    if ( !iommu_enabled ||
         (rangeset_is_empty(d->iomem_caps) &&
          rangeset_is_empty(d->arch.ioport_caps) &&
          !has_arch_pdevs(d)) )
    {
        ASSERT(!direct_mmio ||
               mfn_x(mfn) == d->arch.hvm_domain.vmx.apic_access_mfn);
        *ipat = 1;
        return MTRR_TYPE_WRBACK;
    }

    if ( direct_mmio )
    {
        if ( mfn_x(mfn) != d->arch.hvm_domain.vmx.apic_access_mfn )
            return MTRR_TYPE_UNCACHABLE;
        *ipat = 1;
        return MTRR_TYPE_WRBACK;
    }

    if ( iommu_snoop )
    {
        *ipat = 1;
        return MTRR_TYPE_WRBACK;
    }

    gmtrr_mtype = v && d->arch.hvm_domain.params[HVM_PARAM_IDENT_PT] ?
                  get_mtrr_type(&v->arch.hvm_vcpu.mtrr, (gfn << PAGE_SHIFT)) :
                  MTRR_TYPE_WRBACK;
    hmtrr_mtype = get_mtrr_type(&mtrr_state, (mfn_x(mfn) << PAGE_SHIFT));

    /* If both types match we're fine. */
    if ( likely(gmtrr_mtype == hmtrr_mtype) )
        return hmtrr_mtype;

    /* If either type is UC, we have to go with that one. */
    if ( gmtrr_mtype == MTRR_TYPE_UNCACHABLE ||
         hmtrr_mtype == MTRR_TYPE_UNCACHABLE )
        return MTRR_TYPE_UNCACHABLE;

    /* If either type is WB, we have to go with the other one. */
    if ( gmtrr_mtype == MTRR_TYPE_WRBACK )
        return hmtrr_mtype;
    if ( hmtrr_mtype == MTRR_TYPE_WRBACK )
        return gmtrr_mtype;

    /*
     * At this point we have disagreeing WC, WT, or WP types. The only
     * combination that can be cleanly resolved is WT:WP. The ones involving
     * WC need to be converted to UC, both due to the memory ordering
     * differences and because WC disallows reads to be cached (WT and WP
     * permit this), while WT and WP require writes to go straight to memory
     * (WC can buffer them).
     */
    if ( (gmtrr_mtype == MTRR_TYPE_WRTHROUGH &&
          hmtrr_mtype == MTRR_TYPE_WRPROT) ||
         (gmtrr_mtype == MTRR_TYPE_WRPROT &&
          hmtrr_mtype == MTRR_TYPE_WRTHROUGH) )
        return MTRR_TYPE_WRPROT;

    return MTRR_TYPE_UNCACHABLE;
}
