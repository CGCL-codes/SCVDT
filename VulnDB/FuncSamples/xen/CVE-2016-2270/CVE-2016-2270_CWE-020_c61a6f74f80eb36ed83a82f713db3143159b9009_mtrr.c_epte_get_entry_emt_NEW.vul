int epte_get_entry_emt(struct domain *d, unsigned long gfn, mfn_t mfn,
                       unsigned int order, uint8_t *ipat, bool_t direct_mmio)
{
    int gmtrr_mtype, hmtrr_mtype;
    uint32_t type;
    struct vcpu *v = current;

    *ipat = 0;

    if ( v->domain != d )
        v = d->vcpu ? d->vcpu[0] : NULL;

    if ( !mfn_valid(mfn_x(mfn)) ||
         rangeset_contains_range(mmio_ro_ranges, mfn_x(mfn),
                                 mfn_x(mfn) + (1UL << order) - 1) )
    {
        *ipat = 1;
        return MTRR_TYPE_UNCACHABLE;
    }

    if ( rangeset_overlaps_range(mmio_ro_ranges, mfn_x(mfn),
                                 mfn_x(mfn) + (1UL << order) - 1) )
        return -1;

    switch ( hvm_get_mem_pinned_cacheattr(d, gfn, order, &type) )
    {
    case 1:
        *ipat = 1;
        return type != PAT_TYPE_UC_MINUS ? type : PAT_TYPE_UNCACHABLE;
    case -1:
        return -1;
    }

    if ( !need_iommu(d) && !cache_flush_permitted(d) )
    {
        ASSERT(!direct_mmio ||
               !((mfn_x(mfn) ^ d->arch.hvm_domain.vmx.apic_access_mfn) >>
                 order));
        *ipat = 1;
        return MTRR_TYPE_WRBACK;
    }

    if ( direct_mmio )
    {
        if ( (mfn_x(mfn) ^ d->arch.hvm_domain.vmx.apic_access_mfn) >> order )
            return MTRR_TYPE_UNCACHABLE;
        if ( order )
            return -1;
        *ipat = 1;
        return MTRR_TYPE_WRBACK;
    }

    gmtrr_mtype = is_hvm_domain(d) && v ?
                  get_mtrr_type(&v->arch.hvm_vcpu.mtrr,
                                gfn << PAGE_SHIFT, order) :
                  MTRR_TYPE_WRBACK;
    hmtrr_mtype = get_mtrr_type(&mtrr_state, mfn_x(mfn) << PAGE_SHIFT, order);
    if ( gmtrr_mtype < 0 || hmtrr_mtype < 0 )
        return -1;

    /* If both types match we're fine. */
    if ( likely(gmtrr_mtype == hmtrr_mtype) )
        return hmtrr_mtype;

    /* If either type is UC, we have to go with that one. */
    if ( gmtrr_mtype == MTRR_TYPE_UNCACHABLE ||
         hmtrr_mtype == MTRR_TYPE_UNCACHABLE )
        return MTRR_TYPE_UNCACHABLE;

    /* If either type is WB, we have to go with the other one. */
    if ( gmtrr_mtype == MTRR_TYPE_WRBACK )
        return hmtrr_mtype;
    if ( hmtrr_mtype == MTRR_TYPE_WRBACK )
        return gmtrr_mtype;

    /*
     * At this point we have disagreeing WC, WT, or WP types. The only
     * combination that can be cleanly resolved is WT:WP. The ones involving
     * WC need to be converted to UC, both due to the memory ordering
     * differences and because WC disallows reads to be cached (WT and WP
     * permit this), while WT and WP require writes to go straight to memory
     * (WC can buffer them).
     */
    if ( (gmtrr_mtype == MTRR_TYPE_WRTHROUGH &&
          hmtrr_mtype == MTRR_TYPE_WRPROT) ||
         (gmtrr_mtype == MTRR_TYPE_WRPROT &&
          hmtrr_mtype == MTRR_TYPE_WRTHROUGH) )
        return MTRR_TYPE_WRPROT;

    return MTRR_TYPE_UNCACHABLE;
}
