void load_system_tables(void)
{
	unsigned int cpu = smp_processor_id();
	unsigned long stack_bottom = get_stack_bottom(),
		stack_top = stack_bottom & ~(STACK_SIZE - 1);

	struct tss_struct *tss = &this_cpu(init_tss);
	struct desc_struct *gdt =
		this_cpu(gdt_table) - FIRST_RESERVED_GDT_ENTRY;
	struct desc_struct *compat_gdt =
		this_cpu(compat_gdt_table) - FIRST_RESERVED_GDT_ENTRY;

	const struct desc_ptr gdtr = {
		.base = (unsigned long)gdt,
		.limit = LAST_RESERVED_GDT_BYTE,
	};
	const struct desc_ptr idtr = {
		.base = (unsigned long)idt_tables[cpu],
		.limit = (IDT_ENTRIES * sizeof(idt_entry_t)) - 1,
	};

	*tss = (struct tss_struct){
		/* Main stack for interrupts/exceptions. */
		.rsp0 = stack_bottom,

		/* Ring 1 and 2 stacks poisoned. */
		.rsp1 = 0x8600111111111111ul,
		.rsp2 = 0x8600111111111111ul,

		/*
		 * MCE, NMI and Double Fault handlers get their own stacks.
		 * All others poisoned.
		 */
		.ist = {
			[IST_MCE - 1] = stack_top + IST_MCE * PAGE_SIZE,
			[IST_DF  - 1] = stack_top + IST_DF  * PAGE_SIZE,
			[IST_NMI - 1] = stack_top + IST_NMI * PAGE_SIZE,
			[IST_DB  - 1] = stack_top + IST_DB  * PAGE_SIZE,

			[IST_MAX ... ARRAY_SIZE(tss->ist) - 1] =
				0x8600111111111111ul,
		},

		.bitmap = IOBMP_INVALID_OFFSET,
	};

	_set_tssldt_desc(
		gdt + TSS_ENTRY,
		(unsigned long)tss,
		offsetof(struct tss_struct, __cacheline_filler) - 1,
		SYS_DESC_tss_avail);
	_set_tssldt_desc(
		compat_gdt + TSS_ENTRY,
		(unsigned long)tss,
		offsetof(struct tss_struct, __cacheline_filler) - 1,
		SYS_DESC_tss_busy);

	asm volatile ("lgdt %0"  : : "m"  (gdtr) );
	asm volatile ("lidt %0"  : : "m"  (idtr) );
	asm volatile ("ltr  %w0" : : "rm" (TSS_ENTRY << 3) );
	asm volatile ("lldt %w0" : : "rm" (0) );

	set_ist(&idt_tables[cpu][TRAP_double_fault],  IST_DF);
	set_ist(&idt_tables[cpu][TRAP_nmi],	      IST_NMI);
	set_ist(&idt_tables[cpu][TRAP_machine_check], IST_MCE);
	set_ist(&idt_tables[cpu][TRAP_debug],         IST_DB);

	/*
	 * Bottom-of-stack must be 16-byte aligned!
	 *
	 * Defer checks until exception support is sufficiently set up.
	 */
	BUILD_BUG_ON((sizeof(struct cpu_info) -
		      offsetof(struct cpu_info, guest_cpu_user_regs.es)) & 0xf);
	BUG_ON(system_state != SYS_STATE_early_boot && (stack_bottom & 0xf));
}
