void __cpuinit load_system_tables(void)
{
	unsigned int cpu = smp_processor_id();
	unsigned long stack_bottom = get_stack_bottom(),
		stack_top = stack_bottom & ~(STACK_SIZE - 1);

	struct tss_struct *tss = &this_cpu(init_tss);
	struct desc_struct *gdt =
		this_cpu(gdt_table) - FIRST_RESERVED_GDT_ENTRY;
	struct desc_struct *compat_gdt =
		this_cpu(compat_gdt_table) - FIRST_RESERVED_GDT_ENTRY;

	const struct desc_ptr gdtr = {
		.base = (unsigned long)gdt,
		.limit = LAST_RESERVED_GDT_BYTE,
	};
	const struct desc_ptr idtr = {
		.base = (unsigned long)idt_tables[cpu],
		.limit = (IDT_ENTRIES * sizeof(idt_entry_t)) - 1,
	};

	/* Main stack for interrupts/exceptions. */
	tss->rsp0 = stack_bottom;
	tss->bitmap = IOBMP_INVALID_OFFSET;

	/* MCE, NMI and Double Fault handlers get their own stacks. */
	tss->ist[IST_MCE - 1] = stack_top + IST_MCE * PAGE_SIZE;
	tss->ist[IST_DF  - 1] = stack_top + IST_DF  * PAGE_SIZE;
	tss->ist[IST_NMI - 1] = stack_top + IST_NMI * PAGE_SIZE;
	tss->ist[IST_DB  - 1] = stack_top + IST_DB  * PAGE_SIZE;

	_set_tssldt_desc(
		gdt + TSS_ENTRY,
		(unsigned long)tss,
		offsetof(struct tss_struct, __cacheline_filler) - 1,
		SYS_DESC_tss_avail);
	_set_tssldt_desc(
		compat_gdt + TSS_ENTRY,
		(unsigned long)tss,
		offsetof(struct tss_struct, __cacheline_filler) - 1,
		SYS_DESC_tss_busy);

	asm volatile ("lgdt %0"  : : "m"  (gdtr) );
	asm volatile ("lidt %0"  : : "m"  (idtr) );
	asm volatile ("ltr  %w0" : : "rm" (TSS_ENTRY << 3) );
	asm volatile ("lldt %w0" : : "rm" (0) );

	set_ist(&idt_tables[cpu][TRAP_double_fault],  IST_DF);
	set_ist(&idt_tables[cpu][TRAP_nmi],	      IST_NMI);
	set_ist(&idt_tables[cpu][TRAP_machine_check], IST_MCE);
	set_ist(&idt_tables[cpu][TRAP_debug],         IST_DB);
}
