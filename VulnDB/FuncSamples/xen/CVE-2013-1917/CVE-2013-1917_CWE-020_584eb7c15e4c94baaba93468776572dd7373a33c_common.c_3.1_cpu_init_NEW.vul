void __cpuinit cpu_init(void)
{
	int cpu = smp_processor_id();
	struct tss_struct *t = &this_cpu(init_tss);
	struct desc_ptr gdt_desc = {
		.base = (unsigned long)(this_cpu(gdt_table) - FIRST_RESERVED_GDT_ENTRY),
		.limit = LAST_RESERVED_GDT_BYTE
	};

	if (cpu_test_and_set(cpu, cpu_initialized)) {
		printk(KERN_WARNING "CPU#%d already initialized!\n", cpu);
		for (;;) local_irq_enable();
	}
	if (opt_cpu_info)
		printk("Initializing CPU#%d\n", cpu);

	if (cpu_has_pat)
		wrmsrl(MSR_IA32_CR_PAT, host_pat);

	/* Install correct page table. */
	write_ptbase(current);

	asm volatile ( "lgdt %0" : : "m" (gdt_desc) );

	/* No nested task. */
	asm volatile ("pushf ; andw $0xbfff,(%"__OP"sp) ; popf" );

	/* Ensure FPU gets initialised for each domain. */
	stts();

	/* Set up and load the per-CPU TSS and LDT. */
	t->bitmap = IOBMP_INVALID_OFFSET;
#if defined(CONFIG_X86_32)
	t->ss0  = __HYPERVISOR_DS;
	t->esp0 = get_stack_bottom();
	if ( cpu_has_sep ) {
	    wrmsr(MSR_IA32_SYSENTER_CS, 0, 0);
	    if ( supervisor_mode_kernel )
		wrmsr(MSR_IA32_SYSENTER_ESP, &t->esp1, 0);
	}
#elif defined(CONFIG_X86_64)
	/* Bottom-of-stack must be 16-byte aligned! */
	BUG_ON((get_stack_bottom() & 15) != 0);
	t->rsp0 = get_stack_bottom();
#endif
	load_TR();
	asm volatile ( "lldt %%ax" : : "a" (0) );

	/* Clear all 6 debug registers: */
#define CD(register) asm volatile ( "mov %0,%%db" #register : : "r"(0UL) );
	CD(0); CD(1); CD(2); CD(3); /* no db4 and db5 */; CD(6); CD(7);
#undef CD
}
