EXPORT long do_tmem_op(tmem_cli_op_t uops)
{
    struct tmem_op op;
    client_t *client = tmh_client_from_current();
    pool_t *pool = NULL;
    OID *oidp;
    int rc = 0;
    bool_t succ_get = 0, succ_put = 0;
    bool_t non_succ_get = 0, non_succ_put = 0;
    bool_t flush = 0, flush_obj = 0;
    bool_t tmem_write_lock_set = 0, tmem_read_lock_set = 0;
    DECL_LOCAL_CYC_COUNTER(succ_get);
    DECL_LOCAL_CYC_COUNTER(succ_put);
    DECL_LOCAL_CYC_COUNTER(non_succ_get);
    DECL_LOCAL_CYC_COUNTER(non_succ_put);
    DECL_LOCAL_CYC_COUNTER(flush);
    DECL_LOCAL_CYC_COUNTER(flush_obj);

    if ( !tmem_initialized )
        return -ENODEV;

    total_tmem_ops++;

    if ( tmh_lock_all )
    {
        if ( tmh_lock_all > 1 )
            spin_lock_irq(&tmem_spinlock);
        else
            spin_lock(&tmem_spinlock);
    }

    START_CYC_COUNTER(succ_get);
    DUP_START_CYC_COUNTER(succ_put,succ_get);
    DUP_START_CYC_COUNTER(non_succ_get,succ_get);
    DUP_START_CYC_COUNTER(non_succ_put,succ_get);
    DUP_START_CYC_COUNTER(flush,succ_get);
    DUP_START_CYC_COUNTER(flush_obj,succ_get);

    if ( client != NULL && tmh_client_is_dying(client) )
    {
        rc = -ENODEV;
        goto out;
    }

    if ( unlikely(tmh_get_tmemop_from_client(&op, uops) != 0) )
    {
        printk("tmem: can't get tmem struct from %s\n",client_str);
        rc = -EFAULT;
        goto out;
    }

    if ( op.cmd == TMEM_CONTROL )
    {
        tmem_write_lock(&tmem_rwlock);
        tmem_write_lock_set = 1;
        rc = do_tmem_control(&op);
        goto out;
    } else if ( op.cmd == TMEM_AUTH ) {
        tmem_write_lock(&tmem_rwlock);
        tmem_write_lock_set = 1;
        rc = tmemc_shared_pool_auth(op.u.creat.arg1,op.u.creat.uuid[0],
                         op.u.creat.uuid[1],op.u.creat.flags);
        goto out;
    } else if ( op.cmd == TMEM_RESTORE_NEW ) {
        tmem_write_lock(&tmem_rwlock);
        tmem_write_lock_set = 1;
        rc = do_tmem_new_pool(op.u.creat.arg1, op.pool_id, op.u.creat.flags,
                         op.u.creat.uuid[0], op.u.creat.uuid[1]);
        goto out;
    }

    /* create per-client tmem structure dynamically on first use by client */
    if ( client == NULL )
    {
        tmem_write_lock(&tmem_rwlock);
        tmem_write_lock_set = 1;
        if ( (client = client_create(tmh_get_cli_id_from_current())) == NULL )
        {
            printk("tmem: can't create tmem structure for %s\n",client_str);
            rc = -ENOMEM;
            goto out;
        }
    }

    if ( op.cmd == TMEM_NEW_POOL || op.cmd == TMEM_DESTROY_POOL )
    {
        if ( !tmem_write_lock_set )
        {
            tmem_write_lock(&tmem_rwlock);
            tmem_write_lock_set = 1;
        }
    }
    else
    {
        if ( !tmem_write_lock_set )
        {
            tmem_read_lock(&tmem_rwlock);
            tmem_read_lock_set = 1;
        }
        if ( ((uint32_t)op.pool_id >= MAX_POOLS_PER_DOMAIN) ||
             ((pool = client->pools[op.pool_id]) == NULL) )
        {
            rc = -ENODEV;
            printk("tmem: operation requested on uncreated pool\n");
            goto out;
        }
        ASSERT_SENTINEL(pool,POOL);
    }

    oidp = (OID *)&op.u.gen.oid[0];
    switch ( op.cmd )
    {
    case TMEM_NEW_POOL:
        rc = do_tmem_new_pool(CLI_ID_NULL, 0, op.u.creat.flags,
                              op.u.creat.uuid[0], op.u.creat.uuid[1]);
        break;
    case TMEM_NEW_PAGE:
        tmem_ensure_avail_pages();
        rc = do_tmem_put(pool, oidp, op.u.gen.index, op.u.gen.cmfn, 0, 0, 0,
                         tmh_cli_buf_null);
        break;
    case TMEM_PUT_PAGE:
        tmem_ensure_avail_pages();
        rc = do_tmem_put(pool, oidp, op.u.gen.index, op.u.gen.cmfn, 0, 0,
                         PAGE_SIZE, tmh_cli_buf_null);
        if (rc == 1) succ_put = 1;
        else non_succ_put = 1;
        break;
    case TMEM_GET_PAGE:
        rc = do_tmem_get(pool, oidp, op.u.gen.index, op.u.gen.cmfn,
                         0, 0, PAGE_SIZE, tmh_cli_buf_null);
        if (rc == 1) succ_get = 1;
        else non_succ_get = 1;
        break;
    case TMEM_FLUSH_PAGE:
        flush = 1;
        rc = do_tmem_flush_page(pool, oidp, op.u.gen.index);
        break;
    case TMEM_FLUSH_OBJECT:
        rc = do_tmem_flush_object(pool, oidp);
        flush_obj = 1;
        break;
    case TMEM_DESTROY_POOL:
        flush = 1;
        rc = do_tmem_destroy_pool(op.pool_id);
        break;
    case TMEM_READ:
        rc = do_tmem_get(pool, oidp, op.u.gen.index, op.u.gen.cmfn,
                         op.u.gen.tmem_offset, op.u.gen.pfn_offset,
                         op.u.gen.len, tmh_cli_buf_null);
        break;
    case TMEM_WRITE:
        rc = do_tmem_put(pool, oidp,
                         op.u.gen.index, op.u.gen.cmfn,
                         op.u.gen.tmem_offset, op.u.gen.pfn_offset,
                         op.u.gen.len, tmh_cli_buf_null);
        break;
    case TMEM_XCHG:
        /* need to hold global lock to ensure xchg is atomic */
        printk("tmem_xchg op not implemented yet\n");
        rc = 0;
        break;
    default:
        printk("tmem: op %d not implemented\n", op.cmd);
        rc = 0;
        break;
    }

out:
    if ( rc < 0 )
        errored_tmem_ops++;
    if ( succ_get )
        END_CYC_COUNTER_CLI(succ_get,client);
    else if ( succ_put )
        END_CYC_COUNTER_CLI(succ_put,client);
    else if ( non_succ_get )
        END_CYC_COUNTER_CLI(non_succ_get,client);
    else if ( non_succ_put )
        END_CYC_COUNTER_CLI(non_succ_put,client);
    else if ( flush )
        END_CYC_COUNTER_CLI(flush,client);
    else if ( flush_obj )
        END_CYC_COUNTER_CLI(flush_obj,client);

    if ( tmh_lock_all )
    {
        if ( tmh_lock_all > 1 )
            spin_unlock_irq(&tmem_spinlock);
        else
            spin_unlock(&tmem_spinlock);
    } else {
        if ( tmem_write_lock_set )
            write_unlock(&tmem_rwlock);
        else if ( tmem_read_lock_set )
            read_unlock(&tmem_rwlock);
        else 
            ASSERT(0);
    }

    return rc;
}
