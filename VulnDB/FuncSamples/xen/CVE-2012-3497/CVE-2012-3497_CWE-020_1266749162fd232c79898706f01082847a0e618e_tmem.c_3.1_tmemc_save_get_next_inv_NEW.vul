static NOINLINE int tmemc_save_get_next_inv(int cli_id, tmem_cli_va_t buf,
                        uint32_t bufsize)
{
    client_t *client = tmh_client_from_cli_id(cli_id);
    pgp_t *pgp;
    struct tmem_handle h;
    int ret = 0;

    if ( client == NULL )
        return 0;
    if ( bufsize < sizeof(struct tmem_handle) )
        return 0;
    tmem_spin_lock(&pers_lists_spinlock);
    if ( list_empty(&client->persistent_invalidated_list) )
        goto out;
    if ( client->cur_pgp == NULL )
    {
        pgp = list_entry((&client->persistent_invalidated_list)->next,
                         pgp_t,client_inv_pages);
        client->cur_pgp = pgp;
    } else if ( list_is_last(&client->cur_pgp->client_inv_pages, 
                             &client->persistent_invalidated_list) )
    {
        client->cur_pgp = NULL;
        ret = 0;
        goto out;
    } else {
        pgp = list_entry((&client->cur_pgp->client_inv_pages)->next,
                         pgp_t,client_inv_pages);
        client->cur_pgp = pgp;
    }
    h.pool_id = pgp->pool_id;
    BUILD_BUG_ON(sizeof(h.oid) != sizeof(pgp->inv_oid));
    memcpy(h.oid, pgp->inv_oid.oid, sizeof(h.oid));
    h.index = pgp->index;
    tmh_copy_to_client_buf(buf, &h, 1);
    ret = 1;
out:
    tmem_spin_unlock(&pers_lists_spinlock);
    return ret;
}
