static NOINLINE int do_tmem_get(pool_t *pool, OID *oidp, uint32_t index,
              tmem_cli_mfn_t cmfn, pagesize_t tmem_offset,
              pagesize_t pfn_offset, pagesize_t len, tmem_cli_va_t clibuf)
{
    obj_t *obj;
    pgp_t *pgp;
    client_t *client = pool->client;
    DECL_LOCAL_CYC_COUNTER(decompress);
    int rc = -EFAULT;

    if ( !_atomic_read(pool->pgp_count) )
        return -EEMPTY;

    pool->gets++;
    obj = obj_find(pool,oidp);
    if ( obj == NULL )
        return 0;

    ASSERT_SPINLOCK(&obj->obj_spinlock);
    if (is_shared(pool) || is_persistent(pool) )
        pgp = pgp_lookup_in_obj(obj, index);
    else
        pgp = pgp_delete_from_obj(obj, index);
    if ( pgp == NULL )
    {
        obj->no_evict = 0;
        tmem_spin_unlock(&obj->obj_spinlock);
        return 0;
    }
    ASSERT(pgp->size != -1);
    if ( tmh_dedup_enabled() && !is_persistent(pool) &&
              pgp->firstbyte != NOT_SHAREABLE )
    {
        rc = pcd_copy_to_client(cmfn, pgp);
        if ( rc <= 0 )
            goto bad_copy;
    } else if ( pgp->size != 0 ) {
        START_CYC_COUNTER(decompress);
        rc = tmh_decompress_to_client(cmfn, pgp->cdata,
                                      pgp->size, clibuf);
        if ( rc <= 0 )
            goto bad_copy;
        END_CYC_COUNTER(decompress);
    } else if ( tmh_copy_to_client(cmfn, pgp->pfp, tmem_offset,
                                 pfn_offset, len, clibuf) == -EFAULT)
        goto bad_copy;
    if ( is_ephemeral(pool) )
    {
        if ( is_private(pool) )
        {
            pgp_delete(pgp,0);
            if ( obj->pgp_count == 0 )
            {
                tmem_write_lock(&pool->pool_rwlock);
                obj_free(obj,0);
                obj = NULL;
                tmem_write_unlock(&pool->pool_rwlock);
            }
        } else {
            tmem_spin_lock(&eph_lists_spinlock);
            list_del(&pgp->global_eph_pages);
            list_add_tail(&pgp->global_eph_pages,&global_ephemeral_page_list);
            list_del(&pgp->us.client_eph_pages);
            list_add_tail(&pgp->us.client_eph_pages,&client->ephemeral_page_list);
            tmem_spin_unlock(&eph_lists_spinlock);
            ASSERT(obj != NULL);
            obj->last_client = tmh_get_cli_id_from_current();
        }
    }
    if ( obj != NULL )
    {
        obj->no_evict = 0;
        tmem_spin_unlock(&obj->obj_spinlock);
    }
    pool->found_gets++;
    if ( is_ephemeral(pool) )
        client->succ_eph_gets++;
    else
        client->succ_pers_gets++;
    return 1;

bad_copy:
    /* this should only happen if the client passed a bad mfn */
    failed_copies++;
    return rc;
}
