static NOINLINE int tmemc_save_get_next_page(int cli_id, uint32_t pool_id,
                        tmem_cli_va_t buf, uint32_t bufsize)
{
    client_t *client = tmh_client_from_cli_id(cli_id);
    pool_t *pool = (client == NULL || pool_id >= MAX_POOLS_PER_DOMAIN)
                   ? NULL : client->pools[pool_id];
    pgp_t *pgp;
    OID oid;
    int ret = 0;
    struct tmem_handle h;
    unsigned int pagesize = 1 << (pool->pageshift+12);

    if ( pool == NULL || is_ephemeral(pool) )
        return -1;
    if ( bufsize < pagesize + sizeof(struct tmem_handle) )
        return -ENOMEM;

    tmem_spin_lock(&pers_lists_spinlock);
    if ( list_empty(&pool->persistent_page_list) )
    {
        ret = -1;
        goto out;
    }
    /* note: pool->cur_pgp is the pgp last returned by get_next_page */
    if ( pool->cur_pgp == NULL )
    {
        /* process the first one */
        pool->cur_pgp = pgp = list_entry((&pool->persistent_page_list)->next,
                         pgp_t,us.pool_pers_pages);
    } else if ( list_is_last(&pool->cur_pgp->us.pool_pers_pages, 
                             &pool->persistent_page_list) )
    {
        /* already processed the last one in the list */
        ret = -1;
        goto out;
    }
    pgp = list_entry((&pool->cur_pgp->us.pool_pers_pages)->next,
                         pgp_t,us.pool_pers_pages);
    pool->cur_pgp = pgp;
    oid = pgp->us.obj->oid;
    h.pool_id = pool_id;
    BUILD_BUG_ON(sizeof(h.oid) != sizeof(oid));
    memcpy(h.oid, oid.oid, sizeof(h.oid));
    h.index = pgp->index;
    tmh_copy_to_client_buf(buf, &h, 1);
    tmh_client_buf_add(buf, sizeof(h));
    ret = do_tmem_get(pool, &oid, pgp->index, 0, 0, 0, pagesize, buf);

out:
    tmem_spin_unlock(&pers_lists_spinlock);
    return ret;
}
