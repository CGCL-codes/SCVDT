static NOINLINE int tmemc_save_get_next_page(int cli_id, uint32_t pool_id,
                        tmem_cli_va_t buf, uint32_t bufsize)
{
    client_t *client = tmh_client_from_cli_id(cli_id);
    pool_t *pool = (client == NULL || pool_id >= MAX_POOLS_PER_DOMAIN)
                   ? NULL : client->pools[pool_id];
    pgp_t *pgp;
    OID oid;
    int ret = 0;
    struct tmem_handle *h;
    unsigned int pagesize = 1 << (pool->pageshift+12);

    if ( pool == NULL || is_ephemeral(pool) )
        return -1;
    if ( bufsize < pagesize + sizeof(struct tmem_handle) )
        return -ENOMEM;

    tmem_spin_lock(&pers_lists_spinlock);
    if ( list_empty(&pool->persistent_page_list) )
    {
        ret = -1;
        goto out;
    }
    /* note: pool->cur_pgp is the pgp last returned by get_next_page */
    if ( pool->cur_pgp == NULL )
    {
        /* process the first one */
        pool->cur_pgp = pgp = list_entry((&pool->persistent_page_list)->next,
                         pgp_t,us.pool_pers_pages);
    } else if ( list_is_last(&pool->cur_pgp->us.pool_pers_pages, 
                             &pool->persistent_page_list) )
    {
        /* already processed the last one in the list */
        ret = -1;
        goto out;
    }
    pgp = list_entry((&pool->cur_pgp->us.pool_pers_pages)->next,
                         pgp_t,us.pool_pers_pages);
    pool->cur_pgp = pgp;
    oid = pgp->us.obj->oid;
    h = (struct tmem_handle *)buf.p;
    *(OID *)&h->oid[0] = oid;
    h->index = pgp->index;
    buf.p = (void *)(h+1);
    ret = do_tmem_get(pool, &oid, h->index,0,0,0,pagesize,buf.p);

out:
    tmem_spin_unlock(&pers_lists_spinlock);
    return ret;
}
