int unmap_domain_pirq(struct domain *d, int pirq)
{
    unsigned long flags;
    struct irq_desc *desc;
    int irq, ret = 0;
    bool_t forced_unbind;
    struct pirq *info;
    struct msi_desc *msi_desc = NULL;

    if ( (pirq < 0) || (pirq >= d->nr_pirqs) )
        return -EINVAL;

    ASSERT(spin_is_locked(&pcidevs_lock));
    ASSERT(spin_is_locked(&d->event_lock));

    info = pirq_info(d, pirq);
    if ( !info || (irq = info->arch.irq) <= 0 )
    {
        dprintk(XENLOG_G_ERR, "dom%d: pirq %d not mapped\n",
                d->domain_id, pirq);
        ret = -EINVAL;
        goto done;
    }

    forced_unbind = pirq_guest_force_unbind(d, info);
    if ( forced_unbind )
        dprintk(XENLOG_G_WARNING, "dom%d: forcing unbind of pirq %d\n",
                d->domain_id, pirq);

    desc = irq_to_desc(irq);

    if ( (msi_desc = desc->msi_desc) != NULL )
        pci_disable_msi(msi_desc);

    spin_lock_irqsave(&desc->lock, flags);

    BUG_ON(irq != domain_pirq_to_irq(d, pirq));

    if ( !forced_unbind )
        clear_domain_irq_pirq(d, irq, info);
    else
    {
        info->arch.irq = -irq;
        radix_tree_replace_slot(
            radix_tree_lookup_slot(&d->arch.irq_pirq, irq),
            radix_tree_int_to_ptr(-pirq));
    }

    if ( msi_desc )
    {
        desc->handler = &no_irq_type;
        desc->msi_desc = NULL;
    }

    spin_unlock_irqrestore(&desc->lock, flags);
    if (msi_desc)
        msi_free_irq(msi_desc);

    if ( !forced_unbind )
        cleanup_domain_irq_pirq(d, irq, info);

    ret = irq_deny_access(d, irq);
    if ( ret )
        printk(XENLOG_G_ERR
               "dom%d: could not deny access to IRQ%d (pirq %d)\n",
               d->domain_id, irq, pirq);

 done:
    return ret;
}
