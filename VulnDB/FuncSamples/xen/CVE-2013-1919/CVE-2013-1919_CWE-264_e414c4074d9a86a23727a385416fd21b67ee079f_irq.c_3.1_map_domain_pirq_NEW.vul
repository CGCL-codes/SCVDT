int map_domain_pirq(
    struct domain *d, int pirq, int irq, int type, void *data)
{
    int ret = 0;
    int old_irq, old_pirq;
    struct pirq *info;
    struct irq_desc *desc;
    unsigned long flags;

    ASSERT(spin_is_locked(&d->event_lock));

    if ( !IS_PRIV(current->domain) &&
         !(IS_PRIV_FOR(current->domain, d) &&
           irq_access_permitted(current->domain, irq)))
        return -EPERM;

    if ( pirq < 0 || pirq >= d->nr_pirqs || irq < 0 || irq >= nr_irqs )
    {
        dprintk(XENLOG_G_ERR, "dom%d: invalid pirq %d or irq %d\n",
                d->domain_id, pirq, irq);
        return -EINVAL;
    }

    old_irq = domain_pirq_to_irq(d, pirq);
    old_pirq = domain_irq_to_pirq(d, irq);

    if ( (old_irq > 0 && (old_irq != irq) ) ||
         (old_pirq && (old_pirq != pirq)) )
    {
        dprintk(XENLOG_G_WARNING, "dom%d: pirq %d or irq %d already mapped\n",
                d->domain_id, pirq, irq);
        return 0;
    }

    ret = xsm_map_domain_pirq(d, irq, data);
    if ( ret )
    {
        dprintk(XENLOG_G_ERR, "dom%d: could not permit access to irq %d mapping to pirq %d\n",
                d->domain_id, irq, pirq);
        return ret;
    }

    ret = irq_permit_access(d, irq);
    if ( ret )
    {
        printk(XENLOG_G_ERR
               "dom%d: could not permit access to IRQ%d (pirq %d)\n",
               d->domain_id, irq, pirq);
        return ret;
    }

    ret = prepare_domain_irq_pirq(d, irq, pirq, &info);
    if ( ret )
        goto revoke;

    desc = irq_to_desc(irq);

    if ( type == MAP_PIRQ_TYPE_MSI )
    {
        struct msi_info *msi = (struct msi_info *)data;
        struct msi_desc *msi_desc;
        struct pci_dev *pdev;

        ASSERT(spin_is_locked(&pcidevs_lock));

        ret = -ENODEV;
        if ( !cpu_has_apic )
            goto done;

        pdev = pci_get_pdev(msi->seg, msi->bus, msi->devfn);
        ret = pci_enable_msi(msi, &msi_desc);
        if ( ret )
            goto done;

        spin_lock_irqsave(&desc->lock, flags);

        if ( desc->handler != &no_irq_type )
        {
            spin_unlock_irqrestore(&desc->lock, flags);
            dprintk(XENLOG_G_ERR, "dom%d: irq %d in use\n",
                    d->domain_id, irq);
            pci_disable_msi(msi_desc);
            ret = -EBUSY;
            goto done;
        }
        setup_msi_handler(desc, msi_desc);

        if ( opt_irq_vector_map == OPT_IRQ_VECTOR_MAP_PERDEV
             && !desc->arch.used_vectors )
        {
            desc->arch.used_vectors = &pdev->arch.used_vectors;
            if ( desc->arch.vector != IRQ_VECTOR_UNASSIGNED )
            {
                int vector = desc->arch.vector;
                ASSERT(!test_bit(vector, desc->arch.used_vectors));

                set_bit(vector, desc->arch.used_vectors);
            }
        }

        set_domain_irq_pirq(d, irq, info);
        setup_msi_irq(desc);
        spin_unlock_irqrestore(&desc->lock, flags);
    }
    else
    {
        spin_lock_irqsave(&desc->lock, flags);
        set_domain_irq_pirq(d, irq, info);
        spin_unlock_irqrestore(&desc->lock, flags);
    }

done:
    if ( ret )
    {
        cleanup_domain_irq_pirq(d, irq, info);
 revoke:
        if ( irq_deny_access(d, irq) )
            printk(XENLOG_G_ERR
                   "dom%d: could not revoke access to IRQ%d (pirq %d)\n",
                   d->domain_id, irq, pirq);
    }
    return ret;
}
