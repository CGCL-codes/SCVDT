static void sh_pagetable_dying(struct vcpu *v, paddr_t gpa)
{
    int i = 0;
    int flush = 0;
    int fast_path = 0;
    paddr_t gcr3 = 0;
    p2m_type_t p2mt;
    char *gl3pa = NULL;
    guest_l3e_t *gl3e = NULL;
    paddr_t gl2a = 0;
    unsigned long l3gfn;
    mfn_t l3mfn;

    gcr3 = (v->arch.hvm_vcpu.guest_cr[3]);
    /* fast path: the pagetable belongs to the current context */
    if ( gcr3 == gpa )
        fast_path = 1;

    l3gfn = gpa >> PAGE_SHIFT;
    l3mfn = get_gfn_query(v->domain, _gfn(l3gfn), &p2mt);
    if ( !mfn_valid(l3mfn) || !p2m_is_ram(p2mt) )
    {
        printk(XENLOG_DEBUG "sh_pagetable_dying: gpa not valid %"PRIpaddr"\n",
               gpa);
        goto out_put_gfn;
    }

    paging_lock(v->domain);

    if ( !fast_path )
    {
        gl3pa = sh_map_domain_page(l3mfn);
        gl3e = (guest_l3e_t *)(gl3pa + ((unsigned long)gpa & ~PAGE_MASK));
    }
    for ( i = 0; i < 4; i++ )
    {
        unsigned long gfn;
        mfn_t smfn, gmfn;

        if ( fast_path ) {
            if ( pagetable_is_null(v->arch.shadow_table[i]) )
                smfn = _mfn(INVALID_MFN);
            else
                smfn = _mfn(pagetable_get_pfn(v->arch.shadow_table[i]));
        }
        else
        {
            /* retrieving the l2s */
            gl2a = guest_l3e_get_paddr(gl3e[i]);
            gfn = gl2a >> PAGE_SHIFT;
            gmfn = get_gfn_query_unlocked(v->domain, gfn, &p2mt);
            smfn = shadow_hash_lookup(v, mfn_x(gmfn), SH_type_l2_pae_shadow);
        }

        if ( mfn_valid(smfn) )
        {
            gmfn = _mfn(mfn_to_page(smfn)->v.sh.back);
            mfn_to_page(gmfn)->shadow_flags |= SHF_pagetable_dying;
            shadow_unhook_mappings(v, smfn, 1/* user pages only */);
            flush = 1;
        }
    }
    if ( flush )
        flush_tlb_mask(v->domain->domain_dirty_cpumask);

    /* Remember that we've seen the guest use this interface, so we
     * can rely on it using it in future, instead of guessing at
     * when processes are being torn down. */
    v->domain->arch.paging.shadow.pagetable_dying_op = 1;

    v->arch.paging.shadow.pagetable_dying = 1;

    if ( !fast_path )
        unmap_domain_page(gl3pa);
    paging_unlock(v->domain);
out_put_gfn:
    put_gfn(v->domain, l3gfn);
}
