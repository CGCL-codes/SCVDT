static int xc_try_bzip2_decode(
    struct xc_dom_image *dom, void **blob, size_t *size)
{
    bz_stream stream;
    int ret;
    char *out_buf;
    char *tmp_buf;
    int retval = -1;
    int outsize;
    uint64_t total;

    stream.bzalloc = NULL;
    stream.bzfree = NULL;
    stream.opaque = NULL;

    ret = BZ2_bzDecompressInit(&stream, 0, 0);
    if ( ret != BZ_OK )
    {
        DOMPRINTF("BZIP2: Error initting stream");
        return -1;
    }

    /* sigh.  We don't know up-front how much memory we are going to need
     * for the output buffer.  Allocate the output buffer to be equal
     * the input buffer to start, and we'll realloc as needed.
     */
    outsize = dom->kernel_size;
    out_buf = malloc(outsize);
    if ( out_buf == NULL )
    {
        DOMPRINTF("BZIP2: Failed to alloc memory");
        goto bzip2_cleanup;
    }

    stream.next_in = dom->kernel_blob;
    stream.avail_in = dom->kernel_size;

    stream.next_out = out_buf;
    stream.avail_out = dom->kernel_size;

    for ( ; ; )
    {
        ret = BZ2_bzDecompress(&stream);
        if ( ret == BZ_STREAM_END )
        {
            DOMPRINTF("BZIP2: Saw data stream end");
            retval = 0;
            break;
        }
        if ( ret != BZ_OK )
        {
            DOMPRINTF("BZIP2: error %d", ret);
            free(out_buf);
            goto bzip2_cleanup;
        }

        if ( stream.avail_out == 0 )
        {
            /* Protect against output buffer overflow */
            if ( outsize > INT_MAX / 2 )
            {
                DOMPRINTF("BZIP2: output buffer overflow");
                free(out_buf);
                goto bzip2_cleanup;
            }

            tmp_buf = realloc(out_buf, outsize * 2);
            if ( tmp_buf == NULL )
            {
                DOMPRINTF("BZIP2: Failed to realloc memory");
                free(out_buf);
                goto bzip2_cleanup;
            }
            out_buf = tmp_buf;

            stream.next_out = out_buf + outsize;
            stream.avail_out = (outsize * 2) - outsize;
            outsize *= 2;
        }
        else if ( stream.avail_in == 0 )
        {
            /*
             * If there is output buffer available then this indicates
             * that BZ2_bzDecompress would like more input data to be
             * provided.  However our complete input buffer is in
             * memory and provided upfront so if avail_in is zero this
             * actually indicates a truncated input.
             */
            DOMPRINTF("BZIP2: not enough input");
            free(out_buf);
            goto bzip2_cleanup;
        }
    }

    total = (((uint64_t)stream.total_out_hi32) << 32) | stream.total_out_lo32;

    DOMPRINTF("%s: BZIP2 decompress OK, 0x%zx -> 0x%lx",
              __FUNCTION__, *size, (long unsigned int) total);

    *blob = out_buf;
    *size = total;

 bzip2_cleanup:
    BZ2_bzDecompressEnd(&stream);

    return retval;
}
