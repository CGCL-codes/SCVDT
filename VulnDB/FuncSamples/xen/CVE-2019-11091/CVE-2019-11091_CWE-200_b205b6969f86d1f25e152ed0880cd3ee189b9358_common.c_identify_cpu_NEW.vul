void identify_cpu(struct cpuinfo_x86 *c)
{
	int i;

	c->x86_cache_size = -1;
	c->x86_vendor = X86_VENDOR_UNKNOWN;
	c->cpuid_level = -1;	/* CPUID not detected */
	c->x86_model = c->x86_mask = 0;	/* So far unknown... */
	c->x86_vendor_id[0] = '\0'; /* Unset */
	c->x86_model_id[0] = '\0';  /* Unset */
	c->x86_max_cores = 1;
	c->x86_num_siblings = 1;
	c->x86_clflush_size = 0;
	c->phys_proc_id = XEN_INVALID_SOCKET_ID;
	c->cpu_core_id = XEN_INVALID_CORE_ID;
	c->compute_unit_id = INVALID_CUID;
	memset(&c->x86_capability, 0, sizeof c->x86_capability);

	generic_identify(c);

#ifdef NOISY_CAPS
	printk(KERN_DEBUG "CPU: After vendor identify, caps:");
	for (i = 0; i < NCAPINTS; i++)
		printk(" %08x", c->x86_capability[i]);
	printk("\n");
#endif

	/*
	 * Vendor-specific initialization.  In this section we
	 * canonicalize the feature flags, meaning if there are
	 * features a certain CPU supports which CPUID doesn't
	 * tell us, CPUID claiming incorrect flags, or other bugs,
	 * we handle them here.
	 *
	 * At the end of this section, c->x86_capability better
	 * indicate the features this CPU genuinely supports!
	 */
	if (this_cpu->c_init)
		this_cpu->c_init(c);


   	if ( !opt_pku )
		setup_clear_cpu_cap(X86_FEATURE_PKU);

	/*
	 * The vendor-specific functions might have changed features.  Now
	 * we do "generic changes."
	 */
	for (i = 0; i < FSCAPINTS; ++i)
		c->x86_capability[i] &= known_features[i];

	for (i = 0 ; i < NCAPINTS ; ++i)
		c->x86_capability[i] &= ~cleared_caps[i];

	/* If the model name is still unset, do table lookup. */
	if ( !c->x86_model_id[0] ) {
		/* Last resort... */
		snprintf(c->x86_model_id, sizeof(c->x86_model_id),
			"%02x/%02x", c->x86_vendor, c->x86_model);
	}

	/* Now the feature flags better reflect actual CPU features! */

	if ( cpu_has_xsave )
		xstate_init(c);

#ifdef NOISY_CAPS
	printk(KERN_DEBUG "CPU: After all inits, caps:");
	for (i = 0; i < NCAPINTS; i++)
		printk(" %08x", c->x86_capability[i]);
	printk("\n");
#endif

	/*
	 * On SMP, boot_cpu_data holds the common feature set between
	 * all CPUs; so make sure that we indicate which features are
	 * common between the CPUs.  The first time this routine gets
	 * executed, c == &boot_cpu_data.
	 */
	if ( c != &boot_cpu_data ) {
		/* Inherit certain bits from the boot CPU. */
		if (test_bit(X86_FEATURE_IND_THUNK_LFENCE,
		             boot_cpu_data.x86_capability))
			__set_bit(X86_FEATURE_IND_THUNK_LFENCE,
			          c->x86_capability);
		if (test_bit(X86_FEATURE_IND_THUNK_JMP,
			     boot_cpu_data.x86_capability))
			__set_bit(X86_FEATURE_IND_THUNK_JMP, c->x86_capability);
		if (test_bit(X86_FEATURE_SC_MSR_PV,
		             boot_cpu_data.x86_capability))
			__set_bit(X86_FEATURE_SC_MSR_PV, c->x86_capability);
		if (test_bit(X86_FEATURE_SC_MSR_HVM,
		             boot_cpu_data.x86_capability))
			__set_bit(X86_FEATURE_SC_MSR_HVM, c->x86_capability);
		if (test_bit(X86_FEATURE_SC_RSB_PV,
		             boot_cpu_data.x86_capability))
			__set_bit(X86_FEATURE_SC_RSB_PV, c->x86_capability);
		if (test_bit(X86_FEATURE_SC_RSB_HVM,
		             boot_cpu_data.x86_capability))
			__set_bit(X86_FEATURE_SC_RSB_HVM, c->x86_capability);
		if (test_bit(X86_FEATURE_NO_XPTI,
		             boot_cpu_data.x86_capability))
			__set_bit(X86_FEATURE_NO_XPTI, c->x86_capability);
		if (test_bit(X86_FEATURE_SC_MSR_IDLE,
			     boot_cpu_data.x86_capability))
			__set_bit(X86_FEATURE_SC_MSR_IDLE, c->x86_capability);
		if (test_bit(X86_FEATURE_SC_VERW_PV,
			     boot_cpu_data.x86_capability))
			__set_bit(X86_FEATURE_SC_VERW_PV, c->x86_capability);
		if (test_bit(X86_FEATURE_SC_VERW_HVM,
			     boot_cpu_data.x86_capability))
			__set_bit(X86_FEATURE_SC_VERW_HVM, c->x86_capability);
		if (test_bit(X86_FEATURE_SC_VERW_IDLE,
			     boot_cpu_data.x86_capability))
			__set_bit(X86_FEATURE_SC_VERW_IDLE, c->x86_capability);

		/* AND the already accumulated flags with these */
		for ( i = 0 ; i < NCAPINTS ; i++ )
			boot_cpu_data.x86_capability[i] &= c->x86_capability[i];

		mcheck_init(c, 0);
	} else {
		mcheck_init(c, 1);

		mtrr_bp_init();
	}
}
