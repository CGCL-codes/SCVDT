int libxl_device_disk_add(libxl_ctx *ctx, uint32_t domid, libxl_device_disk *disk)
{
    libxl__gc gc = LIBXL_INIT_GC(ctx);
    flexarray_t *front;
    flexarray_t *back;
    char *backend_type;
    int devid;
    libxl__device device;
    int major, minor, rc;

    rc = validate_virtual_disk(ctx, disk->pdev_path, disk); 
    if (rc)
        return rc;

    front = flexarray_make(16, 1);
    if (!front) {
        rc = ERROR_NOMEM;
        goto out;
    }
    back = flexarray_make(16, 1);
    if (!back) {
        rc = ERROR_NOMEM;
        goto out_free;
    }

    backend_type = libxl__device_disk_string_of_backend(disk->backend);
    devid = libxl__device_disk_dev_number(disk->vdev);
    if (devid==-1) {
        LIBXL__LOG(ctx, LIBXL__LOG_ERROR, "Invalid or unsupported"
               " virtual disk identifier %s", disk->vdev);
        rc = ERROR_INVAL;
        goto out_free;
    }

    device.backend_devid = devid;
    device.backend_domid = disk->backend_domid;
    device.devid = devid;
    device.domid = disk->domid;
    device.kind = DEVICE_VBD;

    switch (disk->backend) {
        case DISK_BACKEND_PHY: 
            libxl__device_physdisk_major_minor(disk->pdev_path, &major, &minor);
            flexarray_append(back, "physical-device");
            flexarray_append(back, libxl__sprintf(&gc, "%x:%x", major, minor));

            flexarray_append(back, "params");
            flexarray_append(back, disk->pdev_path);

            device.backend_kind = DEVICE_VBD;
            break;
        case DISK_BACKEND_TAP:
            if (libxl__blktap_enabled(&gc) && disk->format != DISK_FORMAT_EMPTY) {
                const char *dev = libxl__blktap_devpath(&gc,
                                               disk->pdev_path, disk->format);
                if (!dev) {
                    rc = ERROR_FAIL;
                    goto out_free;
                }
                flexarray_append(back, "tapdisk-params");
                flexarray_append(back, libxl__sprintf(&gc, "%s:%s", 
                    libxl__device_disk_string_of_format(disk->format), 
                    disk->pdev_path));
                flexarray_append(back, "params");
                flexarray_append(back, libxl__strdup(&gc, dev));
                backend_type = "phy";
                libxl__device_physdisk_major_minor(dev, &major, &minor);
                flexarray_append(back, "physical-device");
                flexarray_append(back, libxl__sprintf(&gc, "%x:%x", major, minor));
                device.backend_kind = DEVICE_VBD;

                break;
            }
        case DISK_BACKEND_QDISK: 
            flexarray_append(back, "params");
            flexarray_append(back, libxl__sprintf(&gc, "%s:%s",
                          libxl__device_disk_string_of_format(disk->format), disk->pdev_path));

            if (libxl__blktap_enabled(&gc) && 
                 disk->backend != DISK_BACKEND_QDISK)
                device.backend_kind = DEVICE_TAP;
            else
                device.backend_kind = DEVICE_QDISK;
            break;
        default:
            LIBXL__LOG(ctx, LIBXL__LOG_ERROR, "unrecognized disk backend type: %d\n", disk->backend);
            rc = ERROR_INVAL;
            goto out_free;
    }

    flexarray_append(back, "frontend-id");
    flexarray_append(back, libxl__sprintf(&gc, "%d", disk->domid));
    flexarray_append(back, "online");
    flexarray_append(back, "1");
    flexarray_append(back, "removable");
    flexarray_append(back, libxl__sprintf(&gc, "%d", (disk->unpluggable) ? 1 : 0));
    flexarray_append(back, "bootable");
    flexarray_append(back, libxl__sprintf(&gc, "%d", 1));
    flexarray_append(back, "state");
    flexarray_append(back, libxl__sprintf(&gc, "%d", 1));
    flexarray_append(back, "dev");
    flexarray_append(back, disk->vdev);
    flexarray_append(back, "type");
    flexarray_append(back, backend_type);
    flexarray_append(back, "mode");
    flexarray_append(back, disk->readwrite ? "w" : "r");

    flexarray_append(front, "backend-id");
    flexarray_append(front, libxl__sprintf(&gc, "%d", disk->backend_domid));
    flexarray_append(front, "state");
    flexarray_append(front, libxl__sprintf(&gc, "%d", 1));
    flexarray_append(front, "virtual-device");
    flexarray_append(front, libxl__sprintf(&gc, "%d", devid));
    flexarray_append(front, "device-type");
    flexarray_append(front, disk->is_cdrom ? "cdrom" : "disk");

    if (0 /* protocol != native*/) {
        flexarray_append(front, "protocol");
        flexarray_append(front, "x86_32-abi"); /* hardcoded ! */
    }

    libxl__device_generic_add(ctx, &device,
                              libxl__xs_kvs_of_flexarray(&gc, back, back->count),
                              libxl__xs_kvs_of_flexarray(&gc, front, front->count),
                              NULL);

    rc = 0;

out_free:
    flexarray_free(back);
    flexarray_free(front);
out:
    libxl__free_all(&gc);
    return rc;
}
