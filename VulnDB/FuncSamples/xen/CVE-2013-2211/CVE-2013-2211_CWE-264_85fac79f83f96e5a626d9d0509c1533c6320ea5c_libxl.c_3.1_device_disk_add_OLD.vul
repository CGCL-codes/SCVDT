static void device_disk_add(libxl__egc *egc, uint32_t domid,
                           libxl_device_disk *disk,
                           libxl__ao_device *aodev,
                           char *get_vdev(libxl__gc *, void *,
                                          xs_transaction_t),
                           void *get_vdev_user)
{
    STATE_AO_GC(aodev->ao);
    flexarray_t *front = NULL;
    flexarray_t *back = NULL;
    char *dev = NULL, *script;
    libxl__device *device;
    int rc;
    libxl_ctx *ctx = gc->owner;
    xs_transaction_t t = XBT_NULL;

    for (;;) {
        rc = libxl__xs_transaction_start(gc, &t);
        if (rc) goto out;

        if (get_vdev) {
            assert(get_vdev_user);
            disk->vdev = get_vdev(gc, get_vdev_user, t);
            if (disk->vdev == NULL) {
                rc = ERROR_FAIL;
                goto out;
            }
        }

        rc = libxl__device_disk_setdefault(gc, disk);
        if (rc) goto out;

        if (front)
            flexarray_free(front);
        front = flexarray_make(16, 1);
        if (!front) {
            rc = ERROR_NOMEM;
            goto out;
        }
        if (back)
            flexarray_free(back);
        back = flexarray_make(16, 1);
        if (!back) {
            rc = ERROR_NOMEM;
            goto out_free;
        }

        GCNEW(device);
        rc = libxl__device_from_disk(gc, domid, disk, device);
        if (rc != 0) {
            LIBXL__LOG(ctx, LIBXL__LOG_ERROR, "Invalid or unsupported"
                   " virtual disk identifier %s", disk->vdev);
            goto out_free;
        }

        switch (disk->backend) {
            case LIBXL_DISK_BACKEND_PHY:
                dev = disk->pdev_path;

        do_backend_phy:
                flexarray_append(back, "params");
                flexarray_append(back, dev);

                script = libxl__abs_path(gc, disk->script?: "block",
                                         libxl__xen_script_dir_path());
                flexarray_append_pair(back, "script", script);

                /* If the user did not supply a block script then we
                 * write the physical-device node ourselves.
                 *
                 * If the user did supply a script then that script is
                 * responsible for this since the block device may not
                 * exist yet.
                 */
                if (!disk->script) {
                    int major, minor;
                    libxl__device_physdisk_major_minor(dev, &major, &minor);
                    flexarray_append_pair(back, "physical-device",
                            libxl__sprintf(gc, "%x:%x", major, minor));
                }

                assert(device->backend_kind == LIBXL__DEVICE_KIND_VBD);
                break;

            case LIBXL_DISK_BACKEND_TAP:
                if (dev == NULL) {
                    dev = libxl__blktap_devpath(gc, disk->pdev_path,
                                                disk->format);
                    if (!dev) {
                        LOG(ERROR, "failed to get blktap devpath for %p\n",
                            disk->pdev_path);
                        rc = ERROR_FAIL;
                        goto out_free;
                    }
                }
                flexarray_append(back, "tapdisk-params");
                flexarray_append(back, libxl__sprintf(gc, "%s:%s",
                    libxl__device_disk_string_of_format(disk->format),
                    disk->pdev_path));

                /* tap backends with scripts are rejected by
                 * libxl__device_disk_set_backend */
                assert(!disk->script);

                /* now create a phy device to export the device to the guest */
                goto do_backend_phy;
            case LIBXL_DISK_BACKEND_QDISK:
                flexarray_append(back, "params");
                flexarray_append(back, libxl__sprintf(gc, "%s:%s",
                              libxl__device_disk_string_of_format(disk->format), disk->pdev_path));
                assert(device->backend_kind == LIBXL__DEVICE_KIND_QDISK);
                break;
            default:
                LIBXL__LOG(ctx, LIBXL__LOG_ERROR, "unrecognized disk backend type: %d\n", disk->backend);
                rc = ERROR_INVAL;
                goto out_free;
        }

        flexarray_append(back, "frontend-id");
        flexarray_append(back, libxl__sprintf(gc, "%d", domid));
        flexarray_append(back, "online");
        flexarray_append(back, "1");
        flexarray_append(back, "removable");
        flexarray_append(back, libxl__sprintf(gc, "%d", (disk->removable) ? 1 : 0));
        flexarray_append(back, "bootable");
        flexarray_append(back, libxl__sprintf(gc, "%d", 1));
        flexarray_append(back, "state");
        flexarray_append(back, libxl__sprintf(gc, "%d", 1));
        flexarray_append(back, "dev");
        flexarray_append(back, disk->vdev);
        flexarray_append(back, "type");
        flexarray_append(back, libxl__device_disk_string_of_backend(disk->backend));
        flexarray_append(back, "mode");
        flexarray_append(back, disk->readwrite ? "w" : "r");
        flexarray_append(back, "device-type");
        flexarray_append(back, disk->is_cdrom ? "cdrom" : "disk");

        flexarray_append(front, "backend-id");
        flexarray_append(front, libxl__sprintf(gc, "%d", disk->backend_domid));
        flexarray_append(front, "state");
        flexarray_append(front, libxl__sprintf(gc, "%d", 1));
        flexarray_append(front, "virtual-device");
        flexarray_append(front, libxl__sprintf(gc, "%d", device->devid));
        flexarray_append(front, "device-type");
        flexarray_append(front, disk->is_cdrom ? "cdrom" : "disk");

        libxl__device_generic_add(gc, t, device,
                            libxl__xs_kvs_of_flexarray(gc, back, back->count),
                            libxl__xs_kvs_of_flexarray(gc, front, front->count));

        rc = libxl__xs_transaction_commit(gc, &t);
        if (!rc) break;
        if (rc < 0) goto out_free;
    }

    aodev->dev = device;
    aodev->action = DEVICE_CONNECT;
    libxl__wait_device_connection(egc, aodev);

    rc = 0;

out_free:
    flexarray_free(back);
    flexarray_free(front);
out:
    libxl__xs_transaction_abort(gc, &t);
    aodev->rc = rc;
    if (rc) aodev->callback(egc, aodev);
    return;
}
