static int vgic_distr_mmio_write(struct vcpu *v, mmio_info_t *info)
{
    struct hsr_dabt dabt = info->dabt;
    struct cpu_user_regs *regs = guest_cpu_user_regs();
    register_t *r = select_user_reg(regs, dabt.reg);
    struct vgic_irq_rank *rank;
    int offset = (int)(info->gpa - v->domain->arch.vgic.dbase);
    int gicd_reg = REG(offset);
    uint32_t tr;

    switch ( gicd_reg )
    {
    case GICD_CTLR:
        if ( dabt.size != 2 ) goto bad_width;
        /* Ignore all but the enable bit */
        v->domain->arch.vgic.ctlr = (*r) & GICD_CTL_ENABLE;
        return 1;

    /* R/O -- write ignored */
    case GICD_TYPER:
    case GICD_IIDR:
        goto write_ignore;

    /* Implementation defined -- write ignored */
    case REG(0x020) ... REG(0x03c):
        goto write_ignore;

    case GICD_IGROUPR ... GICD_IGROUPRN:
        /* We do not implement security extensions for guests, write ignore */
        goto write_ignore;

    case GICD_ISENABLER ... GICD_ISENABLERN:
        if ( dabt.size != 2 ) goto bad_width;
        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ISENABLER);
        if ( rank == NULL) goto write_ignore;
        vgic_lock_rank(v, rank);
        tr = rank->ienable;
        rank->ienable |= *r;
        vgic_unlock_rank(v, rank);
        vgic_enable_irqs(v, (*r) & (~tr), gicd_reg - GICD_ISENABLER);
        return 1;

    case GICD_ICENABLER ... GICD_ICENABLERN:
        if ( dabt.size != 2 ) goto bad_width;
        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ICENABLER);
        if ( rank == NULL) goto write_ignore;
        vgic_lock_rank(v, rank);
        tr = rank->ienable;
        rank->ienable &= ~*r;
        vgic_unlock_rank(v, rank);
        vgic_disable_irqs(v, (*r) & tr, gicd_reg - GICD_ICENABLER);
        return 1;

    case GICD_ISPENDR ... GICD_ISPENDRN:
        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;
        printk("vGICD: unhandled %s write %#"PRIregister" to ISPENDR%d\n",
               dabt.size ? "word" : "byte", *r, gicd_reg - GICD_ISPENDR);
        return 0;

    case GICD_ICPENDR ... GICD_ICPENDRN:
        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;
        printk("vGICD: unhandled %s write %#"PRIregister" to ICPENDR%d\n",
               dabt.size ? "word" : "byte", *r, gicd_reg - GICD_ICPENDR);
        return 0;

    case GICD_ISACTIVER ... GICD_ISACTIVERN:
        if ( dabt.size != 2 ) goto bad_width;
        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ISACTIVER);
        if ( rank == NULL) goto write_ignore;
        vgic_lock_rank(v, rank);
        rank->iactive &= ~*r;
        vgic_unlock_rank(v, rank);
        return 1;

    case GICD_ICACTIVER ... GICD_ICACTIVERN:
        if ( dabt.size != 2 ) goto bad_width;
        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ICACTIVER);
        if ( rank == NULL) goto write_ignore;
        vgic_lock_rank(v, rank);
        rank->iactive &= ~*r;
        vgic_unlock_rank(v, rank);
        return 1;

    case GICD_ITARGETSR ... GICD_ITARGETSR + 7:
        /* SGI/PPI target is read only */
        goto write_ignore;

    case GICD_ITARGETSR + 8 ... GICD_ITARGETSRN:
        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;
        rank = vgic_irq_rank(v, 8, gicd_reg - GICD_ITARGETSR);
        if ( rank == NULL) goto write_ignore;
        vgic_lock_rank(v, rank);
        if ( dabt.size == 2 )
            rank->itargets[REG_RANK_INDEX(8, gicd_reg - GICD_ITARGETSR)] = *r;
        else
            byte_write(&rank->itargets[REG_RANK_INDEX(8, gicd_reg - GICD_ITARGETSR)],
                       *r, offset);
        vgic_unlock_rank(v, rank);
        return 1;

    case GICD_IPRIORITYR ... GICD_IPRIORITYRN:
        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;
        rank = vgic_irq_rank(v, 8, gicd_reg - GICD_IPRIORITYR);
        if ( rank == NULL) goto write_ignore;
        vgic_lock_rank(v, rank);
        if ( dabt.size == 2 )
            rank->ipriority[REG_RANK_INDEX(8, gicd_reg - GICD_IPRIORITYR)] = *r;
        else
            byte_write(&rank->ipriority[REG_RANK_INDEX(8, gicd_reg - GICD_IPRIORITYR)],
                       *r, offset);
        vgic_unlock_rank(v, rank);
        return 1;

    case GICD_ICFGR: /* SGIs */
        goto write_ignore;
    case GICD_ICFGR + 1: /* PPIs */
        /* It is implementation defined if these are writeable. We chose not */
        goto write_ignore;
    case GICD_ICFGR + 2 ... GICD_ICFGRN: /* SPIs */
        if ( dabt.size != 2 ) goto bad_width;
        rank = vgic_irq_rank(v, 2, gicd_reg - GICD_ICFGR);
        if ( rank == NULL) goto write_ignore;
        vgic_lock_rank(v, rank);
        rank->icfg[REG_RANK_INDEX(2, gicd_reg - GICD_ICFGR)] = *r;
        vgic_unlock_rank(v, rank);
        return 1;

    case GICD_NSACR ... GICD_NSACRN:
        /* We do not implement security extensions for guests, write ignore */
        goto write_ignore;

    case GICD_SGIR:
        if ( dabt.size != 2 )
            goto bad_width;
        return vgic_to_sgi(v, *r);

    case GICD_CPENDSGIR ... GICD_CPENDSGIRN:
        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;
        printk("vGICD: unhandled %s write %#"PRIregister" to ICPENDSGIR%d\n",
               dabt.size ? "word" : "byte", *r, gicd_reg - GICD_CPENDSGIR);
        return 0;

    case GICD_SPENDSGIR ... GICD_SPENDSGIRN:
        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;
        printk("vGICD: unhandled %s write %#"PRIregister" to ISPENDSGIR%d\n",
               dabt.size ? "word" : "byte", *r, gicd_reg - GICD_SPENDSGIR);
        return 0;

    /* Implementation defined -- write ignored */
    case REG(0xfd0) ... REG(0xfe4):
        goto write_ignore;

    /* R/O -- write ignore */
    case GICD_ICPIDR2:
        goto write_ignore;

    /* Implementation defined -- write ignored */
    case REG(0xfec) ... REG(0xffc):
        goto write_ignore;

    /* Reserved -- write ignored */
    case REG(0x00c) ... REG(0x01c):
    case REG(0x040) ... REG(0x07c):
    case REG(0x7fc):
    case REG(0xbfc):
    case REG(0xf04) ... REG(0xf0c):
    case REG(0xf30) ... REG(0xfcc):
        goto write_ignore;

    default:
        printk("vGICD: unhandled write r%d=%"PRIregister" offset %#08x\n",
               dabt.reg, *r, offset);
        return 0;
    }

bad_width:
    printk("vGICD: bad write width %d r%d=%"PRIregister" offset %#08x\n",
           dabt.size, dabt.reg, *r, offset);
    domain_crash_synchronous();
    return 0;

write_ignore:
    if ( dabt.size != 2 ) goto bad_width;
    return 1;
}
