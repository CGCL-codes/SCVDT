static void vmx_cpuid_policy_changed(struct vcpu *v)
{
    const struct cpuid_policy *cp = v->domain->arch.cpuid;

    if ( opt_hvm_fep ||
         (v->domain->arch.cpuid->x86_vendor != boot_cpu_data.x86_vendor) )
        v->arch.hvm_vmx.exception_bitmap |= (1U << TRAP_invalid_op);
    else
        v->arch.hvm_vmx.exception_bitmap &= ~(1U << TRAP_invalid_op);

    vmx_vmcs_enter(v);
    vmx_update_exception_bitmap(v);
    vmx_vmcs_exit(v);

    /*
     * We can safely pass MSR_SPEC_CTRL through to the guest, even if STIBP
     * isn't enumerated in hardware, as SPEC_CTRL_STIBP is ignored.
     */
    if ( cp->feat.ibrsb )
        vmx_clear_msr_intercept(v, MSR_SPEC_CTRL, VMX_MSR_RW);
    else
        vmx_set_msr_intercept(v, MSR_SPEC_CTRL, VMX_MSR_RW);

    /* MSR_PRED_CMD is safe to pass through if the guest knows about it. */
    if ( cp->feat.ibrsb || cp->extd.ibpb )
        vmx_clear_msr_intercept(v, MSR_PRED_CMD,  VMX_MSR_RW);
    else
        vmx_set_msr_intercept(v, MSR_PRED_CMD,  VMX_MSR_RW);
}
