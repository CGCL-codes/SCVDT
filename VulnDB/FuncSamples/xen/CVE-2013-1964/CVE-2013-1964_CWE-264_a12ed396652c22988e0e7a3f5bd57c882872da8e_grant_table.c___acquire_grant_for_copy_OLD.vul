static int
__acquire_grant_for_copy(
    struct domain *rd, unsigned long gref, struct domain *ld, int readonly,
    unsigned long *frame, unsigned *page_off, unsigned *length,
    unsigned allow_transitive, struct domain **owning_domain)
{
    grant_entry_v1_t *sha1;
    grant_entry_v2_t *sha2;
    grant_entry_header_t *shah;
    struct active_grant_entry *act;
    grant_status_t *status;
    uint32_t old_pin;
    domid_t trans_domid;
    grant_ref_t trans_gref;
    struct domain *rrd;
    unsigned long gfn;
    unsigned long grant_frame;
    unsigned trans_page_off;
    unsigned trans_length;
    int is_sub_page;
    struct domain *ignore;
    s16 rc = GNTST_okay;

    *owning_domain = NULL;

    spin_lock(&rd->grant_table->lock);

    if ( rd->grant_table->gt_version == 0 )
        PIN_FAIL(unlock_out, GNTST_general_error,
                 "remote grant table not ready\n");

    if ( unlikely(gref >= nr_grant_entries(rd->grant_table)) )
        PIN_FAIL(unlock_out, GNTST_bad_gntref,
                 "Bad grant reference %ld\n", gref);

    act = &active_entry(rd->grant_table, gref);
    shah = shared_entry_header(rd->grant_table, gref);
    if ( rd->grant_table->gt_version == 1 )
    {
        sha1 = &shared_entry_v1(rd->grant_table, gref);
        sha2 = NULL;
        status = &shah->flags;
    }
    else
    {
        sha1 = NULL;
        sha2 = &shared_entry_v2(rd->grant_table, gref);
        status = &status_entry(rd->grant_table, gref);
    }

    /* If already pinned, check the active domid and avoid refcnt overflow. */
    if ( act->pin &&
         ((act->domid != ld->domain_id) ||
          (act->pin & 0x80808080U) != 0) )
        PIN_FAIL(unlock_out, GNTST_general_error,
                 "Bad domain (%d != %d), or risk of counter overflow %08x\n",
                 act->domid, ld->domain_id, act->pin);

    old_pin = act->pin;
    if ( !act->pin ||
         (!readonly && !(act->pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask))) )
    {
        if ( (rc = _set_status(rd->grant_table->gt_version,
                               ld->domain_id,
                               readonly, 0, shah, act,
                               status) ) != GNTST_okay )
             goto unlock_out;

        trans_domid = ld->domain_id;
        trans_gref = 0;
        if ( sha2 && (shah->flags & GTF_type_mask) == GTF_transitive )
        {
            if ( !allow_transitive )
                PIN_FAIL(unlock_out_clear, GNTST_general_error,
                         "transitive grant when transitivity not allowed\n");

            trans_domid = sha2->transitive.trans_domid;
            trans_gref = sha2->transitive.gref;
            barrier(); /* Stop the compiler from re-loading
                          trans_domid from shared memory */
            if ( trans_domid == rd->domain_id )
                PIN_FAIL(unlock_out_clear, GNTST_general_error,
                         "transitive grants cannot be self-referential\n");

            /* We allow the trans_domid == ld->domain_id case, which
               corresponds to a grant being issued by one domain, sent
               to another one, and then transitively granted back to
               the original domain.  Allowing it is easy, and means
               that you don't need to go out of your way to avoid it
               in the guest. */

            rrd = rcu_lock_domain_by_id(trans_domid);
            if ( rrd == NULL )
                PIN_FAIL(unlock_out_clear, GNTST_general_error,
                         "transitive grant referenced bad domain %d\n",
                         trans_domid);
            spin_unlock(&rd->grant_table->lock);

            rc = __acquire_grant_for_copy(rrd, trans_gref, rd,
                                          readonly, &grant_frame,
                                          &trans_page_off, &trans_length,
                                          0, &ignore);

            spin_lock(&rd->grant_table->lock);
            if ( rc != GNTST_okay ) {
                __fixup_status_for_copy_pin(act, status);
                spin_unlock(&rd->grant_table->lock);
                return rc;
            }

            /* We dropped the lock, so we have to check that nobody
               else tried to pin (or, for that matter, unpin) the
               reference in *this* domain.  If they did, just give up
               and try again. */
            if ( act->pin != old_pin )
            {
                __fixup_status_for_copy_pin(act, status);
                spin_unlock(&rd->grant_table->lock);
                return __acquire_grant_for_copy(rd, gref, ld, readonly,
                                                frame, page_off, length,
                                                allow_transitive,
                                                owning_domain);
            }

            /* The actual remote remote grant may or may not be a
               sub-page, but we always treat it as one because that
               blocks mappings of transitive grants. */
            is_sub_page = 1;
            *owning_domain = rrd;
            act->gfn = -1ul;
        }
        else if ( sha1 )
        {
            gfn = sha1->frame;
            rc = __get_paged_frame(gfn, &grant_frame, readonly, rd);
            if ( rc != GNTST_okay )
                goto unlock_out_clear;
            act->gfn = gfn;
            is_sub_page = 0;
            trans_page_off = 0;
            trans_length = PAGE_SIZE;
            *owning_domain = rd;
        }
        else if ( !(sha2->hdr.flags & GTF_sub_page) )
        {
            gfn = sha2->full_page.frame;
            rc = __get_paged_frame(gfn, &grant_frame, readonly, rd);
            if ( rc != GNTST_okay )
                goto unlock_out_clear;
            act->gfn = gfn;
            is_sub_page = 0;
            trans_page_off = 0;
            trans_length = PAGE_SIZE;
            *owning_domain = rd;
        }
        else
        {
            gfn = sha2->sub_page.frame;
            rc = __get_paged_frame(gfn, &grant_frame, readonly, rd);
            if ( rc != GNTST_okay )
                goto unlock_out_clear;
            act->gfn = gfn;
            is_sub_page = 1;
            trans_page_off = sha2->sub_page.page_off;
            trans_length = sha2->sub_page.length;
            *owning_domain = rd;
        }

        if ( !act->pin )
        {
            act->domid = ld->domain_id;
            act->is_sub_page = is_sub_page;
            act->start = trans_page_off;
            act->length = trans_length;
            act->trans_dom = trans_domid;
            act->trans_gref = trans_gref;
            act->frame = grant_frame;
        }
    }
    else
    {
        *owning_domain = rd;
    }

    act->pin += readonly ? GNTPIN_hstr_inc : GNTPIN_hstw_inc;

    *page_off = act->start;
    *length = act->length;
    *frame = act->frame;

    spin_unlock(&rd->grant_table->lock);
    return rc;

 unlock_out_clear:
    if ( !(readonly) &&
         !(act->pin & GNTPIN_hstw_mask) )
        gnttab_clear_flag(_GTF_writing, status);

    if ( !act->pin )
        gnttab_clear_flag(_GTF_reading, status);

 unlock_out:
    spin_unlock(&rd->grant_table->lock);
    return rc;
}
