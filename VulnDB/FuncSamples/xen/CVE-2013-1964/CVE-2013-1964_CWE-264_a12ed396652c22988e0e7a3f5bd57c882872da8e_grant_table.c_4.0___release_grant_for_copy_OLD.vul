static void
__release_grant_for_copy(
    struct domain *rd, unsigned long gref, int readonly)
{
    grant_entry_header_t *sha;
    struct active_grant_entry *act;
    unsigned long r_frame;
    uint16_t *status;
    domid_t trans_domid;
    grant_ref_t trans_gref;
    int released_read;
    int released_write;
    struct domain *trans_dom;

    released_read = 0;
    released_write = 0;

    spin_lock(&rd->grant_table->lock);

    act = &active_entry(rd->grant_table, gref);
    sha = shared_entry_header(rd->grant_table, gref);
    r_frame = act->frame;

    if (rd->grant_table->gt_version == 1)
    {
        status = &sha->flags;
        trans_domid = rd->domain_id;
        /* Shut the compiler up.  This'll never be used, because
           trans_domid == rd->domain_id, but gcc doesn't know that. */
        trans_gref = 0x1234567;
    }
    else
    {
        status = &status_entry(rd->grant_table, gref);
        trans_domid = act->trans_dom;
        trans_gref = act->trans_gref;
    }

    if ( readonly )
    {
        act->pin -= GNTPIN_hstr_inc;
    }
    else
    {
        gnttab_mark_dirty(rd, r_frame);

        act->pin -= GNTPIN_hstw_inc;
        if ( !(act->pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask)) )
        {
            released_write = 1;
            gnttab_clear_flag(_GTF_writing, status);
        }
    }

    if ( !act->pin )
    {
        gnttab_clear_flag(_GTF_reading, status);
        released_read = 1;
    }

    spin_unlock(&rd->grant_table->lock);

    if ( trans_domid != rd->domain_id )
    {
        if ( released_write || released_read )
        {
            trans_dom = rcu_lock_domain_by_id(trans_domid);
            if ( trans_dom != NULL )
            {
                /* Recursive calls, but they're tail calls, so it's
                   okay. */
                if ( released_write )
                    __release_grant_for_copy(trans_dom, trans_gref, 0);
                else if ( released_read )
                    __release_grant_for_copy(trans_dom, trans_gref, 1);
            }
        }
    }
}
