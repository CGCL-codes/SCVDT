static void
__release_grant_for_copy(
    struct domain *rd, unsigned long gref, int readonly)
{
    grant_entry_header_t *sha;
    struct active_grant_entry *act;
    unsigned long r_frame;
    uint16_t *status;
    grant_ref_t trans_gref;
    int released_read;
    int released_write;
    struct domain *td;

    released_read = 0;
    released_write = 0;

    spin_lock(&rd->grant_table->lock);

    act = &active_entry(rd->grant_table, gref);
    sha = shared_entry_header(rd->grant_table, gref);
    r_frame = act->frame;

    if (rd->grant_table->gt_version == 1)
    {
        status = &sha->flags;
        td = rd;
        trans_gref = gref;
    }
    else
    {
        status = &status_entry(rd->grant_table, gref);
        td = act->trans_domain;
        trans_gref = act->trans_gref;
    }

    if ( readonly )
    {
        act->pin -= GNTPIN_hstr_inc;
    }
    else
    {
        gnttab_mark_dirty(rd, r_frame);

        act->pin -= GNTPIN_hstw_inc;
        if ( !(act->pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask)) )
        {
            released_write = 1;
            gnttab_clear_flag(_GTF_writing, status);
        }
    }

    if ( !act->pin )
    {
        gnttab_clear_flag(_GTF_reading, status);
        released_read = 1;
    }

    spin_unlock(&rd->grant_table->lock);

    if ( td != rd )
    {
        /* Recursive calls, but they're tail calls, so it's
           okay. */
        if ( released_write )
            __release_grant_for_copy(td, trans_gref, 0);
        else if ( released_read )
            __release_grant_for_copy(td, trans_gref, 1);

	rcu_unlock_domain(td);
    }
}
