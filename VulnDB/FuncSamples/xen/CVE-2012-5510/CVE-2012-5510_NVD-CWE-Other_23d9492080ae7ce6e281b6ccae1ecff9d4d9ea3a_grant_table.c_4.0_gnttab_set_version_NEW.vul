static long
gnttab_set_version(XEN_GUEST_HANDLE_PARAM(gnttab_set_version_t uop))
{
    gnttab_set_version_t op;
    struct domain *d = current->domain;
    struct grant_table *gt = d->grant_table;
    struct active_grant_entry *act;
    grant_entry_v1_t reserved_entries[GNTTAB_NR_RESERVED_ENTRIES];
    long res;
    int i;

    if (copy_from_guest(&op, uop, 1))
        return -EFAULT;

    res = -EINVAL;
    if (op.version != 1 && op.version != 2)
        goto out;

    res = 0;
    if ( gt->gt_version == op.version )
        goto out;

    spin_lock(&gt->lock);
    /* Make sure that the grant table isn't currently in use when we
       change the version number, except for the first 8 entries which
       are allowed to be in use (xenstore/xenconsole keeps them mapped).
       (You need to change the version number for e.g. kexec.) */
    if ( gt->gt_version != 0 )
    {
        for ( i = GNTTAB_NR_RESERVED_ENTRIES; i < nr_grant_entries(gt); i++ )
        {
            act = &active_entry(gt, i);
            if ( act->pin != 0 )
            {
                gdprintk(XENLOG_WARNING,
                         "tried to change grant table version from %d to %d, but some grant entries still in use\n",
                         gt->gt_version,
                         op.version);
                res = -EBUSY;
                goto out_unlock;
            }
        }
    }

    /* XXX: If we're going to version 2, we could maybe shrink the
       active grant table here. */

    if ( op.version == 2 && gt->gt_version < 2 )
    {
        res = gnttab_populate_status_frames(d, gt, nr_grant_frames(gt));
        if ( res < 0)
            goto out_unlock;
    }

    /* Preserve the first 8 entries (toolstack reserved grants) */
    if ( gt->gt_version == 1 )
    {
        memcpy(reserved_entries, &shared_entry_v1(gt, 0), sizeof(reserved_entries));
    }
    else if ( gt->gt_version == 2 )
    {
        for ( i = 0; i < GNTTAB_NR_RESERVED_ENTRIES && i < nr_grant_entries(gt); i++ )
        {
            int flags = status_entry(gt, i);
            flags |= shared_entry_v2(gt, i).hdr.flags;
            if ((flags & GTF_type_mask) == GTF_permit_access)
            {
                reserved_entries[i].flags = flags;
                reserved_entries[i].domid = shared_entry_v2(gt, i).hdr.domid;
                reserved_entries[i].frame = shared_entry_v2(gt, i).full_page.frame;
            }
            else
            {
                if ((flags & GTF_type_mask) != GTF_invalid)
                    gdprintk(XENLOG_INFO, "d%d: bad flags %x in grant %d when switching grant version\n",
                           d->domain_id, flags, i);
                memset(&reserved_entries[i], 0, sizeof(reserved_entries[i]));
            }
        }
    }

    if ( op.version < 2 && gt->gt_version == 2 )
        gnttab_unpopulate_status_frames(d, gt);

    /* Make sure there's no crud left over in the table from the
       old version. */
    for ( i = 0; i < nr_grant_frames(gt); i++ )
        memset(gt->shared_raw[i], 0, PAGE_SIZE);

    /* Restore the first 8 entries (toolstack reserved grants) */
    if ( gt->gt_version != 0 && op.version == 1 )
    {
        memcpy(&shared_entry_v1(gt, 0), reserved_entries, sizeof(reserved_entries));
    }
    else if ( gt->gt_version != 0 && op.version == 2 )
    {
        for ( i = 0; i < GNTTAB_NR_RESERVED_ENTRIES; i++ )
        {
            status_entry(gt, i) = reserved_entries[i].flags & (GTF_reading|GTF_writing);
            shared_entry_v2(gt, i).hdr.flags = reserved_entries[i].flags & ~(GTF_reading|GTF_writing);
            shared_entry_v2(gt, i).hdr.domid = reserved_entries[i].domid;
            shared_entry_v2(gt, i).full_page.frame = reserved_entries[i].frame;
        }
    }

    gt->gt_version = op.version;

out_unlock:
    spin_unlock(&gt->lock);

out:
    op.version = gt->gt_version;

    if (copy_to_guest(uop, &op, 1))
        res = -EFAULT;

    return res;
}
