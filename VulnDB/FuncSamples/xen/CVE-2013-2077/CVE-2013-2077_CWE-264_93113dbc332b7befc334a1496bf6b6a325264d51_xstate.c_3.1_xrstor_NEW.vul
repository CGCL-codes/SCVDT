void xrstor(struct vcpu *v, uint64_t mask)
{
    uint32_t hmask = mask >> 32;
    uint32_t lmask = mask;

    struct xsave_struct *ptr = v->arch.xsave_area;

    /*
     * AMD CPUs don't save/restore FDP/FIP/FOP unless an exception
     * is pending. Clear the x87 state here by setting it to fixed
     * values. The hypervisor data segment can be sometimes 0 and
     * sometimes new user value. Both should be ok. Use the FPU saved
     * data block as a safe address because it should be in L1.
     */
    if ( (mask & ptr->xsave_hdr.xstate_bv & XSTATE_FP) &&
         !(ptr->fpu_sse.fsw & 0x0080) &&
         boot_cpu_data.x86_vendor == X86_VENDOR_AMD )
        asm volatile ( "fnclex\n\t"        /* clear exceptions */
                       "ffree %%st(7)\n\t" /* clear stack tag */
                       "fildl %0"          /* load to clear state */
                       : : "m" (ptr->fpu_sse) );

    /*
     * XRSTOR can fault if passed a corrupted data block. We handle this
     * possibility, which may occur if the block was passed to us by control
     * tools or through VCPUOP_initialise, by silently clearing the block.
     */
    asm volatile ( "1: .byte " REX_PREFIX "0x0f,0xae,0x2f\n"
                   ".section .fixup,\"ax\"\n"
                   "2: mov %5,%%ecx       \n"
                   "   xor %1,%1          \n"
                   "   rep stosb          \n"
                   "   lea %2,%0          \n"
                   "   mov %3,%1          \n"
                   "   jmp 1b             \n"
                   ".previous             \n"
                   _ASM_EXTABLE(1b, 2b)
                   : "+&D" (ptr), "+&a" (lmask)
                   : "m" (*ptr), "g" (lmask), "d" (hmask),
                     "m" (xsave_cntxt_size)
                   : "ecx" );
}
