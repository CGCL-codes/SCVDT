diff -uprN ORIG/src/bfd/tekhex.c LOCAL/src/bfd/tekhex.c
--- ORIG/src/bfd/tekhex.c	2005-05-24 02:44:55.000000000 +0900
+++ LOCAL/src/bfd/tekhex.c	2006-04-22 11:24:05.000000000 +0900
@@ -333,7 +333,7 @@ insert_byte (bfd *abfd, int value, bfd_v
 /* The first pass is to find the names of all the sections, and see
   how big the data is.  */
 
-static void
+static bfd_boolean
 first_phase (bfd *abfd, int type, char *src)
 {
   asection *section = bfd_abs_section_ptr;
@@ -355,9 +355,12 @@ first_phase (bfd *abfd, int type, char *
 	  }
       }
 
-      return;
+      return TRUE;
     case '3':
       /* Symbol record, read the segment.  */
+      if (!ISHEX (*src))
+	return FALSE;
+
       len = getsym (sym, &src);
       section = bfd_get_section_by_name (abfd, sym);
       if (section == NULL)
@@ -400,6 +403,9 @@ first_phase (bfd *abfd, int type, char *
 		abfd->flags |= HAS_SYMS;
 		new->prev = abfd->tdata.tekhex_data->symbols;
 		abfd->tdata.tekhex_data->symbols = new;
+		if (!ISHEX (*src))
+		  return FALSE;
+
 		len = getsym (sym, &src);
 		new->symbol.name = bfd_alloc (abfd, (bfd_size_type) len + 1);
 		if (!new->symbol.name)
@@ -412,16 +418,20 @@ first_phase (bfd *abfd, int type, char *
 		  new->symbol.flags = BSF_LOCAL;
 		new->symbol.value = getvalue (&src) - section->vma;
 	      }
+	    default:
+	      return FALSE;
 	    }
 	}
     }
+
+  return TRUE;
 }
 
 /* Pass over a tekhex, calling one of the above functions on each
    record.  */
 
-static void
-pass_over (bfd *abfd, void (*func) (bfd *, int, char *))
+static bfd_boolean
+pass_over (bfd *abfd, bfd_boolean (*func) (bfd *, int, char *))
 {
   unsigned int chars_on_line;
   bfd_boolean eof = FALSE;
@@ -462,8 +472,11 @@ pass_over (bfd *abfd, void (*func) (bfd 
       /* Put a null at the end.  */
       src[chars_on_line] = 0;
 
-      func (abfd, type, src);
+      if (!func (abfd, type, src))
+	return FALSE;
     }
+
+  return TRUE;
 }
 
 static long
@@ -524,7 +537,9 @@ tekhex_object_p (bfd *abfd)
 
   tekhex_mkobject (abfd);
 
-  pass_over (abfd, first_phase);
+  if (!pass_over (abfd, first_phase))
+    return NULL;
+
   return abfd->xvec;
 }
 
