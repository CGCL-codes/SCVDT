Index: channels/chan_sip.c
===================================================================
--- channels/chan_sip.c	(revision 369459)
+++ channels/chan_sip.c	(working copy)
@@ -3989,6 +3989,7 @@
 			if (!resp && (seqno == p->pendinginvite)) {
 				ast_debug(1, "Acked pending invite %u\n", p->pendinginvite);
 				p->pendinginvite = 0;
+				p->ongoing_reinvite = 0;
 			}
 			if (cur->retransid > -1) {
 				if (sipdebug)
@@ -6350,7 +6351,7 @@
 				stop_session_timer(p);
 			}
 
-			if (!p->pendinginvite || p->ongoing_reinvite) {
+			if (!p->pendinginvite) {
 				struct ast_channel *bridge = ast_bridged_channel(oldowner);
 				char quality_buf[AST_MAX_USER_FIELD], *quality;
 
@@ -6414,6 +6415,9 @@
 				AST_SCHED_DEL_UNREF(sched, p->waitid, dialog_unref(p, "when you delete the waitid sched, you should dec the refcount for the stored dialog ptr"));
 				if (sip_cancel_destroy(p))
 					ast_log(LOG_WARNING, "Unable to cancel SIP destruction.  Expect bad things.\n");
+				/* Ongoing re-INVITE packets will cancel the following destroy */
+				if (p->ongoing_reinvite)
+					sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
 			}
 		}
 	}
@@ -19838,28 +19842,32 @@
 static void check_pendings(struct sip_pvt *p)
 {
 	if (ast_test_flag(&p->flags[0], SIP_PENDINGBYE)) {
-		/* if we can't BYE, then this is really a pending CANCEL */
-		if (p->invitestate == INV_PROCEEDING || p->invitestate == INV_EARLY_MEDIA) {
-			p->invitestate = INV_CANCELLED;
-			transmit_request(p, SIP_CANCEL, p->lastinvite, XMIT_RELIABLE, FALSE);
-			/* If the cancel occurred on an initial invite, cancel the pending BYE */
-			if (!ast_test_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED)) {
+		/* A sent re-INVITE cannot be cancelled reliably, so we just need
+		 * to schedule a backstop destroy in case we can never send a BYE */
+                if (!p->ongoing_reinvite) {
+			if (p->invitestate == INV_PROCEEDING || p->invitestate == INV_EARLY_MEDIA) {
+				/* if we can't BYE, then this is really a pending CANCEL */
+				p->invitestate = INV_CANCELLED;
+				transmit_request(p, SIP_CANCEL, p->lastinvite, XMIT_RELIABLE, FALSE);
+				/* If the cancel occurred on an initial invite, cancel the pending BYE */
+				if (!ast_test_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED)) {
+					ast_clear_flag(&p->flags[0], SIP_PENDINGBYE);
+				}
+				/* Actually don't destroy us yet, wait for the 487 on our original
+				   INVITE, but do set an autodestruct just in case we never get it. */
+			} else {
+				/* We have a pending outbound invite, don't send something
+					new in-transaction */
+				if (p->pendinginvite)
+					return;
+
+				if (p->owner) {
+					ast_softhangup_nolock(p->owner, AST_SOFTHANGUP_DEV);
+				}
+				/* Perhaps there is an SD change INVITE outstanding */
+				transmit_request_with_auth(p, SIP_BYE, 0, XMIT_RELIABLE, TRUE);
 				ast_clear_flag(&p->flags[0], SIP_PENDINGBYE);
 			}
-			/* Actually don't destroy us yet, wait for the 487 on our original
-			   INVITE, but do set an autodestruct just in case we never get it. */
-		} else {
-			/* We have a pending outbound invite, don't send something
-				new in-transaction */
-			if (p->pendinginvite)
-				return;
-
-			if (p->owner) {
-				ast_softhangup_nolock(p->owner, AST_SOFTHANGUP_DEV);
-			}
-			/* Perhaps there is an SD change INVITE outstanding */
-			transmit_request_with_auth(p, SIP_BYE, 0, XMIT_RELIABLE, TRUE);
-			ast_clear_flag(&p->flags[0], SIP_PENDINGBYE);
 		}
 		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
 	} else if (ast_test_flag(&p->flags[0], SIP_NEEDREINVITE)) {
@@ -20094,9 +20102,7 @@
 	/* Final response, clear out pending invite */
 	if ((resp == 200 || resp >= 300) && p->pendinginvite && seqno == p->pendinginvite) {
 		p->pendinginvite = 0;
-		if (reinvite) {
-			p->ongoing_reinvite = 0;
-		}
+		p->ongoing_reinvite = 0;
 	}
 
 	/* If this is a response to our initial INVITE, we need to set what we can use