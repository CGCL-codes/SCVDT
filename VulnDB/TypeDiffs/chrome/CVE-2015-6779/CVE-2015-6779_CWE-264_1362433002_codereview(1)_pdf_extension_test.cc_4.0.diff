Index: chrome/browser/pdf/pdf_extension_test.cc
diff --git a/chrome/browser/pdf/pdf_extension_test.cc b/chrome/browser/pdf/pdf_extension_test.cc
index 84101ebcc3129518ff692138bce54330d9b9d375..1aebcdec0c5ed501767ab4e207bf383b23168f26 100644
--- a/chrome/browser/pdf/pdf_extension_test.cc
+++ b/chrome/browser/pdf/pdf_extension_test.cc
@@ -32,6 +32,7 @@
 #include "content/public/browser/notification_observer.h"
 #include "content/public/browser/notification_registrar.h"
 #include "content/public/browser/plugin_service.h"
+#include "content/public/browser/render_process_host.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/test/browser_test_utils.h"
 #include "extensions/browser/extension_registry.h"
@@ -100,14 +101,7 @@ class PDFExtensionTest : public ExtensionApiTest,
     // being seen due to the BrowserPluginGuest not being available yet (see
     // crbug.com/498077). So instead use |LoadPdf| which ensures that the PDF is
     // loaded before continuing.
-    ASSERT_TRUE(LoadPdf(url));
-
-    content::WebContents* contents =
-        browser()->tab_strip_model()->GetActiveWebContents();
-    content::BrowserPluginGuestManager* guest_manager =
-        contents->GetBrowserContext()->GetGuestManager();
-    content::WebContents* guest_contents =
-        guest_manager->GetFullPageGuest(contents);
+    content::WebContents* guest_contents = LoadPdfGetGuestContents(url);
     ASSERT_TRUE(guest_contents);
 
     base::FilePath test_data_dir;
@@ -140,6 +134,21 @@ class PDFExtensionTest : public ExtensionApiTest,
     return pdf_extension_test_util::EnsurePDFHasLoaded(web_contents);
   }
 
+  // Same as |LoadPdf|, but also returns a pointer to the guest WebContents for
+  // the loaded PDF. Returns nullptr if the load fails.
+  content::WebContents* LoadPdfGetGuestContents(const GURL& url) {
+    if (!LoadPdf(url))
+      return nullptr;
+
+    content::WebContents* contents =
+        browser()->tab_strip_model()->GetActiveWebContents();
+    content::BrowserPluginGuestManager* guest_manager =
+        contents->GetBrowserContext()->GetGuestManager();
+    content::WebContents* guest_contents =
+        guest_manager->GetFullPageGuest(contents);
+    return guest_contents;
+  }
+
   // Load all the PDFs contained in chrome/test/data/<dir_name>. This only runs
   // the test if base::Hash(filename) mod kNumberLoadTestParts == k in order
   // to shard the files evenly across values of k in [0, kNumberLoadTestParts).
@@ -382,6 +391,27 @@ IN_PROC_BROWSER_TEST_F(PDFExtensionTest, EnsureSameOriginRepliesAllowed) {
                            true);
 }
 
+// This test ensures that link permissions are enforced properly in PDFs.
+IN_PROC_BROWSER_TEST_F(PDFExtensionTest, LinkPermissions) {
+  GURL test_pdf_url(embedded_test_server()->GetURL("/pdf/test.pdf"));
+  content::WebContents* guest_contents = LoadPdfGetGuestContents(test_pdf_url);
+  ASSERT_TRUE(guest_contents);
+
+  // chrome://favicon links should be allowed for PDFs, while chrome://settings
+  // links should not.
+  GURL valid_link_url("chrome://favicon/https://www.google.ca/");
+  GURL invalid_link_url("chrome://settings");
+
+  GURL unfiltered_valid_link_url(valid_link_url);
+  content::RenderProcessHost* rph = guest_contents->GetRenderProcessHost();
+  rph->FilterURL(true, &valid_link_url);
+  rph->FilterURL(true, &invalid_link_url);
+
+  // Invalid link URLs should be changed to "about:blank" when filtered.
+  EXPECT_EQ(unfiltered_valid_link_url, valid_link_url);
+  EXPECT_EQ(GURL("about:blank"), invalid_link_url);
+}
+
 class MaterialPDFExtensionTest : public PDFExtensionTest {
   void SetUpCommandLine(base::CommandLine* command_line) override {
     command_line->AppendSwitch(switches::kEnablePdfMaterialUI);
