Index: Source/platform/ThreadTimers.cpp
diff --git a/Source/platform/ThreadTimers.cpp b/Source/platform/ThreadTimers.cpp
index 0cc2ac15b644033a6f2d56c7ae000c1778b37fa6..613e5bbe1a4b4c6e99434dbf6f169a0b11b5773b 100644
--- a/Source/platform/ThreadTimers.cpp
+++ b/Source/platform/ThreadTimers.cpp
@@ -30,6 +30,7 @@
 #include "platform/PlatformThreadData.h"
 #include "platform/SharedTimer.h"
 #include "platform/Timer.h"
+#include "platform/TimerHeap.h"
 #include "platform/TraceEvent.h"
 #include "platform/scheduler/Scheduler.h"
 #include "wtf/CurrentTime.h"
@@ -52,7 +53,8 @@ static MainThreadSharedTimer* mainThreadSharedTimer()
 }
 
 ThreadTimers::ThreadTimers()
-    : m_sharedTimer(0)
+    : m_timerHeap(this)
+    , m_sharedTimer(0)
     , m_firingTimers(false)
     , m_pendingSharedTimerFireTime(0)
 {
@@ -78,6 +80,11 @@ void ThreadTimers::setSharedTimer(SharedTimer* sharedTimer)
     }
 }
 
+void ThreadTimers::nextFiringTimerChanged()
+{
+    updateSharedTimer();
+}
+
 void ThreadTimers::updateSharedTimer()
 {
     if (!m_sharedTimer)
@@ -87,7 +94,7 @@ void ThreadTimers::updateSharedTimer()
         m_pendingSharedTimerFireTime = 0;
         m_sharedTimer->stop();
     } else {
-        double nextFireTime = m_timerHeap.first()->m_nextFireTime;
+        double nextFireTime = m_timerHeap.first()->nextFireTime();
         double currentMonotonicTime = monotonicallyIncreasingTime();
         if (m_pendingSharedTimerFireTime) {
             // No need to restart the timer if both the pending fire time and the new fire time are in the past.
@@ -120,12 +127,8 @@ void ThreadTimers::sharedTimerFiredInternal()
     double fireTime = monotonicallyIncreasingTime();
     double timeToQuit = fireTime + maxDurationOfFiringTimers;
 
-    while (!m_timerHeap.isEmpty() && m_timerHeap.first()->m_nextFireTime <= fireTime) {
+    while (!m_timerHeap.isEmpty() && m_timerHeap.first()->nextFireTime() <= fireTime) {
         TimerBase& timer = *m_timerHeap.first();
-        timer.m_nextFireTime = 0;
-        timer.m_unalignedNextFireTime = 0;
-        timer.heapDeleteMin();
-
         double interval = timer.repeatInterval();
         timer.setNextFireTime(interval ? fireTime + interval : 0);
 
@@ -154,4 +157,3 @@ void ThreadTimers::fireTimersInNestedEventLoop()
 }
 
 } // namespace blink
-
