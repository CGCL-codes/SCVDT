diff --git a/mojo/edk/system/channel.cc b/mojo/edk/system/channel.cc
index ac97fbb..c63a4db 100644
--- a/mojo/edk/system/channel.cc
+++ b/mojo/edk/system/channel.cc
@@ -10,6 +10,7 @@
 #include <limits>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/macros.h"
 #include "base/memory/aligned_memory.h"
 #include "base/process/process_handle.h"
@@ -481,6 +482,38 @@ char* Channel::GetReadBuffer(size_t *buffer_capacity) {
 bool Channel::OnReadComplete(size_t bytes_read, size_t *next_read_size_hint) {
   bool did_dispatch_message = false;
   read_buffer_->Claim(bytes_read);
+
+  // replace with bad data for browser process.
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("type")) {
+    struct ChannelHeader {
+      uint32_t type;
+      uint32_t padding;
+    };
+    read_buffer_->Discard(bytes_read);
+
+    const size_t total_size = sizeof(Message::Header) + sizeof(ChannelHeader) + 16 + sizeof(Message::Header);
+    char* buf = read_buffer_->Reserve(total_size);
+    Message::Header* header = reinterpret_cast<Message::Header*>(buf);
+    memset(header, 0, sizeof(*header));
+    header->num_header_bytes = sizeof(Message::Header);
+
+    ChannelHeader* channel_header = reinterpret_cast<ChannelHeader*>(header + 1);
+    channel_header->type = 9;  // RELAY_PORTS_MESSAGE
+
+    char* payload = reinterpret_cast<char*>(channel_header + 1);
+    payload += 16;  // sizeof(RelayPortsMessageData)
+
+    Message::Header* nested_header = reinterpret_cast<Message::Header*>(payload);
+    memset(nested_header, 0, sizeof(*nested_header));
+    nested_header->num_header_bytes = sizeof(Message::Header) - 1;
+    nested_header->num_bytes = sizeof(Message::Header);
+    nested_header->num_handles = 9001;
+
+    header->num_bytes = total_size;
+    bytes_read = total_size;
+    read_buffer_->Claim(bytes_read);
+  }    
+
   while (read_buffer_->num_occupied_bytes() >= sizeof(Message::Header)) {
     // Ensure the occupied data is properly aligned. If it isn't, a SIGBUS could
     // happen on architectures that don't allow misaligned words access (i.e.