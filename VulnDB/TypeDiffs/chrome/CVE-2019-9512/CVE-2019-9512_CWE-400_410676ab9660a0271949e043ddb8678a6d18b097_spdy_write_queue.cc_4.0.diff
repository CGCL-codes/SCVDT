diff --git a/net/spdy/spdy_write_queue.cc b/net/spdy/spdy_write_queue.cc
index d1948c46bb02..e7272b7d557e 100644
--- a/net/spdy/spdy_write_queue.cc
+++ b/net/spdy/spdy_write_queue.cc
@@ -10,6 +10,7 @@
 
 #include "base/containers/circular_deque.h"
 #include "base/logging.h"
+#include "base/metrics/histogram_macros.h"
 #include "base/trace_event/memory_usage_estimator.h"
 #include "net/spdy/spdy_buffer.h"
 #include "net/spdy/spdy_buffer_producer.h"
@@ -17,6 +18,14 @@
 
 namespace net {
 
+bool IsSpdyFrameTypeWriteCapped(spdy::SpdyFrameType frame_type) {
+  return frame_type == spdy::SpdyFrameType::RST_STREAM ||
+         frame_type == spdy::SpdyFrameType::SETTINGS ||
+         frame_type == spdy::SpdyFrameType::WINDOW_UPDATE ||
+         frame_type == spdy::SpdyFrameType::PING ||
+         frame_type == spdy::SpdyFrameType::GOAWAY;
+}
+
 SpdyWriteQueue::PendingWrite::PendingWrite() = default;
 
 SpdyWriteQueue::PendingWrite::PendingWrite(
@@ -43,6 +52,10 @@ size_t SpdyWriteQueue::PendingWrite::EstimateMemoryUsage() const {
 SpdyWriteQueue::SpdyWriteQueue() : removing_writes_(false) {}
 
 SpdyWriteQueue::~SpdyWriteQueue() {
+  DCHECK_GE(num_queued_capped_frames_, 0);
+  DCHECK_GT(highest_num_queued_capped_frames_, 0);
+  UMA_HISTOGRAM_COUNTS_100000("Net.SpdyHighestQueuedCappedFramesCount",
+                              highest_num_queued_capped_frames_);
   Clear();
 }
 
@@ -68,6 +81,15 @@ void SpdyWriteQueue::Enqueue(
   queue_[priority].push_back(
       {frame_type, std::move(frame_producer), stream,
        MutableNetworkTrafficAnnotationTag(traffic_annotation)});
+  if (IsSpdyFrameTypeWriteCapped(frame_type)) {
+    DCHECK_GE(num_queued_capped_frames_, 0);
+    num_queued_capped_frames_++;
+    if (num_queued_capped_frames_ > highest_num_queued_capped_frames_) {
+      DCHECK_EQ(num_queued_capped_frames_,
+                highest_num_queued_capped_frames_ + 1);
+      highest_num_queued_capped_frames_ = num_queued_capped_frames_;
+    }
+  }
 }
 
 bool SpdyWriteQueue::Dequeue(
@@ -86,6 +108,10 @@ bool SpdyWriteQueue::Dequeue(
       *traffic_annotation = pending_write.traffic_annotation;
       if (pending_write.has_stream)
         DCHECK(stream->get());
+      if (IsSpdyFrameTypeWriteCapped(*frame_type)) {
+        num_queued_capped_frames_--;
+        DCHECK_GE(num_queued_capped_frames_, 0);
+      }
       return true;
     }
   }
@@ -116,6 +142,10 @@ void SpdyWriteQueue::RemovePendingWritesForStream(SpdyStream* stream) {
   base::circular_deque<PendingWrite>& queue = queue_[priority];
   for (auto it = queue.begin(); it != queue.end();) {
     if (it->stream.get() == stream) {
+      if (IsSpdyFrameTypeWriteCapped(it->frame_type)) {
+        num_queued_capped_frames_--;
+        DCHECK_GE(num_queued_capped_frames_, 0);
+      }
       erased_buffer_producers.push_back(std::move(it->frame_producer));
       it = queue.erase(it);
     } else {
@@ -141,6 +171,10 @@ void SpdyWriteQueue::RemovePendingWritesForStreamsAfter(
     for (auto it = queue.begin(); it != queue.end();) {
       if (it->stream.get() && (it->stream->stream_id() > last_good_stream_id ||
                                it->stream->stream_id() == 0)) {
+        if (IsSpdyFrameTypeWriteCapped(it->frame_type)) {
+          num_queued_capped_frames_--;
+          DCHECK_GE(num_queued_capped_frames_, 0);
+        }
         erased_buffer_producers.push_back(std::move(it->frame_producer));
         it = queue.erase(it);
       } else {
@@ -196,6 +230,7 @@ void SpdyWriteQueue::Clear() {
     queue_[i].clear();
   }
   removing_writes_ = false;
+  num_queued_capped_frames_ = 0;
 }
 
 size_t SpdyWriteQueue::EstimateMemoryUsage() const {
