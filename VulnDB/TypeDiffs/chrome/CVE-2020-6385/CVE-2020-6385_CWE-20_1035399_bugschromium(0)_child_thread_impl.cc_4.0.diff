diff --git a/content/child/child_thread_impl.cc b/content/child/child_thread_impl.cc
index 3a3e67fec077..83829e2aead1 100644
--- a/content/child/child_thread_impl.cc
+++ b/content/child/child_thread_impl.cc
@@ -151,37 +151,37 @@ class SuicideOnChannelErrorFilter : public IPC::MessageFilter {
  public:
   // IPC::MessageFilter
   void OnChannelError() override {
-    // For renderer/worker processes:
-    // On POSIX, at least, one can install an unload handler which loops
-    // forever and leave behind a renderer process which eats 100% CPU forever.
-    //
-    // This is because the terminate signals (FrameMsg_BeforeUnload and the
-    // error from the IPC sender) are routed to the main message loop but never
-    // processed (because that message loop is stuck in V8).
-    //
-    // One could make the browser SIGKILL the renderers, but that leaves open a
-    // large window where a browser failure (or a user, manually terminating
-    // the browser because "it's stuck") will leave behind a process eating all
-    // the CPU.
-    //
-    // So, we install a filter on the sender so that we can process this event
-    // here and kill the process.
-    base::debug::StopProfiling();
-#if defined(ADDRESS_SANITIZER) || defined(LEAK_SANITIZER) || \
-    defined(MEMORY_SANITIZER) || defined(THREAD_SANITIZER) || \
-    defined(UNDEFINED_SANITIZER)
-    // Some sanitizer tools rely on exit handlers (e.g. to run leak detection,
-    // or dump code coverage data to disk). Instead of exiting the process
-    // immediately, we give it 60 seconds to run exit handlers.
-    CHECK(CreateWaitAndExitThread(base::TimeDelta::FromSeconds(60)));
-#if defined(LEAK_SANITIZER)
-    // Invoke LeakSanitizer early to avoid detecting shutdown-only leaks. If
-    // leaks are found, the process will exit here.
-    __lsan_do_leak_check();
-#endif
-#else
-    base::Process::TerminateCurrentProcessImmediately(0);
-#endif
+//     // For renderer/worker processes:
+//     // On POSIX, at least, one can install an unload handler which loops
+//     // forever and leave behind a renderer process which eats 100% CPU forever.
+//     //
+//     // This is because the terminate signals (FrameMsg_BeforeUnload and the
+//     // error from the IPC sender) are routed to the main message loop but never
+//     // processed (because that message loop is stuck in V8).
+//     //
+//     // One could make the browser SIGKILL the renderers, but that leaves open a
+//     // large window where a browser failure (or a user, manually terminating
+//     // the browser because "it's stuck") will leave behind a process eating all
+//     // the CPU.
+//     //
+//     // So, we install a filter on the sender so that we can process this event
+//     // here and kill the process.
+//     base::debug::StopProfiling();
+// #if defined(ADDRESS_SANITIZER) || defined(LEAK_SANITIZER) || \
+//     defined(MEMORY_SANITIZER) || defined(THREAD_SANITIZER) || \
+//     defined(UNDEFINED_SANITIZER)
+//     // Some sanitizer tools rely on exit handlers (e.g. to run leak detection,
+//     // or dump code coverage data to disk). Instead of exiting the process
+//     // immediately, we give it 60 seconds to run exit handlers.
+//     CHECK(CreateWaitAndExitThread(base::TimeDelta::FromSeconds(60)));
+// #if defined(LEAK_SANITIZER)
+//     // Invoke LeakSanitizer early to avoid detecting shutdown-only leaks. If
+//     // leaks are found, the process will exit here.
+//     __lsan_do_leak_check();
+// #endif
+// #else
+//     base::Process::TerminateCurrentProcessImmediately(0);
+// #endif
   }
 
  protected:
@@ -699,8 +699,8 @@ void ChildThreadImpl::OnChannelError() {
   on_channel_error_called_ = true;
   // If this thread runs in the browser process, only Thread::Stop should
   // stop its message loop. Otherwise, QuitWhenIdle could race Thread::Stop.
-  if (!IsInBrowserProcess())
-    quit_closure_.Run();
+  // if (!IsInBrowserProcess())
+  //   quit_closure_.Run();
 }
 
 bool ChildThreadImpl::Send(IPC::Message* msg) {
