Index: /branches/chromium/742/Source/WebCore/platform/graphics/filters/FilterEffect.cpp

===================================================================

--- /branches/chromium/742/Source/WebCore/platform/graphics/filters/FilterEffect.cpp	(revision 85995)

+++ /branches/chromium/742/Source/WebCore/platform/graphics/filters/FilterEffect.cpp	(revision 85996)

@@ -47,4 +47,12 @@

 }

 

+inline bool isFilterSizeValid(IntRect rect)

+{

+    if (rect.width() < 0 || rect.width() > kMaxFilterSize

+        || rect.height() < 0 || rect.height() > kMaxFilterSize)

+        return false;

+    return true;

+}

+

 void FilterEffect::determineAbsolutePaintRect()

 {

@@ -55,5 +63,5 @@

     

     // SVG specification wants us to clip to primitive subregion.

-    m_absolutePaintRect.intersect(m_maxEffectRect);

+    m_absolutePaintRect.intersect(enclosingIntRect(m_maxEffectRect));

 }

 

@@ -105,4 +113,5 @@

 PassRefPtr<ByteArray> FilterEffect::asUnmultipliedImage(const IntRect& rect)

 {

+    ASSERT(isFilterSizeValid(rect));

     RefPtr<ByteArray> imageData = ByteArray::create(rect.width() * rect.height() * 4);

     copyUnmultipliedImage(imageData.get(), rect);

@@ -112,4 +121,5 @@

 PassRefPtr<ByteArray> FilterEffect::asPremultipliedImage(const IntRect& rect)

 {

+    ASSERT(isFilterSizeValid(rect));

     RefPtr<ByteArray> imageData = ByteArray::create(rect.width() * rect.height() * 4);

     copyPremultipliedImage(imageData.get(), rect);

@@ -170,4 +180,5 @@

             m_unmultipliedImageResult = m_imageBufferResult->getUnmultipliedImageData(IntRect(IntPoint(), m_absolutePaintRect.size()));

         else {

+            ASSERT(isFilterSizeValid(m_absolutePaintRect));

             m_unmultipliedImageResult = ByteArray::create(m_absolutePaintRect.width() * m_absolutePaintRect.height() * 4);

             unsigned char* sourceComponent = m_premultipliedImageResult->data();

@@ -203,4 +214,5 @@

             m_premultipliedImageResult = m_imageBufferResult->getPremultipliedImageData(IntRect(IntPoint(), m_absolutePaintRect.size()));

         else {

+            ASSERT(isFilterSizeValid(m_absolutePaintRect));

             m_premultipliedImageResult = ByteArray::create(m_absolutePaintRect.width() * m_absolutePaintRect.height() * 4);

             unsigned char* sourceComponent = m_unmultipliedImageResult->data();

@@ -239,4 +251,6 @@

     // Only one result type is allowed.

     ASSERT(!hasResult());

+    ASSERT(isFilterSizeValid(m_absolutePaintRect));

+

     determineAbsolutePaintRect();

     if (m_absolutePaintRect.isEmpty())

@@ -250,4 +264,6 @@

     // Only one result type is allowed.

     ASSERT(!hasResult());

+    ASSERT(isFilterSizeValid(m_absolutePaintRect));

+

     determineAbsolutePaintRect();

     if (m_absolutePaintRect.isEmpty())

