--- branches/release_154.next/src/net/http/http_transaction_winhttp.cc	2009/03/13 20:51:58	11668
+++ branches/release_154.next/src/net/http/http_transaction_winhttp.cc	2009/03/13 21:09:08	11669
@@ -987,6 +987,8 @@
     // network attacker can already control HTTP sessions.
     // We reach this case when the user cancels a 407 proxy auth prompt.
     // See http://crbug.com/8473
+    DCHECK(response_.headers->response_code() == 407);
+    LogBlockedTunnelResponse(response_.headers->response_code());
     return ERR_TUNNEL_CONNECTION_FAILED;
   }
 
@@ -1472,6 +1474,13 @@
   UMA_HISTOGRAM_LONG_TIMES(L"Net.Transaction_Latency_WinHTTP", duration);
 }
 
+void HttpTransactionWinHttp::LogBlockedTunnelResponse(
+    int response_code) const {
+  LOG(WARNING) << "Blocked proxy response with status " << response_code
+               << " to CONNECT request for " << request_->url.host() << ":"
+               << request_->url.EffectiveIntPort() << ".";
+}
+
 int HttpTransactionWinHttp::DidReceiveHeaders() {
   session_callback_->set_load_state(LOAD_STATE_IDLE);
 
@@ -1480,10 +1489,10 @@
   if (!WinHttpQueryHeaders(request_handle_,
                            WINHTTP_QUERY_STATUS_CODE |
                            WINHTTP_QUERY_FLAG_NUMBER,
-                           NULL,
+                           WINHTTP_HEADER_NAME_BY_INDEX,
                            &response_code,
                            &size,
-                           NULL)) {
+                           WINHTTP_NO_HEADER_INDEX)) {
     DLOG(ERROR) << "WinHttpQueryHeaders failed: " << GetLastError();
     return TranslateLastOSError();
   }
@@ -1498,11 +1507,7 @@
     // the proxy server would like us to authenticate before tunneling to the
     // remote server.  In that case, |PopulateAuthChallenge()| is responsible
     // for bailing out.
-    LOG(WARNING) << "Blocked proxy response with status "
-                 << response_code
-                 << " to CONNECT request for "
-                 << request_->url.host() << ":"
-                 << request_->url.EffectiveIntPort() << ".";
+    LogBlockedTunnelResponse(response_code);
     return ERR_TUNNEL_CONNECTION_FAILED;
   }
 
@@ -1592,10 +1597,11 @@
   std::string header_name = auth_info->is_proxy ?
       "Proxy-Authenticate" : "WWW-Authenticate";
   if (!response_.headers->EnumerateHeader(NULL, header_name, &header_value)) {
-    if (is_https_ && !response_.ssl_info.cert && auth_info->is_proxy) {
+    if (is_https_ && !response_.ssl_info.cert) {
       // We are establishing a tunnel, we can't show the error page because an
       // active network attacker could control its contents.  Instead, we just
       // fail to establish the tunnel.
+      DCHECK(auth_info->is_proxy);
       return ERR_PROXY_AUTH_REQUESTED;
     }
     return OK;
