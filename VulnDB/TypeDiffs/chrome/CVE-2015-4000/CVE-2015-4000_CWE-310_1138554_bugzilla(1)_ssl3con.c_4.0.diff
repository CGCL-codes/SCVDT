diff --git a/lib/ssl/ssl3con.c b/lib/ssl/ssl3con.c
--- a/lib/ssl/ssl3con.c
+++ b/lib/ssl/ssl3con.c
@@ -6654,16 +6654,21 @@ ssl3_HandleServerKeyExchange(sslSocket *
     case kt_rsa: {
 	SECItem          modulus   = {siBuffer, NULL, 0};
 	SECItem          exponent  = {siBuffer, NULL, 0};
 
     	rv = ssl3_ConsumeHandshakeVariable(ss, &modulus, 2, &b, &length);
     	if (rv != SECSuccess) {
 	    goto loser;		/* malformed. */
 	}
+        if (SECKEY_ModulusLengthBits(&modulus) < SECKEY_MIN_MODP_PRIME_BITS) {
+            errCode = SSL_ERROR_WEAK_SERVER_RSA_KEY;
+            desc = insufficient_security;
+            goto alert_loser;
+        }
     	rv = ssl3_ConsumeHandshakeVariable(ss, &exponent, 2, &b, &length);
     	if (rv != SECSuccess) {
 	    goto loser;		/* malformed. */
 	}
 	if (isTLS12) {
 	    rv = ssl3_ConsumeSignatureAndHashAlgorithm(ss, &b, &length,
 						       &sigAndHash);
 	    if (rv != SECSuccess) {
@@ -6744,17 +6749,18 @@ ssl3_HandleServerKeyExchange(sslSocket *
 	SECItem          dh_p      = {siBuffer, NULL, 0};
 	SECItem          dh_g      = {siBuffer, NULL, 0};
 	SECItem          dh_Ys     = {siBuffer, NULL, 0};
 
     	rv = ssl3_ConsumeHandshakeVariable(ss, &dh_p, 2, &b, &length);
     	if (rv != SECSuccess) {
 	    goto loser;		/* malformed. */
 	}
-	if (dh_p.len < 512/8) {
+        /* Allow a little less than 1024 */
+	if (SECKEY_ModulusLengthBits(&dh_p) < SECKEY_MIN_MODP_PRIME_BITS) {
 	    errCode = SSL_ERROR_WEAK_SERVER_EPHEMERAL_DH_KEY;
 	    goto alert_loser;
 	}
     	rv = ssl3_ConsumeHandshakeVariable(ss, &dh_g, 2, &b, &length);
     	if (rv != SECSuccess) {
 	    goto loser;		/* malformed. */
 	}
 	if (dh_g.len > dh_p.len || !ssl3_BigIntGreaterThanOne(&dh_g))
@@ -10046,16 +10052,23 @@ ssl3_AuthCertificate(sslSocket *ss)
 	** it will get fixed when we handle the server key exchange message.
 	*/
 	SECKEYPublicKey * pubKey  = CERT_ExtractPublicKey(cert);
 	ss->sec.authAlgorithm = ss->ssl3.hs.kea_def->signKeyType;
 	ss->sec.keaType       = ss->ssl3.hs.kea_def->exchKeyType;
 	if (pubKey) {
 	    ss->sec.keaKeyBits = ss->sec.authKeyBits =
 		SECKEY_PublicKeyStrengthInBits(pubKey);
+            /* Too small: not good enough. Send a fatal alert. */
+            if (ss->sec.keaKeyBits < SECKEY_MIN_MODP_PRIME_BITS) {
+                PORT_SetError(SSL_ERROR_WEAK_SERVER_RSA_KEY);
+                (void)SSL3_SendAlert(ss, alert_fatal, insufficient_security);
+                SECKEY_DestroyPublicKey(pubKey); 
+                return SECFailure;
+            }
 #ifndef NSS_DISABLE_ECC
 	    if (ss->sec.keaType == kt_ecdh) {
 		/* Get authKeyBits from signing key.
 		 * XXX The code below uses a quick approximation of
 		 * key size based on cert->signatureWrap.signature.data
 		 * (which contains the DER encoded signature). The field
 		 * cert->signatureWrap.signature.len contains the
 		 * length of the encoded signature in bits.
