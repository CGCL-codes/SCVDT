diff --git a/lib/ssl/ssl3con.c b/lib/ssl/ssl3con.c
--- a/lib/ssl/ssl3con.c
+++ b/lib/ssl/ssl3con.c
@@ -10054,41 +10054,29 @@ ssl3_AuthCertificate(sslSocket *ss)
                 (void)SSL3_SendAlert(ss, alert_fatal,
                                      ss->version >= SSL_LIBRARY_VERSION_TLS_1_0
                                      ? insufficient_security
                                      : illegal_parameter);
                 SECKEY_DestroyPublicKey(pubKey);
                 return SECFailure;
             }
 #ifndef NSS_DISABLE_ECC
-	    if (ss->sec.keaType == kt_ecdh) {
-		/* Get authKeyBits from signing key.
-		 * XXX The code below uses a quick approximation of
-		 * key size based on cert->signatureWrap.signature.data
-		 * (which contains the DER encoded signature). The field
-		 * cert->signatureWrap.signature.len contains the
-		 * length of the encoded signature in bits.
-		 */
-		if (ss->ssl3.hs.kea_def->kea == kea_ecdh_ecdsa) {
-		    ss->sec.authKeyBits = 
-			cert->signatureWrap.signature.data[3]*8;
-		    if (cert->signatureWrap.signature.data[4] == 0x00)
-			    ss->sec.authKeyBits -= 8;
-		    /* 
-		     * XXX: if cert is not signed by ecdsa we should
-		     * destroy pubKey and goto bad_cert
-		     */
-		} else if (ss->ssl3.hs.kea_def->kea == kea_ecdh_rsa) {
-		    ss->sec.authKeyBits = cert->signatureWrap.signature.len;
-		    /* 
-		     * XXX: if cert is not signed by rsa we should
-		     * destroy pubKey and goto bad_cert
-		     */
-		}
-	    }
+            /* Static ECDH suites carry parameters in the certificate and
+             * are therefore authenticated by the strength of their issuer. */
+            if (ss->sec.keaType == kt_ecdh && !cert->isRoot &&
+                (ss->ssl3.hs.kea_def->kea == kea_ecdh_ecdsa ||
+                 ss->ssl3.hs.kea_def->kea == kea_ecdh_rsa)) {
+                CERTCertificate *issuerCert =
+                    CERT_FindCertIssuer(cert, PR_Now(), certUsageAnyCA);
+                SECKEYPublicKey *issuerPublicKey = CERT_ExtractPublicKey(cert);
+                ss->sec.authKeyBits =
+                    SECKEY_PublicKeyStrengthInBits(issuerPublicKey);
+                SECKEY_DestroyPublicKey(issuerPublicKey);
+                CERT_DestroyCertificate(issuerCert);
+            }
 #endif /* NSS_DISABLE_ECC */
 	    SECKEY_DestroyPublicKey(pubKey); 
 	    pubKey = NULL;
     	}
 
 	ss->ssl3.hs.ws = wait_cert_request; /* disallow server_key_exchange */
 	if (ss->ssl3.hs.kea_def->is_limited ||
 	    /* XXX OR server cert is signing only. */
