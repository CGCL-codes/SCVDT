Index: Source/platform/heap/Heap.cpp
diff --git a/Source/platform/heap/Heap.cpp b/Source/platform/heap/Heap.cpp
index 67394e8c468cd16e49e105e5db9f3a389555d42d..dfe3e0e773fac5a0817483677da6f0fd45d8706c 100644
--- a/Source/platform/heap/Heap.cpp
+++ b/Source/platform/heap/Heap.cpp
@@ -1946,7 +1946,8 @@ void Heap::flushHeapDoesNotContainCache()
 
 enum MarkingMode {
     GlobalMarking,
-    ThreadLocalMarking,
+    ThreadLocalMarking, // This works only if the thread is terminating.
+    ZombieMarking,
 };
 
 template <MarkingMode Mode>
@@ -2125,15 +2126,21 @@ protected:
 
     inline bool shouldMarkObject(const void* objectPointer)
     {
-        if (Mode != ThreadLocalMarking)
+        if (Mode == GlobalMarking)
             return true;
 
-        BasePage* page = pageFromObject(objectPointer);
-        ASSERT(!page->orphaned());
-        // When doing a thread local GC, the marker checks if
-        // the object resides in another thread's heap. If it
-        // does, the object should not be marked & traced.
-        return page->terminating();
+        if (Mode == ThreadLocalMarking) {
+            BasePage* page = pageFromObject(objectPointer);
+            ASSERT(!page->orphaned());
+            // When doing a thread local GC, the marker checks if the object
+            // resides in another thread's heap. If it does, the object should
+            // not be marked & traced.
+            return page->terminating();
+        }
+
+        // ZombieMarking case.  Any objects must not be owned by other threads.
+        ASSERT(ThreadState::current()->findPageFromAddress(objectPointer));
+        return true;
     }
 
 #if ENABLE(ASSERT)
@@ -2476,6 +2483,17 @@ void Heap::collectGarbage(ThreadState::StackState stackState, ThreadState::GCTyp
         ScriptForbiddenScope::exit();
 }
 
+void Heap::visitObjects(ThreadState* state, const HashSet<void*>& objects)
+{
+    MarkingVisitor<ZombieMarking> visitor;
+    ThreadState::NoAllocationScope noAllocationScope(state);
+    for (void* address : objects)
+        checkAndMarkPointer(&visitor, reinterpret_cast<Address>(address));
+    processMarkingStack(&visitor);
+    postMarkingProcessing(&visitor);
+    globalWeakProcessing(&visitor);
+}
+
 void Heap::collectGarbageForTerminatingThread(ThreadState* state)
 {
     // We explicitly do not enter a safepoint while doing thread specific
