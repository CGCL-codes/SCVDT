Index: security/nss/lib/softoken/sftkmod.c
===================================================================
RCS file: /cvsroot/mozilla/security/nss/lib/softoken/sftkmod.c,v
retrieving revision 1.8
diff -u -p -r1.8 sftkmod.c
--- security/nss/lib/softoken/sftkmod.c	15 Jan 2011 20:59:11 -0000	1.8
+++ security/nss/lib/softoken/sftkmod.c	30 Sep 2011 22:38:15 -0000
@@ -179,15 +179,18 @@ char *sftk_getOldSecmodName(const char *
     char *sep;
 
     sep = PORT_Strrchr(dirPath,*PATH_SEPARATOR);
-#ifdef WINDOWS
+#ifdef _WIN32
     if (!sep) {
-	sep = PORT_Strrchr(dirPath,'/');
+	/* pkcs11i.h defines PATH_SEPARATOR as "/" for all platforms. */
+	sep = PORT_Strrchr(dirPath,'\\');
     }
 #endif
     if (sep) {
-	*(sep)=0;
+	*sep = 0;
+	file = PR_smprintf("%s"PATH_SEPARATOR"%s", dirPath, filename);
+    } else {
+	file = PR_smprintf("%s", filename);
     }
-    file= PR_smprintf("%s"PATH_SEPARATOR"%s", dirPath, filename);
     PORT_Free(dirPath);
     return file;
 }
@@ -242,13 +245,18 @@ sftkdb_ReadSecmodDB(SDBType dbType, cons
     char *paramsValue=NULL;
     PRBool failed = PR_TRUE;
 
-    if ((dbType == SDB_LEGACY) || (dbType == SDB_MULTIACCESS)) {
+    if ((dbname != NULL) &&
+		((dbType == SDB_LEGACY) || (dbType == SDB_MULTIACCESS))) {
 	return sftkdbCall_ReadSecmodDB(appName, filename, dbname, params, rw);
     }
 
     moduleList = (char **) PORT_ZAlloc(useCount*sizeof(char **));
     if (moduleList == NULL) return NULL;
 
+    if (dbname == NULL) {
+	goto return_default;
+    }
+
     /* do we really want to use streams here */
     fd = fopen(dbname, "r");
     if (fd == NULL) goto done;
@@ -406,6 +414,10 @@ sftkdb_ReadSecmodDB(SDBType dbType, cons
     }
 done:
     /* if we couldn't open a pkcs11 database, look for the old one */
+    /* This is necessary to maintain the semantics of the transition from
+     * old to new DB's. If there is an old DB and not new DB, we will
+     * automatically use the old DB. If the DB was opened read/write, we
+     * create a new db and upgrade it from the old one */
     if (fd == NULL) {
 	char *olddbname = sftk_getOldSecmodName(dbname,filename);
 	PRStatus status;
@@ -462,6 +474,8 @@ bail:
 	    PR_smprintf_free(olddbname);
 	}
     }
+
+return_default:
 	
     if (!moduleList[0]) {
 	char * newParams;
@@ -515,7 +529,8 @@ sftkdb_ReleaseSecmodDBData(SDBType dbTyp
 			const char *filename, const char *dbname, 
 			char **moduleSpecList, PRBool rw)
 {
-    if ((dbType == SDB_LEGACY) || (dbType == SDB_MULTIACCESS)) {
+    if ((dbname != NULL) && 
+		((dbType == SDB_LEGACY) || (dbType == SDB_MULTIACCESS))) {
 	return sftkdbCall_ReleaseSecmodDBData(appName, filename, dbname, 
 					  moduleSpecList, rw);
     }
@@ -546,6 +561,10 @@ sftkdb_DeleteSecmodDB(SDBType dbType, co
     PRBool skip = PR_FALSE;
     PRBool found = PR_FALSE;
 
+    if (dbname == NULL) {
+	return SECFailure;
+    }
+
     if ((dbType == SDB_LEGACY) || (dbType == SDB_MULTIACCESS)) {
 	return sftkdbCall_DeleteSecmodDB(appName, filename, dbname, args, rw);
     }
@@ -669,6 +688,10 @@ sftkdb_AddSecmodDB(SDBType dbType, const
     char *block = NULL;
     PRBool libFound = PR_FALSE;
 
+    if (dbname == NULL) {
+	return SECFailure;
+    }
+
     if ((dbType == SDB_LEGACY) || (dbType == SDB_MULTIACCESS)) {
 	return sftkdbCall_AddSecmodDB(appName, filename, dbname, module, rw);
     }
