Index: Source/WebCore/loader/HistoryController.cpp
===================================================================
--- Source/WebCore/loader/HistoryController.cpp	(revision 77344)
+++ Source/WebCore/loader/HistoryController.cpp	(working copy)
@@ -236,7 +236,7 @@ void HistoryController::goToItem(History
     // Set the BF cursor before commit, which lets the user quickly click back/forward again.
     // - plus, it only makes sense for the top level of the operation through the frametree,
     // as opposed to happening for some/one of the page commits that might happen soon
-    HistoryItem* currentItem = page->backForward()->currentItem();    
+    RefPtr<HistoryItem> currentItem = page->backForward()->currentItem();
     page->backForward()->setCurrentItem(targetItem);
     Settings* settings = m_frame->settings();
     page->setGlobalHistoryItem((!settings || settings->privateBrowsingEnabled()) ? 0 : targetItem);
@@ -402,8 +402,9 @@ void HistoryController::updateForCommit(
         LOG(History, "WebCoreHistory: Updating History for commit in frame %s", frameLoader->documentLoader()->title().utf8().data());
 #endif
     FrameLoadType type = frameLoader->loadType();
-    if (isBackForwardLoadType(type) ||
-        ((type == FrameLoadTypeReload || type == FrameLoadTypeReloadFromOrigin) && !frameLoader->provisionalDocumentLoader()->unreachableURL().isEmpty())) {
+    if (isBackForwardLoadType(type)
+        || type == FrameLoadTypeReplace
+        || ((type == FrameLoadTypeReload || type == FrameLoadTypeReloadFromOrigin) && !frameLoader->provisionalDocumentLoader()->unreachableURL().isEmpty())) {
         // Once committed, we want to use current item for saving DocState, and
         // the provisional item for restoring state.
         // Note previousItem must be set before we close the URL, which will
@@ -608,30 +609,20 @@ PassRefPtr<HistoryItem> HistoryControlle
 // tracking whether each frame already has the content the item requests.  If there is
 // a match, we set the provisional item and recurse.  Otherwise we will reload that
 // frame and all its kids in recursiveGoToItem.
-void HistoryController::recursiveSetProvisionalItem(HistoryItem* item, HistoryItem* fromItem, FrameLoadType type)
+void HistoryController::recursiveSetProvisionalItem(PassRefPtr<HistoryItem> item, PassRefPtr<HistoryItem> fromItem, FrameLoadType type)
 {
     ASSERT(item);
     ASSERT(fromItem);
 
-    if (itemsAreClones(item, fromItem)) {
+    if (itemsAreClones(item.get(), fromItem.get())) {
         // Set provisional item, which will be committed in recursiveUpdateForCommit.
-        m_provisionalItem = item;
+        RefPtr<HistoryItem> targetItem = item;
+        m_provisionalItem = targetItem;
 
-        const HistoryItemVector& childItems = item->children();
+        const HistoryItemVector& childItems = targetItem->children();
 
         int size = childItems.size();
 
-        // Sanity checks for http://webkit.org/b/52819.
-        if (size > 0) {
-            // fromItem should have same number of children according to hasSameFrames,
-            // but crash dumps suggest it might have 0.
-            if (!fromItem->children().size())
-                CRASH();
-            // itemsAreClones checked fromItem->hasSameFrames(item). Check vice versa.
-            if (!item->hasSameFrames(fromItem))
-                CRASH();
-        }
-
         for (int i = 0; i < size; ++i) {
             String childFrameName = childItems[i]->target();
             HistoryItem* fromChildItem = fromItem->childItemWithTarget(childFrameName);
@@ -645,12 +636,12 @@ void HistoryController::recursiveSetProv
 
 // We now traverse the frame tree and item tree a second time, loading frames that
 // do have the content the item requests.
-void HistoryController::recursiveGoToItem(HistoryItem* item, HistoryItem* fromItem, FrameLoadType type)
+void HistoryController::recursiveGoToItem(PassRefPtr<HistoryItem> item, PassRefPtr<HistoryItem> fromItem, FrameLoadType type)
 {
     ASSERT(item);
     ASSERT(fromItem);
 
-    if (itemsAreClones(item, fromItem)) {
+    if (itemsAreClones(item.get(), fromItem.get())) {
         // Just iterate over the rest, looking for frames to navigate.
         const HistoryItemVector& childItems = item->children();
 
@@ -664,20 +655,12 @@ void HistoryController::recursiveGoToIte
             childFrame->loader()->history()->recursiveGoToItem(childItems[i].get(), fromChildItem, type);
         }
     } else {
-        m_frame->loader()->loadItem(item, type);
+        m_frame->loader()->loadItem(item.get(), type);
     }
 }
 
 bool HistoryController::itemsAreClones(HistoryItem* item1, HistoryItem* item2) const
 {
-    // It appears that one of the items can be null in release builds, leading
-    // to the crashes seen in http://webkit.org/b/52819.  For now, try to
-    // narrow it down with a more specific crash.
-    if (!item1)
-        CRASH();
-    if (!item2)
-        CRASH();
-
     // If the item we're going to is a clone of the item we're at, then we do
     // not need to load it again.  The current frame tree and the frame tree
     // snapshot in the item have to match.
