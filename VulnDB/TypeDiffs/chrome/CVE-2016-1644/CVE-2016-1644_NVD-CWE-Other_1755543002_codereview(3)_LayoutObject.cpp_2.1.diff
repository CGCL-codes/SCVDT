Index: third_party/WebKit/Source/core/layout/LayoutObject.cpp
diff --git a/third_party/WebKit/Source/core/layout/LayoutObject.cpp b/third_party/WebKit/Source/core/layout/LayoutObject.cpp
index 7bacec1713b10ba2ba8c418a59bbb52f9ea2f944..b0158df2a099dda2911936ae9fcd406d0af6ac73 100644
--- a/third_party/WebKit/Source/core/layout/LayoutObject.cpp
+++ b/third_party/WebKit/Source/core/layout/LayoutObject.cpp
@@ -759,10 +759,24 @@ static inline bool objectIsRelayoutBoundary(const LayoutObject* object)
     return true;
 }
 
+void LayoutObject::markContainerChainForLayout(bool scheduleRelayout)
+{
+    markContainerChainForLayout(scheduleRelayout, nullptr);
+}
+
+void LayoutObject::markContainerChainForLayout(SubtreeLayoutScope* layouter)
+{
+    // When we have a layouter, it means that we're in layout and we're marking
+    // a descendant as needing layout with the intention of visiting it during
+    // this layout. We shouldn't be scheduling it to be laid out later.
+    markContainerChainForLayout(!layouter, layouter);
+}
+
 void LayoutObject::markContainerChainForLayout(bool scheduleRelayout, SubtreeLayoutScope* layouter)
 {
     ASSERT(!isSetNeedsLayoutForbidden());
     ASSERT(!layouter || this != layouter->root());
+    ASSERT(!scheduleRelayout || !layouter);
 
     LayoutObject* object = container();
     LayoutObject* last = this;
