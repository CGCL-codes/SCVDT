diff -ur src2/video/replay.cc src/video/replay.cc
--- src2/video/replay.cc	2018-05-22 14:43:22.522977179 -0700
+++ src/video/replay.cc	2018-05-22 14:46:10.482324775 -0700
@@ -10,6 +10,7 @@
 
 #include <stdio.h>
 
+#include <fstream>
 #include <map>
 #include <memory>
 #include <sstream>
@@ -20,6 +21,7 @@
 #include "logging/rtc_event_log/rtc_event_log.h"
 #include "modules/rtp_rtcp/include/rtp_header_parser.h"
 #include "rtc_base/checks.h"
+#include "rtc_base/file.h"
 #include "rtc_base/flags.h"
 #include "rtc_base/string_to_number.h"
 #include "rtc_base/timeutils.h"
@@ -71,39 +73,24 @@
 DEFINE_int(media_payload_type,
            test::CallTest::kPayloadTypeVP8,
            "Media payload type");
-static int MediaPayloadType() {
-  return static_cast<int>(FLAG_media_payload_type);
-}
 
 // Flag for RED payload type.
 DEFINE_int(red_payload_type,
            test::CallTest::kRedPayloadType,
            "RED payload type");
-static int RedPayloadType() {
-  return static_cast<int>(FLAG_red_payload_type);
-}
 
 // Flag for ULPFEC payload type.
 DEFINE_int(ulpfec_payload_type,
            test::CallTest::kUlpfecPayloadType,
            "ULPFEC payload type");
-static int UlpfecPayloadType() {
-  return static_cast<int>(FLAG_ulpfec_payload_type);
-}
 
 DEFINE_int(media_payload_type_rtx,
            test::CallTest::kSendRtxPayloadType,
            "Media over RTX payload type");
-static int MediaPayloadTypeRtx() {
-  return static_cast<int>(FLAG_media_payload_type_rtx);
-}
 
 DEFINE_int(red_payload_type_rtx,
            test::CallTest::kRtxRedPayloadType,
            "RED over RTX payload type");
-static int RedPayloadTypeRtx() {
-  return static_cast<int>(FLAG_red_payload_type_rtx);
-}
 
 // Flag for SSRC.
 const std::string& DefaultSsrc() {
@@ -112,9 +99,6 @@
   return ssrc;
 }
 DEFINE_string(ssrc, DefaultSsrc().c_str(), "Incoming SSRC");
-static uint32_t Ssrc() {
-  return rtc::StringToNumber<uint32_t>(FLAG_ssrc).value();
-}
 
 const std::string& DefaultSsrcRtx() {
   static const std::string ssrc_rtx = std::to_string(
@@ -122,21 +106,14 @@
   return ssrc_rtx;
 }
 DEFINE_string(ssrc_rtx, DefaultSsrcRtx().c_str(), "Incoming RTX SSRC");
-static uint32_t SsrcRtx() {
-  return rtc::StringToNumber<uint32_t>(FLAG_ssrc_rtx).value();
-}
 
 // Flag for abs-send-time id.
 DEFINE_int(abs_send_time_id, -1, "RTP extension ID for abs-send-time");
-static int AbsSendTimeId() { return static_cast<int>(FLAG_abs_send_time_id); }
 
 // Flag for transmission-offset id.
 DEFINE_int(transmission_offset_id,
            -1,
            "RTP extension ID for transmission-offset");
-static int TransmissionOffsetId() {
-  return static_cast<int>(FLAG_transmission_offset_id);
-}
 
 // Flag for rtpdump input file.
 DEFINE_string(input_file, "", "input file");
@@ -146,24 +123,15 @@
 
 // Flag for raw output files.
 DEFINE_string(out_base, "", "Basename (excluding .jpg) for raw output");
-static std::string OutBase() {
-  return static_cast<std::string>(FLAG_out_base);
-}
 
 DEFINE_string(decoder_bitstream_filename, "", "Decoder bitstream output file");
-static std::string DecoderBitstreamFilename() {
-  return static_cast<std::string>(FLAG_decoder_bitstream_filename);
-}
 
 // Flag for video codec.
 DEFINE_string(codec, "VP8", "Video codec");
-static std::string Codec() { return static_cast<std::string>(FLAG_codec); }
 
 DEFINE_bool(help, false, "Print this message.");
 }  // namespace flags
 
-static const uint32_t kReceiverLocalSsrc = 0x123456;
-
 class FileRenderPassthrough : public rtc::VideoSinkInterface<VideoFrame> {
  public:
   FileRenderPassthrough(const std::string& basename,
@@ -214,71 +182,67 @@
 };
 
 void RtpReplay() {
-  std::stringstream window_title;
-  window_title << "Playback Video (" << flags::InputFile() << ")";
-  std::unique_ptr<test::VideoRenderer> playback_video(
-      test::VideoRenderer::Create(window_title.str().c_str(), 640, 480));
-  FileRenderPassthrough file_passthrough(flags::OutBase(),
-                                         playback_video.get());
-
   webrtc::RtcEventLogNullImpl event_log;
-  std::unique_ptr<Call> call(Call::Create(Call::Config(&event_log)));
+  Call::Config config(&event_log);
+  config.dump_rtp = false;
+  std::unique_ptr<Call> call(Call::Create(std::move(config)));
+
+  std::string config_path = flags::InputFile() + "_config";
+  std::ifstream config_file(config_path);
+  std::stringstream raw_json_buffer;
+  raw_json_buffer << config_file.rdbuf();
+  std::string raw_json = raw_json_buffer.str();
+  Json::Reader json_reader;
+  Json::Value json_configs;
+  bool parse_res = json_reader.parse(raw_json, json_configs);
+  if (!parse_res) {
+    printf("Error parsing JSON\n");
+    printf("%s\n", json_reader.getFormatedErrorMessages().c_str());
+    return;
+  }
 
+  std::vector<VideoReceiveStream*> receive_streams;
+  std::vector<std::unique_ptr<test::VideoRenderer>> renderers;
   test::NullTransport transport;
-  VideoReceiveStream::Config receive_config(&transport);
-  receive_config.rtp.remote_ssrc = flags::Ssrc();
-  receive_config.rtp.local_ssrc = kReceiverLocalSsrc;
-  receive_config.rtp.rtx_ssrc = flags::SsrcRtx();
-  receive_config.rtp
-      .rtx_associated_payload_types[flags::MediaPayloadTypeRtx()] =
-      flags::MediaPayloadType();
-  receive_config.rtp.rtx_associated_payload_types[flags::RedPayloadTypeRtx()] =
-      flags::RedPayloadType();
-  receive_config.rtp.ulpfec_payload_type = flags::UlpfecPayloadType();
-  receive_config.rtp.red_payload_type = flags::RedPayloadType();
-  receive_config.rtp.nack.rtp_history_ms = 1000;
-  if (flags::TransmissionOffsetId() != -1) {
-    receive_config.rtp.extensions.push_back(RtpExtension(
-        RtpExtension::kTimestampOffsetUri, flags::TransmissionOffsetId()));
-  }
-  if (flags::AbsSendTimeId() != -1) {
-    receive_config.rtp.extensions.push_back(
-        RtpExtension(RtpExtension::kAbsSendTimeUri, flags::AbsSendTimeId()));
-  }
-  receive_config.renderer = &file_passthrough;
+  int n = 0;
+  for (const auto& json_config : json_configs) {
+    Json::StyledWriter writer;
+    std::string wut = writer.write(json_config);
+    printf("%s\n", wut.c_str());
+    VideoReceiveStream::Config receive_config =
+        VideoReceiveStream::Config(&transport, json_config);
+
+    // To instantiate the actual underlying decoder.
+    for (auto& decoder : receive_config.decoders) {
+      decoder.decoder = test::CreateMatchingDecoder(decoder.payload_type,
+                                                    decoder.payload_name)
+                            .decoder;
+    }
 
-  VideoReceiveStream::Decoder decoder;
-  std::unique_ptr<DecoderBitstreamFileWriter> bitstream_writer;
-  if (!flags::DecoderBitstreamFilename().empty()) {
-    bitstream_writer.reset(new DecoderBitstreamFileWriter(
-        flags::DecoderBitstreamFilename().c_str()));
-    receive_config.pre_decode_callback = bitstream_writer.get();
-  }
-  decoder = test::CreateMatchingDecoder(flags::MediaPayloadType(),
-                                        flags::Codec());
-  if (!flags::DecoderBitstreamFilename().empty()) {
-    // Replace with a null decoder if we're writing the bitstream to a file
-    // instead.
-    delete decoder.decoder;
-    decoder.decoder = new test::FakeNullDecoder();
+    std::stringstream window_title;
+    window_title << "Playback Video (" << n++ << ")";
+    renderers.emplace_back(
+        test::VideoRenderer::Create(window_title.str().c_str(), 640, 480));
+    receive_config.renderer = renderers.back().get();
+
+    VideoReceiveStream* receive_stream =
+        call->CreateVideoReceiveStream(std::move(receive_config));
+    receive_streams.push_back(receive_stream);
   }
-  receive_config.decoders.push_back(decoder);
-
-  VideoReceiveStream* receive_stream =
-      call->CreateVideoReceiveStream(std::move(receive_config));
 
-  std::unique_ptr<test::RtpFileReader> rtp_reader(test::RtpFileReader::Create(
-      test::RtpFileReader::kRtpDump, flags::InputFile()));
+  std::string rtp_path = flags::InputFile() + "_rtpdump";
+  std::unique_ptr<test::RtpFileReader> rtp_reader(
+      test::RtpFileReader::Create(test::RtpFileReader::kRtpDump, rtp_path));
   if (!rtp_reader) {
-    rtp_reader.reset(test::RtpFileReader::Create(test::RtpFileReader::kPcap,
-                                                 flags::InputFile()));
+    rtp_reader.reset(
+        test::RtpFileReader::Create(test::RtpFileReader::kPcap, rtp_path));
     if (!rtp_reader) {
       fprintf(stderr,
               "Couldn't open input file as either a rtpdump or .pcap. Note "
               "that .pcapng is not supported.\nTrying to interpret the file as "
               "length/packet interleaved.\n");
       rtp_reader.reset(test::RtpFileReader::Create(
-          test::RtpFileReader::kLengthPacketInterleaved, flags::InputFile()));
+          test::RtpFileReader::kLengthPacketInterleaved, rtp_path));
       if (!rtp_reader) {
         fprintf(stderr,
                 "Unable to open input file with any supported format\n");
@@ -286,7 +250,9 @@
       }
     }
   }
-  receive_stream->Start();
+
+  for (const auto& receive_stream : receive_streams)
+    receive_stream->Start();
 
   int64_t replay_start_ms = -1;
   int num_packets = 0;
@@ -340,9 +306,8 @@
         stderr, "Packets for unknown ssrc '%u': %d\n", it->first, it->second);
   }
 
-  call->DestroyVideoReceiveStream(receive_stream);
-
-  delete decoder.decoder;
+  for (const auto& receive_stream : receive_streams)
+    call->DestroyVideoReceiveStream(receive_stream);
 }
 }  // namespace webrtc
 
