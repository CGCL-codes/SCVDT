diff --git a/src/runtime.cc b/src/runtime.cc
index 6106da7..c275f55 100644
--- a/src/runtime.cc
+++ b/src/runtime.cc
@@ -10472,8 +10472,7 @@ RUNTIME_FUNCTION(Runtime_ArrayConcat) {
       Handle<JSArray> array(Handle<JSArray>::cast(obj));
       length_estimate = static_cast<uint32_t>(array->length()->Number());
       if (length_estimate != 0) {
-        ElementsKind array_kind =
-            GetPackedElementsKind(array->map()->elements_kind());
+        ElementsKind array_kind = array->map()->elements_kind();
         if (IsMoreGeneralElementsKindTransition(kind, array_kind)) {
           kind = array_kind;
         }
@@ -10512,14 +10511,13 @@ RUNTIME_FUNCTION(Runtime_ArrayConcat) {
   // dictionary.
   bool fast_case = (estimate_nof_elements * 2) >= estimate_result_length;
 
-  if (fast_case && kind == FAST_DOUBLE_ELEMENTS) {
+  if (fast_case && IsFastDoubleElementsKind(kind)) {
     Handle<FixedArrayBase> storage =
         isolate->factory()->NewFixedDoubleArray(estimate_result_length);
     int j = 0;
     if (estimate_result_length > 0) {
       Handle<FixedDoubleArray> double_storage =
           Handle<FixedDoubleArray>::cast(storage);
-      bool failure = false;
       for (int i = 0; i < argument_count; i++) {
         Handle<Object> obj(elements->get(i), isolate);
         if (obj->IsSmi()) {
@@ -10540,11 +10538,11 @@ RUNTIME_FUNCTION(Runtime_ArrayConcat) {
                   FixedDoubleArray::cast(array->elements());
               for (uint32_t i = 0; i < length; i++) {
                 if (elements->is_the_hole(i)) {
-                  failure = true;
-                  break;
+                  double_storage->set_the_hole(j);
+                } else {
+                  double double_value = elements->get_scalar(i);
+                  double_storage->set(j, double_value);
                 }
-                double double_value = elements->get_scalar(i);
-                double_storage->set(j, double_value);
                 j++;
               }
               break;
@@ -10556,11 +10554,11 @@ RUNTIME_FUNCTION(Runtime_ArrayConcat) {
               for (uint32_t i = 0; i < length; i++) {
                 Object* element = elements->get(i);
                 if (element->IsTheHole()) {
-                  failure = true;
-                  break;
+                  double_storage->set_the_hole(j);
+                } else {
+                  int32_t int_value = Smi::cast(element)->value();
+                  double_storage->set(j, int_value);
                 }
-                int32_t int_value = Smi::cast(element)->value();
-                double_storage->set(j, int_value);
                 j++;
               }
               break;
@@ -10572,7 +10570,6 @@ RUNTIME_FUNCTION(Runtime_ArrayConcat) {
               UNREACHABLE();
           }
         }
-        if (failure) break;
       }
     }
     Handle<JSArray> array = isolate->factory()->NewJSArray(0);
