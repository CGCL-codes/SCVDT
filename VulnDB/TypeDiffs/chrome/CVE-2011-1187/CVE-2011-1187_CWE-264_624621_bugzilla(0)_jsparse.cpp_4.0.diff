diff --git a/js/src/jsparse.cpp b/js/src/jsparse.cpp
--- a/js/src/jsparse.cpp
+++ b/js/src/jsparse.cpp
@@ -175,34 +175,36 @@ JSParseNode::clear()
 {
     pn_type = TOK_EOF;
     pn_op = JSOP_NOP;
     pn_used = pn_defn = false;
     pn_arity = PN_NULLARY;
     pn_parens = false;
 }
 
-Parser::Parser(JSContext *cx, JSPrincipals *prin, StackFrame *cfp, bool foldConstants)
+Parser::Parser(JSContext *cx, JSPrincipals *prin, JSPrincipals *originPrin,
+               StackFrame *cfp, bool foldConstants)
   : js::AutoGCRooter(cx, PARSER),
     context(cx),
     tokenStream(cx),
     principals(NULL),
+    originPrincipals(NULL),
     callerFrame(cfp),
     callerVarObj(cfp ? &cfp->varObj() : NULL),
     nodeList(NULL),
     functionCount(0),
     traceListHead(NULL),
     tc(NULL),
     emptyCallShape(NULL),
     keepAtoms(cx->runtime),
     foldConstants(foldConstants)
 {
     cx->activeCompilations++;
     js::PodArrayZero(tempFreeList);
-    setPrincipals(prin);
+    setPrincipals(prin, originPrin);
     JS_ASSERT_IF(cfp, cfp->isScriptFrame());
 }
 
 bool
 Parser::init(const jschar *base, size_t length, const char *filename, uintN lineno,
              JSVersion version)
 {
     JSContext *cx = context;
@@ -217,30 +219,34 @@ Parser::init(const jschar *base, size_t 
         return false;
     }
     return true;
 }
 
 Parser::~Parser()
 {
     JSContext *cx = context;
-
     if (principals)
         JSPRINCIPALS_DROP(cx, principals);
+    if (originPrincipals)
+        JSPRINCIPALS_DROP(cx, originPrincipals);
     JS_ARENA_RELEASE(&cx->tempPool, tempPoolMark);
     cx->activeCompilations--;
 }
 
 void
-Parser::setPrincipals(JSPrincipals *prin)
-{
-    JS_ASSERT(!principals);
-    if (prin)
-        JSPRINCIPALS_HOLD(context, prin);
+Parser::setPrincipals(JSPrincipals *prin, JSPrincipals *originPrin)
+{
+    JS_ASSERT(!principals && !originPrincipals);
     principals = prin;
+    if (principals)
+        JSPRINCIPALS_HOLD(context, principals);
+    originPrincipals = originPrin;
+    if (originPrincipals)
+        JSPRINCIPALS_HOLD(context, originPrincipals);
 }
 
 JSObjectBox *
 Parser::newObjectBox(JSObject *obj)
 {
     JS_ASSERT(obj);
 
     /*
@@ -882,24 +888,24 @@ SetStaticLevel(JSTreeContext *tc, uintN 
     }
     tc->staticLevel = staticLevel;
     return true;
 }
 
 /*
  * Compile a top-level script.
  */
-Compiler::Compiler(JSContext *cx, JSPrincipals *prin, StackFrame *cfp)
-  : parser(cx, prin, cfp), globalScope(NULL)
+Compiler::Compiler(JSContext *cx, JSPrincipals *prin, JSPrincipals *originPrin, StackFrame *cfp)
+  : parser(cx, prin, originPrin, cfp), globalScope(NULL)
 {}
 
 JSScript *
 Compiler::compileScript(JSContext *cx, JSObject *scopeChain, StackFrame *callerFrame,
-                        JSPrincipals *principals, uint32 tcflags,
-                        const jschar *chars, size_t length,
+                        JSPrincipals *principals, JSPrincipals *originPrincipals,
+                        uint32 tcflags, const jschar *chars, size_t length,
                         const char *filename, uintN lineno, JSVersion version,
                         JSString *source /* = NULL */,
                         uintN staticLevel /* = 0 */)
 {
     JSArenaPool codePool, notePool;
     TokenKind tt;
     JSParseNode *pn;
     JSScript *script;
@@ -910,17 +916,17 @@ Compiler::compileScript(JSContext *cx, J
 
     /*
      * The scripted callerFrame can only be given for compile-and-go scripts
      * and non-zero static level requires callerFrame.
      */
     JS_ASSERT_IF(callerFrame, tcflags & TCF_COMPILE_N_GO);
     JS_ASSERT_IF(staticLevel != 0, callerFrame);
 
-    Compiler compiler(cx, principals, callerFrame);
+    Compiler compiler(cx, principals, originPrincipals, callerFrame);
     if (!compiler.init(chars, length, filename, lineno, version))
         return NULL;
 
     JS_InitArenaPool(&codePool, "code", 1024, sizeof(jsbytecode));
     JS_InitArenaPool(&notePool, "note", 1024, sizeof(jssrcnote));
 
     Parser &parser = compiler.parser;
     TokenStream &tokenStream = parser.tokenStream;
@@ -1775,21 +1781,22 @@ DefineArg(JSParseNode *pn, JSAtom *atom,
     return true;
 }
 
 /*
  * Compile a JS function body, which might appear as the value of an event
  * handler attribute in an HTML <INPUT> tag.
  */
 bool
-Compiler::compileFunctionBody(JSContext *cx, JSFunction *fun, JSPrincipals *principals,
+Compiler::compileFunctionBody(JSContext *cx, JSFunction *fun,
+                              JSPrincipals *principals, JSPrincipals *originPrincipals,
                               Bindings *bindings, const jschar *chars, size_t length,
                               const char *filename, uintN lineno, JSVersion version)
 {
-    Compiler compiler(cx, principals);
+    Compiler compiler(cx, principals, originPrincipals);
 
     if (!compiler.init(chars, length, filename, lineno, version))
         return false;
 
     /* No early return from after here until the js_FinishArenaPool calls. */
     JSArenaPool codePool, notePool;
     JS_InitArenaPool(&codePool, "code", 1024, sizeof(jsbytecode));
     JS_InitArenaPool(&notePool, "note", 1024, sizeof(jssrcnote));
