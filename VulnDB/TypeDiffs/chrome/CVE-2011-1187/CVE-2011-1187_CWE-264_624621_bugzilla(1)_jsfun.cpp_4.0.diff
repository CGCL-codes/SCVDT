diff --git a/js/src/jsfun.cpp b/js/src/jsfun.cpp
--- a/js/src/jsfun.cpp
+++ b/js/src/jsfun.cpp
@@ -2126,18 +2126,21 @@ Function(JSContext *cx, uintN argc, Valu
     /* Block this call if security callbacks forbid it. */
     GlobalObject *global = call.callee().getGlobal();
     if (!global->isRuntimeCodeGenEnabled(cx)) {
         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CSP_BLOCKED_FUNCTION);
         return false;
     }
 
     Bindings bindings(cx);
+
+    const char *filename;
     uintN lineno;
-    const char *filename = CurrentScriptFileAndLine(cx, &lineno);
+    JSPrincipals *originPrincipals;
+    CurrentScriptFileLineOrigin(cx, &filename, &lineno, &originPrincipals);
 
     Value *argv = call.argv();
     uintN n = argc ? argc - 1 : 0;
     if (n > 0) {
         /*
          * Collect the function-argument arguments into one string, separated
          * by commas, then make a tokenstream from that string, and scan it to
          * get the arguments.  We need to throw the full scanner at the
@@ -2281,18 +2284,18 @@ Function(JSContext *cx, uintN argc, Valu
      * and so would a call to f from another top-level's script or function.
      */
     JSFunction *fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_LAMBDA | JSFUN_INTERPRETED,
                                      global, cx->runtime->atomState.anonymousAtom);
     if (!fun)
         return false;
 
     JSPrincipals *principals = PrincipalsForCompiledCode(call, cx);
-    bool ok = Compiler::compileFunctionBody(cx, fun, principals, &bindings,
-                                            chars, length, filename, lineno,
+    bool ok = Compiler::compileFunctionBody(cx, fun, principals, originPrincipals,
+                                            &bindings, chars, length, filename, lineno,
                                             cx->findVersion());
     call.rval().setObject(*fun);
     return ok;
 }
 
 bool
 IsBuiltinFunctionConstructor(JSFunction *fun)
 {
