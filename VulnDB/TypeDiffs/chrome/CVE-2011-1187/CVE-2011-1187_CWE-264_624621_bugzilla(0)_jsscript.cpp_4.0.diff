diff --git a/js/src/jsscript.cpp b/js/src/jsscript.cpp
--- a/js/src/jsscript.cpp
+++ b/js/src/jsscript.cpp
@@ -616,28 +616,34 @@ js_XDRScript(JSXDRState *xdr, JSScript *
         principals = script->principals;
         encodeable = callbacks && callbacks->principalsTranscoder;
         if (!JS_XDRUint32(xdr, &encodeable))
             goto error;
         if (encodeable &&
             !callbacks->principalsTranscoder(xdr, &principals)) {
             goto error;
         }
+        JS_ASSERT(script->principals == script->originPrincipals);
     } else {
         if (!JS_XDRUint32(xdr, &encodeable))
             goto error;
         if (encodeable) {
             if (!(callbacks && callbacks->principalsTranscoder)) {
                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
                                      JSMSG_CANT_DECODE_PRINCIPALS);
                 goto error;
             }
             if (!callbacks->principalsTranscoder(xdr, &principals))
                 goto error;
             script->principals = principals;
+            script->originPrincipals = principals;
+
+            /* The transcoder only holds 'principals' once. */
+            if (script->originPrincipals)
+                JSPRINCIPALS_HOLD(cx, script->originPrincipals);
         }
     }
 
     if (xdr->mode == JSXDR_DECODE) {
         script->lineno = (uintN)lineno;
         script->nslots = (uint16)nslots;
         script->staticLevel = (uint16)(nslots >> 16);
     }
@@ -1283,20 +1289,28 @@ JSScript::NewScriptFromCG(JSContext *cx,
     }
     script->lineno = cg->firstLine;
     if (script->nfixed + cg->maxStackDepth >= JS_BIT(16)) {
         ReportCompileErrorNumber(cx, CG_TS(cg), NULL, JSREPORT_ERROR, JSMSG_NEED_DIET, "script");
         goto bad;
     }
     script->nslots = script->nfixed + cg->maxStackDepth;
     script->staticLevel = uint16(cg->staticLevel);
+
     script->principals = cg->parser->principals;
     if (script->principals)
         JSPRINCIPALS_HOLD(cx, script->principals);
 
+    /* Establish invariant: principals implies originPrincipals. */
+    script->originPrincipals = cg->parser->originPrincipals;
+    if (!script->originPrincipals)
+        script->originPrincipals = script->principals;
+    if (script->originPrincipals)
+        JSPRINCIPALS_HOLD(cx, script->originPrincipals);
+
     if (!js_FinishTakingSrcNotes(cx, cg, script->notes()))
         goto bad;
     if (cg->ntrynotes != 0)
         js_FinishTakingTryNotes(cg, script->trynotes());
     if (cg->objectList.length != 0)
         cg->objectList.finish(script->objects());
     if (cg->regexpList.length != 0)
         cg->regexpList.finish(script->regexps());
@@ -1418,18 +1432,21 @@ js_CallDestroyScriptHook(JSContext *cx, 
     if (hook)
         hook(cx, script, cx->debugHooks->destroyScriptHookData);
     JS_ClearScriptTraps(cx, script);
 }
 
 static void
 DestroyScript(JSContext *cx, JSScript *script)
 {
+    JS_ASSERT_IF(script->principals, script->originPrincipals);
     if (script->principals)
         JSPRINCIPALS_DROP(cx, script->principals);
+    if (script->originPrincipals)
+        JSPRINCIPALS_DROP(cx, script->originPrincipals);
 
     GSNCache *gsnCache = GetGSNCache(cx);
     if (gsnCache->code == script->code)
         gsnCache->purge();
 
     /*
      * Worry about purging the property cache and any compiled traces related
      * to its bytecode if this script is being destroyed from JS_DestroyScript
@@ -1751,30 +1768,35 @@ js_GetScriptLineExtent(JSScript *script)
 namespace js {
 
 uintN
 CurrentLine(JSContext *cx)
 {
     return js_FramePCToLineNumber(cx, cx->fp(), cx->regs().pc);
 }
 
-const char *
-CurrentScriptFileAndLineSlow(JSContext *cx, uintN *linenop)
+void
+CurrentScriptFileLineOriginSlow(JSContext *cx, const char **file, uintN *linenop,
+                                JSPrincipals **origin)
 {
     FrameRegsIter iter(cx);
     while (!iter.done() && !iter.fp()->isScriptFrame())
         ++iter;
 
     if (iter.done()) {
+        *file = NULL;
         *linenop = 0;
-        return NULL;
+        *origin = NULL;
+        return;
     }
 
+    JSScript *script = iter.fp()->script();
+    *file = script->filename;
     *linenop = js_FramePCToLineNumber(cx, iter.fp(), iter.pc());
-    return iter.fp()->script()->filename;
+    *origin = script->originPrincipals;
 }
 
 }  /* namespace js */
 
 class DisablePrincipalsTranscoding {
     JSSecurityCallbacks *callbacks;
     JSPrincipalsTranscoder temp;
 
@@ -1853,24 +1875,29 @@ js_CloneScript(JSContext *cx, JSScript *
     // mem, lest they both try to free it in JS_XDRDestroy
     JS_XDRMemSetData(r, p, nbytes);
     JS_XDRMemSetData(w, NULL, 0);
 
     XDRScriptState rstate(r);
     rstate.filename = script->filename;
     rstate.filenameSaved = true;
 
-    if (!js_XDRScript(r, &script))
+    JSScript *newScript = NULL;
+    if (!js_XDRScript(r, &newScript))
         return NULL;
 
-    // set the proper principals for the script
-    script->principals = script->compartment->principals;
-    if (script->principals)
-        JSPRINCIPALS_HOLD(cx, script->principals);
+    // set the proper principals for the script's new compartment
+    // the originPrincipals are not related to compartment, so just copy
+    newScript->principals = script->compartment->principals;
+    newScript->originPrincipals = script->originPrincipals;
+    if (newScript->principals) {
+        JSPRINCIPALS_HOLD(cx, newScript->principals);
+        JSPRINCIPALS_HOLD(cx, newScript->originPrincipals);
+    }
 
-    return script;
+    return newScript;
 }
 
 void
 JSScript::copyClosedSlotsTo(JSScript *other)
 {
     memcpy(other->closedSlots, closedSlots, nClosedArgs + nClosedVars);
 }
