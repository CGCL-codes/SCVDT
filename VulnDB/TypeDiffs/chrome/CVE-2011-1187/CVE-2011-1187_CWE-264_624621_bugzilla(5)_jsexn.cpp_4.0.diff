diff --git a/js/src/jsexn.cpp b/js/src/jsexn.cpp
--- a/js/src/jsexn.cpp
+++ b/js/src/jsexn.cpp
@@ -237,16 +237,19 @@ CopyErrorReport(JSContext *cx, JSErrorRe
     }
 
     if (report->filename) {
         copy->filename = (const char *)cursor;
         memcpy(cursor, report->filename, filenameSize);
     }
     JS_ASSERT(cursor + filenameSize == (uint8 *)copy + mallocSize);
 
+    /* HOLD called by the destination error object. */
+    copy->originPrincipals = report->originPrincipals;
+
     /* Copy non-pointer members. */
     copy->lineno = report->lineno;
     copy->errorNumber = report->errorNumber;
 
     /* Note that this is before it gets flagged with JSREPORT_EXCEPTION */
     copy->flags = report->flags;
 
 #undef JS_CHARS_SIZE
@@ -289,16 +292,19 @@ struct SuppressErrorsGuard
 struct AppendArg {
     Vector<Value> &values;
     AppendArg(Vector<Value> &values) : values(values) {}
     bool operator()(uintN, Value *vp) {
         return values.append(*vp);
     }
 };
 
+static void
+SetExnPrivate(JSContext *cx, JSObject *exnObject, JSExnPrivate *priv);
+
 static bool
 InitExnPrivate(JSContext *cx, JSObject *exnObject, JSString *message,
                JSString *filename, uintN lineno, JSErrorReport *report, intN exnType)
 {
     JS_ASSERT(exnObject->isError());
     JS_ASSERT(!exnObject->getPrivate());
 
     JSSecurityCallbacks *callbacks = JS_GetSecurityCallbacks(cx);
@@ -386,17 +392,17 @@ InitExnPrivate(JSContext *cx, JSObject *
 
     JSStackTraceElem *framesDest = priv->stackElems;
     Value *valuesDest = reinterpret_cast<Value *>(framesDest + frames.length());
     JS_ASSERT(valuesDest == GetStackTraceValueBuffer(priv));
 
     PodCopy(framesDest, frames.begin(), frames.length());
     PodCopy(valuesDest, values.begin(), values.length());
 
-    exnObject->setPrivate(priv);
+    SetExnPrivate(cx, exnObject, priv);
     return true;
 }
 
 static inline JSExnPrivate *
 GetExnPrivate(JSObject *obj)
 {
     JS_ASSERT(obj->isError());
     return (JSExnPrivate *) obj->getPrivate();
@@ -429,22 +435,39 @@ exn_trace(JSTracer *trc, JSObject *obj)
         for (i = 0; i != vcount; ++i, ++vp) {
             /* This value is read-only, so it's okay for it to be Unbarriered. */
             v = *vp;
             MarkValueUnbarriered(trc, v, "stack trace argument");
         }
     }
 }
 
+/* NB: An error object's private must be set through this function. */
+static void
+SetExnPrivate(JSContext *cx, JSObject *exnObject, JSExnPrivate *priv)
+{
+    JS_ASSERT(!exnObject->getPrivate());
+    JS_ASSERT(exnObject->isError());
+    if (JSErrorReport *report = priv->errorReport) {
+        if (JSPrincipals *prin = report->originPrincipals)
+            JSPRINCIPALS_HOLD(cx, prin);
+    }
+    exnObject->setPrivate(priv);
+}
+
 static void
 exn_finalize(JSContext *cx, JSObject *obj)
 {
     if (JSExnPrivate *priv = GetExnPrivate(obj)) {
-        if (JSErrorReport *report = priv->errorReport)
+        if (JSErrorReport *report = priv->errorReport) {
+            /* HOLD called by SetExnPrivate. */
+            if (JSPrincipals *prin = report->originPrincipals)
+                JSPRINCIPALS_DROP(cx, prin);
             cx->free_(report);
+        }
         cx->free_(priv);
     }
 }
 
 static JSBool
 exn_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
             JSObject **objp)
 {
@@ -1307,12 +1330,12 @@ js_CopyErrorObject(JSContext *cx, JSObje
     copy->stackDepth = 0;
     copy->exnType = priv->exnType;
 
     // Create the Error object.
     JSObject *proto;
     if (!js_GetClassPrototype(cx, scope->getGlobal(), GetExceptionProtoKey(copy->exnType), &proto))
         return NULL;
     JSObject *copyobj = NewObjectWithGivenProto(cx, &ErrorClass, proto, NULL);
-    copyobj->setPrivate(copy);
+    SetExnPrivate(cx, copyobj, copy);
     autoFree.p = NULL;
     return copyobj;
 }
