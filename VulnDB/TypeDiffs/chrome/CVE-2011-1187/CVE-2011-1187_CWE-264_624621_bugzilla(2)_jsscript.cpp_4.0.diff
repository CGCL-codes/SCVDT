diff --git a/js/src/jsscript.cpp b/js/src/jsscript.cpp
--- a/js/src/jsscript.cpp
+++ b/js/src/jsscript.cpp
@@ -336,18 +336,17 @@ js_XDRScript(JSXDRState *xdr, JSScript *
 {
     JSScript *oldscript;
     JSBool ok;
     uint32 length, lineno, nslots;
     uint32 natoms, nsrcnotes, ntrynotes, nobjects, nregexps, nconsts, i;
     uint32 prologLength, version, encodedClosedCount;
     uint16 nClosedArgs = 0, nClosedVars = 0;
     uint32 nTypeSets = 0;
-    JSPrincipals *principals;
-    uint32 encodeable;
+    uint32 encodeable, sameOriginPrincipals;
     JSSecurityCallbacks *callbacks;
     uint32 scriptBits = 0;
 
     JSContext *cx = xdr->cx;
     JSScript *script = *scriptp;
     nsrcnotes = ntrynotes = natoms = nobjects = nregexps = nconsts = 0;
     jssrcnote *notes = NULL;
     XDRScriptState *state = xdr->state;
@@ -604,37 +603,46 @@ js_XDRScript(JSXDRState *xdr, JSScript *
                 goto error;
         }
         script->filename = state->filename;
     }
 
     JS_ASSERT_IF(xdr->mode == JSXDR_ENCODE, state->filename == script->filename);
 
     callbacks = JS_GetSecurityCallbacks(cx);
-    if (xdr->mode == JSXDR_ENCODE) {
-        principals = script->principals;
-        encodeable = callbacks && callbacks->principalsTranscoder;
-        if (!JS_XDRUint32(xdr, &encodeable))
-            goto error;
-        if (encodeable &&
-            !callbacks->principalsTranscoder(xdr, &principals)) {
+    if (xdr->mode == JSXDR_ENCODE)
+        encodeable = script->principals && callbacks && callbacks->principalsTranscoder;
+
+    if (!JS_XDRUint32(xdr, &encodeable))
+        goto error;
+
+    if (encodeable) {
+        if (!callbacks || !callbacks->principalsTranscoder) {
+            JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
+                                 JSMSG_CANT_DECODE_PRINCIPALS);
             goto error;
         }
-    } else {
-        if (!JS_XDRUint32(xdr, &encodeable))
+
+        if (!callbacks->principalsTranscoder(xdr, &script->principals))
             goto error;
-        if (encodeable) {
-            if (!(callbacks && callbacks->principalsTranscoder)) {
-                JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
-                                     JSMSG_CANT_DECODE_PRINCIPALS);
+
+        if (xdr->mode == JSXDR_ENCODE)
+            sameOriginPrincipals = script->principals == script->originPrincipals;
+
+        if (!JS_XDRUint32(xdr, &sameOriginPrincipals))
+            goto error;
+
+        if (sameOriginPrincipals) {
+            if (xdr->mode == JSXDR_DECODE) {
+                script->originPrincipals = script->principals;
+                JSPRINCIPALS_HOLD(cx, script->originPrincipals);
+            }
+        } else {
+            if (!callbacks->principalsTranscoder(xdr, &script->originPrincipals))
                 goto error;
-            }
-            if (!callbacks->principalsTranscoder(xdr, &principals))
-                goto error;
-            script->principals = principals;
         }
     }
 
     if (xdr->mode == JSXDR_DECODE) {
         script->lineno = (uintN)lineno;
         script->nslots = (uint16)nslots;
         script->staticLevel = (uint16)(nslots >> 16);
     }
@@ -1151,20 +1159,28 @@ JSScript::NewScriptFromCG(JSContext *cx,
     }
     script->lineno = cg->firstLine;
     if (script->nfixed + cg->maxStackDepth >= JS_BIT(16)) {
         ReportCompileErrorNumber(cx, CG_TS(cg), NULL, JSREPORT_ERROR, JSMSG_NEED_DIET, "script");
         return NULL;
     }
     script->nslots = script->nfixed + cg->maxStackDepth;
     script->staticLevel = uint16(cg->staticLevel);
+
     script->principals = cg->parser->principals;
     if (script->principals)
         JSPRINCIPALS_HOLD(cx, script->principals);
 
+    /* Establish invariant: principals implies originPrincipals. */
+    script->originPrincipals = cg->parser->originPrincipals;
+    if (!script->originPrincipals)
+        script->originPrincipals = script->principals;
+    if (script->originPrincipals)
+        JSPRINCIPALS_HOLD(cx, script->originPrincipals);
+
     script->sourceMap = (jschar *) cg->parser->tokenStream.releaseSourceMap();
 
     if (!js_FinishTakingSrcNotes(cx, cg, script->notes()))
         return NULL;
     if (cg->ntrynotes != 0)
         js_FinishTakingTryNotes(cg, script->trynotes());
     if (cg->objectList.length != 0)
         cg->objectList.finish(script->objects());
@@ -1336,18 +1352,21 @@ js_CallDestroyScriptHook(JSContext *cx, 
 
 void
 JSScript::finalize(JSContext *cx)
 {
     CheckScript(this, NULL);
 
     js_CallDestroyScriptHook(cx, this);
 
+    JS_ASSERT_IF(principals, originPrincipals);
     if (principals)
         JSPRINCIPALS_DROP(cx, principals);
+    if (originPrincipals)
+        JSPRINCIPALS_DROP(cx, originPrincipals);
 
 #ifdef JS_TRACER
     if (compartment()->hasTraceMonitor())
         PurgeScriptFragments(compartment()->traceMonitor(), this);
 #endif
 
     if (types)
         types->destroy();
@@ -1599,30 +1618,35 @@ js_GetScriptLineExtent(JSScript *script)
 namespace js {
 
 uintN
 CurrentLine(JSContext *cx)
 {
     return js_FramePCToLineNumber(cx, cx->fp(), cx->regs().pc);
 }
 
-const char *
-CurrentScriptFileAndLineSlow(JSContext *cx, uintN *linenop)
+void
+CurrentScriptFileLineOriginSlow(JSContext *cx, const char **file, uintN *linenop,
+                                JSPrincipals **origin)
 {
     FrameRegsIter iter(cx);
     while (!iter.done() && !iter.fp()->isScriptFrame())
         ++iter;
 
     if (iter.done()) {
+        *file = NULL;
         *linenop = 0;
-        return NULL;
+        *origin = NULL;
+        return;
     }
 
+    JSScript *script = iter.fp()->script();
+    *file = script->filename;
     *linenop = js_FramePCToLineNumber(cx, iter.fp(), iter.pc());
-    return iter.fp()->script()->filename;
+    *origin = script->originPrincipals;
 }
 
 }  /* namespace js */
 
 class DisablePrincipalsTranscoding {
     JSSecurityCallbacks *callbacks;
     JSPrincipalsTranscoder temp;
 
@@ -1700,25 +1724,32 @@ js_CloneScript(JSContext *cx, JSScript *
     // mem, lest they both try to free it in JS_XDRDestroy
     JS_XDRMemSetData(r, p, nbytes);
     JS_XDRMemSetData(w, NULL, 0);
 
     XDRScriptState rstate(r);
     rstate.filename = script->filename;
     rstate.filenameSaved = true;
 
-    if (!js_XDRScript(r, &script))
+    JSScript *newScript = NULL;
+    if (!js_XDRScript(r, &newScript))
         return NULL;
 
-    // set the proper principals for the script
-    script->principals = script->compartment()->principals;
-    if (script->principals)
-        JSPRINCIPALS_HOLD(cx, script->principals);
+    // set the proper principals for the script's new compartment
+    // the originPrincipals are not related to compartment, so just copy
+    newScript->principals = script->compartment()->principals;
+    newScript->originPrincipals = script->originPrincipals;
+    if (!newScript->originPrincipals)
+        newScript->originPrincipals = newScript->principals;
+    if (newScript->principals) {
+        JSPRINCIPALS_HOLD(cx, newScript->principals);
+        JSPRINCIPALS_HOLD(cx, newScript->originPrincipals);
+    }
 
-    return script;
+    return newScript;
 }
 
 void
 JSScript::copyClosedSlotsTo(JSScript *other)
 {
     memcpy(other->closedSlots, closedSlots, nClosedArgs + nClosedVars);
 }
 
