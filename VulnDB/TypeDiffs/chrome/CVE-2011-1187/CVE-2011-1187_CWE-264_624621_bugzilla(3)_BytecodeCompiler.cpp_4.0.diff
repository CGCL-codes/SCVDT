diff --git a/js/src/frontend/BytecodeCompiler.cpp b/js/src/frontend/BytecodeCompiler.cpp
--- a/js/src/frontend/BytecodeCompiler.cpp
+++ b/js/src/frontend/BytecodeCompiler.cpp
@@ -51,24 +51,24 @@
 using namespace js;
 using namespace js::frontend;
 
 namespace js {
 
 /*
  * Compile a top-level script.
  */
-BytecodeCompiler::BytecodeCompiler(JSContext *cx, JSPrincipals *prin, StackFrame *cfp)
-  : parser(cx, prin, cfp), globalScope(NULL)
+BytecodeCompiler::BytecodeCompiler(JSContext *cx, JSPrincipals *prin, JSPrincipals *originPrin, StackFrame *cfp)
+  : parser(cx, prin, originPrin, cfp), globalScope(NULL)
 {}
 
 JSScript *
 BytecodeCompiler::compileScript(JSContext *cx, JSObject *scopeChain, StackFrame *callerFrame,
-                                JSPrincipals *principals, uint32 tcflags,
-                                const jschar *chars, size_t length,
+                                JSPrincipals *principals, JSPrincipals *originPrincipals,
+                                uint32 tcflags, const jschar *chars, size_t length,
                                 const char *filename, uintN lineno, JSVersion version,
                                 JSString *source /* = NULL */,
                                 uintN staticLevel /* = 0 */)
 {
     TokenKind tt;
     ParseNode *pn;
     JSScript *script;
     bool inDirectivePrologue;
@@ -78,17 +78,17 @@ BytecodeCompiler::compileScript(JSContex
 
     /*
      * The scripted callerFrame can only be given for compile-and-go scripts
      * and non-zero static level requires callerFrame.
      */
     JS_ASSERT_IF(callerFrame, tcflags & TCF_COMPILE_N_GO);
     JS_ASSERT_IF(staticLevel != 0, callerFrame);
 
-    BytecodeCompiler compiler(cx, principals, callerFrame);
+    BytecodeCompiler compiler(cx, principals, originPrincipals, callerFrame);
     if (!compiler.init(chars, length, filename, lineno, version))
         return NULL;
 
     Parser &parser = compiler.parser;
     TokenStream &tokenStream = parser.tokenStream;
 
     CodeGenerator cg(&parser, tokenStream.getLineno());
     if (!cg.init(cx, TreeContext::USED_AS_TREE_CONTEXT))
@@ -386,21 +386,22 @@ BytecodeCompiler::defineGlobals(JSContex
     return true;
 }
 
 /*
  * Compile a JS function body, which might appear as the value of an event
  * handler attribute in an HTML <INPUT> tag.
  */
 bool
-BytecodeCompiler::compileFunctionBody(JSContext *cx, JSFunction *fun, JSPrincipals *principals,
+BytecodeCompiler::compileFunctionBody(JSContext *cx, JSFunction *fun,
+                                      JSPrincipals *principals, JSPrincipals *originPrincipals,
                                       Bindings *bindings, const jschar *chars, size_t length,
                                       const char *filename, uintN lineno, JSVersion version)
 {
-    BytecodeCompiler compiler(cx, principals);
+    BytecodeCompiler compiler(cx, principals, originPrincipals);
 
     if (!compiler.init(chars, length, filename, lineno, version))
         return false;
 
     Parser &parser = compiler.parser;
     TokenStream &tokenStream = parser.tokenStream;
 
     CodeGenerator funcg(&parser, tokenStream.getLineno());
