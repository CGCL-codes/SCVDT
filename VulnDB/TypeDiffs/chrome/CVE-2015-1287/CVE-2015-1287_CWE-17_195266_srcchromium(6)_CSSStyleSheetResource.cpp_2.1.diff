--- trunk/Source/core/fetch/CSSStyleSheetResource.cpp	2015/05/12 18:09:55	195265
+++ trunk/Source/core/fetch/CSSStyleSheetResource.cpp	2015/05/12 18:29:34	195266
@@ -77,11 +77,11 @@
         static_cast<StyleSheetResourceClient*>(c)->setCSSStyleSheet(m_resourceRequest.url(), m_response.url(), encoding(), this);
 }
 
-const String CSSStyleSheetResource::sheetText(bool enforceMIMEType, bool* hasValidMIMEType) const
+const String CSSStyleSheetResource::sheetText(bool* hasValidMIMEType) const
 {
     ASSERT(!isPurgeable());
 
-    if (!m_data || m_data->isEmpty() || !canUseSheet(enforceMIMEType, hasValidMIMEType))
+    if (!m_data || m_data->isEmpty() || !canUseSheet(hasValidMIMEType))
         return String();
 
     if (!m_decodedSheetText.isNull())
@@ -125,14 +125,11 @@
     setDecodedSize(0);
 }
 
-bool CSSStyleSheetResource::canUseSheet(bool enforceMIMEType, bool* hasValidMIMEType) const
+bool CSSStyleSheetResource::canUseSheet(bool* hasValidMIMEType) const
 {
     if (errorOccurred())
         return false;
 
-    if (!enforceMIMEType && !hasValidMIMEType)
-        return true;
-
     // This check exactly matches Firefox. Note that we grab the Content-Type
     // header directly because we want to see what the value is BEFORE content
     // sniffing. Firefox does this by setting a "type hint" on the channel.
@@ -143,8 +140,6 @@
     bool typeOK = mimeType().isEmpty() || equalIgnoringCase(mimeType(), "text/css") || equalIgnoringCase(mimeType(), "application/x-unknown-content-type");
     if (hasValidMIMEType)
         *hasValidMIMEType = typeOK;
-    if (!enforceMIMEType)
-        return true;
     return typeOK;
 }
 
