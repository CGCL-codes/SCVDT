Index: WebCore/rendering/RenderRubyBase.cpp
===================================================================
--- WebCore/rendering/RenderRubyBase.cpp	(revision 53240)
+++ WebCore/rendering/RenderRubyBase.cpp	(working copy)
@@ -48,39 +48,143 @@ bool RenderRubyBase::isChildAllowed(Rend
     return child->isInline();
 }
 
-void RenderRubyBase::splitToLeft(RenderBlock* leftBase, RenderObject* beforeChild)
+void RenderRubyBase::moveChildren(RenderBlock* toBase, RenderObject* beforeChild)
 {
     // This function removes all children that are before (!) beforeChild
-    // and appends them to leftBase.
-    ASSERT(leftBase);
-
+    // and appends them to toBase.
+    ASSERT(toBase);
+    
     // First make sure that beforeChild (if set) is indeed a direct child of this.
-    // Fallback: climb up the tree to make sure. This may result in somewhat incorrect rendering.
-    // FIXME: Can this happen? Is there a better/more correct way to solve this?
-    ASSERT(!beforeChild || beforeChild->parent() == this);
+    // Inline children might be wrapped in an anonymous block if there's a continuation.
+    // Theoretically, in ruby bases, this can happen with only the first such a child,
+    // so it should be OK to just climb the tree.
     while (beforeChild && beforeChild->parent() != this)
         beforeChild = beforeChild->parent();
 
-    RenderObject* child = firstChild();
-    while (child != beforeChild) {
-        RenderObject* nextChild = child->nextSibling();
-        moveChildTo(leftBase, leftBase->children(), child);
-        child = nextChild;
+    // Don't move any :after content
+    if (!beforeChild && isAfterContent(lastChild()))
+        beforeChild = lastChild();
+    
+    RenderObject* child;
+
+    if (childrenInline()) {
+        // === Inline flow source. ===
+        
+        if (toBase->childrenInline()) {
+            // --- Inline flow to inline flow ---
+            // The standard and easy case.
+            for (child = firstChild(); child != beforeChild; child = firstChild())
+                moveChildTo(toBase, toBase->children(), child);
+
+        } else {
+            // --- Inline flow to block flow ---
+            // We need to wrap the inline objects into an anonymous block.
+            // If toBase has a suitable block, we re-use it, otherwise create a new one.
+            RenderBlock* block;
+            RenderObject* lastChild = toBase->lastChild();
+            if (lastChild && lastChild->isAnonymousBlock() && lastChild->childrenInline()) {
+                block = toRenderBlock(lastChild);
+            } else {
+                block = toBase->createAnonymousBlock();
+                toBase->children()->appendChildNode(toBase, block);
+            }
+            for (child = firstChild(); child != beforeChild; child = firstChild())
+                moveChildTo(block, block->children(), child);
+        }
+    } else {
+        // === Block flow source. ===
+
+        if (toBase->childrenInline()) {
+            // --- Block flow to inline flow ---
+            // First check whether we move inline-only objects after all.
+            bool inlineOnly = true;
+            for (child = firstChild(); inlineOnly && child != beforeChild; child = child->nextSibling()) {
+                if (!child->isFloatingOrPositioned() && !(child->isAnonymousBlock() && child->childrenInline()))
+                    inlineOnly = false;
+            }
+            if (inlineOnly) {
+                // The reason why the base is in block flow must be after beforeChild.
+                // We therefore can extract the inline objects and move them to toBase.
+                for (child = firstChild(); child != beforeChild; child = firstChild()) {
+                    if (child->isAnonymousBlock()) {
+                        RenderBlock* anonBlock = toRenderBlock(child);
+                        ASSERT(anonBlock->childrenInline());
+                        ASSERT(!anonBlock->inlineContinuation());
+                        anonBlock->moveAllChildrenTo(toBase, toBase->children());
+                        anonBlock->deleteLineBoxTree();
+                        anonBlock->destroy();
+                    } else {
+                        ASSERT(child->isFloatingOrPositioned());
+                        moveChildTo(toBase, toBase->children(), child);
+                    }
+                }
+            } else {
+                // Moving block children -> have to set toBase as block flow
+                ASSERT(!toBase->firstChild());
+                toBase->makeChildrenNonInline();
+                // Move children, potentially collapsing anonymous block wrappers.
+                moveChildrenBlockFlowToBlockFlow(toBase, beforeChild);
+                // Now we need to check if the leftover children are all inline.
+                // If so, make this base inline again.
+                bool inlineOnly = true;
+                for (child = firstChild(); inlineOnly && child; child = child->nextSibling()) {
+                    if (!child->isFloatingOrPositioned() && !(child->isAnonymousBlock() && child->childrenInline()))
+                        inlineOnly = false;
+                }
+                if (inlineOnly) {
+                    RenderObject* next = 0;
+                    for (child = firstChild(); child; child = next) {
+                        next = child->nextSibling();
+                        if (child->isFloatingOrPositioned())
+                            continue;
+                        ASSERT(child->isAnonymousBlock());
+
+                        RenderBlock* anonBlock = toRenderBlock(child);
+                        ASSERT(anonBlock->childrenInline());
+                        ASSERT(!anonBlock->inlineContinuation());
+                        // Move inline children out of anonymous block.
+                        anonBlock->moveAllChildrenTo(this, children(), anonBlock);
+                        anonBlock->deleteLineBoxTree();
+                        anonBlock->destroy();
+                    }
+                }
+            }
+        } else {
+            // --- Block flow to Block flow ---
+            moveChildrenBlockFlowToBlockFlow(toBase, beforeChild);
+        }
     }
+
+    setNeedsLayoutAndPrefWidthsRecalc();
+    toBase->setNeedsLayoutAndPrefWidthsRecalc();
 }
 
-void RenderRubyBase::mergeWithRight(RenderBlock* rightBase)
+void RenderRubyBase::moveChildrenBlockFlowToBlockFlow(RenderBlock* toBase, RenderObject* beforeChild)
 {
-    // This function removes all children and prepends (!) them to rightBase.
-    ASSERT(rightBase);
-
-    RenderObject* firstPos = rightBase->firstChild();
-    RenderObject* child = lastChild();
-    while (child) {
-        moveChildTo(rightBase, rightBase->children(), firstPos, child);
-        firstPos = child;
-        child = lastChild();
+    // This function removes all children that are before (!) beforeChild
+    // and appends them to toBase.
+    ASSERT(!childrenInline());
+    ASSERT(toBase);
+    ASSERT(!toBase->childrenInline());
+
+    // If an anonymous block would be put next to another such block, then merge those.
+    if (beforeChild != firstChild()) {
+        RenderObject* firstChildHere = firstChild();
+        RenderObject* lastChildThere = toBase->lastChild();
+        if (firstChildHere && firstChildHere->isAnonymousBlock() && firstChildHere->childrenInline() && 
+            lastChildThere && lastChildThere->isAnonymousBlock() && lastChildThere->childrenInline() ) {
+            
+            RenderBlock* anonBlockHere = toRenderBlock(firstChildHere);
+            RenderBlock* anonBlockThere = toRenderBlock(lastChildThere); 
+            for (RenderObject* child = anonBlockHere->firstChild(); child; child = anonBlockHere->firstChild())
+                anonBlockHere->moveChildTo(anonBlockThere, anonBlockThere->children(), child);
+            anonBlockHere->deleteLineBoxTree();
+            anonBlockHere->destroy();
+        }
     }
+    // Move remaining children normally.
+    for (RenderObject* child = firstChild(); child != beforeChild; child = firstChild())
+        moveChildTo(toBase, toBase->children(), child);
 }
 
 } // namespace WebCore
