Index: content/browser/renderer_host/render_widget_host_impl.cc
diff --git a/content/browser/renderer_host/render_widget_host_impl.cc b/content/browser/renderer_host/render_widget_host_impl.cc
index 9a1d709a2ef00f024c3194de5ec841498afcfc3b..3e971a32c68b59b14ed1ba4ed154aae8c3a866e3 100644
--- a/content/browser/renderer_host/render_widget_host_impl.cc
+++ b/content/browser/renderer_host/render_widget_host_impl.cc
@@ -186,7 +186,6 @@ RenderWidgetHostImpl::RenderWidgetHostImpl(RenderWidgetHostDelegate* delegate,
       suppress_next_char_events_(false),
       pending_mouse_lock_request_(false),
       allow_privileged_mouse_lock_(false),
-      has_touch_handler_(false),
       last_input_number_(static_cast<int64>(GetProcess()->GetID()) << 32),
       next_browser_snapshot_id_(1),
       browser_composite_latency_history_(kBrowserCompositeLatencyHistorySize),
@@ -222,10 +221,7 @@ RenderWidgetHostImpl::RenderWidgetHostImpl(RenderWidgetHostDelegate* delegate,
   if (!hidden)
     process_->WidgetRestored();
 
-  input_router_.reset(new InputRouterImpl(
-      process_, this, this, routing_id_, GetInputRouterConfigForPlatform()));
-
-  touch_emulator_.reset();
+  ResetInputRouter();
 
   RenderViewHostImpl* rvh = static_cast<RenderViewHostImpl*>(
       IsRenderView() ? RenderViewHost::From(this) : NULL);
@@ -391,13 +387,18 @@ void RenderWidgetHostImpl::SuppressNextCharEvents() {
   suppress_next_char_events_ = true;
 }
 
+void RenderWidgetHostImpl::ResetPendingInput() {
+  if (input_router_->HasPendingEvents())
+    ResetInputRouter();
+}
+
 void RenderWidgetHostImpl::FlushInput() {
-  input_router_->Flush();
+  input_router_->RequestFlushedNotification();
   if (synthetic_gesture_controller_)
     synthetic_gesture_controller_->Flush(base::TimeTicks::Now());
 }
 
-void RenderWidgetHostImpl::SetNeedsFlush() {
+void RenderWidgetHostImpl::SetNeedsFlushInput() {
   if (view_)
     view_->OnSetNeedsFlushInput();
 }
@@ -896,15 +897,15 @@ void RenderWidgetHostImpl::ForwardWheelEventWithLatencyInfo(
       const ui::LatencyInfo& ui_latency) {
   TRACE_EVENT0("input", "RenderWidgetHostImpl::ForwardWheelEvent");
 
+  if (IgnoreInputEvents())
+    return;
+
   ui::LatencyInfo::InputCoordinate logical_coordinate(wheel_event.x,
                                                       wheel_event.y);
 
   ui::LatencyInfo latency_info = CreateInputEventLatencyInfoIfNotExist(
       &ui_latency, wheel_event.type, &logical_coordinate, 1);
 
-  if (IgnoreInputEvents())
-    return;
-
   if (touch_emulator_ && touch_emulator_->HandleMouseWheelEvent(wheel_event))
     return;
 
@@ -1287,8 +1288,7 @@ void RenderWidgetHostImpl::RendererExited(base::TerminationStatus status,
   // renderer. Otherwise it may be stuck waiting for the old renderer to ack an
   // event. (In particular, the above call to view_->RenderProcessGone will
   // destroy the aura window, which may dispatch a synthetic mouse move.)
-  input_router_.reset(new InputRouterImpl(
-      process_, this, this, routing_id_, GetInputRouterConfigForPlatform()));
+  ResetInputRouter();
 
   synthetic_gesture_controller_.reset();
 }
@@ -1416,6 +1416,12 @@ void RenderWidgetHostImpl::RendererIsResponsive() {
   }
 }
 
+void RenderWidgetHostImpl::ResetInputRouter() {
+  base::AutoReset<bool> reset_ignore_input_events(&ignore_input_events_, true);
+  input_router_.reset(new InputRouterImpl(
+      process_, this, this, routing_id_, GetInputRouterConfigForPlatform()));
+}
+
 void RenderWidgetHostImpl::OnRenderViewReady() {
   SendScreenRects();
   WasResized();
@@ -1857,15 +1863,9 @@ void RenderWidgetHostImpl::DecrementInFlightEventCount() {
   }
 }
 
-void RenderWidgetHostImpl::OnHasTouchEventHandlers(bool has_handlers) {
-  has_touch_handler_ = has_handlers;
-}
-
 void RenderWidgetHostImpl::DidFlush() {
   if (synthetic_gesture_controller_)
     synthetic_gesture_controller_->OnDidFlushInput();
-  if (view_)
-    view_->OnDidFlushInput();
 }
 
 void RenderWidgetHostImpl::DidOverscroll(const DidOverscrollParams& params) {
