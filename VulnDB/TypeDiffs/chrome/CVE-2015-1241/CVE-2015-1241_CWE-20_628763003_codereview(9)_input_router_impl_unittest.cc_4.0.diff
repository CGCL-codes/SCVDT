Index: content/browser/renderer_host/input/input_router_impl_unittest.cc
diff --git a/content/browser/renderer_host/input/input_router_impl_unittest.cc b/content/browser/renderer_host/input/input_router_impl_unittest.cc
index 732682113476fc295c7f38d96442e80d7ef96e80..103ceb9b78c028bc5d3874dccb92520bfedfb9ae 100644
--- a/content/browser/renderer_host/input/input_router_impl_unittest.cc
+++ b/content/browser/renderer_host/input/input_router_impl_unittest.cc
@@ -5,7 +5,6 @@
 #include <math.h>
 
 #include "base/basictypes.h"
-#include "base/command_line.h"
 #include "base/memory/scoped_ptr.h"
 #include "base/strings/utf_string_conversions.h"
 #include "content/browser/renderer_host/input/gesture_event_queue.h"
@@ -151,8 +150,6 @@ class InputRouterImplTest : public testing::Test {
     process_.reset(new MockRenderProcessHost(browser_context_.get()));
     client_.reset(new MockInputRouterClient());
     ack_handler_.reset(new MockInputAckHandler());
-    base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
-    command_line->AppendSwitch(switches::kValidateInputEventStream);
     input_router_.reset(new InputRouterImpl(process_.get(),
                                             client_.get(),
                                             ack_handler_.get(),
@@ -176,6 +173,7 @@ class InputRouterImplTest : public testing::Test {
     config_.touch_config.touch_ack_timeout_delay =
         base::TimeDelta::FromMilliseconds(timeout_ms);
     config_.touch_config.touch_ack_timeout_supported = true;
+    config_.validate_event_stream = true;
     TearDown();
     SetUp();
   }
@@ -287,8 +285,8 @@ class InputRouterImplTest : public testing::Test {
     return input_router()->touch_event_queue_.IsAckTimeoutEnabled();
   }
 
-  void Flush() const {
-    return input_router_->Flush();
+  void RequestFlushedNotification() const {
+    return input_router_->RequestFlushedNotification();
   }
 
   size_t GetAndResetDidFlushCount() {
@@ -623,7 +621,6 @@ TEST_F(InputRouterImplTest, TouchEventQueue) {
 // events and the outstanding ack is received.
 TEST_F(InputRouterImplTest, TouchEventQueueFlush) {
   OnHasTouchEventHandlers(true);
-  EXPECT_TRUE(client_->has_touch_handler());
   EXPECT_EQ(0U, GetSentMessageCountAndResetSink());
   EXPECT_TRUE(TouchEventQueueEmpty());
 
@@ -640,7 +637,6 @@ TEST_F(InputRouterImplTest, TouchEventQueueFlush) {
   // The page stops listening for touch-events. Note that flushing is deferred
   // until the outstanding ack is received.
   OnHasTouchEventHandlers(false);
-  EXPECT_FALSE(client_->has_touch_handler());
   EXPECT_EQ(0U, GetSentMessageCountAndResetSink());
   EXPECT_FALSE(TouchEventQueueEmpty());
   EXPECT_TRUE(input_router_->ShouldForwardTouchEvent());
@@ -1361,7 +1357,7 @@ TEST_F(InputRouterImplTest, InputFlush) {
   EXPECT_FALSE(HasPendingEvents());
 
   // Flushing an empty router should immediately trigger DidFlush.
-  Flush();
+  RequestFlushedNotification();
   EXPECT_EQ(1U, GetAndResetDidFlushCount());
   EXPECT_FALSE(HasPendingEvents());
 
@@ -1372,7 +1368,7 @@ TEST_F(InputRouterImplTest, InputFlush) {
   EXPECT_TRUE(HasPendingEvents());
 
   // DidFlush should be called only after the event is ack'ed.
-  Flush();
+  RequestFlushedNotification();
   EXPECT_EQ(0U, GetAndResetDidFlushCount());
   SendInputEventACK(WebInputEvent::TouchStart,
                     INPUT_EVENT_ACK_STATE_NOT_CONSUMED);
@@ -1391,11 +1387,11 @@ TEST_F(InputRouterImplTest, InputFlush) {
                        blink::WebGestureDeviceTouchscreen);
   SimulateGestureEvent(WebInputEvent::GesturePinchUpdate,
                        blink::WebGestureDeviceTouchscreen);
-  Flush();
+  RequestFlushedNotification();
   EXPECT_EQ(0U, GetAndResetDidFlushCount());
 
   // Repeated flush calls should have no effect.
-  Flush();
+  RequestFlushedNotification();
   EXPECT_EQ(0U, GetAndResetDidFlushCount());
 
   // There are still pending gestures.
@@ -1717,4 +1713,8 @@ TEST_F(InputRouterImplTest, OverscrollDispatch) {
             client_overscroll.current_fling_velocity);
 }
 
+TEST_F(InputRouterImplTest, Recycle) {
+  // TODO(jdduke): Implement.
+}
+
 }  // namespace content
