Index: content/browser/renderer_host/render_widget_host_view_android.cc
diff --git a/content/browser/renderer_host/render_widget_host_view_android.cc b/content/browser/renderer_host/render_widget_host_view_android.cc
index 3a2dc883f4031ea824c2b2088f2d1ecfceae9ecb..b28169be452e881bb79568b5c802f817b5e6b691 100644
--- a/content/browser/renderer_host/render_widget_host_view_android.cc
+++ b/content/browser/renderer_host/render_widget_host_view_android.cc
@@ -724,8 +724,10 @@ bool RenderWidgetHostViewAndroid::OnTouchEvent(
   // Send a proactive BeginFrame on the next vsync to reduce latency.
   // This is good enough as long as the first touch event has Begin semantics
   // and the actual scroll happens on the next vsync.
-  if (observing_root_window_)
+  if (observing_root_window_ &&
+      event.GetAction() != ui::MotionEvent::ACTION_CANCEL) {
     RequestVSyncUpdate(BEGIN_FRAME);
+  }
 
   return true;
 }
@@ -736,7 +738,7 @@ bool RenderWidgetHostViewAndroid::OnTouchHandleEvent(
          selection_controller_->WillHandleTouchEvent(event);
 }
 
-void RenderWidgetHostViewAndroid::ResetGestureDetection() {
+void RenderWidgetHostViewAndroid::CancelActiveTouchSequence() {
   const ui::MotionEvent* current_down_event =
       gesture_provider_.GetCurrentDownEvent();
   if (!current_down_event)
@@ -747,6 +749,13 @@ void RenderWidgetHostViewAndroid::ResetGestureDetection() {
   OnTouchEvent(*cancel_event);
 }
 
+void RenderWidgetHostViewAndroid::ResetPendingInput() {
+  CancelActiveTouchSequence();
+  gesture_provider_.ResetDetection();
+  if (host_)
+    host_->ResetPendingInput();
+}
+
 void RenderWidgetHostViewAndroid::SetDoubleTapSupportEnabled(bool enabled) {
   gesture_provider_.SetDoubleTapSupportForPlatformEnabled(enabled);
 }
