Index: ui/events/gesture_detection/touch_disposition_gesture_filter.cc
diff --git a/ui/events/gesture_detection/touch_disposition_gesture_filter.cc b/ui/events/gesture_detection/touch_disposition_gesture_filter.cc
index fcb92d495d4bca53df5016a50209ccfe95328076..aac14f40ad3abf53fc258abda1bc09ad7ccd4196 100644
--- a/ui/events/gesture_detection/touch_disposition_gesture_filter.cc
+++ b/ui/events/gesture_detection/touch_disposition_gesture_filter.cc
@@ -183,6 +183,7 @@ void TouchDispositionGestureFilter::OnTouchEventAck(bool event_consumed) {
   // Dispatch the packet corresponding to the ack'ed touch, as well as any
   // additional timeout-based packets queued before the ack was received.
   bool touch_packet_for_current_ack_handled = false;
+  bool sequence_cancelled = false;
   while (!sequence.empty()) {
     DCHECK_NE(sequence.front().gesture_source(),
               GestureEventDataPacket::UNDEFINED);
@@ -197,6 +198,8 @@ void TouchDispositionGestureFilter::OnTouchEventAck(bool event_consumed) {
         break;
       state_.OnTouchEventAck(event_consumed, IsTouchStartEvent(source));
       touch_packet_for_current_ack_handled = true;
+      sequence_cancelled =
+          source == GestureEventDataPacket::TOUCH_SEQUENCE_CANCEL;
     }
     // We need to pop the current sequence before sending the packet, because
     // sending the packet could result in this method being re-entered (e.g. on
@@ -206,6 +209,10 @@ void TouchDispositionGestureFilter::OnTouchEventAck(bool event_consumed) {
     sequence.pop();
     FilterAndSendPacket(packet);
   }
+
+  if (sequence.empty() && sequence_cancelled)
+    PopGestureSequence();
+
   DCHECK(touch_packet_for_current_ack_handled);
 }
 
