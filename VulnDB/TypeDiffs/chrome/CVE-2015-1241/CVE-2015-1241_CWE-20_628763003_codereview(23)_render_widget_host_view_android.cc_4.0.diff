Index: content/browser/renderer_host/render_widget_host_view_android.cc
diff --git a/content/browser/renderer_host/render_widget_host_view_android.cc b/content/browser/renderer_host/render_widget_host_view_android.cc
index bcbe54799e7b24fa128db02945f9ad2a38272dd4..d666a545568ec88e500494599b8b00064ab0aa82 100644
--- a/content/browser/renderer_host/render_widget_host_view_android.cc
+++ b/content/browser/renderer_host/render_widget_host_view_android.cc
@@ -44,6 +44,7 @@
 #include "content/browser/renderer_host/compositor_impl_android.h"
 #include "content/browser/renderer_host/dip_util.h"
 #include "content/browser/renderer_host/image_transport_factory_android.h"
+#include "content/browser/renderer_host/input/input_router.h"
 #include "content/browser/renderer_host/input/synthetic_gesture_target_android.h"
 #include "content/browser/renderer_host/input/touch_selection_controller.h"
 #include "content/browser/renderer_host/input/web_input_event_builders_android.h"
@@ -69,7 +70,7 @@
 #include "ui/base/android/window_android.h"
 #include "ui/base/android/window_android_compositor.h"
 #include "ui/events/gesture_detection/gesture_config_helper.h"
-#include "ui/events/gesture_detection/motion_event.h"
+#include "ui/events/gesture_detection/motion_event_generic.h"
 #include "ui/gfx/android/device_display_info.h"
 #include "ui/gfx/android/java_bitmap.h"
 #include "ui/gfx/android/view_configuration.h"
@@ -723,8 +724,10 @@ bool RenderWidgetHostViewAndroid::OnTouchEvent(
   // Send a proactive BeginFrame on the next vsync to reduce latency.
   // This is good enough as long as the first touch event has Begin semantics
   // and the actual scroll happens on the next vsync.
-  if (observing_root_window_)
+  if (observing_root_window_ &&
+      event.GetAction() != ui::MotionEvent::ACTION_CANCEL) {
     RequestVSyncUpdate(BEGIN_FRAME);
+  }
 
   return true;
 }
@@ -738,12 +741,22 @@ bool RenderWidgetHostViewAndroid::OnTouchHandleEvent(
 void RenderWidgetHostViewAndroid::ResetGestureDetection() {
   const ui::MotionEvent* current_down_event =
       gesture_provider_.GetCurrentDownEvent();
-  if (!current_down_event)
-    return;
+  // Prefer using the GestureProvider's active down event for cancellation. If
+  // none such exists, insert a synthetic cancel to prevent timer-based gesture
+  // detection, relying on touch filtering to drop the synthetic cancel as
+  // appropriate for the current event stream.
+  if (current_down_event) {
+    scoped_ptr<ui::MotionEvent> actual_cancel = current_down_event->Cancel();
+    OnTouchEvent(*actual_cancel);
+  } else {
+    ui::MotionEventGeneric synthetic_cancel(ui::MotionEvent::ACTION_CANCEL,
+                                            base::TimeTicks::Now(),
+                                            ui::PointerProperties());
+    OnTouchEvent(synthetic_cancel);
+  }
 
-  scoped_ptr<ui::MotionEvent> cancel_event = current_down_event->Cancel();
-  DCHECK(cancel_event);
-  OnTouchEvent(*cancel_event);
+  if (host_)
+    host_->input_router()->Recycle();
 }
 
 void RenderWidgetHostViewAndroid::SetDoubleTapSupportEnabled(bool enabled) {
