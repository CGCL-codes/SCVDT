diff --git a/lib/softoken/pkcs11c.c b/lib/softoken/pkcs11c.c
--- a/lib/softoken/pkcs11c.c
+++ b/lib/softoken/pkcs11c.c
@@ -2856,17 +2856,27 @@ sftk_hashCheckSign(SFTKHashVerifyInfo *i
                              digestLen);
 }
 
 SECStatus
 RSA_HashCheckSign(SECOidTag digestOid, NSSLOWKEYPublicKey *key,
                   const unsigned char *sig, unsigned int sigLen,
                   const unsigned char *digestData, unsigned int digestLen)
 {
-    unsigned char pkcs1DigestInfoData[SGN_PKCS1_DIGESTINFO_LENGTH_MAX];
+    /* The maximum encoded DigestInfo from a RSA PKCS#1 signature is:
+     * 10 + HASH_LENGTH_MAX + the largest encoding of an supported digest Oid.
+     * At the time of writing, this number was 9.
+     * Should the set of allowed digests ever get extended beyond this set:
+     *   SEC_OID_MD5, SEC_OID_SHA1, SEC_OID_SHA224, SEC_OID_SHA256,
+     *   SEC_OID_SHA384, SEC_OID_SHA512
+     * then the maximum number will have to be recalculated.
+     * For now we assume that 99 bytes should be a safe maximum.
+     * See also the implementation of SGN_VerifyPKCS1DigestInfo.
+     */
+    unsigned char pkcs1DigestInfoData[10 + HASH_LENGTH_MAX + 99];
     SECItem pkcs1DigestInfo;
     SECItem digest;
 
     pkcs1DigestInfo.data = pkcs1DigestInfoData;
     pkcs1DigestInfo.len = sizeof(pkcs1DigestInfoData);
     /* decrypt the block */
     if (RSA_CheckSignRecover(&key->u.rsa, pkcs1DigestInfo.data,
                              &pkcs1DigestInfo.len, pkcs1DigestInfo.len,
