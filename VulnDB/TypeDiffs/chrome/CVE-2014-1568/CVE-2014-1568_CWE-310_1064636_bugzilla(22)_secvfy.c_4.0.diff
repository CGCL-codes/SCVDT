diff --git a/lib/cryptohi/secvfy.c b/lib/cryptohi/secvfy.c
--- a/lib/cryptohi/secvfy.c
+++ b/lib/cryptohi/secvfy.c
@@ -11,27 +11,19 @@
 #include "keyhi.h"
 #include "secasn1.h"
 #include "secoid.h"
 #include "pk11func.h"
 #include "secdig.h"
 #include "secerr.h"
 #include "keyi.h"
 
-/*
-** Decrypt signature block using public key
-** Store the hash algorithm oid tag in *tagp
-** Store the digest in the digest buffer
-** Store the digest length in *digestlen
-** XXX this is assuming that the signature algorithm has WITH_RSA_ENCRYPTION
-*/
 static SECStatus
-DecryptSigBlock(SECOidTag *tagp, unsigned char *digest,
-		unsigned int *digestlen, unsigned int maxdigestlen,
-		SECKEYPublicKey *key, const SECItem *sig, char *wincx)
+GetAlgorithmForUnknownDigestInfo(SECKEYPublicKey* key, const SECItem* sig,
+                                 SECOidTag* algorithm, void* wincx)
 {
     SGNDigestInfo *di   = NULL;
     unsigned char *buf  = NULL;
     SECStatus      rv;
     SECOidTag      tag;
     SECItem        it;
 
     if (key == NULL) goto loser;
@@ -45,73 +37,60 @@ DecryptSigBlock(SECOidTag *tagp, unsigne
     rv = PK11_VerifyRecover(key, (SECItem *)sig, &it, wincx);
     if (rv != SECSuccess) goto loser;
 
     di = SGN_DecodeDigestInfo(&it);
     if (di == NULL) goto sigloser;
 
     /*
     ** Finally we have the digest info; now we can extract the algorithm
-    ** ID and the signature block
+    ** ID
     */
     tag = SECOID_GetAlgorithmTag(&di->digestAlgorithm);
     /* Check that tag is an appropriate algorithm */
     if (tag == SEC_OID_UNKNOWN) {
 	goto sigloser;
     }
-    /* make sure the "parameters" are not too bogus. */
-    if (di->digestAlgorithm.parameters.len > 2) {
-	goto sigloser;
-    }
-    if (di->digest.len > maxdigestlen) {
-	PORT_SetError(SEC_ERROR_OUTPUT_LEN);
-	goto loser;
-    }
-    PORT_Memcpy(digest, di->digest.data, di->digest.len);
-    *tagp = tag;
-    *digestlen = di->digest.len;
     goto done;
 
   sigloser:
     PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
 
   loser:
     rv = SECFailure;
 
   done:
     if (di   != NULL) SGN_DestroyDigestInfo(di);
     if (buf  != NULL) PORT_Free(buf);
     
     return rv;
 }
 
-
 struct VFYContextStr {
     SECOidTag hashAlg;  /* the hash algorithm */
     SECKEYPublicKey *key;
     /*
-     * This buffer holds either the digest or the full signature
-     * depending on the type of the signature (key->keyType).  It is
-     * defined as a union to make sure it always has enough space.
+     * This buffer holds the full signature. It is defined as a union to make
+     * sure it always has enough space.
      *
      * Use the "buffer" union member to reference the buffer.
      * Note: do not take the size of the "buffer" union member.  Take
      * the size of the union or some other union member instead.
      */
     union {
 	unsigned char buffer[1];
 
-	/* the digest in the decrypted RSA signature */
-	unsigned char rsadigest[HASH_LENGTH_MAX];
+	/* the full RSA signature */
+	unsigned char rsasig[RSA_MAX_MODULUS_BITS / 8];
 	/* the full DSA signature... 40 bytes */
 	unsigned char dsasig[DSA_MAX_SIGNATURE_LEN];
 	/* the full ECDSA signature */
 	unsigned char ecdsasig[2 * MAX_ECKEY_LEN];
     } u;
-    unsigned int rsadigestlen;
+    unsigned int rsasiglen;
     void * wincx;
     void *hashcx;
     const SECHashObject *hashobj;
     SECOidTag encAlg;  /* enc alg */
     PRBool hasSignature;  /* true if the signature was provided in the
                            * VFY_CreateContext call.  If false, the
                            * signature must be provided with a
                            * VFY_EndWithSignature call. */
@@ -375,22 +354,26 @@ vfy_CreateContext(const SECKEYPublicKey 
     cx->hasSignature = (sig != NULL);
     cx->encAlg = encAlg;
     cx->hashAlg = hashAlg;
     cx->key = SECKEY_CopyPublicKey(key);
     rv = SECSuccess;
     if (sig) {
 	switch (type) {
 	case rsaKey:
-	    rv = DecryptSigBlock(&cx->hashAlg, cx->u.buffer, &cx->rsadigestlen,
-			HASH_LENGTH_MAX, cx->key, sig, (char*)wincx);
-	    if (cx->hashAlg != hashAlg && hashAlg != SEC_OID_UNKNOWN) {
-		PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
-		rv = SECFailure;	
-	    }
+            cx->rsasiglen = sig->len;
+            if (cx->rsasiglen > sizeof(cx->u.rsasig)) {
+                PORT_SetError(SEC_ERROR_INPUT_LEN);
+                rv = SECFailure;
+                break;
+            }
+            if (cx->hashAlg == SEC_OID_UNKNOWN) {
+                rv = GetAlgorithmForUnknownDigestInfo(cx->key, sig,
+                                                      &cx->hashAlg, wincx);
+            }
 	    break;
 	case dsaKey:
 	case ecKey:
 	    sigLen = SECKEY_SignatureLen(key);
 	    if (sigLen == 0) {
 		/* error set by SECKEY_SignatureLen */
 		rv = SECFailure;	
 		break;
@@ -501,129 +484,137 @@ VFY_Update(VFYContext *cx, const unsigne
     if (cx->hashcx == NULL) {
 	PORT_SetError(SEC_ERROR_INVALID_ARGS);
 	return SECFailure;
     }
     (*cx->hashobj->update)(cx->hashcx, input, inputLen);
     return SECSuccess;
 }
 
-SECStatus
-VFY_EndWithSignature(VFYContext *cx, SECItem *sig)
+static SECStatus
+vfy_VerifyDigestInternal(VFYContext *cx, const SECItem* digest,
+                         const SECItem* sig)
 {
-    unsigned char final[HASH_LENGTH_MAX];
-    unsigned part;
-    SECItem hash,dsasig; /* dsasig is also used for ECDSA */
+    SECItem hash, dsasig, rsasig; /* dsasig is also used for ECDSA */
     SECStatus rv;
+    SGNDigestInfo* digestInfo = NULL;
+    SECItem* encodedDigestInfo = NULL;
 
     if ((cx->hasSignature == PR_FALSE) && (sig == NULL)) {
 	PORT_SetError(SEC_ERROR_INVALID_ARGS);
 	return SECFailure;
     }
 
-    if (cx->hashcx == NULL) {
-	PORT_SetError(SEC_ERROR_INVALID_ARGS);
-	return SECFailure;
-    }
-    (*cx->hashobj->end)(cx->hashcx, final, &part, sizeof(final));
     switch (cx->key->keyType) {
       case ecKey:
       case dsaKey:
 	dsasig.data = cx->u.buffer;
 	dsasig.len = SECKEY_SignatureLen(cx->key);
 	if (dsasig.len == 0) {
 	    return SECFailure;
 	} 
 	if (sig) {
 	    rv = decodeECorDSASignature(cx->encAlg, sig, dsasig.data,
 					dsasig.len);
 	    if (rv != SECSuccess) {
 		PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
 		return SECFailure;
 	    }
 	} 
-	hash.data = final;
-	hash.len = part;
 	if (PK11_Verify(cx->key,&dsasig,&hash,cx->wincx) != SECSuccess) {
 		PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
 		return SECFailure;
 	}
 	break;
       case rsaKey:
-	if (sig) {
-	    SECOidTag hashid = SEC_OID_UNKNOWN;
-	    rv = DecryptSigBlock(&hashid, cx->u.buffer, &cx->rsadigestlen,
-		    HASH_LENGTH_MAX, cx->key, sig, (char*)cx->wincx);
-	    if ((rv != SECSuccess) || (hashid != cx->hashAlg)) {
-		PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
-		return SECFailure;
-	    }
-	}
-	if ((part != cx->rsadigestlen) ||
-	    PORT_Memcmp(final, cx->u.buffer, part)) {
-	    PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
-	    return SECFailure;
-	}
+        if (!sig) {
+            rsasig.data = cx->u.buffer;
+            rsasig.len = cx->rsasiglen;
+            sig = &rsasig;
+        }
+        digestInfo = SGN_CreateDigestInfo(cx->hashAlg, digest->data,
+                                          digest->len);
+        if (!digestInfo) {
+            PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
+            return SECFailure;
+        }
+        /* Allocate from the digestInfo arena, as it will be freed before
+         * this returns.
+         */
+        encodedDigestInfo = SGN_EncodeDigestInfo(digestInfo->arena, NULL,
+                                                 digestInfo);
+        /* Try to verify with a properly encoded NULL params. */
+        if (encodedDigestInfo && PK11_Verify(cx->key, sig, encodedDigestInfo,
+                                             cx->wincx) != SECSuccess) {
+            /* Fall back to improperly encoded, omitted params */
+            digestInfo->digestAlgorithm.parameters.len = 0;
+            digestInfo->digestAlgorithm.parameters.data = NULL;
+            encodedDigestInfo = SGN_EncodeDigestInfo(digestInfo->arena, NULL,
+                                                     digestInfo);
+        }
+        if (encodedDigestInfo && PK11_Verify(cx->key, sig, encodedDigestInfo,
+                                             cx->wincx) == SECSuccess) {
+            rv = SECSuccess;
+        } else {
+            rv = SECFailure;
+        }
+        /* This also frees encodedDigestInfo */
+        SGN_DestroyDigestInfo(digestInfo);
+        if (rv == SECFailure) {
+            PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
+        }
 	break;
       default:
 	PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
 	return SECFailure; /* shouldn't happen */
     }
     return SECSuccess;
 }
 
 SECStatus
+VFY_EndWithSignature(VFYContext *cx, SECItem *sig)
+{
+    unsigned char final[HASH_LENGTH_MAX];
+    unsigned part;
+    SECItem hash;
+
+    if (cx->hashcx == NULL) {
+	PORT_SetError(SEC_ERROR_INVALID_ARGS);
+	return SECFailure;
+    }
+    (*cx->hashobj->end)(cx->hashcx, final, &part, sizeof(final));
+    hash.data = final;
+    hash.len = part;
+
+    return vfy_VerifyDigestInternal(cx, &hash, sig);
+}
+
+SECStatus
 VFY_End(VFYContext *cx)
 {
     return VFY_EndWithSignature(cx,NULL);
 }
 
 /************************************************************************/
 /*
  * Verify that a previously-computed digest matches a signature.
  */
 static SECStatus
 vfy_VerifyDigest(const SECItem *digest, const SECKEYPublicKey *key, 
 		 const SECItem *sig, SECOidTag encAlg, SECOidTag hashAlg,
 		 void *wincx)
 {
     SECStatus rv;
     VFYContext *cx;
-    SECItem dsasig; /* also used for ECDSA */
 
     rv = SECFailure;
 
     cx = vfy_CreateContext(key, sig, encAlg, hashAlg, NULL, wincx);
     if (cx != NULL) {
-	switch (key->keyType) {
-	case rsaKey:
-	    if ((digest->len != cx->rsadigestlen) ||
-		PORT_Memcmp(digest->data, cx->u.buffer, digest->len)) {
-		PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
-	    } else {
-		rv = SECSuccess;
-	    }
-	    break;
-	case dsaKey:
-	case ecKey:
-	    dsasig.data = cx->u.buffer;
-	    dsasig.len = SECKEY_SignatureLen(cx->key);
-	    if (dsasig.len == 0) {
-		break;
-	    }
-	    if (PK11_Verify(cx->key, &dsasig, (SECItem *)digest, cx->wincx)
-		!= SECSuccess) {
-		PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
-	    } else {
-		rv = SECSuccess;
-	    }
-	    break;
-	default:
-	    break;
-	}
+        rv = vfy_VerifyDigestInternal(cx, digest, sig);
 	VFY_DestroyContext(cx, PR_TRUE);
     }
     return rv;
 }
 
 SECStatus
 VFY_VerifyDigestDirect(const SECItem *digest, const SECKEYPublicKey *key, 
 		       const SECItem *sig, SECOidTag encAlg, 
