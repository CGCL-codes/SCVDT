diff --git a/lib/softoken/pkcs11c.c b/lib/softoken/pkcs11c.c
--- a/lib/softoken/pkcs11c.c
+++ b/lib/softoken/pkcs11c.c
@@ -2857,65 +2857,53 @@ sftk_hashCheckSign(SFTKHashVerifyInfo *i
 
 SECStatus
 RSA_HashCheckSign(SECOidTag hashOid, NSSLOWKEYPublicKey *key,
                   const unsigned char *sig, unsigned int sigLen,
                   const unsigned char *hash, unsigned int hashLen)
 {
     SECItem it;
     SGNDigestInfo *di = NULL;
+    SECItem *encodedDi = NULL;
     SECStatus rv = SECSuccess;
 
-    it.data = NULL;
-    it.len = nsslowkey_PublicModulusLen(key);
-    if (!it.len) {
-        goto loser;
-    }
-
-    it.data = (unsigned char *)PORT_Alloc(it.len);
-    if (it.data == NULL) {
-        goto loser;
-    }
-
-    /* decrypt the block */
-    rv = RSA_CheckSignRecover(&key->u.rsa, it.data, &it.len, it.len, sig,
-                              sigLen);
-    if (rv != SECSuccess) {
-        goto loser;
-    }
-
-    di = SGN_DecodeDigestInfo(&it);
+    di = SGN_CreateDigestInfo(hashOid, hash, hashLen);
     if (di == NULL) {
         goto loser;
     }
-    if (di->digest.len != hashLen) {
-        goto loser; 
-    }
-
-    /* make sure the tag is OK */
-    if (SECOID_GetAlgorithmTag(&di->digestAlgorithm) != hashOid) {
+    encodedDi = SGN_EncodeDigestInfo(di->arena, NULL, di);
+    if (encodedDi == NULL) {
         goto loser;
     }
-    /* make sure the "parameters" are not too bogus. */
-    if (di->digestAlgorithm.parameters.len > 2) {
+    /* Attempt to verify with proper encoding (explicit NULL parameter) */
+    rv = RSA_CheckSign(&key->u.rsa, sig, sigLen, encodedDi->data,
+                       encodedDi->len);
+    if (rv == SECSuccess) {
+        goto done; /* Success! */
+    }
+    /* Fall back to degenerate encoding where parameters was omitted, which
+     * is a violation of RFC 3447. This is only included for backwards
+     * compatability */
+    di->digestAlgorithm.parameters.len = 0;
+    di->digestAlgorithm.parameters.data = NULL;
+    encodedDi = SGN_EncodeDigestInfo(di->arena, NULL, di);
+    if (encodedDi == NULL) {
         goto loser;
     }
-    /* Now check the signature */
-    if (PORT_Memcmp(hash, di->digest.data, di->digest.len) == 0) {
-        goto done;
+    rv = RSA_CheckSign(&key->u.rsa, sig, sigLen, encodedDi->data,
+                       encodedDi->len);
+    if (rv == SECSuccess) {
+        goto done; /* Success, but for dengenerate sigs */
     }
 
   loser:
     PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
     rv = SECFailure;
 
   done:
-    if (it.data != NULL) {
-        PORT_Free(it.data);
-    }
     if (di != NULL) {
         SGN_DestroyDigestInfo(di);
     }
 
     return rv;
 }
 
 static SECStatus
