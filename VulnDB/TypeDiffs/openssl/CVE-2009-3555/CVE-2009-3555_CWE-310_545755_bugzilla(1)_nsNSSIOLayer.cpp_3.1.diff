diff --git a/security/manager/ssl/src/nsNSSIOLayer.cpp b/security/manager/ssl/src/nsNSSIOLayer.cpp
--- a/security/manager/ssl/src/nsNSSIOLayer.cpp
+++ b/security/manager/ssl/src/nsNSSIOLayer.cpp
@@ -81,16 +81,17 @@
 #include "nsNSSCleaner.h"
 #include "nsThreadUtils.h"
 #include "nsIDocShell.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsISecureBrowserUI.h"
 #include "nsProxyRelease.h"
 #include "nsIClassInfoImpl.h"
 #include "nsIProgrammingLanguage.h"
+#include "nsCommaSeparatedTokenizer.h"
 
 #include "ssl.h"
 #include "secerr.h"
 #include "sslerr.h"
 #include "secder.h"
 #include "secasn1.h"
 #include "certdb.h"
 #include "cert.h"
@@ -824,16 +825,21 @@ PRBool nsNSSSocketInfo::HandshakeTimeout
 
 void nsSSLIOLayerHelpers::Cleanup()
 {
   if (mTLSIntolerantSites) {
     delete mTLSIntolerantSites;
     mTLSIntolerantSites = nsnull;
   }
 
+  if (mRenegoUnrestrictedSites) {
+    delete mRenegoUnrestrictedSites;
+    mRenegoUnrestrictedSites = nsnull;
+  }
+
   if (mSharedPollableEvent)
     PR_DestroyPollableEvent(mSharedPollableEvent);
 
   if (mutex) {
     PR_DestroyLock(mutex);
     mutex = nsnull;
   }
 
@@ -1923,16 +1929,18 @@ nsSSLIOLayerPoll(PRFileDesc *fd, PRInt16
 }
 
 PRBool nsSSLIOLayerHelpers::nsSSLIOLayerInitialized = PR_FALSE;
 PRDescIdentity nsSSLIOLayerHelpers::nsSSLIOLayerIdentity;
 PRIOMethods nsSSLIOLayerHelpers::nsSSLIOLayerMethods;
 PRLock *nsSSLIOLayerHelpers::mutex = nsnull;
 nsCStringHashSet *nsSSLIOLayerHelpers::mTLSIntolerantSites = nsnull;
 nsPSMRememberCertErrorsTable *nsSSLIOLayerHelpers::mHostsWithCertErrors = nsnull;
+nsCStringHashSet *nsSSLIOLayerHelpers::mRenegoUnrestrictedSites = nsnull;
+PRBool nsSSLIOLayerHelpers::mTreatUnsafeNegotiationAsBroken = PR_FALSE;
 PRFileDesc *nsSSLIOLayerHelpers::mSharedPollableEvent = nsnull;
 nsNSSSocketInfo *nsSSLIOLayerHelpers::mSocketOwningPollableEvent = nsnull;
 PRBool nsSSLIOLayerHelpers::mPollableEventCurrentlySet = PR_FALSE;
 
 static PRIntn _PSM_InvalidInt(void)
 {
     PR_ASSERT(!"I/O method is invalid");
     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
@@ -2132,16 +2140,24 @@ nsresult nsSSLIOLayerHelpers::Init()
   // if we can not get a pollable event, we'll have to do busy waiting
 
   mTLSIntolerantSites = new nsCStringHashSet();
   if (!mTLSIntolerantSites)
     return NS_ERROR_OUT_OF_MEMORY;
 
   mTLSIntolerantSites->Init(1);
 
+  mRenegoUnrestrictedSites = new nsCStringHashSet();
+  if (!mRenegoUnrestrictedSites)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  mRenegoUnrestrictedSites->Init(1);
+
+  mTreatUnsafeNegotiationAsBroken = PR_FALSE;
+  
   mHostsWithCertErrors = new nsPSMRememberCertErrorsTable();
   if (!mHostsWithCertErrors)
     return NS_ERROR_OUT_OF_MEMORY;
 
   return NS_OK;
 }
 
 void nsSSLIOLayerHelpers::addIntolerantSite(const nsCString &str)
@@ -2151,16 +2167,59 @@ void nsSSLIOLayerHelpers::addIntolerantS
 }
 
 PRBool nsSSLIOLayerHelpers::isKnownAsIntolerantSite(const nsCString &str)
 {
   nsAutoLock lock(mutex);
   return mTLSIntolerantSites->Contains(str);
 }
 
+void nsSSLIOLayerHelpers::setRenegoUnrestrictedSites(const nsCString &str)
+{
+  nsAutoLock lock(mutex);
+  
+  if (mRenegoUnrestrictedSites) {
+    delete mRenegoUnrestrictedSites;
+    mRenegoUnrestrictedSites = nsnull;
+  }
+
+  mRenegoUnrestrictedSites = new nsCStringHashSet();
+  if (!mRenegoUnrestrictedSites)
+    return;
+  
+  mRenegoUnrestrictedSites->Init(1);
+  
+  nsCCommaSeparatedTokenizer toker(str);
+
+  while (toker.hasMoreTokens()) {
+    const nsCSubstring &host = toker.nextToken();
+    if (!host.IsEmpty()) {
+      mRenegoUnrestrictedSites->Put(host);
+    }
+  }
+}
+
+PRBool nsSSLIOLayerHelpers::isRenegoUnrestrictedSite(const nsCString &str)
+{
+  nsAutoLock lock(mutex);
+  return mRenegoUnrestrictedSites->Contains(str);
+}
+
+void nsSSLIOLayerHelpers::setTreatUnsafeNegotiationAsBroken(PRBool broken)
+{
+  nsAutoLock lock(mutex);
+  mTreatUnsafeNegotiationAsBroken = broken;
+}
+
+PRBool nsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken()
+{
+  nsAutoLock lock(mutex);
+  return mTreatUnsafeNegotiationAsBroken;
+}
+
 nsresult
 nsSSLIOLayerNewSocket(PRInt32 family,
                       const char *host,
                       PRInt32 port,
                       const char *proxyHost,
                       PRInt32 proxyPort,
                       PRFileDesc **fd,
                       nsISupports** info,
@@ -3440,16 +3499,25 @@ nsSSLIOLayerSetOptions(PRFileDesc *fd, P
   if (SECSuccess != SSL_OptionSet(fd, SSL_HANDSHAKE_AS_CLIENT, PR_TRUE)) {
     return NS_ERROR_FAILURE;
   }
   if (SECSuccess != SSL_BadCertHook(fd, (SSLBadCertHandler) nsNSSBadCertHandler,
                                     infoObject)) {
     return NS_ERROR_FAILURE;
   }
 
+  if (nsSSLIOLayerHelpers::isRenegoUnrestrictedSite(nsDependentCString(host))) {
+    if (SECSuccess != SSL_OptionSet(fd, SSL_REQUIRE_SAFE_NEGOTIATION, PR_FALSE)) {
+      return NS_ERROR_FAILURE;
+    }
+    if (SECSuccess != SSL_OptionSet(fd, SSL_ENABLE_RENEGOTIATION, SSL_RENEGOTIATE_UNRESTRICTED)) {
+      return NS_ERROR_FAILURE;
+    }
+  }
+
   // Set the Peer ID so that SSL proxy connections work properly.
   char *peerId;
   if (anonymousLoad) {  // See bug #466080. Separate the caches.
       peerId = PR_smprintf("anon:%s:%d", host, port);
   } else {
       peerId = PR_smprintf("%s:%d", host, port);
   }
   
