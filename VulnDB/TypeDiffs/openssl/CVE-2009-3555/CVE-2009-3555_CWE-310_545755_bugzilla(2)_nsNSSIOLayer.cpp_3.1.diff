diff --git a/security/manager/ssl/src/nsNSSIOLayer.cpp b/security/manager/ssl/src/nsNSSIOLayer.cpp
--- a/security/manager/ssl/src/nsNSSIOLayer.cpp
+++ b/security/manager/ssl/src/nsNSSIOLayer.cpp
@@ -81,16 +81,17 @@
 #include "nsNSSCleaner.h"
 #include "nsThreadUtils.h"
 #include "nsIDocShell.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsISecureBrowserUI.h"
 #include "nsProxyRelease.h"
 #include "nsIClassInfoImpl.h"
 #include "nsIProgrammingLanguage.h"
+#include "nsCommaSeparatedTokenizer.h"
 
 #include "ssl.h"
 #include "secerr.h"
 #include "sslerr.h"
 #include "secder.h"
 #include "secasn1.h"
 #include "certdb.h"
 #include "cert.h"
@@ -831,16 +832,21 @@ void nsSSLIOLayerHelpers::Cleanup()
     mTLSIntolerantSites = nsnull;
   }
 
   if (mTLSTolerantSites) {
     delete mTLSTolerantSites;
     mTLSTolerantSites = nsnull;
   }
 
+  if (mRenegoUnrestrictedSites) {
+    delete mRenegoUnrestrictedSites;
+    mRenegoUnrestrictedSites = nsnull;
+  }
+
   if (mSharedPollableEvent)
     PR_DestroyPollableEvent(mSharedPollableEvent);
 
   if (mutex) {
     PR_DestroyLock(mutex);
     mutex = nsnull;
   }
 
@@ -1963,16 +1969,18 @@ nsSSLIOLayerPoll(PRFileDesc *fd, PRInt16
 
 PRBool nsSSLIOLayerHelpers::nsSSLIOLayerInitialized = PR_FALSE;
 PRDescIdentity nsSSLIOLayerHelpers::nsSSLIOLayerIdentity;
 PRIOMethods nsSSLIOLayerHelpers::nsSSLIOLayerMethods;
 PRLock *nsSSLIOLayerHelpers::mutex = nsnull;
 nsCStringHashSet *nsSSLIOLayerHelpers::mTLSIntolerantSites = nsnull;
 nsCStringHashSet *nsSSLIOLayerHelpers::mTLSTolerantSites = nsnull;
 nsPSMRememberCertErrorsTable *nsSSLIOLayerHelpers::mHostsWithCertErrors = nsnull;
+nsCStringHashSet *nsSSLIOLayerHelpers::mRenegoUnrestrictedSites = nsnull;
+PRBool nsSSLIOLayerHelpers::mTreatUnsafeNegotiationAsBroken = PR_FALSE;
 PRFileDesc *nsSSLIOLayerHelpers::mSharedPollableEvent = nsnull;
 nsNSSSocketInfo *nsSSLIOLayerHelpers::mSocketOwningPollableEvent = nsnull;
 PRBool nsSSLIOLayerHelpers::mPollableEventCurrentlySet = PR_FALSE;
 
 static PRIntn _PSM_InvalidInt(void)
 {
     PR_ASSERT(!"I/O method is invalid");
     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
@@ -2181,16 +2189,24 @@ nsresult nsSSLIOLayerHelpers::Init()
   if (!mTLSTolerantSites)
     return NS_ERROR_OUT_OF_MEMORY;
 
   // Initialize the tolerant site hashtable to 16 items at the start seems
   // reasonable as most servers are TLS tolerant. We just want to lower 
   // the rate of hashtable array reallocation.
   mTLSTolerantSites->Init(16);
 
+  mRenegoUnrestrictedSites = new nsCStringHashSet();
+  if (!mRenegoUnrestrictedSites)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  mRenegoUnrestrictedSites->Init(1);
+
+  mTreatUnsafeNegotiationAsBroken = PR_FALSE;
+  
   mHostsWithCertErrors = new nsPSMRememberCertErrorsTable();
   if (!mHostsWithCertErrors || !mHostsWithCertErrors->mErrorHosts.IsInitialized())
     return NS_ERROR_OUT_OF_MEMORY;
 
   return NS_OK;
 }
 
 void nsSSLIOLayerHelpers::addIntolerantSite(const nsCString &str)
@@ -2208,16 +2224,59 @@ void nsSSLIOLayerHelpers::removeIntolera
 }
 
 PRBool nsSSLIOLayerHelpers::isKnownAsIntolerantSite(const nsCString &str)
 {
   nsAutoLock lock(mutex);
   return mTLSIntolerantSites->Contains(str);
 }
 
+void nsSSLIOLayerHelpers::setRenegoUnrestrictedSites(const nsCString &str)
+{
+  nsAutoLock lock(mutex);
+  
+  if (mRenegoUnrestrictedSites) {
+    delete mRenegoUnrestrictedSites;
+    mRenegoUnrestrictedSites = nsnull;
+  }
+
+  mRenegoUnrestrictedSites = new nsCStringHashSet();
+  if (!mRenegoUnrestrictedSites)
+    return;
+  
+  mRenegoUnrestrictedSites->Init(1);
+  
+  nsCCommaSeparatedTokenizer toker(str);
+
+  while (toker.hasMoreTokens()) {
+    const nsCSubstring &host = toker.nextToken();
+    if (!host.IsEmpty()) {
+      mRenegoUnrestrictedSites->Put(host);
+    }
+  }
+}
+
+PRBool nsSSLIOLayerHelpers::isRenegoUnrestrictedSite(const nsCString &str)
+{
+  nsAutoLock lock(mutex);
+  return mRenegoUnrestrictedSites->Contains(str);
+}
+
+void nsSSLIOLayerHelpers::setTreatUnsafeNegotiationAsBroken(PRBool broken)
+{
+  nsAutoLock lock(mutex);
+  mTreatUnsafeNegotiationAsBroken = broken;
+}
+
+PRBool nsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken()
+{
+  nsAutoLock lock(mutex);
+  return mTreatUnsafeNegotiationAsBroken;
+}
+
 nsresult
 nsSSLIOLayerNewSocket(PRInt32 family,
                       const char *host,
                       PRInt32 port,
                       const char *proxyHost,
                       PRInt32 proxyPort,
                       PRFileDesc **fd,
                       nsISupports** info,
@@ -3497,16 +3556,25 @@ nsSSLIOLayerSetOptions(PRFileDesc *fd, P
 
   if (SECSuccess != SSL_OptionSet(fd, SSL_HANDSHAKE_AS_CLIENT, PR_TRUE)) {
     return NS_ERROR_FAILURE;
   }
   if (SECSuccess != SSL_BadCertHook(fd, (SSLBadCertHandler) nsNSSBadCertHandler,
                                     infoObject)) {
     return NS_ERROR_FAILURE;
   }
+  
+  if (nsSSLIOLayerHelpers::isRenegoUnrestrictedSite(nsDependentCString(host))) {
+    if (SECSuccess != SSL_OptionSet(fd, SSL_REQUIRE_SAFE_NEGOTIATION, PR_FALSE)) {
+      return NS_ERROR_FAILURE;
+    }
+    if (SECSuccess != SSL_OptionSet(fd, SSL_ENABLE_RENEGOTIATION, SSL_RENEGOTIATE_UNRESTRICTED)) {
+      return NS_ERROR_FAILURE;
+    }
+  }
 
   // Set the Peer ID so that SSL proxy connections work properly.
   char *peerId;
   if (anonymousLoad) {  // See bug #466080. Separate the caches.
       peerId = PR_smprintf("anon:%s:%d", host, port);
   } else {
       peerId = PR_smprintf("%s:%d", host, port);
   }
