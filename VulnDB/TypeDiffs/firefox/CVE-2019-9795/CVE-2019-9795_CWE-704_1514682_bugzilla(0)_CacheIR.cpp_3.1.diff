diff -r 1deedd79bc67 -r acf56427a738 js/src/jit/CacheIR.cpp
--- a/js/src/jit/CacheIR.cpp	Fri Feb 15 19:12:32 2019 +0000
+++ b/js/src/jit/CacheIR.cpp	Sat Feb 16 02:18:06 2019 +0000
@@ -3354,14 +3354,15 @@
 
 SetPropIRGenerator::SetPropIRGenerator(
     JSContext* cx, HandleScript script, jsbytecode* pc, CacheKind cacheKind,
-    ICState::Mode mode, bool* isTemporarilyUnoptimizable, HandleValue lhsVal,
-    HandleValue idVal, HandleValue rhsVal, bool needsTypeBarrier,
-    bool maybeHasExtraIndexedProps)
+    ICState::Mode mode, bool* isTemporarilyUnoptimizable, bool* canAddSlot,
+    HandleValue lhsVal, HandleValue idVal, HandleValue rhsVal,
+    bool needsTypeBarrier, bool maybeHasExtraIndexedProps)
     : IRGenerator(cx, script, pc, cacheKind, mode),
       lhsVal_(lhsVal),
       idVal_(idVal),
       rhsVal_(rhsVal),
       isTemporarilyUnoptimizable_(isTemporarilyUnoptimizable),
+      canAddSlot_(canAddSlot),
       typeCheckInfo_(cx, needsTypeBarrier),
       preliminaryObjectAction_(PreliminaryObjectAction::None),
       attachedTypedArrayOOBStub_(false),
@@ -3424,6 +3425,9 @@
           return true;
         }
       }
+      if (canAttachAddSlotStub(obj, id)) {
+        *canAddSlot_ = true;
+      }
       return false;
     }
 
@@ -4473,6 +4477,79 @@
   return true;
 }
 
+bool SetPropIRGenerator::canAttachAddSlotStub(HandleObject obj, HandleId id) {
+  // Special-case JSFunction resolve hook to allow redefining the 'prototype'
+  // property without triggering lazy expansion of property and object
+  // allocation.
+  if (obj->is<JSFunction>() && JSID_IS_ATOM(id, cx_->names().prototype)) {
+    MOZ_ASSERT(ClassMayResolveId(cx_->names(), obj->getClass(), id, obj));
+
+    // We check group->maybeInterpretedFunction() here and guard on the
+    // group. The group is unique for a particular function so this ensures
+    // we don't add the default prototype property to functions that don't
+    // have it.
+    JSFunction* fun = &obj->as<JSFunction>();
+    if (!obj->group()->maybeInterpretedFunction() ||
+        !fun->needsPrototypeProperty()) {
+      return false;
+    }
+
+    // If property exists this isn't an "add"
+    if (fun->lookupPure(id)) {
+      return false;
+    }
+  } else {
+    // Normal Case: If property exists this isn't an "add"
+    PropertyResult prop;
+    if (!LookupOwnPropertyPure(cx_, obj, id, &prop)) {
+      return false;
+    }
+    if (prop) {
+      return false;
+    }
+  }
+
+  // Object must be extensible.
+  if (!obj->nonProxyIsExtensible()) {
+    return false;
+  }
+
+  // Also watch out for addProperty hooks. Ignore the Array addProperty hook,
+  // because it doesn't do anything for non-index properties.
+  DebugOnly<uint32_t> index;
+  MOZ_ASSERT_IF(obj->is<ArrayObject>(), !IdIsIndex(id, &index));
+  if (!obj->is<ArrayObject>() && obj->getClass()->getAddProperty()) {
+    return false;
+  }
+
+  // Walk up the object prototype chain and ensure that all prototypes are
+  // native, and that all prototypes have no setter defined on the property.
+  for (JSObject* proto = obj->staticPrototype(); proto;
+       proto = proto->staticPrototype()) {
+    if (!proto->isNative()) {
+      return false;
+    }
+
+    // If prototype defines this property in a non-plain way, don't optimize.
+    Shape* protoShape = proto->as<NativeObject>().lookup(cx_, id);
+    if (protoShape && !protoShape->isDataDescriptor()) {
+      return false;
+    }
+
+    // Otherwise, if there's no such property, watch out for a resolve hook
+    // that would need to be invoked and thus prevent inlining of property
+    // addition. Allow the JSFunction resolve hook as it only defines plain
+    // data properties and we don't need to invoke it for objects on the
+    // proto chain.
+    if (ClassMayResolveId(cx_->names(), proto->getClass(), id, proto) &&
+        !proto->is<JSFunction>()) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
 bool SetPropIRGenerator::tryAttachAddSlotStub(HandleObjectGroup oldGroup,
                                               HandleShape oldShape) {
   ValOperandId objValId(writer.setInputOperandId(0));
@@ -4500,11 +4577,10 @@
   RootedObject obj(cx_, &lhsVal_.toObject());
 
   PropertyResult prop;
-  JSObject* holder;
-  if (!LookupPropertyPure(cx_, obj, id, &holder, &prop)) {
-    return false;
-  }
-  if (obj != holder) {
+  if (!LookupOwnPropertyPure(cx_, obj, id, &prop)) {
+    return false;
+  }
+  if (!prop) {
     return false;
   }
 
@@ -4533,13 +4609,12 @@
   MOZ_ASSERT(propShape);
 
   // The property must be the last added property of the object.
-  if (holderOrExpando->lastProperty() != propShape) {
-    return false;
-  }
-
-  // Object must be extensible, oldShape must be immediate parent of
-  // current shape.
-  if (!obj->nonProxyIsExtensible() || propShape->previous() != oldShape) {
+  MOZ_RELEASE_ASSERT(holderOrExpando->lastProperty() == propShape);
+
+  // Old shape should be parent of new shape. Object flag updates may make this
+  // false even for simple data properties. It may be possible to support these
+  // transitions in the future, but ignore now for simplicity.
+  if (propShape->previous() != oldShape) {
     return false;
   }
 
@@ -4549,66 +4624,15 @@
     return false;
   }
 
-  // Watch out for resolve hooks.
-  if (ClassMayResolveId(cx_->names(), obj->getClass(), id, obj)) {
-    // The JSFunction resolve hook defines a (non-configurable and
-    // non-enumerable) |prototype| property on certain functions. Scripts
-    // often assign a custom |prototype| object and we want to optimize
-    // this |prototype| set and eliminate the default object allocation.
-    //
-    // We check group->maybeInterpretedFunction() here and guard on the
-    // group. The group is unique for a particular function so this ensures
-    // we don't add the default prototype property to functions that don't
-    // have it.
-    if (!obj->is<JSFunction>() || !JSID_IS_ATOM(id, cx_->names().prototype) ||
-        !oldGroup->maybeInterpretedFunction() ||
-        !obj->as<JSFunction>().needsPrototypeProperty()) {
-      return false;
-    }
-    MOZ_ASSERT(!propShape->configurable());
-    MOZ_ASSERT(!propShape->enumerable());
-  }
-
-  // Also watch out for addProperty hooks. Ignore the Array addProperty hook,
-  // because it doesn't do anything for non-index properties.
-  DebugOnly<uint32_t> index;
-  MOZ_ASSERT_IF(obj->is<ArrayObject>(), !IdIsIndex(id, &index));
-  if (!obj->is<ArrayObject>() && obj->getClass()->getAddProperty()) {
-    return false;
-  }
-
-  // Walk up the object prototype chain and ensure that all prototypes are
-  // native, and that all prototypes have no setter defined on the property.
-  for (JSObject* proto = obj->staticPrototype(); proto;
-       proto = proto->staticPrototype()) {
-    if (!proto->isNative()) {
-      return false;
-    }
-
-    // If prototype defines this property in a non-plain way, don't optimize.
-    Shape* protoShape = proto->as<NativeObject>().lookup(cx_, id);
-    if (protoShape && !protoShape->hasDefaultSetter()) {
-      return false;
-    }
-
-    // Otherwise, if there's no such property, watch out for a resolve hook
-    // that would need to be invoked and thus prevent inlining of property
-    // addition. Allow the JSFunction resolve hook as it only defines plain
-    // data properties and we don't need to invoke it for objects on the
-    // proto chain.
-    if (ClassMayResolveId(cx_->names(), proto->getClass(), id, proto) &&
-        !proto->is<JSFunction>()) {
-      return false;
-    }
-  }
-
   ObjOperandId objId = writer.guardIsObject(objValId);
   maybeEmitIdGuard(id);
 
   // In addition to guarding for type barrier, we need this group guard (or
-  // shape guard below) to ensure class is unchanged.
+  // shape guard below) to ensure class is unchanged. This group guard may also
+  // implay maybeInterpretedFunction() for the special-case of function
+  // prototype property set.
   MOZ_ASSERT(!oldGroup->hasUncacheableClass() || obj->is<ShapedObject>());
-  writer.guardGroupForTypeBarrier(objId, oldGroup);
+  writer.guardGroup(objId, oldGroup);
 
   // If we are adding a property to an object for which the new script
   // properties analysis hasn't been performed yet, make sure the stub fails
