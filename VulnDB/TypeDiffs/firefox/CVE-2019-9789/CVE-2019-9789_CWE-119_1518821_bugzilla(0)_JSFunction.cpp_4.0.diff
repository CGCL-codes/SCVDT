diff -r 4e34cf5e62ab -r 3d7c4c17ff5c js/src/vm/JSFunction.cpp
--- a/js/src/vm/JSFunction.cpp	Thu Jan 24 15:02:44 2019 +0000
+++ b/js/src/vm/JSFunction.cpp	Thu Jan 24 11:56:55 2019 +0000
@@ -307,6 +307,12 @@
       return true;
     }
 
+    if (JS_IsDeadWrapper(callerObj)) {
+      JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
+                                JSMSG_DEAD_OBJECT);
+      return false;
+    }
+
     JSFunction* callerFun = &callerObj->as<JSFunction>();
     if (IsWrappedAsyncFunction(callerFun)) {
       callerFun = GetUnwrappedAsyncFunction(callerFun);
@@ -335,64 +341,14 @@
 bool CallerSetterImpl(JSContext* cx, const CallArgs& args) {
   MOZ_ASSERT(IsFunction(args.thisv()));
 
-  // Beware!  This function can be invoked on *any* function!  It can't
-  // assume it'll never be invoked on natives, strict mode functions, bound
-  // functions, or anything else that ordinarily has immutable .caller
-  // defined with [[ThrowTypeError]].
-  RootedFunction fun(cx, &args.thisv().toObject().as<JSFunction>());
-  if (!CallerRestrictions(cx, fun)) {
+  // We just have to return |undefined|, but first we call CallerGetterImpl
+  // because we need the same strict-mode and security checks.
+
+  if (!CallerGetterImpl(cx, args)) {
     return false;
   }
 
-  // Return |undefined| unless an error must be thrown.
   args.rval().setUndefined();
-
-  // We can almost just return |undefined| here -- but if the caller function
-  // was strict mode code, we still have to throw a TypeError.  This requires
-  // computing the caller, checking that no security boundaries are crossed,
-  // and throwing a TypeError if the resulting caller is strict.
-
-  NonBuiltinScriptFrameIter iter(cx);
-  if (!AdvanceToActiveCallLinear(cx, iter, fun)) {
-    return true;
-  }
-
-  ++iter;
-  while (!iter.done() && iter.isEvalFrame()) {
-    ++iter;
-  }
-
-  if (iter.done() || !iter.isFunctionFrame()) {
-    return true;
-  }
-
-  RootedObject caller(cx, iter.callee(cx));
-  // |caller| is only used for security access-checking and for its
-  // strictness.  An unwrapped async function has its wrapped async
-  // function's security access and strictness, so don't bother calling
-  // |GetUnwrappedAsyncFunction|.
-  if (!cx->compartment()->wrap(cx, &caller)) {
-    cx->clearPendingException();
-    return true;
-  }
-
-  // If we don't have full access to the caller, or the caller is not strict,
-  // return undefined.  Otherwise throw a TypeError.
-  JSObject* callerObj = CheckedUnwrap(caller);
-  if (!callerObj) {
-    return true;
-  }
-
-  JSFunction* callerFun = &callerObj->as<JSFunction>();
-  MOZ_ASSERT(!callerFun->isBuiltin(),
-             "non-builtin iterator returned a builtin?");
-
-  if (callerFun->strict()) {
-    JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
-                              JSMSG_CALLER_IS_STRICT);
-    return false;
-  }
-
   return true;
 }
 
