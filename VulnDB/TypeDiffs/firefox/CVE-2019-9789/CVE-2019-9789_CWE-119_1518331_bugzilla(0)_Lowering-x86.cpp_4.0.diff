diff -r 16819308720e -r 0985217ed619 js/src/jit/x86/Lowering-x86.cpp
--- a/js/src/jit/x86/Lowering-x86.cpp	Tue Jan 08 20:43:01 2019 +0100
+++ b/js/src/jit/x86/Lowering-x86.cpp	Tue Jan 08 17:48:00 2019 +0100
@@ -256,6 +256,33 @@
   define(lir, ins);
 }
 
+// If the base is a constant, and it is zero or its offset is zero, then
+// code generation will fold the values into the access.  Allocate the
+// pointer to a register only if that can't happen.
+
+static bool OptimizableConstantAccess(MDefinition* base,
+                                      const wasm::MemoryAccessDesc& access) {
+  MOZ_ASSERT(base->isConstant());
+  MOZ_ASSERT(base->type() == MIRType::Int32);
+
+  if (!(base->toConstant()->isInt32(0) || access.offset() == 0)) {
+    return false;
+  }
+  if (access.type() == Scalar::Int64) {
+    // For int64 accesses on 32-bit systems we will need to add another offset
+    // of 4 to access the high part of the value; make sure this does not
+    // overflow the value.
+    int32_t v;
+    if (base->toConstant()->isInt32(0)) {
+      v = access.offset();
+    } else {
+      v = base->toConstant()->toInt32();
+    }
+    return v <= int32_t(INT32_MAX - INT64HIGH_OFFSET);
+  }
+  return true;
+}
+
 void LIRGenerator::visitWasmLoad(MWasmLoad* ins) {
   MDefinition* base = ins->base();
   MOZ_ASSERT(base->type() == MIRType::Int32);
@@ -273,13 +300,8 @@
     return;
   }
 
-  // If the base is a constant, and it is zero or its offset is zero, then
-  // code generation will fold the values into the access.  Allocate the
-  // pointer to a register only if that can't happen.
-
   LAllocation baseAlloc;
-  if (!base->isConstant() ||
-      !(base->toConstant()->isInt32(0) || ins->access().offset() == 0)) {
+  if (!base->isConstant() || !OptimizableConstantAccess(base, ins->access())) {
     baseAlloc = ins->type() == MIRType::Int64 ? useRegister(base)
                                               : useRegisterAtStart(base);
   }
@@ -326,13 +348,8 @@
     return;
   }
 
-  // If the base is a constant, and it is zero or its offset is zero, then
-  // code generation will fold the values into the access.  Allocate the
-  // pointer to a register only if that can't happen.
-
   LAllocation baseAlloc;
-  if (!base->isConstant() ||
-      !(base->toConstant()->isInt32(0) || ins->access().offset() == 0)) {
+  if (!base->isConstant() || !OptimizableConstantAccess(base, ins->access())) {
     baseAlloc = useRegisterAtStart(base);
   }
 
