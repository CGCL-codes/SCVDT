diff -r 398360c9d5c6 -r 3f7a950871b4 media/webrtc/signaling/src/media-conduit/VideoConduit.cpp
--- a/media/webrtc/signaling/src/media-conduit/VideoConduit.cpp	Wed Jan 10 14:45:17 2018 -0500
+++ b/media/webrtc/signaling/src/media-conduit/VideoConduit.cpp	Wed Jan 10 20:41:03 2018 -0500
@@ -633,22 +633,6 @@
     simulcastEncoding = mConduit->mCurSendCodecConfig->mSimulcastEncodings[idx];
     MOZ_ASSERT(simulcastEncoding.constraints.scaleDownBy >= 1.0);
 
-    // leave vector temporal_layer_thresholds_bps empty for non-simulcast
-    if (config.number_of_streams > 1) {
-      // Oddly, though this is a 'bps' array, nothing really looks at the
-      // values, just the size of the array to know the number of temporal
-      // layers.
-      video_stream.temporal_layer_thresholds_bps.resize(2);
-      // XXX Note: in simulcast.cc in upstream code, the array value is
-      // 3(-1) for all streams, though it's in an array, except for screencasts,
-      // which use 1 (i.e 2 layers).
-
-      // XXX Bug 1390215 investigate using more of
-      // simulcast.cc:GetSimulcastConfig() or our own algorithm to replace it
-    } else {
-      video_stream.temporal_layer_thresholds_bps.clear();
-    }
-
     // Calculate these first
     video_stream.max_bitrate_bps = MinIgnoreZero(simulcastEncoding.constraints.maxBr,
                                                  kDefaultMaxBitrate_bps);
@@ -678,6 +662,30 @@
     video_stream.max_qp = kQpMax;
     video_stream.SetRid(simulcastEncoding.rid);
 
+    // leave vector temporal_layer_thresholds_bps empty for non-simulcast
+    if (config.number_of_streams > 1) {
+      // XXX Note: in simulcast.cc in upstream code, the array value is
+      // 3(-1) for all streams, though it's in an array, except for screencasts,
+      // which use 1 (i.e 2 layers).
+
+      // Oddly, though this is a 'bps' array, nothing really looks at the
+      // values for normal video, just the size of the array to know the
+      // number of temporal layers.
+      // For VideoEncoderConfig::ContentType::kScreen, though, in
+      // video_codec_initializer.cc it uses [0] to set the target bitrate
+      // for the screenshare.
+      video_stream.temporal_layer_thresholds_bps.clear();
+      if (mConduit->mCodecMode == webrtc::VideoCodecMode::kScreensharing) {
+        video_stream.temporal_layer_thresholds_bps.push_back(video_stream.target_bitrate_bps);
+      } else {
+        video_stream.temporal_layer_thresholds_bps.resize(2);
+      }
+      // XXX Bug 1390215 investigate using more of
+      // simulcast.cc:GetSimulcastConfig() or our own algorithm to replace it
+    } else {
+      video_stream.temporal_layer_thresholds_bps.clear();
+    }
+
     if (mConduit->mCurSendCodecConfig->mName == "H264") {
       if (mConduit->mCurSendCodecConfig->mEncodingConstraints.maxMbps > 0) {
         // Not supported yet!
