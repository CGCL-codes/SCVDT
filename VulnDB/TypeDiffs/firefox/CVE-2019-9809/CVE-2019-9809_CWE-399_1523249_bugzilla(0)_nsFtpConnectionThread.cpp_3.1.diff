diff -r 9b74b2602df1 -r 0630d18a7d26 netwerk/protocol/ftp/nsFtpConnectionThread.cpp
--- a/netwerk/protocol/ftp/nsFtpConnectionThread.cpp	Tue Jan 29 06:06:50 2019 +0000
+++ b/netwerk/protocol/ftp/nsFtpConnectionThread.cpp	Wed Jan 30 11:39:42 2019 +0000
@@ -31,7 +31,6 @@
 #include "nsIStreamListenerTee.h"
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
-#include "nsIStringBundle.h"
 #include "nsAuthInformationHolder.h"
 #include "nsIProtocolProxyService.h"
 #include "nsICancelable.h"
@@ -850,33 +849,8 @@
       mServerType = FTP_VMS_TYPE;
     } else {
       NS_ERROR("Server type list format unrecognized.");
-      // Guessing causes crashes.
-      // (Of course, the parsing code should be more robust...)
-      nsCOMPtr<nsIStringBundleService> bundleService =
-          do_GetService(NS_STRINGBUNDLE_CONTRACTID);
-      if (!bundleService) return FTP_ERROR;
 
-      nsCOMPtr<nsIStringBundle> bundle;
-      nsresult rv =
-          bundleService->CreateBundle(NECKO_MSGS_URL, getter_AddRefs(bundle));
-      if (NS_FAILED(rv)) return FTP_ERROR;
-
-      char16_t *ucs2Response = ToNewUnicode(mResponseMsg);
-      const char16_t *formatStrings[1] = {ucs2Response};
-
-      nsAutoString formattedString;
-      rv = bundle->FormatStringFromName("UnsupportedFTPServer", formatStrings,
-                                        1, formattedString);
-      free(ucs2Response);
-      if (NS_FAILED(rv)) return FTP_ERROR;
-
-      // TODO(darin): this code should not be dictating UI like this!
-      nsCOMPtr<nsIPrompt> prompter;
-      mChannel->GetCallback(prompter);
-      if (prompter) prompter->Alert(nullptr, formattedString.get());
-
-      // since we just alerted the user, clear mResponseMsg,
-      // which is displayed to the user.
+      // clear mResponseMsg, which is displayed to the user.
       mResponseMsg = "";
       return FTP_ERROR;
     }
@@ -1629,29 +1603,6 @@
   mControlConnection = nullptr;
 }
 
-class nsFtpAsyncAlert : public Runnable {
- public:
-  nsFtpAsyncAlert(nsIPrompt *aPrompter, nsString aResponseMsg)
-      : mozilla::Runnable("nsFtpAsyncAlert"),
-        mPrompter(aPrompter),
-        mResponseMsg(std::move(aResponseMsg)) {}
-
- protected:
-  virtual ~nsFtpAsyncAlert() = default;
-
- public:
-  NS_IMETHOD Run() override {
-    if (mPrompter) {
-      mPrompter->Alert(nullptr, mResponseMsg.get());
-    }
-    return NS_OK;
-  }
-
- private:
-  nsCOMPtr<nsIPrompt> mPrompter;
-  nsString mResponseMsg;
-};
-
 nsresult nsFtpState::StopProcessing() {
   // Only do this function once.
   if (!mKeepRunning) return NS_OK;
@@ -1660,23 +1611,7 @@
   LOG_INFO(("FTP:(%p) nsFtpState stopping", this));
 
   if (NS_FAILED(mInternalError) && !mResponseMsg.IsEmpty()) {
-    // check to see if the control status is bad.
-    // web shell wont throw an alert.  we better:
-
-    // XXX(darin): this code should not be dictating UI like this!
-    nsCOMPtr<nsIPrompt> prompter;
-    mChannel->GetCallback(prompter);
-    if (prompter) {
-      nsCOMPtr<nsIRunnable> alertEvent;
-      if (mUseUTF8) {
-        alertEvent =
-            new nsFtpAsyncAlert(prompter, NS_ConvertUTF8toUTF16(mResponseMsg));
-      } else {
-        alertEvent =
-            new nsFtpAsyncAlert(prompter, NS_ConvertASCIItoUTF16(mResponseMsg));
-      }
-      NS_DispatchToMainThread(alertEvent);
-    }
+    // check to see if the control status is bad, forward the error message.
     nsCOMPtr<nsIFTPChannelParentInternal> ftpChanP;
     mChannel->GetCallback(ftpChanP);
     if (ftpChanP) {
