diff -r 2a6eab645431 -r aae715e5060b accessible/generic/DocAccessible.cpp
--- a/accessible/generic/DocAccessible.cpp	Fri Jun 23 16:25:45 2017 +0200
+++ b/accessible/generic/DocAccessible.cpp	Mon Jun 26 20:20:40 2017 -0400
@@ -2100,12 +2100,12 @@
     // Same child on same position, no change.
     if (child->Parent() == aOwner &&
         child->IndexInParent() == static_cast<int32_t>(insertIdx)) {
-      NS_ASSERTION(child == children->ElementAt(arrayIdx), "Not in sync!");
+      MOZ_ASSERT(child == children->ElementAt(arrayIdx), "Not in sync!");
       insertIdx++; arrayIdx++;
       continue;
     }
 
-    NS_ASSERTION(children->SafeElementAt(arrayIdx) != child, "Already in place!");
+    MOZ_ASSERT(children->SafeElementAt(arrayIdx) != child, "Already in place!");
 
     nsTArray<RefPtr<Accessible> >::index_type idx = children->IndexOf(child);
     if (idx < arrayIdx) {
@@ -2202,8 +2202,10 @@
                     "child", aChild, nullptr);
 #endif
 
-  // If the child was taken from from an ARIA owns element.
+  // Forget aria-owns info in case of ARIA owned element. The caller is expected
+  // to update it if needed.
   if (aChild->IsRelocated()) {
+    aChild->SetRelocated(false);
     nsTArray<RefPtr<Accessible> >* owned = mARIAOwnsHash.Get(curParent);
     MOZ_ASSERT(owned, "IsRelocated flag is out of sync with mARIAOwnsHash");
     owned->RemoveElement(aChild);
@@ -2320,6 +2322,7 @@
       owned->RemoveElement(child);
       if (owned->Length() == 0) {
         mARIAOwnsHash.Remove(aRoot);
+        owned = nullptr;
       }
     }
 
