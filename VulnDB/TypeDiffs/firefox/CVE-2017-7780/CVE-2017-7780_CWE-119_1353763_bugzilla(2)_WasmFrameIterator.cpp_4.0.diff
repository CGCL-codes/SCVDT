diff -r 20e85b5bd342 -r f90707333e7f js/src/wasm/WasmFrameIterator.cpp
--- a/js/src/wasm/WasmFrameIterator.cpp	Fri Apr 14 09:18:02 2017 -0500
+++ b/js/src/wasm/WasmFrameIterator.cpp	Fri Apr 14 09:18:02 2017 -0500
@@ -56,8 +56,7 @@
     callsite_(nullptr),
     codeRange_(nullptr),
     fp_(nullptr),
-    unwind_(Unwind::False),
-    missingFrameMessage_(false)
+    unwind_(Unwind::False)
 {
     MOZ_ASSERT(done());
 }
@@ -67,64 +66,73 @@
     code_(nullptr),
     callsite_(nullptr),
     codeRange_(nullptr),
-    fp_(nullptr),
-    unwind_(unwind),
-    missingFrameMessage_(false)
+    fp_(activation->exitFP()),
+    unwind_(unwind)
 {
-    // When execution is interrupted, the embedding may capture a stack trace.
-    // Since we've lost all the register state, we can't unwind the full stack
-    // like ProfilingFrameIterator does. However, we can recover the interrupted
-    // function via the resumePC and at least print that frame.
-    if (void* resumePC = activation->resumePC()) {
-        code_ = activation->compartment()->wasm.lookupCode(resumePC);
-        codeRange_ = code_->lookupRange(resumePC);
-        if (codeRange_->kind() != CodeRange::Function) {
-            // We might be in a stub inserted between functions, in which case
-            // we don't have a frame.
-            codeRange_ = nullptr;
-            missingFrameMessage_ = true;
-        }
+    MOZ_ASSERT(fp_);
+
+    // Normally, execution exits wasm code via an exit stub which sets exitFP to
+    // the exit stub's frame. Thus, in this case, we want to start iteration at
+    // the caller of the exit frame, whose Code, CodeRange and CallSite are
+    // indicated by the returnAddress of the exit stub's frame.
+
+    if (!activation->interrupted()) {
+        popFrame();
         MOZ_ASSERT(!done());
         return;
     }
 
-    fp_ = activation->exitFP();
+    // When asynchronously interrupted, exitFP is set to the interrupted frame
+    // itself and so we do not want to skip it. Instead, we can recover the
+    // Code and CodeRange from the WasmActivation, which set these when control
+    // flow was interrupted. There is no CallSite (b/c the interrupt was async),
+    // but this is fine because CallSite is only used for line number for which
+    // we can use the beginning of the function from the CodeRange instead.
 
-    if (!fp_) {
-        MOZ_ASSERT(done());
-        return;
-    }
+    code_ = activation_->compartment()->wasm.lookupCode(activation->resumePC());
+    MOZ_ASSERT(code_);
 
-    settle();
+    codeRange_ = code_->lookupRange(activation->resumePC());
+    MOZ_ASSERT(codeRange_->kind() == CodeRange::Function);
+
+    MOZ_ASSERT(!done());
 }
 
 bool
 FrameIterator::done() const
 {
-    return !codeRange_ && !missingFrameMessage_;
+    MOZ_ASSERT(!!fp_ == !!code_);
+    MOZ_ASSERT(!!fp_ == !!codeRange_);
+    return !fp_;
 }
 
 void
 FrameIterator::operator++()
 {
     MOZ_ASSERT(!done());
-    if (fp_) {
-        settle();
-    } else if (codeRange_) {
-        codeRange_ = nullptr;
-        missingFrameMessage_ = true;
-    } else {
-        MOZ_ASSERT(missingFrameMessage_);
-        missingFrameMessage_ = false;
+
+    // When the iterator is set to Unwind::True, each time the iterator pops a
+    // frame, the WasmActivation is updated so that the just-popped frame
+    // is no longer visible. This is necessary since Debugger::onLeaveFrame is
+    // called before popping each frame and, once onLeaveFrame is called for a
+    // given frame, that frame must not be visible to subsequent stack iteration
+    // (or it could be added as a "new" frame just as it becomes garbage).
+    // When the frame is "interrupted", then exitFP is included in the callstack
+    // (otherwise, it is skipped, as explained above). So to unwind the
+    // innermost frame, we just clear the interrupt state.
+
+    if (unwind_ == Unwind::True) {
+        if (activation_->interrupted())
+            activation_->finishInterrupt();
+        activation_->unwindExitFP(fp_);
     }
+
+    popFrame();
 }
 
 void
-FrameIterator::settle()
+FrameIterator::popFrame()
 {
-    if (unwind_ == Unwind::True)
-        activation_->unwindExitFP(fp_);
-
     void* returnAddress = ReturnAddressFromFP(fp_);
 
     fp_ = CallerFPFromFP(fp_);
@@ -180,20 +188,6 @@
     MOZ_ASSERT(!done());
 
     JSContext* cx = activation_->cx();
-
-    if (missingFrameMessage_) {
-        const char* msg = "asm.js/wasm frames may be missing below this one";
-        JSAtom* atom = Atomize(cx, msg, strlen(msg));
-        if (!atom) {
-            cx->clearPendingException();
-            return cx->names().empty;
-        }
-
-        return atom;
-    }
-
-    MOZ_ASSERT(codeRange_);
-
     JSAtom* atom = code_->getFuncAtom(cx, codeRange_->funcIndex());
     if (!atom) {
         cx->clearPendingException();
@@ -207,51 +201,43 @@
 FrameIterator::lineOrBytecode() const
 {
     MOZ_ASSERT(!done());
-    return callsite_ ? callsite_->lineOrBytecode()
-                     : (codeRange_ ? codeRange_->funcLineOrBytecode() : 0);
-}
-
-bool
-FrameIterator::hasInstance() const
-{
-    MOZ_ASSERT(!done());
-    return !!fp_;
+    MOZ_ASSERT_IF(!callsite_, activation_->interrupted());
+    return callsite_ ? callsite_->lineOrBytecode() : codeRange_->funcLineOrBytecode();
 }
 
 Instance*
 FrameIterator::instance() const
 {
     MOZ_ASSERT(!done());
-    MOZ_ASSERT(hasInstance());
     return FrameToDebugFrame(fp_)->instance();
 }
 
 bool
 FrameIterator::debugEnabled() const
 {
-    MOZ_ASSERT(!done() && code_);
-    MOZ_ASSERT_IF(!missingFrameMessage_, codeRange_->kind() == CodeRange::Function);
-    MOZ_ASSERT_IF(missingFrameMessage_, !codeRange_ && !fp_);
+    MOZ_ASSERT(!done());
+
     // Only non-imported functions can have debug frames.
     return code_->metadata().debugEnabled &&
-           fp_ &&
-           !missingFrameMessage_ &&
            codeRange_->funcIndex() >= code_->metadata().funcImports.length();
 }
 
 DebugFrame*
 FrameIterator::debugFrame() const
 {
-    MOZ_ASSERT(!done() && debugEnabled());
-    MOZ_ASSERT(fp_);
+    MOZ_ASSERT(!done());
+    MOZ_ASSERT(debugEnabled());
     return FrameToDebugFrame(fp_);
 }
 
 const CallSite*
 FrameIterator::debugTrapCallsite() const
 {
-    MOZ_ASSERT(!done() && debugEnabled());
-    MOZ_ASSERT(callsite_->kind() == CallSite::EnterFrame || callsite_->kind() == CallSite::LeaveFrame ||
+    MOZ_ASSERT(!done());
+    MOZ_ASSERT(callsite_);
+    MOZ_ASSERT(debugEnabled());
+    MOZ_ASSERT(callsite_->kind() == CallSite::EnterFrame ||
+               callsite_->kind() == CallSite::LeaveFrame ||
                callsite_->kind() == CallSite::Breakpoint);
     return callsite_;
 }
@@ -524,16 +510,9 @@
 ProfilingFrameIterator::initFromExitFP()
 {
     uint8_t* fp = activation_->exitFP();
-    stackAddress_ = fp;
+    void* pc = ReturnAddressFromFP(fp);
 
-    // If a signal was handled while entering an activation, the frame will
-    // still be null.
-    if (!fp) {
-        MOZ_ASSERT(done());
-        return;
-    }
-
-    void* pc = ReturnAddressFromFP(fp);
+    stackAddress_ = fp;
 
     code_ = activation_->compartment()->wasm.lookupCode(pc);
     MOZ_ASSERT(code_);
@@ -598,8 +577,6 @@
         return;
     }
 
-    // If pc isn't in the instance's code, we must have exited the code via an
-    // exit trampoline or signal handler.
     code_ = activation_->compartment()->wasm.lookupCode(state.pc);
 
     const CodeRange* codeRange = nullptr;
@@ -612,6 +589,8 @@
             codeRange = &thunk->codeRange;
             codeBase = (uint8_t*) thunk->base;
         } else {
+            // If pc isn't in any wasm code or builtin exit, we must be between
+            // pushing the WasmActivation and entering wasm code.
             MOZ_ASSERT(done());
             return;
         }
@@ -947,10 +926,8 @@
 {
     for (ActivationIterator iter(cx, target); !iter.done(); ++iter) {
         if (iter.activation()->isWasm()) {
-            for (FrameIterator fi(iter.activation()->asWasm()); !fi.done(); ++fi) {
-                if (fi.hasInstance())
-                    fi.instance()->trace(trc);
-            }
+            for (FrameIterator fi(iter.activation()->asWasm()); !fi.done(); ++fi)
+                fi.instance()->trace(trc);
         }
     }
 }
