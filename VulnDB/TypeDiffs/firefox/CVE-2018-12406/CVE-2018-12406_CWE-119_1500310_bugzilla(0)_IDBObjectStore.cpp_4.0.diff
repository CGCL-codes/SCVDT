diff -r 6b3e88486ae1 -r 7473fdd1c21c dom/indexedDB/IDBObjectStore.cpp
--- a/dom/indexedDB/IDBObjectStore.cpp	Tue Nov 13 08:22:25 2018 +0000
+++ b/dom/indexedDB/IDBObjectStore.cpp	Mon Nov 12 12:59:06 2018 +0100
@@ -1575,31 +1575,27 @@
   }
 
   // Figure out indexes and the index values to update here.
-  const nsTArray<IndexMetadata>& indexes = mSpec->indexes();
-
-  uint32_t idxCount = indexes.Length();
-
-  if (idxCount) {
-    if (!aValueWrapper.Clone(aCx)) {
-      return NS_ERROR_DOM_DATA_CLONE_ERR;
-    }
-
-    // Update idxCount, the structured clone process may trigger content code
-    // via getters/other which can potentially call CreateIndex/DeleteIndex.
-    idxCount = indexes.Length();
+
+  if (mSpec->indexes().Length() && !aValueWrapper.Clone(aCx)) {
+    return NS_ERROR_DOM_DATA_CLONE_ERR;
   }
 
-  aUpdateInfoArray.SetCapacity(idxCount); // Pretty good estimate
-
-  for (uint32_t idxIndex = 0; idxIndex < idxCount; idxIndex++) {
-    const IndexMetadata& metadata = indexes[idxIndex];
-
-    rv = AppendIndexUpdateInfo(metadata.id(), metadata.keyPath(),
-                               metadata.unique(), metadata.multiEntry(),
-                               metadata.locale(), aCx, aValueWrapper.Value(),
-                               aUpdateInfoArray);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
+  {
+    const nsTArray<IndexMetadata>& indexes = mSpec->indexes();
+    uint32_t idxCount = indexes.Length();
+
+    aUpdateInfoArray.SetCapacity(idxCount); // Pretty good estimate
+
+    for (uint32_t idxIndex = 0; idxIndex < idxCount; idxIndex++) {
+      const IndexMetadata& metadata = indexes[idxIndex];
+
+      rv = AppendIndexUpdateInfo(metadata.id(), metadata.keyPath(),
+                                 metadata.unique(), metadata.multiEntry(),
+                                 metadata.locale(), aCx, aValueWrapper.Value(),
+                                 aUpdateInfoArray);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
     }
   }
 
@@ -1664,6 +1660,11 @@
     return nullptr;
   }
 
+  if (!mTransaction->IsOpen()) {
+    aRv.Throw(NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR);
+    return nullptr;
+  }
+
   // Check the size limit of the serialized message which mainly consists of
   // a StructuredCloneBuffer, an encoded object key, and the encoded index keys.
   // kMaxIDBMsgOverhead covers the minor stuff not included in this calculation
