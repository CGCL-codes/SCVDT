diff -r f47b24dad390 -r 3f1ae6d1d01d dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp	Fri Dec 22 10:05:48 2017 +0100
+++ b/dom/fetch/Fetch.cpp	Fri Dec 22 10:06:47 2017 +0100
@@ -162,6 +162,22 @@
   }
 };
 
+class WorkerFetchResolver;
+
+class WorkerNotifier final : public WorkerHolder
+{
+  RefPtr<WorkerFetchResolver> mResolver;
+
+public:
+  explicit WorkerNotifier(WorkerFetchResolver* aResolver)
+    : WorkerHolder(AllowIdleShutdownStart)
+    , mResolver(aResolver)
+  {}
+
+  bool
+  Notify(Status aStatus) override;
+};
+
 class WorkerFetchResolver final : public FetchDriverObserver
 {
   // Thread-safe:
@@ -170,6 +186,7 @@
 
   // Touched only on the worker thread.
   RefPtr<FetchObserver> mFetchObserver;
+  UniquePtr<WorkerHolder> mWorkerHolder;
 
 public:
   // Returns null if worker is shutting down.
@@ -193,6 +210,11 @@
 
     RefPtr<WorkerFetchResolver> r =
       new WorkerFetchResolver(proxy, signalProxy, aObserver);
+
+    if (NS_WARN_IF(!r->HoldWorker(aWorkerPrivate))) {
+      return nullptr;
+    }
+
     return r.forget();
   }
 
@@ -271,6 +293,8 @@
       mSignalProxy->Shutdown();
       mSignalProxy = nullptr;
     }
+
+    mWorkerHolder = nullptr;
   }
 
 private:
@@ -290,6 +314,18 @@
 
   virtual void
   FlushConsoleReport() override;
+
+  bool
+  HoldWorker(WorkerPrivate* aWorkerPrivate)
+  {
+    UniquePtr<WorkerNotifier> wn(new WorkerNotifier(this));
+    if (NS_WARN_IF(!wn->HoldWorker(aWorkerPrivate, Canceling))) {
+      return false;
+    }
+
+    mWorkerHolder = Move(wn);
+    return true;
+  }
 };
 
 class MainThreadFetchResolver final : public FetchDriverObserver
@@ -724,6 +760,18 @@
   // Control runnable cancel already calls Run().
 };
 
+bool
+WorkerNotifier::Notify(Status aStatus)
+{
+  if (mResolver) {
+    // This will nullify this object.
+    // No additional operation after this line!
+    mResolver->Shutdown(mWorkerPrivate);
+  }
+
+  return true;
+}
+
 void
 WorkerFetchResolver::OnResponseAvailableInternal(InternalResponse* aResponse)
 {
