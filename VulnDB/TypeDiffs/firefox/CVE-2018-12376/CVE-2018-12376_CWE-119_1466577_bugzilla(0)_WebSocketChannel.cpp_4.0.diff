diff -r d5018fab9650 -r 996ae2e4deaa netwerk/protocol/websocket/WebSocketChannel.cpp
--- a/netwerk/protocol/websocket/WebSocketChannel.cpp	Tue Jul 17 10:27:46 2018 -0400
+++ b/netwerk/protocol/websocket/WebSocketChannel.cpp	Tue Jul 24 17:18:58 2018 -0400
@@ -1212,7 +1212,8 @@
   mDynamicOutputSize(0),
   mDynamicOutput(nullptr),
   mPrivateBrowsing(false),
-  mConnectionLogService(nullptr)
+  mConnectionLogService(nullptr),
+  mMutex("WebSocketChannel::mMutex")
 {
   MOZ_ASSERT(NS_IsMainThread(), "not main thread");
 
@@ -2234,7 +2235,7 @@
       if (NS_FAILED(rv)) {
         LOG(("WebSocketChannel::PrimeNewOutgoingMessage(): "
              "GenerateRandomBytes failure %" PRIx32 "\n", static_cast<uint32_t>(rv)));
-        StopSession(rv);
+        AbortSession(rv);
         return;
       }
       memcpy(&mask, buffer, sizeof(mask));
@@ -2390,10 +2391,27 @@
   LOG(("WebSocketChannel::StopSession() %p [%" PRIx32 "]\n",
        this, static_cast<uint32_t>(reason)));
 
+  {
+    MutexAutoLock lock(mMutex);
+    if (mStopped) {
+      return;
+    }
+    mStopped = true;
+  }
+
+  DoStopSession(reason);
+}
+
+void
+WebSocketChannel::DoStopSession(nsresult reason)
+{
+  LOG(("WebSocketChannel::DoStopSession() %p [%" PRIx32 "]\n",
+       this, static_cast<uint32_t>(reason)));
+
   // normally this should be called on socket thread, but it is ok to call it
   // from OnStartRequest before the socket thread machine has gotten underway
 
-  mStopped = true;
+  MOZ_ASSERT(mStopped);
 
   if (!mOpenedHttpChannel) {
     // The HTTP channel information will never be used in this case
@@ -2464,7 +2482,7 @@
     // is set when the server close arrives without waiting for the timeout to
     // expire.
 
-    LOG(("WebSocketChannel::StopSession: Wait for Server TCP close"));
+    LOG(("WebSocketChannel::DoStopSession: Wait for Server TCP close"));
 
     nsresult rv;
     rv = NS_NewTimerWithCallback(getter_AddRefs(mLingeringCloseTimer),
@@ -2499,6 +2517,8 @@
   LOG(("WebSocketChannel::AbortSession() %p [reason %" PRIx32 "] stopped = %d\n",
        this, static_cast<uint32_t>(reason), !!mStopped));
 
+  MOZ_ASSERT(NS_FAILED(reason), "reason must be a failure!");
+
   // normally this should be called on socket thread, but it is ok to call it
   // from the main thread before StartWebsocketData() has completed
 
@@ -2513,20 +2533,26 @@
     return;
   }
 
-  if (mStopped)
-    return;
-  mStopped = true;
-
-  if (mTransport && reason != NS_BASE_STREAM_CLOSED && !mRequestedClose &&
-      !mClientClosed && !mServerClosed && mConnecting == NOT_CONNECTING) {
-    mRequestedClose = true;
-    mStopOnClose = reason;
-    mSocketThread->Dispatch(
-      new OutboundEnqueuer(this, new OutboundMessage(kMsgTypeFin, nullptr)),
-                           nsIEventTarget::DISPATCH_NORMAL);
-  } else {
-    StopSession(reason);
+  {
+    MutexAutoLock lock(mMutex);
+    if (mStopped) {
+      return;
+    }
+
+    if (mTransport && reason != NS_BASE_STREAM_CLOSED && !mRequestedClose &&
+        !mClientClosed && !mServerClosed && mDataStarted) {
+      mRequestedClose = true;
+      mStopOnClose = reason;
+      mSocketThread->Dispatch(
+        new OutboundEnqueuer(this, new OutboundMessage(kMsgTypeFin, nullptr)),
+                             nsIEventTarget::DISPATCH_NORMAL);
+      return;
+    }
+
+    mStopped = true;
   }
+
+  DoStopSession(reason);
 }
 
 // ReleaseSession is called on orderly shutdown
@@ -2537,8 +2563,6 @@
        this, !!mStopped));
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
 
-  if (mStopped)
-    return;
   StopSession(NS_OK);
 }
 
@@ -2980,9 +3004,19 @@
       NS_DISPATCH_NORMAL);
   }
 
-  LOG(("WebSocketChannel::StartWebsocketData() %p", this));
-  MOZ_ASSERT(!mDataStarted, "StartWebsocketData twice");
-  mDataStarted = true;
+  {
+    MutexAutoLock lock(mMutex);
+    LOG(("WebSocketChannel::StartWebsocketData() %p", this));
+    MOZ_ASSERT(!mDataStarted, "StartWebsocketData twice");
+
+    if (mStopped) {
+      LOG(("WebSocketChannel::StartWebsocketData channel already closed, not "
+           "starting data"));
+      return NS_ERROR_NOT_AVAILABLE;
+    }
+
+    mDataStarted = true;
+  }
 
   rv = mSocketIn->AsyncWait(this, 0, 0, mSocketThread);
   if (NS_FAILED(rv)) {
@@ -3600,35 +3634,46 @@
   LOG(("WebSocketChannel::Close() %p\n", this));
   MOZ_ASSERT(NS_IsMainThread(), "not main thread");
 
-  if (mRequestedClose) {
-    return NS_OK;
+  {
+    MutexAutoLock lock(mMutex);
+
+    if (mRequestedClose) {
+      return NS_OK;
+    }
+
+    if (mStopped) {
+      return NS_ERROR_NOT_AVAILABLE;
+    }
+
+    // The API requires the UTF-8 string to be 123 or less bytes
+    if (reason.Length() > 123)
+      return NS_ERROR_ILLEGAL_VALUE;
+
+    mRequestedClose = true;
+    mScriptCloseReason = reason;
+    mScriptCloseCode = code;
+
+    if (mDataStarted) {
+      return mSocketThread->Dispatch(
+        new OutboundEnqueuer(this, new OutboundMessage(kMsgTypeFin, nullptr)),
+                             nsIEventTarget::DISPATCH_NORMAL);
+    }
+
+    mStopped = true;
   }
 
-  // The API requires the UTF-8 string to be 123 or less bytes
-  if (reason.Length() > 123)
-    return NS_ERROR_ILLEGAL_VALUE;
-
-  mRequestedClose = true;
-  mScriptCloseReason = reason;
-  mScriptCloseCode = code;
-
-  if (!mTransport || mConnecting != NOT_CONNECTING) {
-    nsresult rv;
-    if (code == CLOSE_GOING_AWAY) {
-      // Not an error: for example, tab has closed or navigated away
-      LOG(("WebSocketChannel::Close() GOING_AWAY without transport."));
-      rv = NS_OK;
-    } else {
-      LOG(("WebSocketChannel::Close() without transport - error."));
-      rv = NS_ERROR_NOT_CONNECTED;
-    }
-    StopSession(rv);
-    return rv;
+  nsresult rv;
+  if (code == CLOSE_GOING_AWAY) {
+    // Not an error: for example, tab has closed or navigated away
+    LOG(("WebSocketChannel::Close() GOING_AWAY without transport."));
+    rv = NS_OK;
+  } else {
+    LOG(("WebSocketChannel::Close() without transport - error."));
+    rv = NS_ERROR_NOT_CONNECTED;
   }
 
-  return mSocketThread->Dispatch(
-      new OutboundEnqueuer(this, new OutboundMessage(kMsgTypeFin, nullptr)),
-                           nsIEventTarget::DISPATCH_NORMAL);
+  DoStopSession(rv);
+  return rv;
 }
 
 NS_IMETHODIMP
@@ -4003,13 +4048,11 @@
     }
 
     if (NS_FAILED(rv)) {
-      mTCPClosed = true;
       AbortSession(rv);
       return rv;
     }
 
     if (count == 0) {
-      mTCPClosed = true;
       AbortSession(NS_BASE_STREAM_CLOSED);
       return NS_OK;
     }
