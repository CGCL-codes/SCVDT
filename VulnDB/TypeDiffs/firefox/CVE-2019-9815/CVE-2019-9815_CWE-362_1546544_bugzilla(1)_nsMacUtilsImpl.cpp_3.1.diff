diff -r d851ba3d3b29 -r cd1ccb74af7c xpcom/base/nsMacUtilsImpl.cpp
--- a/xpcom/base/nsMacUtilsImpl.cpp	Wed May 08 05:28:15 2019 +0000
+++ b/xpcom/base/nsMacUtilsImpl.cpp	Tue May 07 22:16:14 2019 +0000
@@ -17,16 +17,21 @@
 #include "prenv.h"
 
 #include <CoreFoundation/CoreFoundation.h>
+#include <sys/sysctl.h>
 
 NS_IMPL_ISUPPORTS(nsMacUtilsImpl, nsIMacUtils)
 
 using mozilla::StaticMutexAutoLock;
+using mozilla::Unused;
 
 #if defined(MOZ_SANDBOX)
 StaticAutoPtr<nsCString> nsMacUtilsImpl::sCachedAppPath;
 StaticMutex nsMacUtilsImpl::sCachedAppPathMutex;
 #endif
 
+// Initialize with Unknown until we've checked if TCSM is available to set
+Atomic<nsMacUtilsImpl::TCSMStatus> nsMacUtilsImpl::sTCSMStatus(TCSM_Unknown);
+
 nsresult nsMacUtilsImpl::GetArchString(nsAString& aArchString) {
   if (!mBinaryArchs.IsEmpty()) {
     aArchString.Assign(mBinaryArchs);
@@ -241,3 +246,60 @@
 }
 #  endif /* DEBUG */
 #endif   /* MOZ_SANDBOX */
+
+/* static */
+bool nsMacUtilsImpl::IsTCSMAvailable() {
+  if (sTCSMStatus == TCSM_Unknown) {
+    uint32_t oldVal = 0;
+    size_t oldValSize = sizeof(oldVal);
+    int rv = sysctlbyname("kern.tcsm_available", &oldVal, &oldValSize, NULL, 0);
+    TCSMStatus newStatus;
+    if (rv < 0 || oldVal == 0) {
+      newStatus = TCSM_Unavailable;
+    } else {
+      newStatus = TCSM_Available;
+    }
+    // The value of sysctl kern.tcsm_available is the same for all
+    // threads within the same process. If another thread raced with us
+    // and initialized sTCSMStatus first (changing it from
+    // TCSM_Unknown), we can continue without needing to update it
+    // again. Hence, we ignore compareExchange's return value.
+    Unused << sTCSMStatus.compareExchange(TCSM_Unknown, newStatus);
+  }
+  return (sTCSMStatus == TCSM_Available);
+}
+
+/* static */
+nsresult nsMacUtilsImpl::EnableTCSM() {
+  uint32_t newVal = 1;
+  int rv = sysctlbyname("kern.tcsm_enable", NULL, 0, &newVal, sizeof(newVal));
+  if (rv < 0) {
+    return NS_ERROR_UNEXPECTED;
+  }
+  return NS_OK;
+}
+
+/*
+ * Intentionally return void so that failures will be ignored in non-debug
+ * builds. This method uses new sysctls which may not be as thoroughly tested
+ * and we don't want to cause crashes handling the failure due to an OS bug.
+ */
+/* static */
+void nsMacUtilsImpl::EnableTCSMIfAvailable() {
+  if (IsTCSMAvailable()) {
+    if (NS_FAILED(EnableTCSM())) {
+      NS_WARNING("Failed to enable TCSM");
+    }
+    MOZ_ASSERT(IsTCSMEnabled());
+  }
+}
+
+#if defined(DEBUG)
+/* static */
+bool nsMacUtilsImpl::IsTCSMEnabled() {
+  uint32_t oldVal = 0;
+  size_t oldValSize = sizeof(oldVal);
+  int rv = sysctlbyname("kern.tcsm_enable", &oldVal, &oldValSize, NULL, 0);
+  return (rv == 0) && (oldVal != 0);
+}
+#endif
