diff --git a/epan/reassemble.c b/epan/reassemble.c
index abc84df..998d133 100644
--- a/epan/reassemble.c
+++ b/epan/reassemble.c
@@ -523,21 +523,49 @@ fragment_set_tot_len(const packet_info *pinfo, const guint32 id, GHashTable *fra
 			 const guint32 tot_len)
 {
 	fragment_data *fd_head;
-	fragment_key key;
+	fragment_data *fd;
+	fragment_key   key;
+	guint32        max_offset = 0;
 
 	/* create key to search hash with */
 	key.src = pinfo->src;
 	key.dst = pinfo->dst;
 	key.id	= id;
 
-	fd_head = g_hash_table_lookup(fragment_table, &key);
+	fd = fd_head = g_hash_table_lookup(fragment_table, &key);
 
-	if(fd_head){
-		fd_head->datalen = tot_len;
-		fd_head->flags |= FD_DATALEN_SET;
+	if (!fd_head)
+		return;
+
+	/* Verify that the length (or block sequence number) we're setting
+	 * doesn't conflict with values set by existing fragments.
+	 */
+	if (fd_head->flags & FD_BLOCKSEQUENCE) {
+		while (fd) {
+			if (fd->offset > max_offset) {
+				max_offset = fd->offset;
+				DISSECTOR_ASSERT(max_offset <= tot_len);
+			}
+			fd = fd->next;
+		}
+	}
+	else {
+		while (fd) {
+			if (fd->offset + fd->len > max_offset) {
+				max_offset = fd->offset + fd->len;
+				DISSECTOR_ASSERT(max_offset <= tot_len);
+			}
+			fd = fd->next;
+		}
+	}
+
+	if (fd_head->flags & FD_DEFRAGMENTED) {
+		DISSECTOR_ASSERT(max_offset == tot_len);
 	}
 
-	return;
+	/* We got this far so the value is sane. */
+	fd_head->datalen = tot_len;
+	fd_head->flags |= FD_DATALEN_SET;
 }
 
 guint32
