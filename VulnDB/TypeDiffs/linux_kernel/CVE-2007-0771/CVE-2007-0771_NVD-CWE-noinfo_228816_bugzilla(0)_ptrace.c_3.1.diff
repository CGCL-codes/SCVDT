diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index d0cbf66..809a4fb 100644  
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -161,10 +161,19 @@ ptrace_update(struct task_struct *target
 			state->u.live.u.siginfo = NULL;
 
 		if (target->state == TASK_STOPPED) {
-			spin_lock_irq(&target->sighand->siglock);
-			if (target->state == TASK_STOPPED)
-				target->signal->flags &= ~SIGNAL_STOP_STOPPED;
-			spin_unlock_irq(&target->sighand->siglock);
+			/*
+			 * We have to double-check for naughty de_thread
+			 * reaping despite NOREAP, before we can get siglock.
+			 */
+			read_lock(&tasklist_lock);
+			if (!target->exit_state) {
+				spin_lock_irq(&target->sighand->siglock);
+				if (target->state == TASK_STOPPED)
+					target->signal->flags &=
+						~SIGNAL_STOP_STOPPED;
+				spin_unlock_irq(&target->sighand->siglock);
+			}
+			read_unlock(&tasklist_lock);
 		}
 	}
 
@@ -290,13 +299,23 @@ static int ptrace_attach(struct task_str
 	if (retval)
 		(void) utrace_detach(task, engine);
 	else {
-		int stopped;
-
-		force_sig_specific(SIGSTOP, task);
+		int stopped = 0;
 
-		spin_lock_irq(&task->sighand->siglock);
-		stopped = (task->state == TASK_STOPPED);
-		spin_unlock_irq(&task->sighand->siglock);
+		/*
+		 * We must double-check that task has not just died and
+		 * been reaped (after ptrace_update succeeded).
+		 * This happens when exec (de_thread) ignores NOREAP.
+		 * We cannot call into the signal code if it's dead.
+		 */
+		read_lock(&tasklist_lock);
+		if (likely(!task->exit_state)) {
+			force_sig_specific(SIGSTOP, task);
+
+			spin_lock_irq(&task->sighand->siglock);
+			stopped = (task->state == TASK_STOPPED);
+			spin_unlock_irq(&task->sighand->siglock);
+		}
+		read_unlock(&tasklist_lock);
 
 		if (stopped) {
 			/*

commit 5278b661c82df463c07f1de9b4f442d828502d92
Author: Roland McGrath <roland@redhat.com>
Date:   Tue Mar 6 23:42:13 2007 -0800

    Fix utrace_engine_cache leak in utrace_attach race restart case.

