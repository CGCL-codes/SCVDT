diff --git a/kernel/utrace.c b/kernel/utrace.c
index cec2e0a..277852b 100644  
--- a/kernel/utrace.c
+++ b/kernel/utrace.c
@@ -202,17 +202,23 @@ check_dead_utrace(struct task_struct *ts
 	 */
 	if (((tsk->utrace_flags &~ flags) & UTRACE_ACTION_NOREAP)
 	    && tsk->exit_state) {
-		BUG_ON(tsk->exit_state != EXIT_ZOMBIE);
 		/*
 		 * While holding the utrace lock, mark that it's been done.
 		 * For self-reaping, we need to change tsk->exit_state
 		 * before clearing tsk->utrace_flags, so that the real
-		 * parent can't see it in EXIT_ZOMBIE momentarily and reap it.
+		 * parent can't see it in EXIT_ZOMBIE momentarily and reap
+		 * it.  If tsk was the group_leader, an exec by another
+		 * thread can release_task it despite our NOREAP.  Holding
+		 * tasklist_lock for reading excludes de_thread until we
+		 * decide what to do.
 		 */
-		if (tsk->exit_signal == -1) {
+		read_lock(&tasklist_lock);
+		if (tsk->exit_signal == -1) { /* Self-reaping thread.  */
 			exit_state = xchg(&tsk->exit_state, EXIT_DEAD);
+			read_unlock(&tasklist_lock);
+
 			BUG_ON(exit_state != EXIT_ZOMBIE);
-			exit_state = EXIT_DEAD;
+			exit_state = EXIT_DEAD;	/* Reap it below.  */
 
 			/*
 			 * Now that we've changed its state to DEAD,
@@ -220,7 +226,7 @@ check_dead_utrace(struct task_struct *ts
 			 * value without the UTRACE_ACTION_NOREAP bit set.
 			 */
 		}
-		else if (thread_group_empty(tsk)) {
+		else if (thread_group_empty(tsk)) /* Normal solo zombie.  */
 			/*
 			 * We need to prevent the real parent from reaping
 			 * until after we've called do_notify_parent, below.
@@ -233,32 +239,47 @@ check_dead_utrace(struct task_struct *ts
 			 * everything we need to do.
 			 */
 			exit_state = EXIT_ZOMBIE;
-			read_lock(&tasklist_lock);
-		}
+		else
+			/*
+			 * Delayed group leader, nothing to do yet.
+			 * This is also the situation with the old
+			 * group leader in an exec by another thread,
+			 * which will call release_task itself.
+			 */
+			read_unlock(&tasklist_lock);
+
 	}
 
 	tsk->utrace_flags = flags;
 	if (flags)
 		utrace_unlock(utrace);
-	else {
+	else
 		rcu_utrace_free(utrace);
-		utrace = NULL;
-	}
 
 	/*
 	 * Now we're finished updating the utrace state.
 	 * Do a pending self-reaping or parent notification.
 	 */
+	if (exit_state == EXIT_ZOMBIE) {
+		do_notify_parent(tsk, tsk->exit_signal);
+
+		/*
+		 * If SIGCHLD was ignored, that set tsk->exit_signal = -1
+		 * to tell us to reap it immediately.
+		 */
+		if (tsk->exit_signal == -1) {
+			exit_state = xchg(&tsk->exit_state, EXIT_DEAD);
+			BUG_ON(exit_state != EXIT_ZOMBIE);
+			exit_state = EXIT_DEAD;	/* Reap it below.  */
+		}
+		read_unlock(&tasklist_lock); /* See comment above.  */
+	}
 	if (exit_state == EXIT_DEAD)
 		/*
 		 * Note this can wind up in utrace_reap and do more callbacks.
 		 * Our callers must be in places where that is OK.
 		 */
 		release_task(tsk);
-	else if (exit_state == EXIT_ZOMBIE) {
-		do_notify_parent(tsk, tsk->exit_signal);
-		read_unlock(&tasklist_lock); /* See comment above.  */
-	}
 }
 
 

commit 6dad5136660f1d58531ea235c0261e8c10dc766d
Author: Roland McGrath <roland@redhat.com>
Date:   Tue Mar 6 23:36:51 2007 -0800

    Protect ptrace against unstoppable exec de_thread reaping.

